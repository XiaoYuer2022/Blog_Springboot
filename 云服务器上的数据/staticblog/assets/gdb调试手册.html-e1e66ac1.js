import{$ as i,a0 as o,a1 as p,a6 as c,a2 as a,a4 as e,a9 as l,a3 as n,a5 as t,I as d}from"./framework-e783454b.js";const r={},u=a("div",{class:"hint-container tip"},[a("p",{class:"hint-container-title"},"提示"),a("p",null,"GDB调试手册")],-1),b=a("h1",{id:"gdb调试手册",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#gdb调试手册","aria-hidden":"true"},"#"),n(" GDB调试手册")],-1),f=a("p",null,"前提：gcc在编译时需要加上-g参数",-1),v=a("p",null,"总结：",-1),k=a("p",null,"说明：gdb -c /tmp/core-tuxclocker-19395-1584497577 xx(可执行程序名)",-1),m=t(`<div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">/*”核心文件已转储“的错误原因解析：

原因一：内存访问越界

  a) 使用错误的下标，导致数组访问越界；

原因二：多线程程序使用了线程不安全的函数

原因三：多线程读写的数据没有加锁保护；

原因四：非法指针

  a) 使用空指针，

  b) 随意使用指针转换；

原因五：堆栈溢出*/</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>layout：用于分割窗口，可以一边查看代码，一边测试。主要有以下几种用法：
layout src：显示源代码窗口
layout <span class="token keyword">asm</span>：显示汇编窗口
layout regs：显示源代码<span class="token operator">/</span>汇编和寄存器窗口
layout split：显示源代码和汇编窗口
layout next：显示下一个layout
layout prev：显示上一个layout
Ctrl <span class="token operator">+</span> L：刷新窗口
Ctrl <span class="token operator">+</span> x，再按<span class="token number">1</span>：单窗口模式，显示一个窗口
Ctrl <span class="token operator">+</span> x，再按<span class="token number">2</span>：双窗口模式，显示两个窗口

Ctrl <span class="token operator">+</span> x，再按a：回到传统模式，即退出layout，回到执行layout之前的调试窗口。

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="一、基础入门" tabindex="-1"><a class="header-anchor" href="#一、基础入门" aria-hidden="true">#</a> 一、基础入门</h2><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>gdb hello  <span class="token comment">#hello为程序名</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>1.1 参数-q，可以再启动时不打印gdb的默认参数</p><p>2 参看源码</p><p>命令list (简写l)可以查看源码，默认显示10行，通过回车键不断查看剩余代码</p><p>3 运行程序</p><p>命令run (简写r)用于运行代码，在程序结束或者遇到断点处停下</p><p>4 设置断点</p><p>运行break (简写b)命令可以在指定行设置一个断点，断点调试是程序调试里面使用频率最高的技巧</p><p>使用方法：“b”命令后面加上相应的行号</p><p>设置好断点后，执行一下命令查看断点信息：info b <img src="https://s3.bmp.ovh/imgs/2022/11/12/9d9d4ba1565c9ad2.png" alt="" loading="lazy"></p><p>5 单步调试</p><ul><li>continue (简写c)：继续执行，到下一个断点处（或运行结束）。</li><li>next (简写n)：单步执行，跳过子函数</li><li>strp (简写s)：单步执行，进入子函数</li></ul><p>6 查看变量</p><p>使用print (简写p)指令来查看变量的值，用法为&quot;print 变量名&quot;。</p><p>7 清除断点</p><p>clear + 行号以清除断点。</p><p>8 运行至函数结束</p><p>使用finish命令来运行程序至函数结束</p><p>9 显示源代码窗口</p><p>程序运行后，使用命令“layout src”可以显示源代码窗口，当前执行代码会高亮</p><p>10 退出gdb</p><p>执行quit (简写q)会退出gdb调试</p><p>11 附加说明</p><p>cgdb是gdb的终端界面增强版，它有上下两栏窗口，上栏的窗口支持vi编辑器的语法， 可以方便的使用它来进行字符串定位等功能。在gdb下使用“layout src”时，界面往往容易花屏， 而cgbd更加的稳定可靠。还有一点，cgdb会给不同符号的不同类型辅以不同的颜色。</p><p>使用<code>sudo apt install cgdb</code>来安装该软件。</p><h2 id="二、-gdb调试之函数调用栈——backtrace" tabindex="-1"><a class="header-anchor" href="#二、-gdb调试之函数调用栈——backtrace" aria-hidden="true">#</a> 二、 gdb调试之函数调用栈——backtrace</h2><p>在写代码的时候，我们会封装很多函数，而这些函数之中又会调用其他的函数，当程序每次调用函数的时候，就会跳转到函数的地方去执行，那么这期间就有很多信息产生了，比如：调用函数的地方，函数的参数，被调用函数的变量等，这些信息其实是存储在栈中的，其实更确切地说，这些信息是存储在函数调用信息帧中的，每个函数及其变量都被分配了一个帧（frame），这些函数信息帧就组成了函数调用栈。我们使用 gdb 调试工具就可以查看函数调用栈的内容信息，可以清晰地看到各个函数的调用顺序以及各函数的输入形参值，是分析程序的执行流程和输入依赖的重要手段。</p><p>gdb提供了一些指令可以查看这些帧中的信息，当查询函数变量的信息时，gdb就是从这个被选中的帧内获取信息，但是查看被选中帧外的变量信息是非法的，当程序运行停止的时候，gdb会自动选择当前被调用的函数帧，并且打印简单帧信息。</p><p>2、gdb中函数调用栈的指令</p><ul><li>2.1 查看栈信息</li></ul>`,33),g=a("code",null," backtrace",-1),_=a("ul",null,[a("li",null,"2.2 查看帧信息")],-1),h=a("p",null,"上面的bt指令主要是查看栈的信息，而每一帧都会有详细的信息，这些函数调用信息帧包括：调用函数的地方，函数的参数等。如果想查看栈中某一帧的信息，首先要做的是切换当前栈。这时候需用用到 frame 指令（缩写形式为 f）。",-1),x=a("figure",null,[a("img",{src:"https://s3.bmp.ovh/imgs/2022/11/13/a89a6a826e86a4be.png",alt:"",tabindex:"0",loading:"lazy"}),a("figcaption")],-1),y=a("ul",null,[a("li",null,"2.3 up/down指令")],-1),q=a("p",null,"除了使用 frame 指令切换栈帧外，还可以使用 up 和 down 指令。",-1),w=a("ul",null,[a("li",null,"2.4 查看更详细的帧信息")],-1),C=a("p",null,"info 指令是一个很强大的指令，使用它可以查看各种变量的值，如果我们希望看到详细的函数调用信息帧的信息，如：函数地址、调用函数的地址、被调用函数的地址、当前函数由哪种编程语言编写、函数参数地址及形参值、局部变量的地址、当前桢中存储的寄存器等，可以使用以下指令：",-1),B=a("code",null,"i f",-1),N=t('<figure><img src="https://s3.bmp.ovh/imgs/2022/11/13/7c7dafcff67e8f53.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>这里面有很多信息：</p><blockquote><ul><li><p>当前桢的地址：0x7fffffffe030。</p></li><li><p>ip的值：0x400b58，此处引申介绍一下rip是什么：它是指令地址寄存器，用来存储 CPU 即将要执行的指令地址。每次 CPU 执行完相应的汇编指令之后，rip 寄存器的值就会自行累加，rip 无法直接赋值。</p></li><li><p>当前桢函数：test1 (backtrace.c:9)。</p></li><li><p>调用者的rip值：saved rip = 0x400bbe。</p></li><li><p>调用者的帧地址：0x7fffffffe060。</p></li><li><p>源代码所用的程序的语言: source language c。</p></li><li><p>当前桢的参数的地址及值：Arglist at 0x7fffffffe020, args: arg=1。</p></li><li><p>当前帧中局部变量的地址：Locals at 0x7fffffffe020, Previous frame’s sp is 0x7fffffffe030。</p></li><li><p>当前桢中存储的寄存器：rbp at 0x7fffffffe020, rip at 0x7fffffffe028。</p></li></ul></blockquote><p>除此之外 info 指令还可以查看当前寄存器的值：</p>',4),V=t(`<h3 id="_2-2-gdb调试递归函数" tabindex="-1"><a class="header-anchor" href="#_2-2-gdb调试递归函数" aria-hidden="true">#</a> 2.2 gdb调试递归函数</h3><p>本小节的主题是教大家用gdb去调试递归函数，因为一步步去调试太麻烦了，也没法打断点，因为打断点每次递归时都会停下来，实在是难以调试，那么强大如gdb调试工具，对这种递归函数的调试也是轻而易举的。</p><p>我们用递归算法计算斐波拉契数列，这是在大学C语言课本中的非常有名的递归算法——计算斐波拉契数列，我们回顾一下是什么是斐波拉契数列：斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p><p>代码示例：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">||</span> n <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
 <span class="token keyword">return</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	ret <span class="token operator">=</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;fibonacci(%d)=%d\\n&quot;</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> ret<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>变异后用gdb调试：比如我想让递归调用，n=5时停下来，则有：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>gdb <span class="token punctuation">.</span><span class="token operator">/</span><span class="token function">test</span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> b fibonacci <span class="token keyword">if</span> n<span class="token operator">==</span><span class="token number">5</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="三、跟踪系统调用——strace" tabindex="-1"><a class="header-anchor" href="#三、跟踪系统调用——strace" aria-hidden="true">#</a> 三、跟踪系统调用——strace</h2><h2 id="gdb调试多线程" tabindex="-1"><a class="header-anchor" href="#gdb调试多线程" aria-hidden="true">#</a> GDB调试多线程</h2>`,9);function z(D,G){const s=d("font");return o(),p("div",null,[u,c(" more "),b,f,v,a("blockquote",null,[k,e(s,{color:"red"},{default:l(()=>[n("list")]),_:1}),n("命令(简写为l)查看源码"),e(s,{color:"red"},{default:l(()=>[n("layout src")]),_:1}),n("显示源代码窗口 （ctrl + x + a 以关闭源代码界面）"),a("p",null,[n("运行程序命令"),e(s,{color:"red"},{default:l(()=>[n("run")]),_:1}),n("(简写为r)")]),a("p",null,[n("设置断点命令"),e(s,{color:"red"},{default:l(()=>[n("break")]),_:1}),n("(简写为b) +行号 或b 函数名")]),a("p",null,[n("查看断点信息："),e(s,{color:"red"},{default:l(()=>[n(" info b ")]),_:1})]),a("p",null,[n("清除断点"),e(s,{color:"red"},{default:l(()=>[n("clear")]),_:1}),n("(简写为c) +行号")]),a("p",null,[n("单步调试：继续执行到下一个断点"),e(s,{color:"red"},{default:l(()=>[n("continue")]),_:1}),n("(简写为c)；单步执行，跳过子函数"),e(s,{color:"red"},{default:l(()=>[n("next")]),_:1}),n("(简写为n)；单步执行，进入子函数"),e(s,{color:"red"},{default:l(()=>[n("strp")]),_:1}),n("(简写为s)")]),a("p",null,[n("查看变量"),e(s,{color:"red"},{default:l(()=>[n("print 变量名")]),_:1})]),a("p",null,[n("运行至函数结束"),e(s,{color:"red"},{default:l(()=>[n("finish")]),_:1})]),a("p",null,[n("退出"),e(s,{color:"red"},{default:l(()=>[n("quit")]),_:1})])]),m,a("blockquote",null,[e(s,{color:"red"},{default:l(()=>[n("bt")]),_:1}),n("：bt是"),g,n(" 指令的缩写，显示所有的函数调用栈的信息，栈中的每个函数都被分配了一个编号，最近被调用的函数在 0 号帧中（栈顶），并且每个帧占用一行。"),e(s,{color:"red"},{default:l(()=>[n("bt n")]),_:1}),n("：显示函数调用栈从栈顶算起的n帧信息（n 表示一个正整数）。"),e(s,{color:"red"},{default:l(()=>[n("bt -n")]),_:1}),n("：显示函数调用栈从栈底算起的n帧信息。"),e(s,{color:"red"},{default:l(()=>[n("bt full")]),_:1}),n("：显示栈中所有信息如：函数参数，本地变量等。"),e(s,{color:"red"},{default:l(()=>[n("bt full n")]),_:1}),n("：显示函数调用栈从栈顶算起的n帧的所有信息。"),e(s,{color:"red"},{default:l(()=>[n("bt full -n")]),_:1}),n("：显示函数调用栈从栈底算起的n帧的所有信息。")]),_,h,a("blockquote",null,[e(s,{color:"red"},{default:l(()=>[n("f n")]),_:1}),n(" ： 它的功能是切换到编号为 n 的栈帧（n 表示一个正整数），并显示相关信息。")]),x,y,q,a("blockquote",null,[e(s,{color:"red"},{default:l(()=>[n("down n")]),_:1}),n(" ： 表示往栈顶方向下移 n 层（n 表示一个正整数，默认值为 1）。"),e(s,{color:"red"},{default:l(()=>[n("up n")]),_:1}),n(" ： 表示往栈底方向上移 n 层。")]),w,C,a("blockquote",null,[e(s,{color:"red"},{default:l(()=>[n("info frame")]),_:1}),n(" ：指令的缩写形式为 "),B,n(" ，查看函数调用帧的所有信息。"),e(s,{color:"red"},{default:l(()=>[n("info args")]),_:1}),n(" ：查看函数变量的值。(与print args功能是一样的)"),e(s,{color:"red"},{default:l(()=>[n("info locals")]),_:1}),n(" ：查看函数变量的值。")]),N,a("blockquote",null,[e(s,{color:"red"},{default:l(()=>[n("info registers")]),_:1}),n("：查看寄存器的情况（除了浮点寄存器）。"),e(s,{color:"red"},{default:l(()=>[n("info all-registers")]),_:1}),n("：查看所有寄存器的情况（包括浮点寄存器）。")]),V])}const L=i(r,[["render",z],["__file","gdb调试手册.html.vue"]]);export{L as default};
