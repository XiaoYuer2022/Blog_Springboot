import{$ as t,a0 as n,a1 as a,a6 as s,a2 as l,a3 as i,a4 as c,a5 as e,I as r}from"./framework-e783454b.js";const _={},p=l("div",{class:"hint-container tip"},[l("p",{class:"hint-container-title"},"提示"),l("p",null,"结构体字节大小计算手册")],-1),d=e("<p>结构体 1、结构体计算字节数规则 总结规则如下:</p><ul><li>0:结构体变量的首地址能够被其最宽基本类型成员的大小所整除</li><li>1: VC6和VC71默认的内存对齐方式是#pragam pack(8)</li><li>2: 结构体中每个成员按其类型的对齐参数(通常是这个类型的大小)和指定对齐参数中较小的个对齐.</li><li>3:结构体每 个成员相对于结构体首地址的偏移量都是成员大小的整数倍.</li><li>4:结构体本身也存在着对齐要求规则，不能比它所有字段中要求最严格的那个宽松</li><li>5:结构体的总大小为结构体最宽基本类型成员大小的整数倍.且应尽量节省内存。</li><li>6: 在GCC中，对齐模数的准则是:对齐模数最大只能是4，也就是说，即使结构体中有 double类型，对齐模数还是4，所以对齐模数只能是1，2，4。而且在上述的规则中，第3条里，offset必须是成员大小的整数倍: <ul><li>(1):如果这个成员大小小于等于4则按照上述准则是可行的，</li><li>(2):如果成员的大小大于4，则结构体每个成员相对于结构体首地址的偏移量只能按照是4的整数倍来进行判断是否添加填充。</li></ul></li></ul>",2),h={href:"http://www.javashuo.com/article/p-pyhbyxqy-bh.html",target:"_blank",rel:"noopener noreferrer"},m=e("<ol><li>一个位域必须存储在同一个字节中，不能跨两个字节，故位域的长度不能大于一个字节的长度。</li><li>取地址操做符&amp;不能应用在位域字段上;</li><li>位域字段不能是类的静态成员;</li><li>位域字段在内存中的位置是按照从低位向高位的顺序放置的;</li><li>位域的对齐</li></ol><blockquote><ol><li>若是相邻位域字段的类型相同，且其位宽之和小于类型的sizeof大小，则后面的字段将紧邻前一个字段存储，直到不能容纳为止；</li><li>若是相邻位域字段的类型相同，但其位宽之和大于类型的sizeof大小，则后面的字段将重新的存储单元开始，其偏移量为其类型大小的整数倍；</li><li>若是相邻的两个位域字段的类型不一样,则各个编译器的具体实现有差别,VC6采起不压缩方式,GCC和Dev-C++都采用压缩方式;</li><li>整个结构体的总大小为最宽基本类型成员大小的整数倍。</li><li>若是位域字段之间穿插着非位域字段，则不进行压缩；（不针对全部的编译器）</li></ol></blockquote><ol><li>当要把某个成员说明成位域时,其类型只能是int,unsigned int与signed int三者之一(说明:int类型一般表明特定机器中整数的天然长度。short类型一般为16位,long类型一般为32位,int类型能够为16位或32位.各编译器能够根据硬件特性自主选择合适的类型长度.见The C Programming Language中文 P32)。</li></ol>",3);function u(f,C){const o=r("ExternalLinkIcon");return n(),a("div",null,[p,s(" more "),d,l("p",null,[i("2、位域 "),l("a",h,[i("参考链接"),c(o)])]),m])}const k=t(_,[["render",u],["__file","结构体字节大小计算手册.html.vue"]]);export{k as default};
