import{$ as r,a0 as l,a1 as o,a6 as d,a4 as a,a9 as c,a3 as n,a2 as s,a5 as e,I as i}from"./framework-e783454b.js";const u={},m=s("div",{class:"hint-container tip"},[s("p",{class:"hint-container-title"},"提示"),s("p",null,"大话数据结构和算法")],-1),k=e(`<p>注：内容来源于书籍《大话数据结构》，部分内容来源于网络补充。</p><p>数据结构：使相互之间存在的一种或多种特定关系的数据元素的集合。从不同的角度来讨论，会有不同的分类。按照逻辑结构来分，有“集合结构、线性结构、树状结构和图形结构”，按照物理结构分类，有“顺序存储结构、链式存储结构”。</p><p>算法：是解决特定问题求解步骤的描述，在计算机中表现为指令的优先序列，并且每条指令表示一个或多个操作。</p><p>算法的五大基本特性：输入、输出、有穷性】确定性和可行性。</p><p>算法设计的要求：正确性、可读性、健壮性、时间效率高和存储量低。</p><h2 id="一、算法优劣的度量" tabindex="-1"><a class="header-anchor" href="#一、算法优劣的度量" aria-hidden="true">#</a> 一、算法优劣的度量</h2><p>算法优劣的度量有事前分析法和事后统计法。一般采用事前分析法，分析算法的时间效率和空间存储量。</p><p>大O记法：T(n)=O(f(n))，一般说来，随着n的增大，T(n)增长最慢的算法为最优算法。</p><blockquote><p>推导大O阶：</p><ul><li>用常数1来取代运行时间中的所有加法常数</li><li>在修改后的运行次数函数中，只保留最高阶项</li><li>如果最高阶项存在且系数不为1，就像系数调整为1</li></ul></blockquote><p>1、常数阶O(1)</p><p>一般顺序结构的时间复杂度是O(1)。对于分支结构而言，无论是镇还是假，执行的次数都是恒定的，不会随着n的变大而发生变化，所以单纯的分支结构（不包含在循环结构里），其时间复杂度也是O(1)。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>n<span class="token operator">=</span><span class="token number">100</span>  <span class="token comment">//执行一次</span>
sum<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">+</span>n<span class="token punctuation">)</span><span class="token operator">*</span>n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>   <span class="token comment">//执行一次</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>2、线性阶O(n)</p><p>一般循环结构都要重复执行n次，所以循环结构的时间复杂度为O(n)。一般分析算法的复杂度，主要就是分析循环结构的复杂度。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> i<span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token comment">//时间复杂度为n</span>
<span class="token punctuation">{</span>
<span class="token comment">//时间复杂度为1的代码序列</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>3、对数阶O(logn)</p><p>如果在循环中，对循环因子进行了处理，那这段代码的时间复杂度就会发生变化，比如：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> count<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>count<span class="token operator">&lt;</span>n<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
count <span class="token operator">=</span> count<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">;</span>
<span class="token comment">//时间复杂度为1的代码序列</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因为每次count乘以2之后，就距离n更近了一步，也就是说有多少个2相乘后大于n，则会退出循环，有2<sup>x</sup>=n可以得到x=log<sub>2</sub>n。所以该类算法的时间复杂度为log<sub>2</sub>n。</p><p>4、平方阶</p><p>1、简单循环结构的循环嵌套，其算法时间度一般为O(n<sup>2</sup>)。 2、如果外层循环改为了m，那么时间复杂度就该为了O(mxn); 3、有些排序和搜索算法会用到这种循环结构：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span>i<span class="token punctuation">;</span>j<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
	<span class="token comment">//时间复杂度为1的程序代码片段</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当i=0时，内循环了n次；当i=1时，内循环了n-1次，...，当i=n-1时，内循环了1次。综上，这个代码块的总运行时间为：n+(n-1)+(n-2)+...+1=(n+1)n/2=1/2(n<sup>2</sup>+n)。根据大O算法，推导出时间复杂度为O(n<sup>2</sup>)。</p><p>下面这段代码相对而言更复杂：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>n<span class="token operator">++</span><span class="token punctuation">;</span>   <span class="token comment">//执行次数为1</span>
<span class="token function">function</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//执行次数为n</span>
<span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">;</span><span class="token comment">//执行次数为1</span>
<span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment">//执行次数为n*n</span>
<span class="token punctuation">{</span>
	<span class="token function">function</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment">//执行次数为n*(n+1)/2</span>
<span class="token punctuation">{</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span>i<span class="token punctuation">;</span>j<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token comment">//时间复杂度为1的代码</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">function</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token comment">//时间复杂度为1的代码</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>综上，它的执行次数为1+n+1+n*n+n*(n+1)/2，时间复杂度为O(n<sup>2</sup>)。 <img src="https://s3.bmp.ovh/imgs/2022/11/05/dda3163c8daa0b01.png" alt="" loading="lazy"></p><p>算法的空间复杂度S(n)=O(f(n))，其中n为问题的规模，f(n)为语句关于n所占存储空间的函数。</p><p>一般来说，一个程序在机器上执行时，出了需要存储程序本身的指令、常数、变量和输入数据外，还需要存储对数据操作的存储单元。若输入数据所占空间只取决于问题本身，和算法无关，这样只需要分析该算法在实现时所需的辅助单元即可。若算法执行时所需的辅助空间相对于输入数据量而言是个常数，则称此算法为原地工作，空间复杂度为O(1)。</p><h2 id="二、线性表-顺序存储结构和链式存储结构" tabindex="-1"><a class="header-anchor" href="#二、线性表-顺序存储结构和链式存储结构" aria-hidden="true">#</a> 二、线性表（顺序存储结构和链式存储结构）</h2><p>线性表：零个或多个数据元素的有限序列。分为顺序存储结构（数组）和链式存储结构（链表）。 线性表的两个特点：1）有序；2）有限。有序是指，首元素无前驱结点，尾元素无后继节点，其余元素都有唯一的前驱结点和后继节点。有限是指元素个数是可以统计的。</p>`,30),h=e(`<div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXSIZE</span> <span class="token expression"><span class="token number">30</span></span></span>
<span class="token keyword">typedef</span> <span class="token keyword">int</span> ElemType
<span class="token keyword">typedef</span> <span class="token keyword">struct</span>
<span class="token punctuation">{</span>
	ElemType data<span class="token punctuation">[</span>MAXSIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> length<span class="token punctuation">;</span>
<span class="token punctuation">}</span>Sqlist<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里，我们可以发现描述顺序存储结构需要三个属性：</p><ul><li>存储空间的起始位置，数组data</li><li>线性表的最大存储容量；</li><li>线性表当前的长度；</li></ul><p>通过上述分析，不难看出数组、链表(单链表、双向链表、循环链表)、栈、队列和字符串都是一种线性表结构。他们都有下面几种操作(除字符串以外)</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token number">1</span>、初始化  <span class="token function">InitList</span><span class="token punctuation">(</span><span class="token operator">*</span>L<span class="token punctuation">)</span>
<span class="token number">2</span>、验证是否为空：<span class="token function">ListEmpty</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span>
<span class="token number">3</span>、清空 <span class="token function">ClearList</span><span class="token punctuation">(</span><span class="token operator">*</span>L<span class="token punctuation">)</span>
<span class="token number">3.2</span> 摧毁 <span class="token function">DestroyList</span><span class="token punctuation">(</span><span class="token operator">*</span>L<span class="token punctuation">)</span>

<span class="token number">4</span>、通过序号获取元素<span class="token function">GetElem</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span>i<span class="token punctuation">,</span><span class="token operator">*</span>e<span class="token punctuation">)</span>
<span class="token number">5</span>、通过元素查找序号<span class="token function">LocateElem</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span>e<span class="token punctuation">)</span>

<span class="token number">6</span>、增<span class="token function">ListInsert</span><span class="token punctuation">(</span><span class="token operator">*</span>L<span class="token punctuation">,</span>i<span class="token punctuation">,</span>e<span class="token punctuation">)</span>
<span class="token number">7</span>、删<span class="token function">ListDelete</span><span class="token punctuation">(</span><span class="token operator">*</span>L<span class="token punctuation">,</span>i<span class="token punctuation">,</span><span class="token operator">*</span>e<span class="token punctuation">)</span>
<span class="token number">8</span>、改<span class="token function">Modify</span><span class="token punctuation">(</span><span class="token operator">*</span>L<span class="token punctuation">,</span>i<span class="token punctuation">,</span>e<span class="token punctuation">)</span>
<span class="token number">9</span>、统计长度<span class="token function">ListLength</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span>

<span class="token comment">//细节</span>
当然，各自的细节不一样。比如<span class="token number">1</span>、数组不需要清空和验证是否为空，还有通过元素获取序号、通过序号查询值也是不需要的。在插入上，单链表、循环链表、双向链表上有微小差异。<span class="token number">2</span>、栈只有查询栈顶元素，队列只有查询队首元素 <span class="token number">3</span>、注意区分线性表长度和数组长度（针对顺序存储结构），数组长度一般是指这个数据结构对象的容量，而线性表长度是指这个对象的实际存储数据的数量。<span class="token number">4</span>、关于字符串，它是一种特殊的线性表，他符合线性表的特征，它是线性表，他也有顺序存储和链式存储，不过其他几种线性表能关注单个元素的操作，比如查找、插入和删除，但是串中更多的查找子串、得到指定位置的子串和替换子串等操作。

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>线性表顺序存储结构的优缺点：</p><blockquote><p>优点</p><ul><li>无需为表示表中元素之间的逻辑关系而增加额外的存储空间；</li><li>可以快速地存储、查找表中任意位置的元素</li></ul><p>缺点</p><ul><li>插入/删除元素的效率较低。特别是在首部插入和删除元素时，时间效率为O(n)，平均插入/删除的小绿尾O((n-1)/2)</li><li>当线性表长度变化较大时，难以确定存储空间的容量</li><li>造成存储空间的“碎片”</li></ul></blockquote>`,7),b=e(`<p>顺序存储结构最大的缺点就是插入和删除元素的效率问题，而链式存储可以解决该问题。链式存储解除了空间上的连续性，使得元素存储自由化，就可以提高元素插入/删除的效率，但也带来了额外的空间消耗。</p><p>除了其本身的信息之外，还需存储一个指向其直接后继的信息(即直接后继的存储位置)。</p><p>链表的分类有很多种，可以分为有头结点、无头结点；可以分为单链表、双向链表、循环链表。双向链表是有头尾指针，可以前进也可以后退。循环链表是头尾相连的链表。双向循环链表指的是在循环链表和双向链表的基础上，将两种链表的最后一个结点指向第一个结点从而实现循环。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">Node</span>
<span class="token punctuation">{</span>
	<span class="token keyword">int</span> data<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">Node</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span>List<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>1、从查找性能上看，顺序存储结构的性能为O(1)，链式存储的性能为O(n)；2、从插入/删除的性能上看，顺序存储结构的性能为O(n)，链式存储的性能为O(1)；3、从空间性能上看，顺序存储需要预先分配空间，分配大了就浪费，分配小了会溢出，而链式存储不需要提前分配空间。</p>`,5),v=s("p",null,"情况2：如果元素总数变化较大或者不知道有多少总数时，宜采用链式结构。",-1),g={href:"https://blog.csdn.net/heyuchang666/article/details/49996237",target:"_blank",rel:"noopener noreferrer"},_=s("img",{src:"https://s3.bmp.ovh/imgs/2022/11/15/65762f5ec5f6d72a.png",alt:"",loading:"lazy"},null,-1),y=e(`<p>数组和链表的对比： <img src="https://s3.bmp.ovh/imgs/2022/10/30/106260aed0a641e5.png" alt="" loading="lazy"></p><p>跳表：上表说过，链表的优点是可以更灵活的使用内存空间，长度可以动态变化，且插入/删除数据灵活。但是链表查询元素必须遍历链表，效率低。所以提出了一种跳表。在原链表的基础上，在新增一条或多条索引链表，加速对元素的查询。 <img src="https://s3.bmp.ovh/imgs/2022/10/30/1db5cfb2d228ca2b.png" alt="" loading="lazy"></p><h3 id="_2-2-链表小总结" tabindex="-1"><a class="header-anchor" href="#_2-2-链表小总结" aria-hidden="true">#</a> 2.2 链表小总结</h3><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">//单链表插入元素</span>
<span class="token comment">//在p节点后插入新节点new:</span>
new<span class="token operator">-&gt;</span>next<span class="token operator">=</span>p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
p<span class="token operator">-&gt;</span>next<span class="token operator">=</span>new<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>普通链表、静态链表、循环链表、双向链表</p><p>为了使空链表与非空链表处理 致，我们通常设一个头结点，当然 这并不是说，循环链表一定要头结点，这需要注意。</p><p>普通链表，各节点之间通过指针相连，无需提前设计容量，无数据溢出风险。数据插入/删除效率高，但是遍历效率低。数组是查询效率高。对于遍历效率低的问题，可以使用循环链表解决。对于链表只能前进不能后退的问题，引入了双向链表。</p><h3 id="_2-2-2-循环链表" tabindex="-1"><a class="header-anchor" href="#_2-2-2-循环链表" aria-hidden="true">#</a> 2.2.2 循环链表</h3><p>头尾相连的链表，为了使空链表的处理和非空链表的处理保持一致，通常要设置一个头结点。</p><p>除了头结点，还需要一个指针。设置头指针还是尾指针？设置头指针：访问第一个元素，时间复杂度为O(1)，访问尾元素为O(n)。设置尾指针，访问尾元素，时间复杂度为O(1)，访问首元素为O(2)，即为<code>rear-&gt;next-&gt;next</code>（因为要跳过头结点）。</p><p>有了尾指针，两个循环链表的结合也变得非常简单了，如下图所示。 <img src="https://s3.bmp.ovh/imgs/2022/12/15/c7b7bf6fb88cb300.png" alt="" loading="lazy"></p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>p<span class="token operator">=</span>rearA<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
rearA<span class="token operator">-&gt;</span>next<span class="token operator">=</span>rearB<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
q<span class="token operator">=</span>rearB<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
rearB<span class="token operator">-&gt;</span>next<span class="token operator">=</span>p<span class="token punctuation">;</span>
<span class="token function">free</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-2-3-双向链表" tabindex="-1"><a class="header-anchor" href="#_2-2-3-双向链表" aria-hidden="true">#</a> 2.2.3 双向链表</h3><p>双向循环链表是从单链表里面扩展出来的，所以他的很多操作都与单链表相同。比如求长度、查元素位置和通过位置查元素等。只是涉及到插入和删除的时候，需要两个指针的参与。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>有：p<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>prior<span class="token operator">=</span>p<span class="token operator">=</span>p<span class="token operator">-&gt;</span>prior<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
<span class="token comment">//双向链表的插入：</span>
<span class="token comment">//在p节点后插入新节点e</span>
e<span class="token operator">-&gt;</span>next<span class="token operator">=</span>p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
e<span class="token operator">-&gt;</span>prior<span class="token operator">=</span>p<span class="token punctuation">;</span>
p<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>prior<span class="token operator">=</span>e<span class="token punctuation">;</span>
p<span class="token operator">-&gt;</span>next<span class="token operator">=</span>e<span class="token punctuation">;</span>
<span class="token comment">//双向链表的插入-2 李慧芹方法</span>
e<span class="token operator">-&gt;</span>next<span class="token operator">=</span>p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
e<span class="token operator">-&gt;</span>prior<span class="token operator">=</span>p<span class="token punctuation">;</span>
e<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>prior<span class="token operator">=</span>e<span class="token punctuation">;</span>
e<span class="token operator">-&gt;</span>prior<span class="token operator">-&gt;</span>next<span class="token operator">=</span>e<span class="token punctuation">;</span>
<span class="token comment">//双向链表的删除  删除节点p</span>
p<span class="token operator">-&gt;</span>prior<span class="token operator">-&gt;</span>next<span class="token operator">=</span>p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
p<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>prior<span class="token operator">=</span>p<span class="token operator">-&gt;</span>prior<span class="token punctuation">;</span>
<span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="三、栈与队列" tabindex="-1"><a class="header-anchor" href="#三、栈与队列" aria-hidden="true">#</a> 三、栈与队列</h2><p>栈是先进后出的FILO，队列是先进先出的FIFO。栈和队列都有链式结构和顺序结构的实现。虽然把栈和队列从第二章线性表中分离来讲，但是栈和队列也是一种线性表。</p><p>特殊之处在于，栈和队列限制了元素的插入和删除的位置。对于该部分的重点只是在于：</p><ul class="task-list-container"><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-0" disabled="disabled"><label class="task-list-item-label" for="task-item-0"> 不同情况的出栈顺序，其出栈结果不同</label></li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-1" disabled="disabled"><label class="task-list-item-label" for="task-item-1"> 栈和队列都有链式存储和顺序存储两种结构</label></li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-2" disabled="disabled"><label class="task-list-item-label" for="task-item-2"> 两栈共享空间(一般是顺序存储结构)</label></li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-3" disabled="disabled"><label class="task-list-item-label" for="task-item-3"> 栈的应用：浏览器网页的后退功能、word的后退功能、用栈实现递归(斐波那契数列)、用栈实现计算器(包含如何将中缀运算符转换成后缀元素安抚、后缀运算符的计算规则)</label></li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-4" disabled="disabled"><label class="task-list-item-label" for="task-item-4"> 队列的应用：任务队列</label></li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-5" disabled="disabled"><label class="task-list-item-label" for="task-item-5"> 队列的顺序存储的不足(循环队列)、链式队列</label></li></ul><h3 id="_3-1-栈的顺序存储和两栈共享空间" tabindex="-1"><a class="header-anchor" href="#_3-1-栈的顺序存储和两栈共享空间" aria-hidden="true">#</a> 3.1 栈的顺序存储和两栈共享空间</h3><p>顺序存储一般使用数组实现，栈底为a[0]元素。栈顶指针top随元素增减而变化。</p><p>顺序存储的弊端在于长度固定，所以容量设置小了容易溢出，设置打了容易浪费。对于浪费这种情况，可以采用“两栈共享的方法”来解决。两个栈各占数组的一端，</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token number">1</span><span class="token punctuation">)</span>当top1<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span>时，栈<span class="token number">1</span>为空，当top2<span class="token operator">=</span>n时，栈<span class="token number">2</span>位空
<span class="token number">2</span><span class="token punctuation">)</span>当top1为n<span class="token operator">-</span><span class="token number">1</span>，或top2位<span class="token number">0</span>，又或者top<span class="token operator">+</span><span class="token number">1</span><span class="token operator">=</span>top2时栈满
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>事实上，使用这种数据结构的情况，一般是“当两个栈的空间需求为相反关系时，也就是一个栈增长同时另一个栈减小的情况”，比如投票、买卖股票。</p><p>栈的链式存储，因为链表有头结点，栈有栈顶指针，所以索性就把这两个指针合二为一了。在（栈顶指针）头结点后插入元素。</p><h3 id="_3-2-斐波那契数列" tabindex="-1"><a class="header-anchor" href="#_3-2-斐波那契数列" aria-hidden="true">#</a> 3.2 斐波那契数列</h3><p>其核心就是使用了递归。递归是自己调用自己，迭代是循环。 递归：自己调用自己，重复运行函数，选择结构，[优}结构简单，节省代码，[缺]费时费空间] 迭代：循环重复运行代码，循环结构，[优]占内存小 [缺] 这是斐波那契数列的公式：</p>`,27),f={class:"katex-block"},x={class:"katex-display"},w={class:"katex"},L=s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block"},[s("semantics",null,[s("mrow",null,[s("mi",null,"F"),s("mo",{stretchy:"false"},"("),s("mi",null,"n"),s("mo",{stretchy:"false"},")"),s("mo",null,"="),s("mrow",null,[s("mo",{fence:"true"},"{"),s("mtable",{rowspacing:"0.16em",columnalign:"left",columnspacing:"1em"},[s("mtr",null,[s("mtd",null,[s("mstyle",{scriptlevel:"0",displaystyle:"false"},[s("mrow",null,[s("mn",null,"0"),s("mo",{separator:"true"},","),s("mtext",null," 当 "),s("mi",null,"n"),s("mo",null,"="),s("mn",null,"0")])])])]),s("mtr",null,[s("mtd",null,[s("mstyle",{scriptlevel:"0",displaystyle:"false"},[s("mrow",null,[s("mn",null,"1"),s("mo",{separator:"true"},","),s("mtext",null," 当 "),s("mi",null,"n"),s("mo",null,"="),s("mn",null,"1")])])])]),s("mtr",null,[s("mtd",null,[s("mstyle",{scriptlevel:"0",displaystyle:"false"},[s("mrow",null,[s("mi",null,"F"),s("mo",{stretchy:"false"},"("),s("mi",null,"n"),s("mo",null,"−"),s("mn",null,"1"),s("mo",{stretchy:"false"},")"),s("mo",null,"+"),s("mi",null,"F"),s("mo",{stretchy:"false"},"("),s("mi",null,"n"),s("mo",null,"−"),s("mn",null,"2"),s("mo",{stretchy:"false"},")"),s("mo",{separator:"true"},","),s("mtext",null," 当 "),s("mi",null,"n"),s("mo",null,">"),s("mn",null,"1")])])])])])])]),s("annotation",{encoding:"application/x-tex"}," F(n)=\\left\\{\\begin{array}{l} 0, \\text { 当 } n=0 \\\\ 1, \\text { 当 } n=1 \\\\ F(n-1)+F(n-2), \\text { 当 } n>1 \\end{array}\\right. ")])])],-1),O={class:"katex-html","aria-hidden":"true"},z=e('<span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span>',1),q={class:"base"},M=s("span",{class:"strut",style:{height:"3.6em","vertical-align":"-1.55em"}},null,-1),S={class:"minner"},E={class:"mopen"},N={class:"delimsizing mult"},V={class:"vlist-t vlist-t2"},F={class:"vlist-r"},I={class:"vlist",style:{height:"2.05em"}},j=s("span",{style:{top:"-2.5em"}},[s("span",{class:"pstrut",style:{height:"3.15em"}}),s("span",{class:"delimsizinginner delim-size4"},[s("span",null,"⎩")])],-1),B={style:{top:"-2.492em"}},R=s("span",{class:"pstrut",style:{height:"3.15em"}},null,-1),A={style:{height:"0.016em",width:"0.8889em"}},H={xmlns:"http://www.w3.org/2000/svg",width:"0.8889em",height:"0.016em",style:{width:"0.8889em"},viewBox:"0 0 888.89 16",preserveAspectRatio:"xMinYMin"},T=s("path",{d:"M384 0 H504 V16 H384z M384 0 H504 V16 H384z"},null,-1),C=[T],K=s("span",{style:{top:"-3.15em"}},[s("span",{class:"pstrut",style:{height:"3.15em"}}),s("span",{class:"delimsizinginner delim-size4"},[s("span",null,"⎨")])],-1),D={style:{top:"-4.292em"}},Q=s("span",{class:"pstrut",style:{height:"3.15em"}},null,-1),P={style:{height:"0.016em",width:"0.8889em"}},X={xmlns:"http://www.w3.org/2000/svg",width:"0.8889em",height:"0.016em",style:{width:"0.8889em"},viewBox:"0 0 888.89 16",preserveAspectRatio:"xMinYMin"},Y=s("path",{d:"M384 0 H504 V16 H384z M384 0 H504 V16 H384z"},null,-1),Z=[Y],G=s("span",{style:{top:"-4.3em"}},[s("span",{class:"pstrut",style:{height:"3.15em"}}),s("span",{class:"delimsizinginner delim-size4"},[s("span",null,"⎧")])],-1),U=s("span",{class:"vlist-s"},"​",-1),$=s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"1.55em"}},[s("span")])],-1),J=e('<span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord text"><span class="mord"> </span><span class="mord cjk_fallback">当</span><span class="mord"> </span></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">0</span></span></span><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord text"><span class="mord"> </span><span class="mord cjk_fallback">当</span><span class="mord"> </span></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">1</span></span></span><span style="top:-1.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord text"><span class="mord"> </span><span class="mord cjk_fallback">当</span><span class="mord"> </span></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose nulldelimiter"></span>',2),W=e(`<h3 id="_3-3-用栈实现计算器" tabindex="-1"><a class="header-anchor" href="#_3-3-用栈实现计算器" aria-hidden="true">#</a> 3.3 用栈实现计算器</h3><p>1、 用后缀运算符来计算</p><p>后缀运算符又称逆波兰表示法， 它的特点是所有符号都是在要运算的数字后面出现，例如：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>前缀模式：<span class="token number">9</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">3</span><span class="token operator">+</span><span class="token number">10</span><span class="token operator">/</span><span class="token number">2</span>
后缀模式：<span class="token number">9</span> <span class="token number">3</span> <span class="token number">1</span> <span class="token operator">-</span> <span class="token operator">*</span> <span class="token number">3</span> <span class="token operator">+</span> <span class="token number">10</span> <span class="token number">2</span> <span class="token operator">/</span> <span class="token operator">+</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>计算机喜欢用后缀模式来处理运算符，是因为栈的结构。1）左括号进，直到遇到右括号才弹出。2）遇到数字进栈，遇到运算符取两个数字进行运算。注意，后缀运算符中只有数字和运算符了。</p><p>还有一点是，在栈中数字从上往下依次为1和3，然后遇到减号，则1先弹出做减数，然后3后弹出做被减数，所以为：<code>3-1</code>。</p><p>2、中缀转后缀表达式</p><p>规则：从左到右遍历中缀表达式的每个数字和符号，若是数字就输出，即成为后缀表达式的一部分；若是符号，则判断其与楼顶符号的优先级，是右括号或优先级不高于栈顶符号(乘除优先加减)则栈顶元素依次弹出并输出，并将当前符号进栈，一直到最终输出后缀表达式为止。</p><p>即：1）数字直接输出，2）符号考虑情况，要不要进栈。2.1 左括号直接进，2.2 右括号直接出，并且把左右括号之间的东西一起弹出 2.3 如果是运算符之间，要比较大小。外头的运算符大，不弹，直接进栈。2.4 否则，先把栈里面的小的或相同的弹出并输出，然后再把栈外新元素（运算符）入栈。</p><h3 id="顺序存储队列的不足" tabindex="-1"><a class="header-anchor" href="#顺序存储队列的不足" aria-hidden="true">#</a> 顺序存储队列的不足</h3><p>1、一方面，顺序存储的通病就是在不知道最大长度的情况下，容量不好设置。设置大了浪费，小了就溢出。</p><p>2、另一方面，插入和删除元素问题。更改一个，整个数组就要跟着动。影响效率。</p><p>解决方案1：新增一个队头和队尾的指针，插入和删除只是这两指针在动。新问题：“假溢出”：数组前半部分空着，但是数据都在后面存着，数据插入时会出现溢出错误。</p><p>解决方案2：循环队列</p><p>特点就是头尾相连。</p><p>问题又来了：如何判断队列是否为空？</p><p>在前面带两个指针的队列，队头指向首元素，队尾指向尾元素的下一个。这样，队列为空是就是front=rear。那这里的循环队列呢？front=rear有可能是空，有可能是满队列。</p><p>方案1：设置标志量flag。当队列为空时，flag=0,队列满时，flag=1 方案2：保留了个元素空间。当front=rear时，就是表示队列为空。当(rear+1)%QueueSize=front时，队列为满。</p><p>计算队列长度的公式：(rear-front+QueueSize)%QueueSize</p><h2 id="四、字符串" tabindex="-1"><a class="header-anchor" href="#四、字符串" aria-hidden="true">#</a> 四、字符串</h2><p>字符串操作常见的有：生成字符串、复制字符串、清空字符串、字符串是否为空？、字符串长度、字符串比较和字符串拼接、子串、子串索引、替换子串、插入子串、删除子串</p><p>其中的核心操作就是字符串的比较。这里一共提到了三种匹配操作： 1）朴素的模式匹配方法<br> 2）KMP模式匹配算法 3）改进的KMP模式匹配算法</p><p>朴素的模式匹配方法：</p><p>通过循环，将主串的每一个字符和测试串T的每个元素进行比较。采用双层循环结构。优点是想法简单，容易实现，缺点是算法效率低。</p><h2 id="五、树" tabindex="-1"><a class="header-anchor" href="#五、树" aria-hidden="true">#</a> 五、树</h2><blockquote><p>完全二叉树：除了最后一层节点，其余层的节点数已经达到了最大值，且最后一层的节点是按照从左到右的顺序排列的。</p><p>满二叉树：除了最后一层，其余层的节点都有两个子节点。</p><p>二叉排序树：左节点的值一定小于根节点；右节点的值一定大于根节点。</p><p>平衡二叉树：又称AVL树，它是一颗二叉平衡树，且具有以下性质：它是一颗空树或左右两个子树的高度差绝对值不超过1，并且左右两个子树都是一颗平衡二叉树。</p><blockquote><p>说明：平衡因子：左子树高度 - 右子树高度</p></blockquote><p>红黑树：一种自平衡二叉查找树，是一种特化的平衡二叉树。</p></blockquote><figure><img src="https://s3.bmp.ovh/imgs/2022/10/30/ad75abd7cfbc22ba.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>二叉排序树</strong>：</p><p>二叉排序树：是一棵空树，或者：若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；它的左、右子树也分别为二叉排序树。</p><p>二叉排序树意味着二叉树中的数据是排好序的，顺序为左结点&lt;根节点&lt;右结点，这表明二叉排序树的中序遍历结果是有序的。</p><p><strong>平衡二叉树</strong>： 平衡二叉树的产生是为了解决二叉排序树在插入时发生线性排列的现象。由于二叉排序树本身为有序，当插入一个有序程度十分高的序列时，生成的二叉排序树会持续在某个方向的字数上插入数据，导致最终的二叉排序树会退化为链表，从而使得二叉树的查询和插入效率恶化。 <img src="https://s3.bmp.ovh/imgs/2022/10/30/a88628b6aef2dec2.png" alt="" loading="lazy"></p><p>平衡二叉树的出现能够解决上述问题，但是在构造平衡二叉树时，却需要采用不同的调整方式，使得二叉树在插入数据后保持平衡。主要的四种调整方式有LL（左旋）、RR（右旋）、LR（先左旋再右旋）、RL（先右旋再左旋）。这里先给大家介绍下简单的单旋转操作，左旋和右旋。LR和RL本质上只是LL和RR的组合。</p><blockquote><p>在插入一个结点后应该沿搜索路径将路径上的结点平衡因子进行修改，当平衡因子大于1时，就需要进行平衡化处理。从发生不平衡的结点起，沿刚才回溯的路径取直接下两层的结点，如果这三个结点在一条直线上，则采用单旋转进行平衡化，如果这三个结点位于一条折线上，则采用双旋转进行平衡化。</p></blockquote><p>左旋：S为当前需要左旋的结点，E为当前结点的父节点。 <img src="https://s3.bmp.ovh/imgs/2022/10/30/d9a414037fcbe702.png" alt="" loading="lazy"> 左旋的操作可以用一句话简单表示：将当前结点S的左孩子旋转为当前结点父结点E的右孩子，同时将父结点E旋转为当前结点S的左孩子。</p><p>二叉排序树：当插入的数据高度有序时，二叉树会退化成链表，从而使得二叉树的查询和插入效率恶化。</p><p>平衡二叉树优化了查询效率问题。但是在构造平衡二叉树时，却需要采用不同的调整方式使得二叉树在插入数据后保持平衡。高度平衡带来的好处是能够提供更高的搜索效率，其最坏的查找时间复杂度都是O(logN)。</p><p>平衡二叉树带来了插入效率低的问题。有没有一种方法可以兼顾插入效率和查询效率呢？--答案是红黑树。</p><p><strong>红黑树</strong>：</p><p>平衡二叉树（AVL）为了追求高度平衡，需要通过平衡处理使得左右子树的高度差必须小于等于1。高度平衡带来的好处是能够提供更高的搜索效率，其最坏的查找时间复杂度都是O(logN)。但是由于需要维持这份高度平衡，所付出的代价就是当对树种结点进行插入和删除时，需要经过多次旋转实现复衡。这导致AVL的插入和删除效率并不高。</p><p>为了解决这样的问题，能不能找一种结构能够兼顾搜索和插入删除的效率呢？这时候红黑树便申请出战了。</p><p>红黑树的五个特性：</p><blockquote><p>1、每个结点要么是红的要么是黑的。</p><p>2、根结点是黑的。</p><p>3、每个叶结点（叶结点即指树尾端NIL指针或NULL结点）都是黑的。</p><p>4、如果一个结点是红的，那么它的两个儿子都是黑的。</p><p>5、对于任意结点而言，其到叶结点树尾端NIL指针的每条路径都包含相同数目的黑结点。</p></blockquote><p><img src="https://s3.bmp.ovh/imgs/2022/10/30/6810891e8e72ed25.png" alt="" loading="lazy"> 黑树通过将结点进行红黑着色，使得原本高度平衡的树结构被稍微打乱，平衡程度降低。红黑树不追求完全平衡，只要求达到部分平衡。这是一种折中的方案，大大提高了结点删除和插入的效率。C++中的STL就常用到红黑树作为底层的数据结构。</p><p>红黑树VS平衡二叉树 <img src="https://s3.bmp.ovh/imgs/2022/10/30/285dcb87b89c0d04.png" alt="" loading="lazy"></p><p>除了上面所提及的树结构，还有许多广泛应用在数据库、磁盘存储等场景下的树结构。比如B树、B+树等。这里就先不介绍了诶，下次在讲述相关存储原理的时候将会着重介绍。（其实是因为懒）</p><h2 id="六、堆与散列表-哈希表" tabindex="-1"><a class="header-anchor" href="#六、堆与散列表-哈希表" aria-hidden="true">#</a> 六、堆与散列表（哈希表）</h2><h3 id="_6-1-堆" tabindex="-1"><a class="header-anchor" href="#_6-1-堆" aria-hidden="true">#</a> 6.1 堆</h3><p>了解完二叉树，再来理解堆就不是什么难事了。堆通常是一个可以被看做一棵树的数组对象。堆的具体实现一般不通过指针域，而是通过构建一个一维数组与二叉树的父子结点进行对应，因此堆总是一颗完全二叉树。</p><p>对于任意一个父节点的序号n来说（这里n从0算），它的子节点的序号一定是2n+1，2n+2，因此可以直接用数组来表示一个堆。</p><p>不仅如此，堆还有一个性质：堆中某个节点的值总是不大于或不小于其父节点的值。将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。</p><p><img src="https://s3.bmp.ovh/imgs/2022/10/30/a0e7cdbcd8e45b1d.png" alt="" loading="lazy"> 堆常用来实现优先队列，在面试中经常考的问题都是与排序有关，比如堆排序、topK问题等。由于堆的根节点是序列中最大或者最小值，因而可以在建堆以及重建堆的过程中，筛选出数据序列中的极值，从而达到排序或者挑选topK值的目的。</p><h3 id="_6-2-哈希表" tabindex="-1"><a class="header-anchor" href="#_6-2-哈希表" aria-hidden="true">#</a> 6.2 哈希表</h3><p>散列表也叫哈希表，是一种通过键值对直接访问数据的机构。在初中，我们就学过一种能够将一个x值通过一个函数获得对应的一个y值的操作，叫做映射。散列表的实现原理正是映射的原理，通过设定的一个关键字和一个映射函数，就可以直接获得访问数据的地址，实现O(1)的数据访问效率。在映射的过程中，事先设定的函数就是一个映射表，也可以称作散列函数或者哈希函数。 <img src="https://s3.bmp.ovh/imgs/2022/10/30/3ba468006ba54746.png" alt="" loading="lazy"> 散列表的实现最关键的就是散列函数的定义和选择。一般常用的有以下几种散列函数：</p><blockquote><p>直接寻址法：取关键字或关键字的某个线性函数值为散列地址。</p><p>数字分析法：通过对数据的分析，发现数据中冲突较少的部分，并构造散列地址。例如同学们的学号，通常同一届学生的学号，其中前面的部分差别不太大，所以用后面的部分来构造散列地址。</p><p>平方取中法：当无法确定关键字里哪几位的分布相对比较均匀时，可以先求出关键字的平方值，然后按需要取平方值的中间几位作为散列地址。这是因为：计算平方之后的中间几位和关键字中的每一位都相关，所以不同的关键字会以较高的概率产生不同的散列地址。</p><p>取随机数法：使用一个随机函数，取关键字的随机值作为散列地址，这种方式通常用于关键字长度不同的场合。</p><p>除留取余法：取关键字被某个不大于散列表的表长 n 的数 m 除后所得的余数 p 为散列地址。这种方式也可以在用过其他方法后再使用。该函数对 m 的选择很重要，一般取素数或者直接用 n。</p></blockquote><p>确定好散列函数之后，通过某个key值的确会得到一个唯一的value地址。但是却会出现一些特殊情况。即通过不同的key值可能会访问到同一个地址，这个现象称之为冲突。</p><p>冲突在发生之后，当在对不同的key值进行操作时会使得造成相同地址的数据发生覆盖或者丢失，是非常危险的。所以在设计散列表往往还需要采用冲突解决的办法。</p><p>常用的冲突处理方式有很多，常用的包括以下几种：</p><blockquote><p>开放地址法（也叫开放寻址法）：实际上就是当需要存储值时，对Key哈希之后，发现这个地址已经有值了，这时该怎么办？不能放在这个地址，不然之前的映射会被覆盖。这时对计算出来的地址进行一个探测再哈希，比如往后移动一个地址，如果没人占用，就用这个地址。如果超过最大长度，则可以对总长度取余。这里移动的地址是产生冲突时的增列序量。</p><p>再哈希法：在产生冲突之后，使用关键字的其他部分继续计算地址，如果还是有冲突，则继续使用其他部分再计算地址。这种方式的缺点是时间增加了。</p><p>链地址法：链地址法其实就是对Key通过哈希之后落在同一个地址上的值，做一个链表。其实在很多高级语言的实现当中，也是使用这种方式处理冲突的。</p><p>公共溢出区：这种方式是建立一个公共溢出区，当地址存在冲突时，把新的地址放在公共溢出区里。</p></blockquote><p>目前比较常用的冲突解决方法是链地址法，一般可以通过数组和链表的结合达到冲突数据缓存的目的。 <img src="https://s3.bmp.ovh/imgs/2022/10/30/77f0d941522f5204.png" alt="" loading="lazy"></p><p>左侧数组的每个成员包括一个指针，指向一个链表的头。每发生一个冲突的数据，就将该数据作为链表的节点链接到链表尾部。这样一来，就可以保证冲突的数据能够区分并顺利访问。</p><p>考虑到链表过长造成的问题，还可以使用红黑树替换链表进行冲突数据的处理操作，来提高散列表的查询稳定性。</p><h2 id="七、图" tabindex="-1"><a class="header-anchor" href="#七、图" aria-hidden="true">#</a> 七、图</h2><p>图相较于上文的几个结构可能接触的不多，但是在实际的应用场景中却经常出现。比方说交通中的线路图，常见的思维导图都可以看作是图的具体表现形式。</p><p>图结构一般包括顶点和边，顶点通常用圆圈来表示，边就是这些圆圈之间的连线。边还可以根据顶点之间的关系设置不同的权重，默认权重相同皆为1。此外根据边的方向性，还可将图分为有向图和无向图。 <img src="https://s3.bmp.ovh/imgs/2022/10/30/6895b3dbf5ae8d5f.png" alt="" loading="lazy"> 图结构用抽象的图线来表示十分简单，顶点和边之间的关系非常清晰明了。但是在具体的代码实现中，为了将各个顶点和边的关系存储下来，却不是一件易事。</p><h2 id="八、算法-查找" tabindex="-1"><a class="header-anchor" href="#八、算法-查找" aria-hidden="true">#</a> 八、算法：查找</h2>`,65),ss={href:"https://blog.csdn.net/chenlong_cxy/article/details/116563972?spm=1001.2101.3001.6661.1&depth_1-",target:"_blank",rel:"noopener noreferrer"},ns={href:"https://blog.csdn.net/heyuchang666/article/details/50041455?spm=1001.2101.3001.6650.1&depth_1-",target:"_blank",rel:"noopener noreferrer"},as={href:"https://blog.csdn.net/heyuchang666/article/details/47275047",target:"_blank",rel:"noopener noreferrer"},es=s("h2",{id:"九、算法-排序",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#九、算法-排序","aria-hidden":"true"},"#"),n(" 九、算法：排序")],-1);function ps(ts,ls){const t=i("font"),p=i("ExternalLinkIcon");return l(),o("div",null,[m,d(" more "),k,a(t,{color:"red"},{default:c(()=>[n("线性表的顺序存储结构")]),_:1}),n("代码："),h,a(t,{color:"red"},{default:c(()=>[n("线性表的链式存储结构")]),_:1}),n("："),b,a(t,{color:"red"},{default:c(()=>[n("结论")]),_:1}),n("：情况1：若线性表需要频繁查找，很少进行插入和删除操作时，宜采用顺序存储结构。若需要频繁插入和删除时，宜采用单链表结构。举个简单的例子，游戏开发中的玩家账号信息，只有注册时需要插入，平时一般是查询操作，最好采用顺序结构。游戏装备会频繁刷新，经常读写，最好采用链式结构。"),v,s("p",null,[n("补充一点，散列表（Hash哈希表）：一种由数组和链表组合起来的数据结构，（也可能是数组、链表和红黑树组合起来），它兼顾数组和链表的优点，有较好的查询性能和插入/删除性能。"),s("a",g,[n("参考CSDN博客"),a(p)]),n("，哈希表的结构如图所示： "),_]),y,s("p",f,[s("span",x,[s("span",w,[L,s("span",O,[z,s("span",q,[M,s("span",S,[s("span",E,[s("span",N,[s("span",V,[s("span",F,[s("span",I,[j,s("span",B,[R,s("span",A,[(l(),o("svg",H,C))])]),K,s("span",D,[Q,s("span",P,[(l(),o("svg",X,Z))])]),G]),U]),$])])]),J])])])])])]),W,s("p",null,[n("参考： "),s("a",ss,[n("https://blog.csdn.net/chenlong_cxy/article/details/116563972?spm=1001.2101.3001.6661.1&depth_1-"),a(p)])]),s("p",null,[n("参考："),s("a",ns,[n("https://blog.csdn.net/heyuchang666/article/details/50041455?spm=1001.2101.3001.6650.1&depth_1-"),a(p)])]),s("p",null,[n("参考："),s("a",as,[n("https://blog.csdn.net/heyuchang666/article/details/47275047"),a(p)])]),es])}const cs=r(u,[["render",ps],["__file","大话数据结构和算法.html.vue"]]);export{cs as default};
