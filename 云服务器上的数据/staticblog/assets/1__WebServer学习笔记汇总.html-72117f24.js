import{$ as p,a0 as d,a1 as o,a6 as c,a2 as e,a3 as n,a4 as l,a9 as s,a5 as a,I as r}from"./framework-e783454b.js";const u={},h=e("div",{class:"hint-container tip"},[e("p",{class:"hint-container-title"},"提示"),e("p",null,"WebServer项目相关")],-1),v=a('<h1 id="webserver项目学习总结" tabindex="-1"><a class="header-anchor" href="#webserver项目学习总结" aria-hidden="true">#</a> WebServer项目学习总结</h1><h2 id="零、前言" tabindex="-1"><a class="header-anchor" href="#零、前言" aria-hidden="true">#</a> 零、前言</h2><p>0、为什么还要做webserver</p><p>1、所需要的基本知识</p><ul><li>1）编程语言</li><li>2）操作系统相关</li><li>3）计算机网路</li><li>4）数据库</li></ul><p>2、设计的内容</p>',6),b=e("li",null,[n("1）并发框架 （1） "),e("ul",null,[e("li",null,"Reactor模式"),e("li",null,"Proactor模式")])],-1),m={href:"https://blog.csdn.net/ShenHang_/article/details/115201561",target:"_blank",rel:"noopener noreferrer"},g={href:"https://blog.csdn.net/ShenHang_/article/details/115201561",target:"_blank",rel:"noopener noreferrer"},_=e("li",null,"2）基本http处理逻辑",-1),k=e("li",null,"3）日志系统",-1),f=e("li",null,"4）内存池",-1),x=e("li",null,[e("ol",{start:"5"},[e("li",null,"线程池")])],-1),T=e("li",null,"6）定时器",-1),w=e("li",null,"7）LFU（最不经常使用页置换算法）",-1),L=e("li",null,"8）部署相关",-1),y=e("li",null,"9）性能测试的原理和结果webbench软件",-1),S=a("<p>3、问题</p><ul><li>项目介绍 <ul><li>①简单介绍⼀下你的项⽬？</li><li>②项⽬中的难点？</li><li>③项⽬中遇到的困难？是如何解决的？</li><li>④针对项⽬做了哪些优化？</li><li>⑤项⽬中⽤到哪些设计模式？</li><li>⑥这个web服务器是你⾃⼰申请的域名吗</li><li>⑦C++ ⾯向对象特性在项⽬中的体现？</li></ul></li><li>项目细节 <ul><li>①线程池 <ul><li>你的线程池⼯作线程处理完⼀个任务后的状态是什么？</li><li>讲⼀下你项⽬中线程池的作⽤？具体是怎么实现的？有参考开源的线程池实现吗？</li><li>请你实现⼀个简单的线程池（现场⼿撕）</li></ul></li><li>②日志系统</li><li>③缓存机制</li><li>④内存池 <ul><li>讲一讲问什么要加入内存池？项目中所有的内存申请都要走内存池吗？</li></ul></li><li>⑤并发性问题 <ul><li>如果同时1000个客户端进⾏访问请求，线程数不多，怎么能及时响应处理每⼀个呢？</li><li>如果⼀个客户请求需要占⽤线程很久的时间，会不会影响接下来的客户请求呢，有什么好的策略 呢？</li></ul></li><li>⑥IO多路复用 <ul><li>说⼀下什么是ET，什么是LT，有什么区别？</li><li>LT什么时候会触发？ET呢？</li><li>为什么ET模式不可以⽂件描述符阻塞，⽽LT模式可以呢？</li><li>你⽤了epoll，说⼀下为什么⽤epoll，还有其他多路复⽤⽅式吗？区别是什么？</li></ul></li><li>⑦并发模型 <ul><li>reactor、proactor模型的区别？</li><li>reactor模式中，各个模式的区别？</li></ul></li><li>⑧跳表skipList</li><li>⑨测试的相关问题</li></ul></li></ul><p>参考资料汇总：</p>",3),P={href:"https://huixxi.github.io/2020/06/02/%E5%B0%8F%E7%99%BD%E8%A7%86%E8%A7%92%EF%BC%9A%E4%B8%80%E6%96%87%E8%AF%BB%E6%87%82%E7%A4%BE%E9%95%BF%E7%9A%84TinyWebServer/#more",target:"_blank",rel:"noopener noreferrer"},C={href:"https://mp.weixin.qq.com/s/Lg3jogZ_dszXoEvLIHT4Qg",target:"_blank",rel:"noopener noreferrer"},E={href:"https://mp.weixin.qq.com/s/04f4UuDLgzAF1-TV1QwoXg",target:"_blank",rel:"noopener noreferrer"},O={href:"https://zhuanlan.zhihu.com/p/269247362",target:"_blank",rel:"noopener noreferrer"},q={href:"https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247507842&idx=1&sn=e6311f4909c4188c88b1fd2c0adcc43e&chksm=f9a1ecd3ced665c54375a4a840b364d7d3c782ff0e8d686d230187c2c54afcb8063ef46ba631&scene=126&sessionid=1687525760#rd",target:"_blank",rel:"noopener noreferrer"},I={href:"https://mp.weixin.qq.com/s/aBD8pgOa02OBjlGrFAvpCA",target:"_blank",rel:"noopener noreferrer"},A=e("h2",{id:"一、个人对tinywebserver的学习总结",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#一、个人对tinywebserver的学习总结","aria-hidden":"true"},"#"),n(" 一、个人对TinyWebServer的学习总结")],-1),U={href:"https://huixxi.github.io/2020/06/02/%E5%B0%8F%E7%99%BD%E8%A7%86%E8%A7%92%EF%BC%9A%E4%B8%80%E6%96%87%E8%AF%BB%E6%87%82%E7%A4%BE%E9%95%BF%E7%9A%84TinyWebServer/#more",target:"_blank",rel:"noopener noreferrer"},W=a('<h3 id="_1、io复用技术" tabindex="-1"><a class="header-anchor" href="#_1、io复用技术" aria-hidden="true">#</a> 1、IO复用技术</h3><p>  服务器端的通过socket的accept来接受客户端请求，使用epoll这种IO复用技术（还有select和poll）来实现对监听socket(listen)和连接socket(客户端请求)的同时监听。注意IO复用可以同时间挺多个文件描述符，但它本身是阻塞的，因此在调用多线程来处理每一个文件描述符上的事件。</p><ul><li>select: 遍历所有fd，并且会将所有fd从内核态拷贝到用户态，消耗大，且在高并发环境下效率极低，有fd连接数量1024个的限制，数组实现；优点在于编程简单。</li><li>poll：与select类似，会有将所有从内核态拷贝至用户态的资料损耗，有对所有fd的轮询，不过相较于select的优点是无fd数量限制，因为使用链表实现的。</li><li>epoll：在Linux内核2.4.6之后可以使用，epoll监测所有fd，有事件发生才处理，不必轮询。有LT水平触发（默认）和ET边缘触发（高速模式）。水平触发模式下，只要该fd还有数据刻度，epoll_waite就都会返回它的事件，而边缘触发模式下，读一个fd必须把它里面的内容一次性读完，即读到read返回值小于请求值或遇到EAGAIN错误。</li></ul><p>  总的来说，epoll的优点是：</p><ul><li>无最大并发连接的限制，能打开的FD上限远大于1024（1G内存能监听约10万个端口）</li><li>效率提升，不是轮询，不会随FD数目增加而效率下降。只有活跃可用的FD才会调用callback函数 即Epoll最大优点在于它只关心“活跃”连接，而跟连接总数无关，因此实际网络环境中，epoll效率远高于select、poll</li><li>内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销。</li><li>epoll通过内核和用户空间共享一块内存而实现</li></ul><p>  但是，缺点在于：</p><ul><li>在连接数少且都十分活跃情况下，select/poll性能可能比epoll好，毕竟epoll通知机制需要很多函数回调。</li><li>epoll的跨平台性能可能不太好：epoll跟select都能提供多路I/O复用。在现在的Linux内核里有都能够支持，epoll是Linux所特有，而select则是POSIX所规定，一般os均有实现。</li><li>epoll的编程比较复杂：select和poll都只提供一个函数：select或poll函数。而epoll提供了三个函数：epoll_create、epoll_ctl、epoll_wait</li></ul><p>  epoll的时间消耗主要在系统调用，而select/poll的时间消耗主要在于内核判断是否有文件描述符就绪这一过程：每次执行select或poll调用时，它们会采用遍历的方式，遍历整个文件描述符集合去判断各个文件描述符是否有活动。select/poll只支持低效率的LT模式，epoll支持LT(默认值)和ET。在短期活跃连接中，select/poll的效率反而高于epoll。</p><p>  应用场景</p><ul><li><p>当所有的fd都是活跃连接，使用epoll，需要建立文件系统，红黑书和链表对于此来说，效率反而不高，不如selece和poll</p></li><li><p>当监测的fd数目较小，且各个fd都比较活跃，建议使用select或者poll</p></li><li><p>当监测的fd数目非常大，成千上万，且单位时间只有其中的一部分fd处于就绪状态，这个时候使用epoll能够明显提升性能</p></li></ul><p>  <strong>ET、LT、EPOLLONESHOT介绍</strong></p><ul><li><p>LT水平触发模式</p><ul><li>epoll_wait检测到文件描述符有事件发生，则将其通知给应用程序，应用程序可以不立即处理该事件。</li><li>当下一次调用epoll_wait时，epoll_wait还会再次向应用程序报告此事件，直至被处理</li></ul></li><li><p>ET边缘触发模式</p><ul><li>epoll_wait检测到文件描述符有事件发生，则将其通知给应用程序，应用程序必须立即处理该事件</li><li>必须要一次性将数据读取完，使用非阻塞I/O，读取到出现eagain</li></ul></li><li><p>EPOLLONESHOT</p><ul><li>一个线程读取某个socket上的数据后开始处理数据，在处理过程中该socket上又有新数据可读，此时另一个线程被唤醒读取，此时出现两个线程处理同一个socket</li><li>我们期望的是一个socket连接在任一时刻都只被一个线程处理，通过epoll_ctl对该文件描述符注册epolloneshot事件，一个线程处理socket时，其他线程将无法处理，当该线程处理完后，需要通过epoll_ctl重置epolloneshot事件</li></ul></li></ul><h3 id="_2、并发处理模式" tabindex="-1"><a class="header-anchor" href="#_2、并发处理模式" aria-hidden="true">#</a> 2、并发处理模式</h3><p>  服务器程序通常需要处理三类事件：I/O事件，信号及定时事件。有两种事件处理模式：</p>',14),N=e("li",null,"Reactor模式：要求主线程（I/O处理单元）只负责监听文件描述符上是否有事件发生（可读、可写），若有，则立即通知工作线程（逻辑单元），将socket可读可写事件放入请求队列，交给工作线程处理。【主线程：监听事件+分发任务；工作线程：具体的IO操作和逻辑处理】",-1),H=e("code",null,"users[sockfd].read()",-1),z=e("code",null,"pool->append(users + sockfd)",-1),j=e("code",null,"process()",-1),B=e("p",null,"  Reactor 可以理解为「来了事件操作系统通知应用进程，让应用进程来处理」，而 Proactor 可以理解为「来了事件操作系统来处理，处理完再通知应用进程」。这里的「事件」就是有新连接、有数据可读、有数据可写的这些 I/O 事件这里的「处理」包含从驱动读取到内核以及从内核读取到用户空间。",-1),R=e("p",null,"  举个实际生活中的例子，Reactor 模式就是快递员在楼下，给你打电话告诉你快递到你家小区了，你需要自己下楼来拿快递。而在 Proactor 模式下，快递员直接将快递送到你家门口，然后通知你。",-1),F=e("p",null,"  无论是 Reactor，还是 Proactor，都是一种基于「事件分发」的网络编程模式，区别在于 Reactor 模式是基于「待完成」的 I/O 事件，而 Proactor 模式则是基于「已完成」的 I/O 事件。",-1),D=e("p",null,"  也就是说，Proactor异步IO效率更高。但是Linux是模拟的异步IO，在 Linux 下的异步 I/O 是不完善的，aio 系列函数是由 POSIX 定义的异步操作接口，不是真正的操作系统级别支持的，而是在用户空间模拟出来的异步，并且仅仅支持基于本地文件的 aio 异步操作，网络编程中的 socket 是不支持的，这也使得基于 Linux 的高性能网络程序都是使用 Reactor 方案（TinyRaw版本是使用的模拟Proactor模式，主线程监控+IO操作，工作线程只处理逻辑）。",-1),M=e("p",null,"  而 Windows 里实现了一套完整的支持 socket 的异步编程接口，这套接口就是 IOCP，是由操作系统级别实现的异步 I/O，真正意义上异步 I/O，因此在 Windows 里实现高性能网络程序可以使用效率更高的 Proactor 方案。",-1),G={href:"https://github.com/XiaoYuer2022/My_TinyWebServer_full_version",target:"_blank",rel:"noopener noreferrer"},K=a('<p>  raw版本使用的是模拟的Proactor，主线程监控和IO操作（read_once() / write()），工作线程只处理逻辑(process())。full版本实现了模拟的Proactor和Reactor模式。</p><h3 id="_3、程序逻辑" tabindex="-1"><a class="header-anchor" href="#_3、程序逻辑" aria-hidden="true">#</a> 3、程序逻辑</h3><p>  该项目使用线程池（半同步半反应堆模式）并发处理用户请求，主线程负责读写，工作线程（线程池中的线程）负责处理逻辑（HTTP请求报文的解析等等）。通过之前的代码，我们将listenfd上到达的connection通过 accept()接收，并返回一个新的socket文件描述符connfd用于和用户通信，并对用户请求返回响应，同时将这个connfd注册到内核事件表中，等用户发来请求报文。这个过程是：通过epoll_wait发现这个connfd上有可读事件了（EPOLLIN），主线程就将这个HTTP的请求报文读进这个连接socket的读缓存中users[sockfd].read()，然后将该任务对象（指针）插入线程池的请求队列中pool-&gt;append(users + sockfd);，线程池的实现还需要依靠锁机制以及信号量机制来实现线程同步，保证操作的原子性。</p><p>  在线程池部分做几点解释，然后大家去看代码的时候就更容易看懂了：</p><ul><li>所谓线程池，就是一个pthread_t类型的普通数组，通过pthread_create()函数创建m_thread_number个线程，用来执行worker()函数以执行每个请求处理函数（HTTP请求的process函数），通过pthread_detach()将线程设置成脱离态（detached）后，当这一线程运行结束时，它的资源会被系统自动回收，而不再需要在其它线程中对其进行 pthread_join() 操作。</li><li>操作工作队列一定要加锁（locker），因为它被所有线程共享。</li><li>我们用信号量来标识请求队列中的请求数，通过m_queuestat.wait();来等待一个请求队列中待处理的HTTP请求，然后交给线程池中的空闲线程来处理。</li></ul><h4 id="为什么要使用线程池" tabindex="-1"><a class="header-anchor" href="#为什么要使用线程池" aria-hidden="true">#</a> <strong>为什么要使用线程池？</strong></h4><p>  当你需要限制你应用程序中同时运行的线程数时，线程池非常有用。因为启动一个新线程会带来性能开销，每个线程也会为其堆栈分配一些内存等。为了任务的并发执行，我们可以将这些任务任务传递到线程池，而不是为每个任务动态开启一个新的线程。</p><h4 id="线程池中的线程数量是依据什么确定的" tabindex="-1"><a class="header-anchor" href="#线程池中的线程数量是依据什么确定的" aria-hidden="true">#</a> <strong>⭐线程池中的线程数量是依据什么确定的？</strong></h4>',8),Q={href:"https://stackoverflow.com/questions/16128436/setting-ideal-size-of-thread-pool/16128493#16128493",target:"_blank",rel:"noopener noreferrer"},X=a(`<h3 id="_4、http的处理逻辑" tabindex="-1"><a class="header-anchor" href="#_4、http的处理逻辑" aria-hidden="true">#</a> 4、HTTP的处理逻辑</h3><p>  在线程池中，通过pthread_create函数创建work()线程，在通过work()函数来启动run函数。在run()函数中是一个信号量的等待函数和一个while()死循环，while()死循环中如果是reactor模式就是先处理IO数据：read_once()或write()函数，在处理HTTP逻辑：process()函数。每当需要触发读/写事件时，调用append/append_p()函数向工作线程链表中添加一个新的http对象（使用C++的模板T），再释放一个信号量来启动一个工作线程。   process()是用来解析http请求报文并添加http响应报文的，分别调用process_read()和process_write()来实现对应的功能。</p><figure><img src="https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdljwGeiv29xBgBKgN/root/content" alt="content" tabindex="0" loading="lazy"><figcaption>content</figcaption></figure><p><strong>HTTP的报文格式</strong>：</p><ul><li>请求报文 <ul><li><ol><li>解析请求行（第一行）</li></ol></li><li><ol start="2"><li>解析头（一般是若干行）</li></ol></li><li><ol start="3"><li>空行</li></ol></li><li><ol start="4"><li>请求数据（POST有，GET没有这个）</li></ol></li></ul></li><li>响应报文 <ul><li><ol><li>状态行（第一行）</li></ol></li><li><ol start="2"><li>消息报头（属于附加消息，若干行）</li></ol></li><li><ol start="3"><li>空行</li></ol></li><li>响应数据（）</li></ul></li></ul><p>下面是http报文示例：</p><ul><li>HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据四个部分组成。</li><li>HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。</li></ul><p>1）请求报文：GET 用于获取<code>/</code>下的root/judge.html文件：</p><div class="language-http line-numbers-mode" data-ext="http"><pre class="language-http"><code><span class="token request-line"><span class="token method property">GET</span> <span class="token request-target url">/</span> <span class="token http-version property">HTTP/1.1</span></span>
<span class="token header"><span class="token header-name keyword">Host</span><span class="token punctuation">:</span> <span class="token header-value">47.115.211.46:9999</span></span>
<span class="token header"><span class="token header-name keyword">User-Agent</span><span class="token punctuation">:</span> <span class="token header-value">Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.0.0 Safari/537.36 Edg/113.0.1774.57</span></span>
<span class="token header"><span class="token header-name keyword">Accept</span><span class="token punctuation">:</span> <span class="token header-value">text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7</span></span>
<span class="token header"><span class="token header-name keyword">Accept-Encoding</span><span class="token punctuation">:</span> <span class="token header-value">gzip, deflate</span></span>
<span class="token header"><span class="token header-name keyword">Accept-Language</span><span class="token punctuation">:</span> <span class="token header-value">zh-CN,zh;q=0.9,en;q=0.8,en-US;q=0.7</span></span>
<span class="token header"><span class="token header-name keyword">Dnt</span><span class="token punctuation">:</span> <span class="token header-value">1</span></span>
<span class="token header"><span class="token header-name keyword">Upgrade-Insecure-Requests</span><span class="token punctuation">:</span> <span class="token header-value">1</span></span>
&lt;这里是空行&gt;
&lt;这里是请求的数据，为空&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2）请求报文：POST 用户账户登录</p><div class="language-http line-numbers-mode" data-ext="http"><pre class="language-http"><code><span class="token request-line"><span class="token method property">POST</span> <span class="token request-target url">/2CGISQL.cgi</span> <span class="token http-version property">HTTP/1.1</span></span>
<span class="token header"><span class="token header-name keyword">Host</span><span class="token punctuation">:</span> <span class="token header-value">47.115.211.46:9999</span></span>
<span class="token header"><span class="token header-name keyword">User-Agent</span><span class="token punctuation">:</span> <span class="token header-value">Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.0.0 Safari/537.36 Edg/113.0.1774.57</span></span>
<span class="token header"><span class="token header-name keyword">Content-Length</span><span class="token punctuation">:</span> <span class="token header-value">21</span></span>
<span class="token header"><span class="token header-name keyword">Accept</span><span class="token punctuation">:</span> <span class="token header-value">text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7</span></span>
<span class="token header"><span class="token header-name keyword">Accept-Encoding</span><span class="token punctuation">:</span> <span class="token header-value">gzip, deflate</span></span>
<span class="token header"><span class="token header-name keyword">Accept-Language</span><span class="token punctuation">:</span> <span class="token header-value">zh-CN,zh;q=0.9,en;q=0.8,en-US;q=0.7</span></span>
<span class="token header"><span class="token header-name keyword">Cache-Control</span><span class="token punctuation">:</span> <span class="token header-value">max-age=0</span></span>
<span class="token header"><span class="token header-name keyword">Content-Type</span><span class="token punctuation">:</span> <span class="token header-value">application/x-www-form-urlencoded</span></span>
<span class="token header"><span class="token header-name keyword">Dnt</span><span class="token punctuation">:</span> <span class="token header-value">1</span></span>
<span class="token header"><span class="token header-name keyword">Origin</span><span class="token punctuation">:</span> <span class="token header-value">http://47.115.211.46:9999</span></span>
<span class="token header"><span class="token header-name keyword">Referer</span><span class="token punctuation">:</span> <span class="token header-value">http://47.115.211.46:9999/1</span></span>
<span class="token header"><span class="token header-name keyword">Upgrade-Insecure-Requests</span><span class="token punctuation">:</span> <span class="token header-value">1</span></span>
&lt;这里是空行&gt;
user=yuhao&amp;password=1      //这里是请求的数据，POST的话请求数据放在尾部
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,11),V=a("<li><p><strong>请求行</strong>，用来说明请求类型,要访问的资源以及所使用的HTTP版本。 GET说明请求类型为GET，/562f25980001b1b106000338.jpg(URL)为要访问的资源，该行的最后一部分说明使用的是HTTP1.1版本。</p></li><li><p><strong>请求头部</strong>，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息。</p><ul><li><p>HOST，给出请求资源所在服务器的域名。</p></li><li><p>User-Agent，HTTP客户端程序的信息，该信息由你发出请求使用的浏览器来定义,并且在每个请求中自动发送等。</p></li><li><p>Accept，说明用户代理可处理的媒体类型。</p></li><li><p>Accept-Encoding，说明用户代理支持的内容编码。</p></li><li><p>Accept-Language，说明用户代理能够处理的自然语言集。</p></li><li><p>Content-Type，说明实现主体的媒体类型。</p></li><li><p>Content-Length，说明实现主体的大小。</p></li><li><p>Connection，连接管理，可以是Keep-Alive或close。</p></li></ul></li>",2),Y=e("strong",null,"空行",-1),Z=e("li",null,[e("p",null,[e("strong",null,"请求数据"),n("也叫主体，可以添加任意的其他数据。")])],-1),$=a(`<p>3）响应报文：</p><div class="language-http line-numbers-mode" data-ext="http"><pre class="language-http"><code><span class="token response-status"><span class="token http-version property">HTTP/1.1</span> <span class="token status-code number">200</span> <span class="token reason-phrase string">OK</span></span>
<span class="token header"><span class="token header-name keyword">Content-Length</span><span class="token punctuation">:</span><span class="token header-value">587</span></span>
<span class="token header"><span class="token header-name keyword">Connection</span><span class="token punctuation">:</span><span class="token header-value">close</span></span>

&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot;&gt;
        &lt;title&gt;WebServer&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
    &lt;br/&gt;
    &lt;br/&gt;
    &lt;div align=&quot;center&quot;&gt;&lt;font size=&quot;15&quot;&gt; &lt;strong&gt;欢迎访问&lt;/strong&gt;&lt;/font&gt;&lt;/div&gt;
	&lt;br/&gt;
		&lt;br/&gt;
		&lt;form action=&quot;0&quot; method=&quot;post&quot;&gt;
 			&lt;div align=&quot;center&quot;&gt;&lt;button type=&quot;submit&quot;&gt;新用户&lt;/button&gt;&lt;/div&gt;
                &lt;/form&gt;
		&lt;br/&gt;
                &lt;form action=&quot;1&quot; method=&quot;post&quot;&gt;
                        &lt;div align=&quot;center&quot;&gt;&lt;button type=&quot;submit&quot; &gt;已有账号&lt;/button&gt;&lt;/div&gt;
                &lt;/form&gt;
		
		
        &lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,2),J=e("li",null,[e("p",null,"状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。 第一行为状态行，（HTTP/1.1）表明HTTP版本为1.1版本，状态码为200，状态消息为OK。")],-1),ee=e("li",null,[e("p",null,"消息报头，用来说明客户端要使用的一些附加信息。 第二行和第三行为消息报头，Date:生成响应的日期和时间；Content-Type:指定了MIME类型的HTML(text/html),编码类型是UTF-8。")],-1),ne=e("li",null,[e("p",null,"响应正文，服务器返回给客户端的文本信息。空行后面的html部分为响应正文。")],-1),le=a(`<p>HTTP的五类响应码：</p><ul><li><p>1xx：指示信息--表示请求已接收，继续处理。</p></li><li><p>2xx：成功--表示请求正常处理完毕。</p><ul><li><p>200 OK：客户端请求被正常处理。</p></li><li><p>206 Partial content：客户端进行了范围请求。</p></li></ul></li><li><p>3xx：重定向--要完成请求必须进行更进一步的操作。</p><ul><li><p>301 Moved Permanently：永久重定向，该资源已被永久移动到新位置，将来任何对该资源的访问都要使用本响应返回的若干个URI之一。</p></li><li><p>302 Found：临时重定向，请求的资源现在临时从不同的URI中获得。</p></li></ul></li><li><p>4xx：客户端错误--请求有语法错误，服务器无法处理请求。</p><ul><li><p>400 Bad Request：请求报文存在语法错误。</p></li><li><p>403 Forbidden：请求被服务器拒绝。</p></li><li><p>404 Not Found：请求不存在，服务器上找不到请求的资源。</p></li></ul></li><li><p>5xx：服务器端错误--服务器处理请求出错。</p><ul><li>500 Internal Server Error：服务器在执行请求时出现错误。</li></ul></li></ul><p>HTTP的处理流程：</p><ul><li><ol><li>浏览器端发出http连接请求，主线程创建http对象接收请求并将所有数据读入对应buffer，将该对象插入任务队列，工作线程从任务队列中取出一个任务进行处理。</li></ol></li><li><ol start="2"><li>工作线程取出任务后，调用process_read函数，通过主、从状态机对请求报文进行解析。</li></ol></li><li><ol start="3"><li>解析完之后，跳转do_request函数生成响应报文，通过process_write写入buffer，返回给浏览器端。</li></ol></li></ul><p>在本项目的HTTP处理中，使用主从状态机来对HTTP服务进行处理。<strong>从状态机负责读取报文的一行，主状态机负责对该行数据进行解析</strong>，主状态机内部调用从状态机，从状态机驱动主状态机。</p><figure><img src="https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlj2jCXv-a7l80amG/root/content" alt="content" tabindex="0" loading="lazy"><figcaption>content</figcaption></figure><p><strong>主状态机</strong></p><p>三种状态标识解析位置：</p><ul><li>CHECK_STATE_REQUESTLINE，解析请求行</li><li>CHECK_STATE_HEADER，解析请求头</li><li>CHECK_STATE_CONTENT，解析消息体，仅用于解析POST请求</li></ul><p><strong>从状态机</strong></p><p>三种状态，标识解析一行的读取状态。</p><ul><li>LINE_OK，完整读取一行</li><li>LINE_BAD，报文语法有误</li><li>LINE_OPEN，读取的行不完整（读取到/r/n字符表示读完，返回LINE_OK状态；否则等待新数据到达）</li></ul><figure><img src="https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdljwGeiv29xBgBKgN/root/content" alt="content" tabindex="0" loading="lazy"><figcaption>content</figcaption></figure><p>将上面两张图比对着学习。</p><p>  在HTTP报文中，每一行的数据由\\r\\n作为结束字符，空行则是仅仅是字符\\r\\n。因此，可以通过查找\\r\\n将报文拆解成单独的行进行解析，项目中便是利用了这一点。</p><h3 id="_5、c-的新特性" tabindex="-1"><a class="header-anchor" href="#_5、c-的新特性" aria-hidden="true">#</a> 5、C++的新特性</h3><p>  单例模式（饿汉模式和懒汉模式）、   单例模式是一种最简单的设计模式，分为懒汉模式和饿汉模式。懒汉模式第一次调用时才分配空间，饿汉模式程序运行时立刻分配空间。该类函数的通常特征为：1）该类的构造函数为私有类型；2）返回值类型为类对象指针，且是static类型的。使用类的私有静态指针变量指向类的唯一实例，并用一个公有的静态方法获取该实例。</p><p>  单例模式，保证一个类只创建一个实例，同时提供全局访问的方法。本项目中使用的是懒汉模式，在main函数中需要手动调用<code>Log::get_instance()-&gt;init(&quot;output/WebServerSYN&quot;, 2000, 800000, 0);//同步日志</code>来获取唯一日志对象实例。</p><p>  1）经典线程安全的懒汉模式：</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>class single{
private:
	static single *p; //私有静态指针变量指向唯一实例
	static pthread_mutex_t lock; //静态锁，是由于静态函数只能访问静态成员
	single(){
		pthread_mutex_init(&amp;lock,NULL); //私有化构造函数
	}
	~single(){}
public:
	static single* getinstance();
};
//静态变量在类外初始化
pthread_mutex_t single::lock;
single* single::p = NULL;

single* single::getinstance(){
	if (NULL == p){
		pthread_mutex_lock(&amp;lock);
		if (NULL == p){
			p = new single;
		}
		pthread_mutex_unlock(&amp;lock);
	}
	return p;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>  <strong>上面为什么要用双检测，只检测一次不行吗？</strong></p><p>  如果只检测一次，在每次调用获取实例的方法时，都需要加锁，这将严重影响程序性能。双层检测可以有效避免这种情况，仅在第一次创建单例的时候加锁，其他时候都不再符合NULL == p的情况，直接返回已创建好的实例。</p><p>  2）局部静态变量之线程安全懒汉模式</p><p>  前面的双检测锁模式，写起来不太优雅，《Effective C++》（Item 04）中的提出另一种更优雅的单例模式实现，使用函数内的局部静态对象，这种方法不用加锁和解锁操作。</p><p>  这种方法不加锁也不会造成线程安全问题，因为C++0X以后，要求编译器保证内部静态变量的线程安全性，故C++0x之后该实现是线程安全的，C++0x之前仍需加锁，其中C++0x是C++11标准成为正式标准之前的草案临时名字。</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>class single{
private:
    single(){}
    ~single(){}
public:
    static single* getinstance();

};
single* single::getinstance(){
    static single obj;
    return &amp;obj;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>  注意，如果使用C++11之前的标准，还是需要加锁，这里同样给出加锁的版本。</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>class single{
private:
	static pthread_mutex_t lock;
    single(){
    pthread_mutex_init(&amp;lock, NULL);
    }
    ~single(){}
public:
    static single* getinstance();

};
pthread_mutex_t single::lock;
single* single::getinstance(){
	pthread_mutex_lock(&amp;lock);
    static single obj;
    pthread_mutex_unlock(&amp;lock);
    return &amp;obj;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>3）饿汉模式</p><p>  饿汉模式不需要用锁，就可以实现线程安全。原因在于，在程序运行时就定义了对象，并对其初始化。之后，不管哪个线程调用成员函数getinstance()，都只不过是返回一个对象的指针而已。所以是线程安全的，不需要在获取实例的成员函数中加锁。</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>class single{
private:
	static single* p;
    single(){}
    ~single(){}
public:
    static single* getinstance();
};
single* single::p = new single();
single* single::getinstance(){
    return p;
}

//测试方法
int main(){
    single *p1 = single::getinstance();
    single *p2 = single::getinstance();
    if (p1 == p2)
        cout &lt;&lt; &quot;same&quot; &lt;&lt; endl;
    system(&quot;pause&quot;);
    return 0;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>  饿汉模式虽好，但其存在隐藏的问题，在于非静态对象（函数外的static对象）在不同编译单元中的初始化顺序是未定义的。如果在初始化完成之前调用 getInstance() 方法会返回一个未定义的实例。即：无法确保上面代码部分的<code>single* single::p = new single();</code>语句一定在<code>single* single::getinstance()</code>函数调用之前被调用。</p><h3 id="_6、整体框架" tabindex="-1"><a class="header-anchor" href="#_6、整体框架" aria-hidden="true">#</a> 6、整体框架</h3><p>  高性能多并发web服务器 1、web服务器的基本功能：TCP基本通信和HTTP服务的解析和处理； 2、高性能多并发：IO多路复用（epoll和LT/ET模式）、并发处理模式（reactor/proactor）、线程池的使用； 3、用户注册功能：用到MySQL数据库； 4、日志记录功能；</p><h3 id="_7、后续的扩展" tabindex="-1"><a class="header-anchor" href="#_7、后续的扩展" aria-hidden="true">#</a> 7、后续的扩展</h3><p>考虑加入skiplist跳表。</p><h2 id="二、为什么还要做webserver" tabindex="-1"><a class="header-anchor" href="#二、为什么还要做webserver" aria-hidden="true">#</a> 二、为什么还要做webserver?</h2><p>  新的cpp项⽬当然有，只是这些新项⽬的前置知识太多、可供参考的⽂档⼜不多，还要结合许多开源库使⽤，对于校招⽣（或者说对没有具体主攻⽅向的同学）来说学习成本太⾼了。</p><p>webserver有个RPC框架（远程程序连接）:</p><p>  1）能够将面试所需的基础知识串联起来：WebServer 能够串联绝⼤部分的⾯试⼋股，语⾔（C/C++全覆盖，可以扩展⾄C++11/17）+操作系统（含有⼤量的I/O 系统调⽤及其封装，还有 EPOLL 等多路复⽤机制）+计算机⽹络（本身就是⼀个⽹络框架，对⽹络异常的处理）+数据库（注册中⼼的数据库语句、负载均衡等）。</p><p>  当你的项⽬中涵盖了所有⾯试所需的基础知识后，⾯试官更倾向结合你的项⽬去考察知识，⽽不是东问⼀个⻄问⼀个，<strong>这样可以将⾯试的问题限制在⼀定的范围中，⼀定程度上降低了⾯试准备的难度</strong>。</p><p>  2）万物均能集成到 WebServer 中：WebServer 的本质上是⼀个⾼性能⽹络框架，它提供了⼀个单服务端（当然也可以扩展为多服务端）与多客户端的⾼效连接框架，但是客户端与服务端连接上以后具体应该做些什么（也就是有哪些业务），这就可以由我们⾃由发挥了，这就是 WebServer 的功能扩展。</p><p>  ⽬前⼤多数的 WebServer 都将从服务端获取 MIME 作为主要功能（MIME：网络多媒体服务扩展）。</p>`,43),ie={href:"https://github.com/youngyangyang04/Skiplist-CPP",target:"_blank",rel:"noopener noreferrer"},ae=a('<p>  把webserver和计网八股文联合起来讲,比如C++的new/delete和malloc/free区别+内存泄漏+内存分布+堆区和栈区+RAII+智能指针+shared_ptr源码这些完全可以横向的串联成一个非常大的话题！我可以把它包装成一个完整的故事来讲，而其中每一个点又可以和其他八股串联。比较细节的点比如堆区和栈区的问题，又可以纵向的切入，从内存布局-&gt;数据结构-&gt;空间大小/使用效率-&gt;申请方式-&gt;使用时机这样的逻辑再由浅入深的讲很久。八股并不是死的，他们不是一个个需要背的问题，而是你面试时侃侃而谈的语料库。如何从项目的数据流角度串联Reactor模式和Proactor模式，阻塞和非阻塞，同步IO和异步IO这三组高频八股。</p><p>  从WebServer中学到了什么？</p><p>  个人收获：1、熟悉了Linux系统的使用和C++网络编程的流程；2、对TCP通信和Socket网络编程有了更深的理解，对HTTP的服务过程有了更清晰的认识。</p><h2 id="三、所需的基础知识" tabindex="-1"><a class="header-anchor" href="#三、所需的基础知识" aria-hidden="true">#</a> 三、所需的基础知识</h2><p>1）编程语言：</p><ul><li>基本的C/C++语言；</li><li>C++11的新特性（智能指针、function等），能够掌握C++14/17更好。</li><li>单例模式（懒汉模式）</li></ul><p>2）操作系统</p><ul><li>基本的Linux命令，调试程序用的，参考鸟哥的私房菜</li><li>常见的系统调用，主要是read/write和socket相关的函数，参考CSAPP来看。</li></ul><p>3）计算机网路</p><ul><li>TCP/UDP的连接机制和对应的函数</li><li>常用的服务器模式，单对单、多对单、多对多（点播、组播、广播）</li><li>抓包工具的使用，如tcpdump</li></ul><p>4）数据库</p><ul><li>数据库的安装</li><li>数据库的常用MYSQL语句</li></ul><h2 id="四、常见的webserver项目" tabindex="-1"><a class="header-anchor" href="#四、常见的webserver项目" aria-hidden="true">#</a> 四、常见的WebServer项目</h2><p>视频资料：</p>',14),te={href:"https://www.nowcoder.com/courses/cover/live/504",target:"_blank",rel:"noopener noreferrer"},se={href:"https://www.nowcoder.com/study/live/690/4/1",target:"_blank",rel:"noopener noreferrer"},re=e("p",null,"GitHub/Gitee：",-1),pe={href:"https://github.com/sylar-yin/sylar",target:"_blank",rel:"noopener noreferrer"},de={href:"https://www.bilibili.com/video/av53602631/?from=www.sylar.top&vd_source=d0ee64ac63fa4af6553687c1e0a80570",target:"_blank",rel:"noopener noreferrer"},oe={href:"https://github.com/qinguoyi/TinyWebServer",target:"_blank",rel:"noopener noreferrer"},ce={href:"https://github.com/linyacool/WebServer",target:"_blank",rel:"noopener noreferrer"},ue={href:"https://github.com/markparticle/WebServer",target:"_blank",rel:"noopener noreferrer"},he=a(`<h2 id="五、代码运行和测试" tabindex="-1"><a class="header-anchor" href="#五、代码运行和测试" aria-hidden="true">#</a> 五、代码运行和测试</h2><p>1、可以用以下命令来测试：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">curl</span> <span class="token string">&quot;127.0.0.1:9006&quot;</span>
<span class="token function">wget</span> <span class="token string">&quot;127.0.0.1:9006&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>只要能够获取到 HTTP 响应，就说明 WebServer 起码是能够完成响应 HTTP 这⼀个基本功能的，其余部分的测试我们后⾯再讲。</p><h2 id="六、框架梳理和知识点总结" tabindex="-1"><a class="header-anchor" href="#六、框架梳理和知识点总结" aria-hidden="true">#</a> 六、框架梳理和知识点总结</h2><p>  整个项⽬⼤概由哪些模块组成，各个模块的功能是什么，模块之间的关系具体是怎么样的。只能你脑袋⾥对整个项⽬框架有清晰的认识，你在写代码的时候才能够明确当前部分的代码应该实现怎样的功能，给下⼀部分的代码什么样的输入。</p><p>  我们⾸先还是先看下项⽬的⽂档，看下作者有没有提供代码的框架，有的话就简单了，对着框架图去看代码，可以迅速理清代码的模块组成，快速上手他人的代码。</p><figure><img src="https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdliav7W3-_cHkkU_p/root/content" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>  从图中我们可以看到，项⽬中搭建了⼀个半同步/反应堆线程池，在其中维护了⼀个请求队列，线程池中的主线程通过 epoll 来监听 socket，并且将请求队列中的任务分配给线程池中的⼯作线程，其中⼯作线程能够处理的任务分为⽇志输出、定时器处理⾮活动连接以及处理 HTTP 请求三种。</p><p>  如果没有框架图，就从代码工程结构上去分析。</p><h2 id="七、学习记录-自我记录" tabindex="-1"><a class="header-anchor" href="#七、学习记录-自我记录" aria-hidden="true">#</a> 七、学习记录--自我记录</h2><h3 id="并发框架" tabindex="-1"><a class="header-anchor" href="#并发框架" aria-hidden="true">#</a> 并发框架</h3><h3 id="main函数的事件监听和分配" tabindex="-1"><a class="header-anchor" href="#main函数的事件监听和分配" aria-hidden="true">#</a> main函数的事件监听和分配</h3><h3 id="多路复用" tabindex="-1"><a class="header-anchor" href="#多路复用" aria-hidden="true">#</a> 多路复用</h3><h3 id="日志系统" tabindex="-1"><a class="header-anchor" href="#日志系统" aria-hidden="true">#</a> 日志系统</h3><h3 id="内存池" tabindex="-1"><a class="header-anchor" href="#内存池" aria-hidden="true">#</a> 内存池</h3><h3 id="线程池" tabindex="-1"><a class="header-anchor" href="#线程池" aria-hidden="true">#</a> 线程池</h3><h3 id="lfu-least-frequently-used-page-replacement-algorithm" tabindex="-1"><a class="header-anchor" href="#lfu-least-frequently-used-page-replacement-algorithm" aria-hidden="true">#</a> LFU（least frequently used page-replacement algorithm）</h3><p>最不经常使用页置换算法</p><ul><li>LFU:最近不经常使⽤，发⽣淘汰的时候，淘汰频次低的⻚⾯。</li><li>LRU:最近最少使⽤，发⽣淘汰的时候，淘汰访问时间最旧的⻚⾯。</li><li>对于时间相关度较低（⻚⾯访问完全是随机，与时间⽆关） WebServer 来说，经常被访问的⻚⾯在下⼀次有更⼤的可能被访问，此时使⽤LFU更好，并且LFU能够避免周期性或者偶发性的操作导致缓存命中率下降的问题；⽽对于时间相关度较⾼（某些⻚⾯在特定时间段访问量较⼤，⽽在整体来看频率较低）的 WebServer 来说，在特定的时间段内，最近访问的⻚⾯在下⼀次有更⼤的可能被访问，此时使⽤LRU更好。</li><li>⽬前设计的 WebServer 时间相关度较低，所以选择LFU。</li></ul><p>LFU的原理⽐较简单，实现⽅法也⽐较多样（leetcode上⾯就有设计LFU和LRU的题），我⽬前采⽤的是双重链表+hash表的经典做法。</p><h3 id="云端部署" tabindex="-1"><a class="header-anchor" href="#云端部署" aria-hidden="true">#</a> 云端部署</h3><h3 id="性能测试原理和结果" tabindex="-1"><a class="header-anchor" href="#性能测试原理和结果" aria-hidden="true">#</a> 性能测试原理和结果</h3><h2 id="八、面试相关" tabindex="-1"><a class="header-anchor" href="#八、面试相关" aria-hidden="true">#</a> 八、面试相关</h2><h3 id="项目介绍" tabindex="-1"><a class="header-anchor" href="#项目介绍" aria-hidden="true">#</a> 项目介绍</h3>`,25),ve={href:"https://mp.weixin.qq.com/s?__biz=MzAxNzU2MzcwMw==&mid=2649274431&idx=1&sn=2dd28c92f5d9704a57c001a3d2630b69&chksm=83ffb167b48838715810b27b8f8b9a576023ee5c08a8e5d91df5baf396732de51268d1bf2a4e&cur_album_id=1339230165934882817&scene=190#rd",target:"_blank",rel:"noopener noreferrer"},be=a('<p>简单介绍？</p><p>项目中的难点？</p><p>遇到的困难和解决方案？</p><p>针对项目做了哪些优化？</p><p>项目中用到了哪些设计模式？</p><p>C++面向对象特性在项目中的体现？</p><h3 id="项目细节" tabindex="-1"><a class="header-anchor" href="#项目细节" aria-hidden="true">#</a> 项目细节</h3><p>线程池</p><p>日志系统</p><p>缓存系统</p><p>内存池</p><p>并发性问题</p><p>IO多路复用</p><p>并发模型</p><p>跳表skipList存储</p><p>跳表，全称是跳跃表，是一种增加了向前指针的链表。</p><p>测试相关</p><h2 id="九、-项目提问" tabindex="-1"><a class="header-anchor" href="#九、-项目提问" aria-hidden="true">#</a> 九、 项目提问</h2><p>关于该项目的问答：</p>',19),me={href:"https://zhuanlan.zhihu.com/p/269247362",target:"_blank",rel:"noopener noreferrer"},ge=a('<h3 id="_9-1、简单介绍一下你的项目" tabindex="-1"><a class="header-anchor" href="#_9-1、简单介绍一下你的项目" aria-hidden="true">#</a> 9.1、简单介绍一下你的项目？</h3><p>  这个项目主要的目的是<strong>对浏览器的链接请求进行解析处理，处理完之后给浏览器客户端返回一个响应，如文字图片视频等</strong>。服务器后端的处理方式<strong>使用socket通信，利用多路IO复用</strong>，可以同时处理多个请求，请求的解析使用<strong>预先准备好的线程池</strong>，使用<strong>模拟proactor模式</strong>，<strong>主线程负责监听</strong>，监听到有事件之后，从socket中循环读取数据，然后将读取到的数据封装成一个请求对象插入请求队列。睡眠在请求队列上的<strong>工作线程被唤醒进行处理</strong>。处理的方式用<strong>状态机</strong>。</p><p>  对请求文件的处理：客户端发出链接，到达服务器，服务器这端先用read_once（）函数一次性把所有请求读到缓冲区。然后process_read函数分别调用用三个函数对缓冲区的内容进行解析。主状态机主要用于解析客户端请求，从状态机用于解析一行内容并把每一行加\\0\\0格式化，方便主状态机解析，主状态机调用解析请求行，请求头，请求内容三部分函数进行解析。解析结束后利用do_request（）函数生成响应报文，该函数会根据不同的网址url产生不同响应体。最后通过write函数里套接字的传输方式把响应体传给客户端。</p><p>  日志分为<strong>同步日志</strong>和<strong>异步日志</strong>，异步日志利用阻塞队列，先将日志放入阻塞队列中，然后利用条件变量将日志添加到对应文件中。采用单例模式。</p><p>  日志系统初始化函数中主要要做的事：如果文件名没带路径，直接放到log_full_name。如果带路径，把文件名取出来放到log_name，把路径取出来放到dir_name，然后把时间+log_name放到log_full_name。</p><p>  在write_log（）函数中，这里面有两部分，一部分是对新的文件名，时间，日志名进行再次处理，一部分是时间+新加入的日志参数放入缓冲区。异步加入阻塞队列，同步直接写入日志文件。阻塞队列是用数组模拟的生产者消费者模式。根据初始化函数传入的最后一个参数阻塞队列最大容纳值判断是同步还是异步，异步则其大于等于1。</p><p>  用<strong>单例模式创建了数据库连接池</strong>。数据库链接池中，提前创建一定量的数据链接，并把他们保存在双向链表中。</p><p>  <strong>用定时器处理非活动链接，定时器容器利用升序链表进行设计</strong>。</p>',8),_e={href:"https://huixxi.github.io/2020/06/02/%E5%B0%8F%E7%99%BD%E8%A7%86%E8%A7%92%EF%BC%9A%E4%B8%80%E6%96%87%E8%AF%BB%E6%87%82%E7%A4%BE%E9%95%BF%E7%9A%84TinyWebServer/#more",target:"_blank",rel:"noopener noreferrer"},ke=a(`<h3 id="_9-2、面试官问这个web服务器是你自己申请的域名么-域名号是多少" tabindex="-1"><a class="header-anchor" href="#_9-2、面试官问这个web服务器是你自己申请的域名么-域名号是多少" aria-hidden="true">#</a> 9.2、面试官问这个web服务器是你自己申请的域名么？域名号是多少？</h3><p>  该域名是我自己申请的，该web服务器的地址为<code>https://haoxx.top/server</code>。web服务器程序运行在Linux云端系统上的8080端口上，由nginx软件进行代理转发。</p><h3 id="_9-3、线程池相关问题" tabindex="-1"><a class="header-anchor" href="#_9-3、线程池相关问题" aria-hidden="true">#</a> 9.3、线程池相关问题</h3><h4 id="_9-3-1-手写线程池" tabindex="-1"><a class="header-anchor" href="#_9-3-1-手写线程池" aria-hidden="true">#</a> 9.3.1 手写线程池</h4><p>  下面是C++实现的简易线程池，<strong>包含线程数量，启动标志位，线程列表以及条件变量</strong>。</p><p>  其中<strong>构造函数</strong>主要是声明未启动和线程数量的。<strong>start函数</strong>为启动线程池，将num个线程绑定threadfunc自定义函数并执行，加入线程列表。<strong>stop</strong>是暂时停止线程，并由条件变量通知所有线程。<strong>析构函</strong>数是停止，阻塞所有线程并将其从线程列表剔除后删除，清空线程列表。</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>#include&lt;vector&gt;
#include&lt;string&gt;
#include&lt;list&gt;
#include&lt;thread&gt;
#include&lt;condition_variable&gt;
using namespace std;
class ThreadPool {
public:
	ThreadPool(int threadnum):started(false),thread_num(threadnum) {

}
~ThreadPool()
{
	stop();
	for (int i = 0; i &lt; thread_num; ++i) {
		threadlist[i]-&gt;join();
	}
	for (int i = 0; i &lt; thread_num; ++i) {
		delete threadlist[i];
	}
	threadlist.clear();
}
void threadFunc(){}//线程执行函数,可自定义。
int getThreadNum() { return thread_num; }
void start() {
	if (thread_num &gt; 0) {
		started = true;
		for (int i = 0; i &lt; thread_num; ++i) {
			thread* pthread = new thread(&amp;threadFunc, this);
			threadlist.push_back(pthread);
		}	
	}
}
void stop() {
	started = false;
	condition.notify_all();
}

private:
	int thread_num;
	bool started;
	vector&lt;thread*&gt; threadlist;
	condition_variable condition;
};
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_9-3-2-线程的同步机制有哪些" tabindex="-1"><a class="header-anchor" href="#_9-3-2-线程的同步机制有哪些" aria-hidden="true">#</a> 9.3.2 线程的同步机制有哪些？</h4><p>  现在流行的进程线程同步互斥的控制机制，其实是由最原始，最基本的4种方法实现的：</p><ul><li>临界区：通过多线程的互串行访问公共资源或一段代码，速度快，适合控制数据访问。</li></ul><p>临界区和锁差不多（临界区的使用）</p><ul><li><p>互斥量（ 又称为互斥锁）：为协调共同对一个共享资源的单独访问而设计。只有拥有互斥对象的线程才有权限去访问系统的公共资源，因为互斥对象只有一个，所以能够保证资源不会同时被多个线程访问。</p></li><li><p>信号量：为控制一个具有有限数量的用户资源而设计。它允许多个线程在同一时刻去访问同一个资源，但一般需要限制同一时刻访问此资源的最大线程数。</p></li><li><p>事件：用来通知线程有一些事件已发生，从而启动后继任务的开始。</p></li></ul><p>条件变量。</p><h4 id="_9-3-3-线程池中的工作线程是一直等待吗" tabindex="-1"><a class="header-anchor" href="#_9-3-3-线程池中的工作线程是一直等待吗" aria-hidden="true">#</a> 9.3.3 线程池中的工作线程是一直等待吗？</h4><p>  线程池中的工作线程是处于一直阻塞等待的模式下的。因为在我们创建线程池之初时，我们通过循环调用pthread_create往线程池中创建了8个工作线程，工作线程处理函数接口为pthread_create函数原型中第三个参数函数指针所指向的worker函数（自定义的函数），然后调用线程池类成员函数run（自定义）。-------这里可能会有疑问？为什么不直接将第三个参数直接指向run函数，而是要通过向worker中传入对象从而调用run呢？<strong>原因是</strong>因为我们已经将worker设置为静态成员函数，而我们都知道静态成员函数只能访问静态成员变量，所以为了能够访问到类内非静态成员变量，我们可以通过在worker中调用run这个非静态成员变量来达到这一要求。在run函数中，我们为了能够处理高并发的问题，将线程池中的工作线程都设置为阻塞等待在请求队列是否不为空的条件上，因此项目中线程池中的工作线程是处于一直阻塞等待的模式下的。</p><h4 id="_9-3-4-你的线程池工作线程处理完一个任务后的状态是什么" tabindex="-1"><a class="header-anchor" href="#_9-3-4-你的线程池工作线程处理完一个任务后的状态是什么" aria-hidden="true">#</a> 9.3.4 你的线程池工作线程处理完一个任务后的状态是什么？</h4><p>  这里要分<strong>两种</strong>情况考虑</p><p>（1） 当处理完任务后如果请求队列为空时，则这个线程重新回到阻塞等待的状态</p><p>（2） 当处理完任务后如果请求队列不为空时，那么这个线程将处于与其他线程竞争资源的状态，谁获得锁谁就获得了处理事件的资格。</p><h4 id="_9-3-5-如果同时1000个客户端进行访问请求-线程数不多-怎么能及时响应处理每一个呢" tabindex="-1"><a class="header-anchor" href="#_9-3-5-如果同时1000个客户端进行访问请求-线程数不多-怎么能及时响应处理每一个呢" aria-hidden="true">#</a> 9.3.5 如果同时1000个客户端进行访问请求，线程数不多，怎么能及时响应处理每一个呢？</h4><p>  首先这种问法就相当于问服务器如何处理高并发的问题。本项目中是通过对子线程循环调用来解决高并发的问题的。</p><p>  <strong>具体实现过程如下</strong>：</p><p>  如上文所述，我们在创建线程的同时时就调用pthread_detach将线程进行分离，这样就不用单独对工作线程进行回收，但是一般情况只要我们设置了分离属性，那么这个线程在处理完任务之后，也就是子线程结束后，资源会被自动回收。那这种情况下我们服务器基本就只能处理8个请求事件了（线程池里只有8个线程）。那怎么实现高并发的请求呢？可能会说让线程池里创建足够多的线程数，这当然是理想化的，现实中线程数量过大会导致更多的线程上下文切换，占用更多内存，这显然是不合理的。</p><p>  接下来所叙述的就是本项目中用来处理高并发问题的方法了：</p><p>  我们知道调用了pthread_detach的线程只有等到他结束时系统才会回收他的资源，那么我们就可以从这里下手了。<strong>我们通过子线程的run调用函数进行while循环，让每一个线程池中的线程永远都不会终止，说白了就是让他处理完当前任务就去处理下一个，没有任务就一直阻塞在那里等待</strong>。这样就能达到服务器高并发的要求，同一时刻8个线程都在处理请求任务，处理完之后接着处理，<strong>直到请求队列为空表示任务全部处理完成</strong>。</p><h4 id="_9-3-6-如果一个客户请求需要占用线程很久的时间-会不会影响接下来的客户请求呢-有什么好的策略呢" tabindex="-1"><a class="header-anchor" href="#_9-3-6-如果一个客户请求需要占用线程很久的时间-会不会影响接下来的客户请求呢-有什么好的策略呢" aria-hidden="true">#</a> 9.3.6 如果一个客户请求需要占用线程很久的时间，会不会影响接下来的客户请求呢，有什么好的策略呢?</h4><p>  会影响接下来的客户请求，因为线程池内线程的数量时有限的，如果客户请求占用线程时间过久的话会影响到处理请求的效率，当请求处理过慢时会造成后续接受的请求只能在请求队列中等待被处理，从而影响接下来的客户请求。</p><p>  <strong>应对策略</strong>：</p><p>  我们可以为线程处理请求对象设置处理超时时间, 超过时间先发送信号告知线程处理超时，然后设定一个时间间隔再次检测，若此时这个请求还占用线程则直接将其断开连接。</p><h3 id="_9-4、http连接处理相关" tabindex="-1"><a class="header-anchor" href="#_9-4、http连接处理相关" aria-hidden="true">#</a> 9.4、http连接处理相关</h3><p>  在本模块中，主要分析http请求的处理与响应两部分。</p><p><strong>http连接请求处理</strong></p><p>  在启动服务器时，先创建好线程池。当浏览器端发出http连接请求，主线程创建http类对象数组用来接收请求并将所有数据读入各个对象对应buffer，然后将该对象插入任务队列；如果是连接请求，那么就将他注册到内核事件表中（通过静态成员变量完成）。线程池中的工作线程从任务队列中取出一个任务进行处理（解析请求报文）。</p><p><strong>http报文解析处理流程</strong></p><p>  各工作线程通过process函数对任务进行处理，调用process_read函数和process_write函数分别完成报文解析与报文响应两个任务。同时我们项目中也加入了主从状态机的使用，状态机根据当前的状态来做特定功能的事情。其中从状态机负责读取报文的一行，主状态机负责对该行数据进行解析，主状态机内部调用从状态机，从状态机驱动主状态机。由于在HTTP报文中，每一行的数据由\\r\\n作为结束字符，空行则是仅仅是字符\\r\\n。因此，可以通过查找\\r\\n将报文拆解成单独的行进行解析，项目中便是利用了这一点。</p><p>  从状态机负责读取buffer中的数据，将每行数据末尾的\\r\\n置为\\0\\0，并更新从状态机在buffer中读取的位置m_checked_idx，以此来驱动主状态机解析。主状态机初始状态是CHECK_STATE_REQUESTLINE，通过调用从状态机来驱动主状态机，在主状态机进行解析前，从状态机已经将每一行的末尾\\r\\n符号改为\\0\\0，以便于主状态机直接取出对应字符串进行处理。process_read通过while循环，将主从状态机进行封装，对报文的每一行进行循环处理。在循环体中从状态机读取数据，同时将读取到的数据间接赋给text缓冲区，然后利用主状态机来解析text中的内容。</p><p>  客户端发出链接，到达服务器，服务器这端先用read_once（）函数一次性把所有请求读到缓冲区。然后process_read函数分别调用用三个函数对缓冲区的内容进行解析。主从状态机主要用于解析客户端请求，从状态机用于解析一行内容并把每一行加\\0\\0格式化，方便主状态机解析，主状态机调用 解析请求行，请求头，请求内容三部分函数进行解析。解析结束后利用do_request（）函数生成响应报文，该函数会根据不同的网址url产生不同响应体。最后通过write函数里套接字的传输方式把响应体传给客户端。</p><p>  read_once() --&gt; process_read()调用解析行，解析头，解析体三个函数进行解析。在这三个函数中使用主从状态机。解析结束利用do_request()函数返回解析结果状态供下一个函数利用，process_write()向缓冲区写入响应报文,最后通过write()函数把响应体返回给客户端。</p><p>  HTTP请求报文由请求行、请求头部、空行和请求数据四个部分组成。报文的请求方法，本项目只用到GET和POST；</p><p>GET的HTTP请求报文格式：</p><div class="language-http line-numbers-mode" data-ext="http"><pre class="language-http"><code><span class="token request-line"><span class="token method property">GET</span> <span class="token request-target url">/562f25980001b1b106000338.jpg</span> <span class="token http-version property">HTTP/1.1</span></span>

<span class="token header"><span class="token header-name keyword">Host</span><span class="token punctuation">:</span><span class="token header-value">http://img.mukewang.com</span></span>

<span class="token header"><span class="token header-name keyword">User-Agent</span><span class="token punctuation">:</span><span class="token header-value">Mozilla/5.0 (Windows NT 10.0; WOW64)</span></span>

AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36

<span class="token header"><span class="token header-name keyword">Accept</span><span class="token punctuation">:</span><span class="token header-value">image/webp,image/*,*/*;q=0.8</span></span>

<span class="token header"><span class="token header-name keyword">Referer</span><span class="token punctuation">:</span><span class="token header-value">http://www.imooc.com/</span></span>

<span class="token header"><span class="token header-name keyword">Accept-Encoding</span><span class="token punctuation">:</span><span class="token header-value">gzip, deflate, sdch</span></span>

<span class="token header"><span class="token header-name keyword">Accept-Language</span><span class="token punctuation">:</span><span class="token header-value">zh-CN,zh;q=0.8</span></span>

空行

请求数据为空
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>POST的请求报文格式：</p><div class="language-http line-numbers-mode" data-ext="http"><pre class="language-http"><code>POST / HTTP1.1

<span class="token header"><span class="token header-name keyword">Host</span><span class="token punctuation">:</span><span class="token header-value">http://www.wrox.com</span></span>

<span class="token header"><span class="token header-name keyword">User-Agent</span><span class="token punctuation">:</span><span class="token header-value">Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022)</span></span>

<span class="token header"><span class="token header-name keyword">Content-Type</span><span class="token punctuation">:</span><span class="token header-value">application/x-www-form-urlencoded</span></span>

<span class="token header"><span class="token header-name keyword">Content-Length</span><span class="token punctuation">:</span><span class="token header-value">40</span></span>

<span class="token header"><span class="token header-name keyword">Connection</span><span class="token punctuation">:</span> <span class="token header-value">Keep-Alive</span></span>

空行

name=Professional%20Ajax&amp;publisher=Wiley
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>http响应报文处理流程</strong></p><p>  当上述报文解析完成后，服务器子线程调用process_write完成响应报文，响应报文包括</p><p>1.状态行：http/1.1 状态码 状态消息；</p><p>2.消息报头，内部调用add_content_length和add_linger函数</p><ul><li><p>content-length记录响应报文长度，用于浏览器端判断服务器是否发送完数据</p></li><li><p>connection记录连接状态，用于告诉浏览器端保持长连接</p></li></ul><p>3.空行</p><p>随后注册epollout事件。服务器主线程检测写事件，并调用http_conn::write函数将响应报文发送给浏览器端。至此整个http请求和响应全部完成。</p><h4 id="_9-4-1-用了状态机啊-为什么要用状态机" tabindex="-1"><a class="header-anchor" href="#_9-4-1-用了状态机啊-为什么要用状态机" aria-hidden="true">#</a> 9.4.1 用了状态机啊，为什么要用状态机？</h4><p>  因为传统应用程序的控制流程基本是<strong>按顺序执行</strong>的：遵循事先设定的逻辑，从头到尾地执行。简单来说如果想在不同状态下实现代码跳转时，就需要破坏一些代码，这样就会造成代码逻辑混乱，代码显得十分复杂。所以我们必须采取不同的技术来处理这些情况。<strong>它能处理任何顺序的事件，并能提供有意义的响应——即使这些事件发生的顺序和预计的不同</strong>，有限状态机正是为了满足这方面的要求而设计的。每个状态都有一系列的转移，每个转移与输入和另一状态相关。当输入进来，如果它与当前状态的某个转移相匹配，机器转换为所指的状态，然后执行相应的代码。</p><h4 id="_9-4-2-状态机的转移图画一下" tabindex="-1"><a class="header-anchor" href="#_9-4-2-状态机的转移图画一下" aria-hidden="true">#</a> 9.4.2 状态机的转移图画一下</h4><figure><img src="https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlj2jCXv-a7l80amG/root/content" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="_9-4-3-https协议为什么安全" tabindex="-1"><a class="header-anchor" href="#_9-4-3-https协议为什么安全" aria-hidden="true">#</a> 9.4.3 https协议为什么安全？</h4><p>  https=http+TLS/SSL</p><p>  TLS/SSL协议位于应用层协议和TCP之间，构建在TCP之上，由TCP协议保证数据传输版的可靠性，任何数据到权达TCP之前，都经过TLS/SSL协议处理。</p><p>  https是加密传输协议，可以保障客户端到服务器端的传输数据安全。用户通过http协议访问网站时，浏览器和服务器之间是明文传输，这就意味着用户填写的密码、帐号、交易记录等机密信息都是明文，随时可能被泄露、窃取、篡改，被第三者加以利用。安装SSL证书后，使用https加密协议访问网站，可激活客户端浏览器到网站服务器之间的&quot;SSL加密通道&quot;（SSL协议），实现高强度双向加密传输，防止传输数据被泄露或篡改。</p><h4 id="_9-4-4-https的ssl连接过程" tabindex="-1"><a class="header-anchor" href="#_9-4-4-https的ssl连接过程" aria-hidden="true">#</a> 9.4.4 https的ssl连接过程</h4><ol><li><p>客户端提交https请求</p></li><li><p>服务器响应客户，并把证书公钥发给客户端</p></li><li><p>客户端验证证书公钥的有效性</p></li><li><p>有效后，会生成一个会话密钥</p></li><li><p>用证书公钥加密这个会话密钥后，发送给服务器</p></li><li><p>服务器收到公钥加密的会话密钥后，用私钥解密，回去会话密钥</p></li><li><p>客户端与服务器双方利用这个会话密钥加密要传输的数据进行通信</p></li></ol><h4 id="_9-4-5-get和post的区别" tabindex="-1"><a class="header-anchor" href="#_9-4-5-get和post的区别" aria-hidden="true">#</a> 9.4.5 GET和POST的区别</h4><table><thead><tr><th style="text-align:center;">请求方式</th><th style="text-align:center;">GET</th><th style="text-align:center;">POST</th></tr></thead><tbody><tr><td style="text-align:center;">参数位置</td><td style="text-align:center;">url的query请求报文中</td><td style="text-align:center;">一般在content中（就是在http请求报文尾部，也可以zhijiefangzaiquery请求报文中）</td></tr><tr><td style="text-align:center;">参数大小</td><td style="text-align:center;">受限于浏览器url的大小，一般不超过32K</td><td style="text-align:center;">1G</td></tr><tr><td style="text-align:center;">服务器数据接收</td><td style="text-align:center;">接收1次</td><td style="text-align:center;">根据数据大小，可分多次接收</td></tr><tr><td style="text-align:center;">适用场景（语义）</td><td style="text-align:center;">从服务器端获取数据，不做增删改</td><td style="text-align:center;">向服务器提交新数据，会进行增删改查操作</td></tr><tr><td style="text-align:center;">安全性</td><td style="text-align:center;">参数携带在url中，不安全</td><td style="text-align:center;">相对于GET要更安全</td></tr></tbody></table><h3 id="_9-5、并发模型相关问题" tabindex="-1"><a class="header-anchor" href="#_9-5、并发模型相关问题" aria-hidden="true">#</a> 9.5、并发模型相关问题</h3><h4 id="_9-5-1-简单说一下服务器使用的并发模型" tabindex="-1"><a class="header-anchor" href="#_9-5-1-简单说一下服务器使用的并发模型" aria-hidden="true">#</a> 9.5.1 简单说一下服务器使用的并发模型？</h4><p>  对应《Linux高性能服务器编程》P130 – P136</p><p>（1）先搞清几个知识点：</p><p>  I/O操作：io是input和output的简写，狭义上是读写硬盘的操作。广义上只要不需要cpu参与的都是io操作。在计算机科学中指计算机之间或人与计算机之间的信息交换。比如两台计算机通过网卡进行交互，比如向硬盘写入数据或读取硬盘数据，比如读取鼠标或键盘输入，读写文件，访问数据库等，都是I/O。I/O操作一般CPU消耗很少，但耗时比较长，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度），所以当出现I/O操作时，CPU都会异步去执行其他事情。</p><p>（2）半同步/半异步模式</p><p>这里的同步异步是：按顺序依次执行程序就是同步，当程序的执行是由信号，中断等驱动执行，则为异步。</p><p>半异步：异步处理I/O事件，就是客户端向服务器端的请求的接收，是通过异步线程进行处理的，来请求触发处理，没有来的时候处理其他事情。</p><p>半同步：是指同步处理请求数据，异步线程接收完请求之后会封装一下插入队列，工作线程就依次同步从队列中取出请求对象进行处理。</p><p>半同步/半反应堆：它是半同步/半异步模式的变体，它核心在于，主线程充当异步线程，只负责监听客户端请求以及向内核注册读写事件，这和前面的rector（反应堆）事件处理模型类似，所以这样称呼。</p><p>它的进阶就是使用模拟的proactor事件模型，主线程除了监听，还负责了数据的读写。</p><p>但是！上面这种半反应堆模式的一个问题就是，因为有了请求队列，每次工作线程处理队列请求都需要加锁，白白消耗CPU；另一方面如果任务很多，工作线程很少，就会造成客户端响应速度变慢。</p><p>高效的半同步/半异步模式：解决办法就是取消任务队列，直接由主线程将各个客户端请求派发给各个工作线程，后期每个工作线程都持续响应同一个请求带来的读写。</p><p>（3）领导者/追随者模式</p><p>任意时间点，仅有一个领导者线程监听，其它线程都是追随者，监听到请求后，领导者线程首先选出新的领导者，再处理请求，然后循环往复。如果没有新的领导者，处理完事件可以重新变成领导者。</p><p>分为三部分：</p><ol><li><p>句柄集：负责监听I/O事件，并把事件报告给领导者线程。</p></li><li><p>线程集：所工作线程的管理者，保证其中的线程每一时间都处于领导者、processing、追随者三者之一。</p></li><li><p>事件处理器和具体的事件处理器：里面包含回调函数处理时间。具体的事件处理器可以重写回调函数。</p></li></ol><h4 id="_9-5-2-reactor、proactor、主从reactor模型的区别" tabindex="-1"><a class="header-anchor" href="#_9-5-2-reactor、proactor、主从reactor模型的区别" aria-hidden="true">#</a> 9.5.2 reactor、proactor、主从reactor模型的区别？</h4><p>对应《Linux高性能服务器编程》P127 – P130</p><p>Reactor是：</p><p>  主线程往epoll内核上注册socket读事件，主线程调用epoll_wait等待socket上有数据可读，当socket上有数据可读的时候，主线程把socket可读事件放入请求队列。睡眠在请求队列上的某个工作线程被唤醒，处理客户请求，然后往epoll内核上注册socket写请求事件。主线程调用epoll_wait等待写请求事件，当有事件可写的时候，主线程把socket可写事件放入请求队列。睡眠在请求队列上的工作线程被唤醒，处理客户请求。</p><p>Proactor:</p><p>  主线程调用aio_read函数向内核注册socket上的读完成事件，并告诉内核用户读缓冲区的位置，以及读完成后如何通知应用程序，主线程继续处理其他逻辑，当socket上的数据被读入用户缓冲区后，通过信号告知应用程序数据已经可以使用。应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求。工作线程处理完客户请求之后调用aio_write函数向内核注册socket写完成事件，并告诉内核写缓冲区的位置，以及写完成时如何通知应用程序。主线程处理其他逻辑。当用户缓存区的数据被写入socket之后内核向应用程序发送一个信号，以通知应用程序数据已经发送完毕。应用程序预先定义的数据处理函数就会完成工作。</p><p>reactor模式：同步阻塞I/O模式，注册对应读写事件处理器，等待事件发生进而调用事件处理器处理事件。 proactor模式：异步I/O模式。</p><p>Reactor和Proactor模式的主要区别就是真正的读取和写入操作是有谁来完成的，Reactor中需要应用程序自己读取或者写入数据，Proactor模式中，应用程序不需要进行实际读写过程。</p><p>Reactor：非阻塞同步网络模型，可以理解为：来了事件我通知你，你来处理</p><p>Proactor：异步网络模型，可以理解为：来了事件我来处理，处理完了我通知你。</p><p>理论上：Proactor比Reactor效率要高一些。</p><p><strong>模拟Proactor模式</strong></p><p>使用同步I/O方式模拟出Proactor模式的原理是：主线程执行数据读写操作，读写完成之后，主线程向工作线程通知这一“完成事件”。那么从工作线程的角度来看，它们就直接获得了数据读写的结果，接下来要做的只是对读写的结果进行逻辑处理。</p><p>使用同步I/O模型（仍以epoll_wait为例）模拟出Proactor模式的工作流程如下：</p><p>主线程往epoll内核事件表中注册socket上的读就绪事件。</p><p>主线程调用epoll_wait等待socket上有数据可读。</p><p>当socket上有数据可读时，epoll_wait 通知主线程。主线程从socket循环读取数据，直到没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列。</p><p>睡眠在请求队列上的某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往epoll内核事件表中注册socket上的写就绪事件。</p><p>当socket可写时，epoll_wait通知主线程。主线程往socket上写入服务器处理客户请求的结果。</p><p><strong>下面是重点，好好理解</strong>：</p><p>读就绪事件：当有事件到来，epoll_wait()单纯通知主线程有事件来了，主线程把事件放入请求队列。应用程序利用工作线程通过read（）等函数把数据从内核缓冲区读到用户缓冲区。</p><p>读完成事件：有事件来了，主线程往内核注册这个读时间（就是告诉内核注意了一会要读数据）。注册了之后，主线程就去干其他事情，内核就自动会负责将数据从内核缓冲区放到用户缓冲区。不用用户程序管。</p><p>而对于用reactor模式模拟的的proactor模式来说，之前proactor是用主线程调用aio_read函数向内核注册读事件，这里它主线程使用epoll向内核注册读事件。但是这里内核不会负责将数据从内核读到用户缓冲区，最后还是要靠主线程也就是用户程序read（）函数等负责将内核数据循环读到用户缓冲区。对于工作线程来说，收到的都是已读完成的数据，模拟就体现在这里。</p><p>有人可能会问，他们都是通过主线程调用不同函数进行注册，然后一个注册之后可以直接内核负责数据从内核到用户。另一个注册之后好像没啥用，那注册还有什么用？直接主线程循环读取然后封装放请求队列不就行了么？</p><p>不对，如果数据一直没来，直接进行循环读取就会持续在这里发生阻塞，这就是同步IO的特点，所以一定要注册一下然后等通知，这样就可以避免长期阻塞等候数据。</p><p><strong>什么是ET（边缘触发）、LT（水平触发）？ET、LT优缺点？</strong></p><p>ET模式</p><p>缺点：应用层业务逻辑复杂，容易遗漏事件，很难用好。</p><p>优点：相对LT模式效率比较高。一触发立即处理事件。</p><p>LT模式：</p><p>优点：编程更符合用户直觉，业务层逻辑更简单。</p><p>缺点：效率比ET低。</p><p><strong>什么时候用ET，什么时候用LT？</strong></p><p>LT适用于并发量小的情况，ET适用于并发量大的情况。</p><p><strong>为什么？</strong></p><p>ET在通知用户之后，就会将fd从就绪链表中删除，而LT不会，它会一直保留，这就会导致随着fd增多，就绪链表越大，每次都要从头开始遍历找到对应的fd，所以并发量越大效率越低。ET因为会删除所以效率比较高。</p><p><strong>怎么解决LT的缺点？</strong></p><p>LT模式下，可写状态的fd会一直触发事件，该怎么处理这个问题</p><p>方法1：每次要写数据时，将fd绑定EPOLLOUT事件，写完后将fd同EPOLLOUT从epoll中移除。</p><p>方法2：方法一中每次写数据都要操作epoll。如果数据量很少，socket很容易将数据发送出去。可以考虑改成：数据量很少时直接send，数据量很多时在采用方法1.</p><p><strong>触发LT模式后，读一次还是循环读？</strong></p><p>读一次。</p><p><strong>为什么ET模式下一定要设置非阻塞？</strong></p><p>  因为ET模式下是无限循环读，直到出现错误为EAGAIN或者EWOULDBLOCK，这两个错误表示socket为空，不用再读了，然后就停止循环了，如果是非阻塞，循环读在socket为空的时候就会阻塞到那里，主线程的read（）函数一旦阻塞住，当再有其他监听事件过来就没办法读了，给其他事情造成了影响，所以必须要设置为非阻塞。</p><p>参考链接：epoll的LT和ET</p><h4 id="_9-5-3-你用了epoll-说一下为什么用epoll-还有其他复用方式吗-区别是什么" tabindex="-1"><a class="header-anchor" href="#_9-5-3-你用了epoll-说一下为什么用epoll-还有其他复用方式吗-区别是什么" aria-hidden="true">#</a> 9.5.3 你用了epoll，说一下为什么用epoll，还有其他复用方式吗？区别是什么？</h4><p>  对于select和poll来说，所有文件描述符都是在用户态被加入其文件描述符集合的，每次调用都需要将整个集合拷贝到内核态；epoll则将整个文件描述符集合维护在内核态，每次添加文件描述符的时候都需要执行一个系统调用。系统调用的开销是很大的，而且在有很多短期活跃连接的情况下，epoll可能会慢于select和poll由于这些大量的系统调用开销。</p><p>  select使用线性表描述文件描述符集合，文件描述符有上限；poll使用链表来描述；epoll底层通过红黑树来描述，并且维护一个ready list，将事件表中已经就绪的事件添加到这里，在使用epoll_wait调用时，仅观察这个list中有没有数据即可。</p><p>  select和poll的最大开销来自内核判断是否有文件描述符就绪这一过程：每次执行select或poll调用时，它们会采用遍历的方式，遍历整个文件描述符集合去判断各个文件描述符是否有活动；epoll则不需要去以这种方式检查，当有活动产生时，会自动触发epoll回调函数通知epoll文件描述符，然后内核将这些就绪的文件描述符放到之前提到的ready list中等待epoll_wait调用后被处理。</p><p>  select和poll都只能工作在相对低效的LT模式下，而epoll同时支持LT和ET模式。</p><p>  综上，当监测的fd数量较小，且各个fd都很活跃的情况下，建议使用select和poll；当监听的fd数量较多，且单位时间仅部分fd活跃的情况下，使用epoll会明显提升性能。</p><p>  epoll最大的优点就是，当出现满足条件的事件时，直接返回的是一个个满足条件结构体保存在结构体数组中，不需要像select和poll那样还需要循环依次判断每个是否满足时间发生条件，或者说不需要专门的数组去记录满足的事件。epoll最适合链接的很多，但是使用的很少的场景高并发低低传输的场景。另外epoll也可以突破最大文件上限。</p><p>  缺点是：不能够跨平台。selet和poll是Linux系统的早期实现，在windows上也可以使用。而epoll函数只能在Linux系统上使用。</p><p>  需要注意的是：Linux的并发模式只能实现Reactor模式（主线程只监听，工作线程读写IO和process逻辑处理），无法实现Proactor模式。TinyWebServer的raw版本使用的是模拟Proactor模式，主线程监听和读写IO处理，工作线程只负责process()逻辑处理。但实际上，真正的Proces模式应该是主线程负责监听，操作系统来负责读写IO操作，工作线程来负责HTTP逻辑处理。Windows操作系统可以实现真正的Process模式。</p><p>  而select业务逻辑复杂，需要自己去循环判断是否满足事件，而且不能突破最大文件上限。但优点就是可以跨平台所以保留了下来。</p><p>  poll在select的基础上进行了改进，将添加事件和满足事件两者分离开来，并且可以突破最大上限。但是仍然需要自己判断或者添加数组，业务逻辑复杂。</p><p>  elect和poll都只能工作在相对低效的LT模式下，而epoll同时支持LT和ET模式。</p><h3 id="_9-6、数据库登录注册相关" tabindex="-1"><a class="header-anchor" href="#_9-6、数据库登录注册相关" aria-hidden="true">#</a> 9.6、数据库登录注册相关</h3><h4 id="_9-6-1-登录说一下" tabindex="-1"><a class="header-anchor" href="#_9-6-1-登录说一下" aria-hidden="true">#</a> 9.6.1 登录说一下？</h4>`,138),fe={href:"https://mp.weixin.qq.com/s?__biz=MzAxNzU2MzcwMw==&mid=2649274431&idx=4&sn=7595a70f06a79cb7abaebcd939e0cbee&chksm=83ffb167b4883871ce110aeb23e04acf835ef41016517247263a2c3ab6f8e615607858127ea6&token=1686112912&lang=zh_CN#rd",target:"_blank",rel:"noopener noreferrer"},xe=a(`<p>  数据库登录分为：1.载入数据表 2.提取用户名和密码 3.注册和登录校验 4.页面跳转</p><p>1.载入数据表就是把数据库的数据通过通过map容器传到服务器上。</p><p>2.当从浏览器上输入用户的用户名和密码后，浏览器会一个post请求报文，服务器通过解析请求报文的消息体，解析出账号密码。</p><p>3.根据解析出的账号密码，与map容器中保存账号密码进行对比校验，相符则成功登陆。注册账号时，同样将输入的账号密码与数据库已经存储的账号名进行对比校验，防止出现相同的账号名。如果不相同就加入数据库。</p><p>4.当输入的账号密码与数据库的数据成功匹配，就将浏览器跳转到对应的界面。</p><h4 id="_9-6-2-你这个保存状态了吗-如果要保存-你会怎么做-cookie和session" tabindex="-1"><a class="header-anchor" href="#_9-6-2-你这个保存状态了吗-如果要保存-你会怎么做-cookie和session" aria-hidden="true">#</a> 9.6.2 你这个保存状态了吗？如果要保存，你会怎么做？（cookie和session）</h4><p>  Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容。</p><p>  Session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是Session。客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了。</p><p>  如果说<strong>Cookie机制是通过检查客户身上的“通行证”来确定客户身份的话，那么Session机制就是通过检查服务器上的“客户明细表”来确认客户身份。Session相当于程序在服务器上建立的一份客户档案，客户来访的时候只需要查询客户档案表就可以了。</strong></p><p>  session会话机制是一种服务器端机制，它使用类似于哈希表（可能还有哈希表）的结构来保存信息。   cookies会话机制：cookie是服务器存储在本地计算机上的小块文本，并随每个请求发送到同一服务器。 Web服务器使用HTTP标头将cookie发送到客户端。在客户端终端，浏览器解析cookie并将其保存为本地文件，该文件自动将来自同一服务器的任何请求绑定到这些cookie。</p><p>cookie和session的对比</p><table><thead><tr><th>Cookie</th><th>session</th></tr></thead><tbody><tr><td>浏览器</td><td>服务器</td></tr><tr><td>不安全</td><td>安全</td></tr><tr><td>不占用服务器，性能高</td><td>占用服务器，性能低</td></tr><tr><td>存储空间小</td><td>存储空间大</td></tr><tr><td>哈希表结构存储信息</td><td>本地计算机上的小块文件</td></tr></tbody></table><h4 id="_9-6-3-登录中的用户名和密码你是load到本地-然后使用map匹配的-如果有10亿数据-即使l0ad到本地后hash-也是很耗时的-你要怎么优化" tabindex="-1"><a class="header-anchor" href="#_9-6-3-登录中的用户名和密码你是load到本地-然后使用map匹配的-如果有10亿数据-即使l0ad到本地后hash-也是很耗时的-你要怎么优化" aria-hidden="true">#</a> 9.6.3 登录中的用户名和密码你是load到本地，然后使用map匹配的，如果有10亿数据，即使l0ad到本地后hash，也是很耗时的，你要怎么优化？</h4><p>  <strong>数据存储的优化</strong>：</p><p>1.数据结构的优化：为了保证数据库的一致性和完整性，在逻辑设计的时候往往会设计过多的表间关联，尽可能的降低数据的冗余。</p><p>2.数据查询的优化：保证在实现功能的基础上，尽量减少对数据库的访问次数；通过搜索参数，尽量减少对表的访问行数,最小化结果集，从而减轻网络负担；能够分开的操作尽量分开处理，提高每次的响应速度；在数据窗口使用SQL时，尽量把使用的索引放在选择的首列；算法的结构尽量简单；</p><p>3.对算法那的优化：尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。.使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。</p><p>4.建立高效的索引：创建索引一般有以下两个目的：维护被索引列的唯一性和提供快速访问表中数据的策略。大型数据库有两种索引即簇索引和非簇索引，一个没有簇索引的表是按堆结构存储数据，所有的数据均添加在表的尾部，而建立了簇索引的表，其数据在物理上会按照簇索引键的顺序存储，一个表只允许有一个簇索引</p><h4 id="_9-6-3-用的mysql啊-redis了解吗-用过吗" tabindex="-1"><a class="header-anchor" href="#_9-6-3-用的mysql啊-redis了解吗-用过吗" aria-hidden="true">#</a> 9.6.3 用的mysql啊，redis了解吗？用过吗？</h4><p>1.mysql和redis的数据库类型</p><p>  mysql是关系型数据库，主要用于存放持久化数据，将数据存储在硬盘中，读取速度较慢。</p><p>  redis是NOSQL，即非关系型数据库，也是缓存数据库，即将数据存储在缓存中，缓存的读取速度快，能够大大的提高运行效率，但是保存时间有限。</p><p>2.mysql的运行机制</p><p>  mysql作为持久化存储的关系型数据库，相对薄弱的地方在于每次请求访问数据库时，都存在着I/O操作，如果反复频繁的访问数据库。第一：会在反复链接数据库上花费大量时间，从而导致运行效率过慢；第二：反复的访问数据库也会导致数据库的负载过高，那么此时缓存的概念就衍生了出来。</p><p>3.缓存</p><p>  缓存就是数据交换的缓冲区（cache），当浏览器执行请求时，首先会对在缓存中进行查找，如果存在，就获取；否则就访问数据库。</p><p>  缓存的好处就是读取速度快</p><p>4.redis数据库</p><p>  redis数据库就是一款缓存数据库，用于存储使用频繁的数据，这样减少访问数据库的次数，提高运行效率。</p><p>5.redis和mysql的区别总结</p><p>（1）类型上</p><p>  从类型上来说，mysql是关系型数据库，redis是缓存数据库</p><p>（2）作用上</p><p>  mysql用于持久化的存储数据到硬盘，功能强大，但是速度较慢</p><p>  redis用于存储使用较为频繁的数据到缓存中，读取速度快</p><p>（3）需求上</p><p>  mysql和redis因为需求的不同，一般都是配合使用。</p><h3 id="_9-7、定时器相关" tabindex="-1"><a class="header-anchor" href="#_9-7、定时器相关" aria-hidden="true">#</a> 9.7、定时器相关</h3><h4 id="_9-7-1-为什么要用定时器" tabindex="-1"><a class="header-anchor" href="#_9-7-1-为什么要用定时器" aria-hidden="true">#</a> 9.7.1 为什么要用定时器？</h4><p>  答：服务器程序通常管理着众多定时事件，因此有效地组织这些定时事件，使之能在预期的时间点被触发且不影响服务器的主要逻辑，对于服务器的性能有着至关重要的影响。为此，我们要将每个定时事件分别封装成定时器，并使用某种容器类数据结构，比如链表、排序链表和时间轮，将所有定时器串联起来，以实现对定时事件的统一管理。</p><p>  本项目是为了<strong>方便释放那些超时的非活动连接</strong>，关闭被占用的文件描述符，才使用定时器。</p><p>  1.1：什么是定时事件？</p><p>定时事件，是指固定一段时间之后触发某段代码，由该段代码处理一个事件。这里是删除非活动的epoll树上的注册事件，并关闭对应的socket，连接次数减一。</p><p>  1.2：什么是定时器？</p><p>是指利用结构体或其他形式，<strong>将多种定时事件进行封装起来</strong>。这里只涉及一种定时事件，这里将该定时事件与连接资源封装为一个定时器类。具体包括连接资源、超时时间和回调函数，这里的回调函数指向定时事件。</p><p>  1.3：连接资源包括什么？</p><p>连接资源包括客户端套接字地址、文件描述符和定时器</p><p>  1.4：超时时间</p><p>超时时间=浏览器和服务器连接时刻 + 固定时间(TIMESLOT)，可以看出，定时器使用绝对时间作为超时值.</p><p>  1.5：什么是定时器容器？</p><p>项目中的定时器容器为带头尾结点的<strong>升序双向链表</strong>，具体的为每个连接创建一个定时器，将其添加到链表中，并按照超时时间升序排列。</p><p>  1.6：什么是定时任务？</p><p>将超时的定时器从链表中删除。</p><p>  1.7:什么是定时任务处理函数？</p><p>定时任务处理函数，该函数封装在容器类中，具体的，函数遍历升序链表容器，根据超时时间，删除对应的到期的定时器，并调用回调函数（即定时事件）。</p><p>(注意：定时任务处理函数在主循环中调用)</p><h4 id="_9-7-2-说一下定时器的工作原理" tabindex="-1"><a class="header-anchor" href="#_9-7-2-说一下定时器的工作原理" aria-hidden="true">#</a> 9.7.2 说一下定时器的工作原理</h4><p>答:服务器主循环为每一个连接创建一个定时器，并对每个连接进行定时。另外，利用升序时间链表容器将所有定时器串联起来，若主循环接收到定时通知，则在链表中依次执行定时任务处理函数。</p><p>怎么通知主循环？</p><p>利用alarm函数周期性地触发<strong>SIGALRM信号</strong>，信号处理函数<strong>利用管道通知主循环</strong>（注意，本项目信号处理函数仅仅发送信号通知程序主循环，将信号对应的处理逻辑放在程序主循环中，由主循环执行信号对应的逻辑代码。）</p><h4 id="_9-7-3-双向链表啊-删除和添加的时间复杂度说一下-还可以优化吗" tabindex="-1"><a class="header-anchor" href="#_9-7-3-双向链表啊-删除和添加的时间复杂度说一下-还可以优化吗" aria-hidden="true">#</a> 9.7.3 双向链表啊，删除和添加的时间复杂度说一下？还可以优化吗？</h4><table><thead><tr><th style="text-align:center;">位置</th><th style="text-align:center;">添加</th><th style="text-align:center;">删除</th></tr></thead><tbody><tr><td style="text-align:center;">刚好在头节点</td><td style="text-align:center;">O(1)</td><td style="text-align:center;">O(1)</td></tr><tr><td style="text-align:center;">刚好在尾节点</td><td style="text-align:center;">O(n)</td><td style="text-align:center;">O(1)</td></tr><tr><td style="text-align:center;">平均</td><td style="text-align:center;">O(n)</td><td style="text-align:center;">O(1)</td></tr></tbody></table><p>备注：</p><p>a.添加的尾节点时间复杂度为O(n)，是因为本项目的逻辑是先从头遍历新定时器在链表的位置，如果位置恰好在最后，才插入在尾节点后，所以是O(n)。</p><p>b.删除的复杂度都是O(1)，因为这里的删除都是已知目标定时器在链表相应位置的删除。（看1.7可知，函数遍历升序链表容器，根据超时时间，删除对应的到期的定时器）。（补充：游双书上的第215页代码注释里对这一点进行了说明：删除一个定时器的时候，只是简单地将它的回调函数设置为空，这样可以节省真正删除该定时器造成的开销，但是这样做容易使堆数组膨胀，所以：时间堆删除复杂度是O(1)，而不是O(logN)）</p><p>优化：</p><p>a.在双向链表的基础上优化：</p><p>添加在尾节点的时间复杂度可以优化：在添加新的定时器的时候，<strong>除了检测新定时器是否在小于头节点定时器的时间外，再先检测新定时器是否在大于尾节点定时器的时间，都不符合再使用常规插入。</strong></p><p>b.不使用双向链表，使用最小堆结构可以进行优化。</p><p>（详情看游双11.4.2章:时间堆）</p><h4 id="_9-7-4-最小堆优化-说一下时间复杂度和工作原理" tabindex="-1"><a class="header-anchor" href="#_9-7-4-最小堆优化-说一下时间复杂度和工作原理" aria-hidden="true">#</a> 9.7.4 最小堆优化？说一下时间复杂度和工作原理</h4><p>时间复杂度：</p><p>添加：O(lgn)</p><p>删除：O(1)</p><p>工作原理：</p><p>  将所有定时器中超时时间最小的一个定时器的超时值作为alarm函数的定时值。这样，一旦定时任务处理函数tick()被调用，超时时间最小的定时器必然到期，我们就可以在tick 函数中处理该定时器。然后，再次从剩余的定时器中找出超时时间最小的一个（堆），并将这段最小时间设置为下一次alarm函数的定时值。如此反复，就实现了较为精确的定时。</p><h3 id="_9-8、日志相关问题" tabindex="-1"><a class="header-anchor" href="#_9-8、日志相关问题" aria-hidden="true">#</a> 9.8、日志相关问题</h3><h4 id="_9-8-1-你c-用过什么设计模式-讲一讲。" tabindex="-1"><a class="header-anchor" href="#_9-8-1-你c-用过什么设计模式-讲一讲。" aria-hidden="true">#</a> 9.8.1 你C++用过什么设计模式？讲一讲。</h4><p>在设计日志系统的时候，用过单例模式。</p><p>  我总结下：单例模式的目的就是，用户在调用该类的时候，只能使用建立一个该类对象。于是呢就把该类的构造函数给私有化了，这样外部就根本没办法直接实例化调用该类，只能类内部调用。这时候就在类内部创建一个公有化的函数，然后让该函数返回一个该类的指针，这样外部就可以通过这个函数调用该类了。但是问题是，调用该成员函数必须实例化一个该类对象，而现在已经不能实例化该类对象了，所以为了可以成功调用该函数，把该函数设置为静态函数，静态函数的作用范围是全局整个文件，这样外部就可以调用了。</p><p>  但是这样的话实际上并不能保证主函数调用时该类对象指针的唯一性，因为该静态成员函数每次返回的都是一个新的new出来的值。每次都不一样。于是办法就是设置一个私有化的静态对象指针，在外部初始化这个指针为空。在静态成员函数中，如果该静态指针为空就创建对象指针，否则直接返回对象指针。这样就确保了在外部使用时，该对象的唯一性。</p><p>  但是问题又来了，这样做可能会导致内存泄漏，因为你静态成员函数申请的指针并没有释放，还需要用户手动释放。改动的话就把该静态成员函数中的创建指针改为创建一个静态对象成员，然后返回该成员的地址。</p><p>  但是返回一个地址就需要用指针去接收，用户就有可能对该指针进行delete造成错误，所以直接静态成员函数返回一个引用更好。这样delete就会无效。</p><p>  又但是引用之后，主函数可以通过赋值号产生新的类对象。突破了唯一性的设定。所以现在又需要对拷贝构造函数进行私有化设置。或者直接对拷贝构造=delete，进行禁用。又或者把默认的运算符重载给禁用了。</p><p>代码如下：</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>#include&lt;iostream&gt;
#include&lt;stdlib.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
using namespace std;

class Singleton{
public:
	~Singleton(){
	printf(&quot;~Singleton() destruct&quot;);
	}
	static Singleton&amp; CreateObject()
	{
		static Singleton obj;
		return obj;
	}
	
	//Singleton(Singleton&amp; obj=delete;编译不能通过，但事实也可以
private:
	Singleton(){
	printf(&quot;Singleton() Construct&quot;);
	}
	Singleton(Singleton&amp; obj){
	printf(&quot;Singleton(Singleton&amp; obj) Construct&quot;);
	}
};
int main(){
	Singleton&amp; p0bj1=Singleton::CreateObject();

	return 0;
    }
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_9-8-2-说下你的日志系统的运行机制" tabindex="-1"><a class="header-anchor" href="#_9-8-2-说下你的日志系统的运行机制" aria-hidden="true">#</a> 9.8.2 说下你的日志系统的运行机制？</h4><p>步骤：</p><p>1)：单例模式（局部静态变量懒汉方法）获取实例</p><p>2)：<strong>主程序一开始Log::get_instance()-&gt;init()初始化实例。初始化后：服务器启动按当前时刻创建日志</strong>（前缀为时间，后缀为自定义log文件名，并记录创建日志的时间day和行数count）。<strong>如果是异步</strong>(通过是否设置队列大小判断是否异步，0为同步)，&amp;&amp;工作线程将要写的内容放进阻塞队列，还创建了写线程用于在阻塞队列里取出一个内容(指针)，写入日志**。</p><p>3)：其他功能模块调用write_log()函数写日志。（write_log：实现日志分级、分文件、按天分类，超行分类的格式化输出内容。）里面会根据异步、同步实现不同的写方式。</p><p>问题：阻塞队列是什么？</p><p>本项目将生产者-消费者模型封装为阻塞队列，使用循环数组实现队列，作为两者共享的缓冲区。</p><h4 id="_9-8-3-为什么要异步-和同步的区别是什么" tabindex="-1"><a class="header-anchor" href="#_9-8-3-为什么要异步-和同步的区别是什么" aria-hidden="true">#</a> 9.8.3 为什么要异步？和同步的区别是什么？</h4><p>因为同步日志的，日志写入函数与工作线程串行执行，由于涉及到I/O操作，<strong>在单条日志比较大的时候，同步模式会阻塞整个处理流程，服务器所能处理的并发能力将有所下降</strong>，尤其是在峰值的时候，写日志可能成为系统的瓶颈。</p><p>而异步日志采用生产者-消费者模型，工作线程将所写的日志内容先存入缓冲区，写线程从缓冲区中取出内容，写入日志。并发能力比较高。</p><p>（工作线程就是生产者，写线程是消费者）</p><p>  3.1缓冲区用什么实现？</p><p>本项目将生产者-消费者模型进行了封装，使用循环数组实现队列，作为两者共享的缓冲区。</p><p>  3.2：什么是生产者消费者模式？</p><p>某个模块负责产生数据，这些数据由另一个模块来负责处理（此处的模块是广义的，可以是类、函数、线程、进程等）。产生数据的模块，就形象地称为生产者；而处理数据的模块，就称为消费者。</p><p>单单抽象出生产者和消费者，还够不上是生产者／消费者模式。该模式还需要有一个缓冲区处于生产者和消费者之间，作为一个中介。生产者把数据放入缓冲区，而消费者从缓冲区取出数据。大概的结构如下图。</p><figure><img src="https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlj4DvHm9GgT2UQ0o/root/content" alt="content" tabindex="0" loading="lazy"><figcaption>content</figcaption></figure><h4 id="_9-8-4-现在你要监控一台服务器的状态-输出监控日志-请问如何将该日志分发到不同的机器上" tabindex="-1"><a class="header-anchor" href="#_9-8-4-现在你要监控一台服务器的状态-输出监控日志-请问如何将该日志分发到不同的机器上" aria-hidden="true">#</a> 9.8.4 现在你要监控一台服务器的状态，输出监控日志，请问如何将该日志分发到不同的机器上？</h4><p>同一个机器：使用观察者模式（有的叫发布订阅模式）</p><p>但是多机器，借助redis数据库的消息队列的发布订阅模式。实现分布式日志系统。</p><h3 id="_9-9、-单例模式以及其他小问题" tabindex="-1"><a class="header-anchor" href="#_9-9、-单例模式以及其他小问题" aria-hidden="true">#</a> 9.9、 单例模式以及其他小问题</h3><p><strong>1）你的项目中用到哪些设计模式</strong></p><p>单例模式</p><p><strong>2）懒汉模式和饿汉模式具体怎么实现</strong></p><p>看书的最后一页。</p><p>单例模式要两次加锁的原因是，如果针对多线程，两个线程同时判断出指针为空，就会同时创建两个单例的指针，判断一次之后进行加锁后再创建实例，就可以避免有另一个同时判断成功也迅速创建了实例，因为加锁后另一个进程不能再进入。</p><p><strong>3）单例模式会带来哪些问题？</strong></p><p>单例模式一般没有接口，扩展困难。如果要扩展，则除了修改原来的代码，没有第二种途径，违背开闭原则。</p><p>在并发测试中，单例模式不利于代码调试。在调试过程中，如果单例中的代码没有执行完，也不能模拟生成一个新的对象。</p><p>单例模式的功能代码通常写在一个类中，如果功能设计不合理，则很容易违背单一职责原则。</p><p><strong>4）有用过动态规划来解决实际问题吗？说一下它的思想？</strong></p><p>  动态规划最初是为了解决递归重复计算导致超时的问题，后来为了防止多次重复计算，引入了记忆化递归，但是记忆化递归仍然效率不是特别高，在记忆化递归的基础上改进后，形成了自上而下的动态规划方法。</p><p><strong>5）你web服务器能说一下项目框架吗？</strong></p><p>略</p><p><strong>6）那你说一下它的结构以及怎么工作的？</strong></p><p>  线程池最重要的是一个线程池数组和一个任务队列，在类的构造函数中创建一定数量的线程，并放到线程池数组中，然后主函数中将任务插入到请求队列中，已经创建的线程对队列中的任务进行抢夺，得到任务加锁进行处理，处理主要依靠线程的运行函数，该函数会调用http类里的解析函数对客户端的请求进行解析。并且调用数据库连接池导入数据。</p><p>  为了可以同时处理多个连接，需要在让一个线程的处理函数不间断的进行while循环</p><p><strong>7）状态机设计机制是什么？你使用状态机给你项目带来哪些好处？</strong></p><p>（自己编的）状态机就是用于不同状态转换的一种数学模型。</p><p>设计机制：将程序中的不同状态进行整合，来保证不论状态发生的顺序如何，最后都能转移到需要的状态上。</p><p>好处：项目中状态机主要用于对客户端请求的处理，其中有三种状态，处理请求行，处理请求头，处理请求体，有了状态机，一方面可以避免多种状态同时发生造成混乱。另一方面保证了状态处理结束后能够正确的进行状态转移，相比只有if进行判断更加安全可靠。</p><p><strong>8）有没有想过状态机会给项目带来哪些危害？</strong></p><p>缺点：状态机的缺点就是性能比较低，一般一个状态做一个事情，性能比较差，在追求高性能的场景下一般不用，高性能场景一般使用流水线设计。</p><p><strong>9）你在项目设计的过程中遇到过什么问题？是怎么解决的。</strong></p><p>略</p><p><strong>10）Webbench是什么，介绍一下原理？</strong></p><p>  父进程fork若干个子进程，每个子进程在用户要求时间或默认的时间内对目标web循环发出实际访问请求，父子进程通过管道进行通信，子进程通过管道写端向父进程传递在若干次请求访问完毕后记录到的总信息，父进程通过管道读端读取子进程发来的相关信息，子进程在时间到后结束，父进程在所有子进程退出后统计并给用户显示最后的测试结果，然后退出。</p><p><strong>11）项目日志系统的工作流程？</strong></p><p>  日志分为同步日志和异步日志，异步日志利用阻塞队列，先将日志放入阻塞队列中，然后利用条件变量将日志添加到对应文件中。下面的意思是如果文件名没带路径，直接放到log_full_name。如果带路径，把文件名取出来放到log_name，把路径取出来放到dir_name，然后把时间+log_name放到log_full_name。这就是在初始化函数中主要要做的事。</p><p>  在write_log（）函数中，这里面有两部分，一部分是对新的文件名，时间，日志名进行再次处理，一部分是时间+新加入的日志参数放入缓冲区。异步加入阻塞队列，同步直接写入日志文件。阻塞队列是用数组模拟的生产者消费者模式。根据初始化函数传入的最后一个参数阻塞队列最大容纳值判断是同步还是异步，异步则其大于等于1。</p><p><strong>12）项目的多线程改成多进程，如何改？</strong></p><p>  使用for循环，每次都调用fork()创建子进程，而不再使用pthread_create()函数。</p><p><strong>13）介绍一下生产者消费者？</strong></p><p>  生产者和消费者主要用于对于数据的同步使用，生产者生产数据，然后放到共享缓冲区中，消费者在缓冲区没有数据之前会阻塞等待，当生产者生产数据之后，会用signal函数唤醒阻塞，开始消费数据，而当数据生产充满缓冲区之后，生产者就会阻塞等待。其中的阻塞都使用条件变量。</p><p><strong>14）recactor为什么主线程只负责监听而工作线程负责处理，为什么这样设计</strong></p><p>答：</p><p><strong>15）两个线程可以同时对一个socket发送链接么、会有什么问题出现么</strong></p><p>答：导致发生数据拥塞</p><p><strong>16）你的项目http请求怎么做的？如何保证http请求完整解析</strong></p><p>答：</p><p><strong>17）如果我发的http包特别大怎么办</strong></p><p>答：</p><p><strong>18）Tcp的时候会进行数据切片</strong></p><p>答：</p><p><strong>19）为什么tcp面向字节流，udp面向报文</strong></p><p>答：</p><p><strong>20）从WebServer中学到了什么？</strong></p><p>答：个人收获：1、熟悉了Linux系统的使用和C++网络编程的流程；2、对TCP通信和Socket网络编程有了更深的理解，对HTTP的服务过程有了更清晰的认识。</p><p><strong>21）什么是URL？</strong></p><p>答：URL是（Uniform Resource Locator,统一资源定位器），由四部分组成：1）传输协议（http/https）、2）域名、3）路径、4）资源名。其中域名由DNS服务器负责解析成具体的IP地址。</p><h2 id="十、-小林的面经" tabindex="-1"><a class="header-anchor" href="#十、-小林的面经" aria-hidden="true">#</a> 十、 小林的面经</h2>`,157),Te={href:"https://mp.weixin.qq.com/s/aBD8pgOa02OBjlGrFAvpCA",target:"_blank",rel:"noopener noreferrer"},we=a('<h3 id="_1、存字符串用unordered-map还是用map好-为什么-要怎么优化" tabindex="-1"><a class="header-anchor" href="#_1、存字符串用unordered-map还是用map好-为什么-要怎么优化" aria-hidden="true">#</a> 1、存字符串用<code>unordered_map</code>还是用<code>map</code>好？为什么？要怎么优化？</h3><p>答：   <strong>map和unordered_map的优缺点</strong> map优点：map是有序的、基于红黑树实现，查找的时间复杂度是O(n) map缺点：空间占用率比较高，因为内部实现了红黑树，虽然提高了运行效率，但是每个节点都要保存父亲节点和孩子节点和红黑树的性质，使得每一个节点都占用大量的空间。   <strong>适用的情况</strong>：对于要有序的结构，使用map。 unordered_map优点：因为内部是哈希表来实现的，所以查找效率会非常高。 unordered_map缺点：哈希表的建立比较费时   <strong>适用的情况</strong>：对于查找问题，使用unordered_map会更好一点。</p><p>  （以下内容来源于chatgpt）存储字符串时，unordered_map和map都可以使用，但它们在性能、内存消耗和功能方面有所不同。</p><ol><li>访问效率：</li></ol><ul><li>unordered_map 使用哈希表实现，在大多数情况下，查找元素的时间复杂度为O(1)。因此，当需要快速查找元素时，unordered_map是更好的选择。</li><li>map 使用红黑树实现，查找元素的时间复杂度为O(log n)，其中n是元素的数量。相对于unordered_map，map查找稍慢一些。</li></ul><ol start="2"><li>内存消耗：</li></ol><ul><li>unordered_map 使用哈希表存储数据，因此可能需要更多的内存来存储哈希表本身和哈希冲突时的解决方案。</li><li>map 使用红黑树存储数据，虽然红黑树会占用额外的内存，但通常整体上比unordered_map消耗更少的内存。</li></ul><ol start="3"><li>键的排序：</li></ol><ul><li>unordered_map 不对键进行排序，键的顺序是不确定的。</li><li>map 默认会按照键的升序进行排序，这种特性非常适合需要有序访问元素的情况。   综上所述，如果你更关注快速的查找操作，并且不需要键的排序，可以选择unordered_map。如果你需要有序访问元素，或者希望降低内存消耗，可以选择map。最终的选择还取决于你对性能和功能的具体需求。</li></ul><h3 id="_2、有一个请求队列-有读者线程和写者线程-在同时操作这个共享的请求队列-属于什么样的读写模型" tabindex="-1"><a class="header-anchor" href="#_2、有一个请求队列-有读者线程和写者线程-在同时操作这个共享的请求队列-属于什么样的读写模型" aria-hidden="true">#</a> 2、有一个请求队列,有读者线程和写者线程 在同时操作这个共享的请求队列,属于什么样的读写模型 ？</h3><p>答：属于生产者-消费者模型</p><h3 id="_3、一写多读模型的情况下怎么解决读写冲突的问题-加锁是一种方案-但是会影响性能-有没有更好的办法" tabindex="-1"><a class="header-anchor" href="#_3、一写多读模型的情况下怎么解决读写冲突的问题-加锁是一种方案-但是会影响性能-有没有更好的办法" aria-hidden="true">#</a> 3、一写多读模型的情况下怎么解决读写冲突的问题？加锁是一种方案,但是会影响性能,有没有更好的办法？</h3>',12),Le={href:"https://blog.csdn.net/simon_2011/article/details/79014110",target:"_blank",rel:"noopener noreferrer"},ye=a('<ul><li>一写多读（含一写一读）</li><li>多写一读</li><li>多写多读</li></ul><h3 id="_4、select和epoll有什么区别" tabindex="-1"><a class="header-anchor" href="#_4、select和epoll有什么区别" aria-hidden="true">#</a> 4、select和epoll有什么区别？</h3><p>答：他们两个，甚至包含poll都是IO多路复用的系统调用，select是一种较老的系统调用，epoll则比较新。</p><ol><li>工作方式：</li></ol><ul><li>select 是阻塞式的，它会一直等待直到指定的文件描述符之一就绪或超时。每次调用select时都需要将所有感兴趣的文件描述符集合传递给它。</li><li>epoll 使用更加高效的事件通知机制，采用&quot;就绪列表&quot;的方式来避免遍历所有文件描述符。它通过在内核中注册事件，只返回就绪的文件描述符，从而提高了性能。</li></ul><ol start="2"><li>可扩展性：</li></ol><ul><li>select 的可扩展性较差，它使用线性扫描方式对所有的文件描述符进行轮询，当文件描述符数量较大时，性能会下降。</li><li>epoll 利用操作系统提供的epoll机制，可以监听大量的文件描述符，并且在文件描述符就绪时立即得到通知，因此它在处理大量并发连接时具有更好的可扩展性。</li></ul><ol start="3"><li>文件描述符管理：</li></ol><ul><li>select 的文件描述符集合大小是固定的，需要通过修改宏定义来改变，默认情况下是1024。这意味着在使用select时，需要事先设置一个足够大的文件描述符集合，并关注其中的文件描述符。</li><li>epoll 不限制文件描述符集合的大小，它只需要关注真正发生事件的文件描述符，可以动态地添加和删除感兴趣的文件描述符。   综上所述，epoll相对于select在性能和可扩展性方面有优势。它通过更高效的事件通知机制和可变大小的文件描述符集合使得并发连接的处理更为高效。因此，在大规模并发服务器开发中，epoll通常是更常用的选择。但对于小规模应用或特定的情况，select也可能是一个简单而有效的选择。</li></ul><h3 id="_5、epoll中可以无限承载socket的连接吗-创建socket时的返回值是什么" tabindex="-1"><a class="header-anchor" href="#_5、epoll中可以无限承载socket的连接吗-创建socket时的返回值是什么" aria-hidden="true">#</a> 5、epoll中可以无限承载socket的连接吗？创建socket时的返回值是什么？</h3><p>答：在epoll中，理论上可以承载无限数量的Socket连接。epoll采用事件驱动的方式，通过注册和监听文件描述符（包括Socket描述符），只返回就绪的文件描述符，并且可以动态地添加和删除感兴趣的文件描述符。这种机制使得epoll具有更好的可扩展性，能够处理大规模并发连接。</p><p>  在创建Socket时，返回值是一个非负整数，表示创建的Socket文件描述符。如果创建失败，返回值通常是-1，并且设置错误码以指示具体错误原因。请注意，Socket描述符是一个整数，可以在后续的网络编程中使用它来进行读写操作、设置选项以及进行其他操作。</p><p>  需要注意的是，尽管epoll本身没有对文件描述符个数的限制，但是操作系统可能对每个进程所能打开的文件描述符数量进行了限制。因此，在实际使用过程中，需要根据系统的最大文件描述符限制和资源消耗进行适当的调优，确保能够处理预期的并发连接数。</p><h3 id="_6、fd在系统中有限制吗-可以无限申请吗" tabindex="-1"><a class="header-anchor" href="#_6、fd在系统中有限制吗-可以无限申请吗" aria-hidden="true">#</a> 6、fd在系统中有限制吗？可以无限申请吗？</h3><p>答：在大多数系统中都对fd做了限制，在Linux下一般文件描述符最多可打开1024个，不过你可以使用ulimit命令或者修改<code>/etc/security/limits.conf</code>系统配置文件来增加或减少进程的最大文件描述符限制。对于不同的操作系统和发行版，最大文件描述符限制可能会有所不同。例如，在Windows系统中，默认的最大文件描述符限制是2048。</p><p>  需要注意的是，尽管可以通过调整最大文件描述符限制来提高进程所能打开的文件描述符数量，但是资源消耗和性能问题也需要考虑。过多地申请文件描述符可能会导致系统资源紧张，从而影响系统的稳定性和性能。</p><h3 id="_7、一个服务端进程最多可以和多少个客户端进行连接-和fd的数量有关吗" tabindex="-1"><a class="header-anchor" href="#_7、一个服务端进程最多可以和多少个客户端进行连接-和fd的数量有关吗" aria-hidden="true">#</a> 7、一个服务端进程最多可以和多少个客户端进行连接？和fd的数量有关吗？</h3><p>答;一个服务端进程可以与多个客户端进行连接，但具体可以支持的最大连接数取决于几个因素，其中包括操作系统和硬件资源的限制、进程所能打开的文件描述符数量，以及应用程序的实现方式。</p><ol><li>操作系统和硬件资源限制：</li></ol><ul><li>操作系统可能对每个进程能够同时处理的网络连接数量设置了限制。这是由操作系统内核的配置参数或者其他资源限制决定的。</li><li>硬件资源如内存、CPU等也会对并发连接数产生影响。</li></ul><ol start="2"><li>文件描述符数量：</li></ol><ul><li>进程所能打开的文件描述符数量限制了其能够管理的连接数量。每个连接对应一个文件描述符，如果文件描述符数量达到上限，则无法建立更多的连接。</li><li>需要注意的是，不仅服务器端需要考虑文件描述符的数量限制，客户端也需要考虑。</li></ul><ol start="3"><li>应用程序实现：</li></ol><ul><li>应用程序的设计和实现方式也影响了能够同时处理的连接数量。例如，采用多线程或多进程模型，可以实现每个线程或进程专门处理一个连接，从而提高并发连接数。</li></ul><p>  综上所述，并发连接数量并非仅与文件描述符数量相关。它还受到操作系统和硬件资源的限制，以及应用程序实现方式的影响。在实际开发中，需要合理的资源规划、优化和管理来满足预期的并发连接需求。</p><h3 id="_8、假设这样一个场景-客户端在和服务端进行tcp的三次握手的过程中-突然间客户端宕机了-那么这个socket怎么处理-可以删除吗-是怎么删除的" tabindex="-1"><a class="header-anchor" href="#_8、假设这样一个场景-客户端在和服务端进行tcp的三次握手的过程中-突然间客户端宕机了-那么这个socket怎么处理-可以删除吗-是怎么删除的" aria-hidden="true">#</a> 8、假设这样一个场景，客户端在和服务端进行TCP的三次握手的过程中，突然间客户端宕机了，那么这个socket怎么处理？可以删除吗？是怎么删除的？</h3>',26),Se={href:"https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247520003&idx=1&sn=3e70c6b54007ffa3130c5956df232bdb&chksm=f98dcba9cefa42bfbf35fd5f867314d8c96c54f5b285db542be42fc0594706d1429eaa069165&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"},Pe=a(`<p>  但是，如果「服务端挂掉」指的是「服务端主机宕机」，那么是不会发生四次挥手的，具体后续会发生什么？还要看客户端会不会发送数据？</p><p>  如果客户端会发送数据，由于服务端已经不存在，客户端的数据报文会超时重传，当重传次数达到一定阈值后，会断开 TCP 连接；   如果客户端一直不会发送数据，再看客户端有没有开启 TCP keepalive 机制？ 如果有开启，客户端在一段时间后，检测到服务端的 TCP 连接已经不存在，则会断开自身的 TCP 连接；   如果没有开启，客户端的 TCP 连接会一直存在，并不会断开。</p><p>有关该问题的更详细解答，请查看上述链接。</p><p>  如果挂了的是<strong>客户端</strong>，则：</p><p>  在TCP的三次握手过程中，如果客户端在握手期间宕机或断开连接，服务端会在一定时间内等待客户端的确认消息，这个等待的时间称为超时时间。</p><p>  如果超过超时时间后仍然没有收到来自客户端的确认消息，那么服务端会认为客户端已经宕机或断开连接。此时，服务端会关闭与该客户端的连接，并释放对应的Socket资源。</p><p>  具体的删除过程可以通过以下步骤完成：</p><ol><li>服务端在接收到客户端的连接请求后创建一个Socket对象，并分配一个文件描述符用于标识这个Socket。</li><li>在三次握手过程中，服务端会监听客户端的确认消息。如果超过超时时间后没有收到客户端的确认消息，服务器会发起一系列的重试和超时机制，直至达到最大重试次数或超时时间的上限。</li><li>当超过最大重试次数或超时时间上限后，服务器认为客户端已经宕机或断开连接。</li><li>服务端会关闭与该客户端的连接，释放对应的Socket资源。这包括释放文件描述符、回收关联的内存、关闭相应的网络连接等操作。</li><li>被关闭和释放的Socket会从操作系统的监听队列和相关数据结构中删除，最终被操作系统回收。</li></ol><p>  需要注意的是，即使客户端在握手期间宕机或断开连接，服务端也需要一定的时间来处理这个情况。具体的超时时间和重试次数可以在服务端的TCP配置中进行设置或使用操作系统的默认值。</p><h3 id="_9、在服务端调用accept-之后-socket就是一直可读的吗-就是调用read-函数就一直可以读吗-会阻塞吗" tabindex="-1"><a class="header-anchor" href="#_9、在服务端调用accept-之后-socket就是一直可读的吗-就是调用read-函数就一直可以读吗-会阻塞吗" aria-hidden="true">#</a> 9、在服务端调用<code>accept()</code>之后,socket就是一直可读的吗？就是调用read()函数就一直可以读吗？会阻塞吗？</h3><p>答：在服务端调用<code>accept()</code>之后，返回的socket对象可以被认为是可读的，但并不意味着调用read()函数就一直可以读取数据。</p><p>  调用accept()函数是为了接受客户端的连接请求，并创建一个新的Socket用于与该客户端通信。这个新的Socket对象表示了与客户端的连接。</p><p>  在使用这个连接进行数据传输时，可以使用read()函数从Socket中读取数据，但需要注意以下几点：</p><ol><li>阻塞式读取：</li></ol><ul><li>默认情况下，read()函数是阻塞的，即如果没有数据可读，它会一直阻塞等待直到有数据到达。</li><li>当没有数据到达时，read()函数会阻塞线程的执行，程序无法继续向下执行。只有当有数据到达时，才会从read()函数返回，并返回实际读取到的数据量。</li></ul><ol start="2"><li>非阻塞式读取：</li></ol><ul><li>可以通过设置Socket为非阻塞模式来使用非阻塞式读取。在非阻塞模式下，read()函数会立即返回，无论是否有数据可读。</li><li>在非阻塞模式下，如果没有数据可读，read()函数可能会返回一个特定的错误码（如EWOULDBLOCK或EAGAIN），表示当前没有可读数据。</li></ul><p>  需要注意的是，调用accept()函数只是用于接受客户端连接，并创建一个新的socket对象。之后，服务端需要通过新的socket对象来进行实际的数据传输操作，包括调用read()函数来读取从客户端发送过来的数据。accept()函数和read()函数是不同的功能接口，它们在不同的阶段使用，分别用于建立连接和进行数据传输。</p><h3 id="_10、如果服务端read-函数发生了阻塞-对方客户端异常关闭了-一直没有发数据过来-服务端会一直阻塞吗-会导致服务端卡死吗" tabindex="-1"><a class="header-anchor" href="#_10、如果服务端read-函数发生了阻塞-对方客户端异常关闭了-一直没有发数据过来-服务端会一直阻塞吗-会导致服务端卡死吗" aria-hidden="true">#</a> 10、如果服务端read()函数发生了阻塞,对方客户端异常关闭了,一直没有发数据过来,服务端会一直阻塞吗？会导致服务端卡死吗？</h3><p>答：如果服务端的read()函数发生了阻塞，而对方客户端异常关闭了连接并没有发送数据过来，服务端可能会一直处于阻塞状态，并且有潜在的导致服务端卡死的风险。</p><ul><li>下面是一种可能的情况：</li></ul><ol><li>服务端调用read()函数进行数据读取。</li><li>如果对方客户端异常关闭了连接并没有发送数据，服务端会一直等待数据到达。</li><li>由于对方客户端已经关闭连接，服务端不会收到任何数据，read()函数会一直阻塞等待数据到达。</li><li>如果服务端没有设置合适的超时机制或其他手段来处理阻塞情况，那么服务端可能会一直保持阻塞状态，无法继续向下执行其他操作，从而导致服务端卡死。</li></ol><ul><li>为了避免这种情况，可以采取以下策略：</li></ul><ol><li>设置读取超时机制：使用适当的方式设置read()函数的超时时间，确保当一定时间内没有数据到达时能够及时返回，避免无限阻塞。</li><li>使用非阻塞模式：将服务端的Socket设置为非阻塞模式，这样在没有数据可读时，read()函数会立即返回，并根据返回值进行相应的处理。</li><li>引入心跳机制：使用心跳机制来检测连接是否仍然有效，定期发送心跳包并等待对方的心跳回复。如果一定时间内没有收到心跳回复，可以判断连接已断开。</li></ol><p>  以上措施可以提高服务端的鲁棒性，避免长时间阻塞和卡死的风险。具体实现上述策略的方式与编程语言和网络库有关，可以根据具体情况进行调整。</p><h3 id="_11、在第七题中提到的这个情况-epoll可以解决这个问题吗-如果要识别这个问题-怎么识别" tabindex="-1"><a class="header-anchor" href="#_11、在第七题中提到的这个情况-epoll可以解决这个问题吗-如果要识别这个问题-怎么识别" aria-hidden="true">#</a> 11、在第七题中提到的这个情况，epoll可以解决这个问题吗？如果要识别这个问题，怎么识别？</h3><p>答：Epoll在解决高并发连接问题上具有很好的性能。Epoll是Linux下的一种I/O事件通知机制，它使用了事件驱动的方式，能够高效地处理大量的并发连接。通过使用epoll，可以实现较高的并发性能。</p><p>epoll_create、epoll_ctl和epoll_wait是epoll机制的三个关键函数，它们一起协作实现高并发服务器的功能。</p><ol><li><p>epoll_create函数：创建一个epoll实例，返回一个文件描述符用于标识该实例。该函数会创建一个红黑树（用于存储文件描述符及其对应的事件）和一个就绪链表（用于保存已经就绪的事件）。</p></li><li><p>epoll_ctl函数：用于向epoll实例中添加、修改或删除文件描述符及其对应的事件监听。</p></li></ol><ul><li>添加监听事件：通过指定EPOLL_CTL_ADD操作，在epoll实例中注册要监听的文件描述符和感兴趣的事件类型（如可读、可写等）。</li><li>修改监听事件：通过指定EPOLL_CTL_MOD操作，修改已经注册的文件描述符对应的事件类型。</li><li>删除监听事件：通过指定EPOLL_CTL_DEL操作，从epoll实例中删除不再监听的文件描述符。</li></ul><ol start="3"><li>epoll_wait函数：等待文件描述符上的事件就绪。</li></ol><ul><li>当有文件描述符上的事件就绪时，epoll_wait函数会阻塞，直到有事件发生或达到超时时间。</li><li>当有事件发生或超时时间到达时，epoll_wait函数会将就绪的文件描述符和其对应的事件放入就绪链表中，并返回就绪的文件描述符数量。</li></ul><p>基于上述函数的配合，实现高并发服务器的主要流程如下：</p><ol><li><p>创建一个epoll实例：使用epoll_create函数创建一个epoll实例，并获取返回的文件描述符。</p></li><li><p>添加初始监听事件：使用epoll_ctl函数将要监听的文件描述符和初始感兴趣的事件类型添加到epoll实例中。</p></li><li><p>进入主循环：在一个无限循环中执行以下操作：</p><ul><li><p>a. 调用epoll_wait函数，等待文件描述符上的事件就绪。</p></li><li><p>b. 当有就绪事件时，遍历就绪链表中的事件，根据事件类型执行相应的操作。例如，可读事件可能表示有客户端请求到达，可写事件可能表示可以向客户端发送响应数据。</p></li><li><p>c. 根据具体需求，可能需要重新注册或修改文件描述符的监听事件。</p></li></ul></li><li><p>处理其他业务逻辑：除了处理已就绪的事件外，还可以在主循环中处理其他业务逻辑，如定时任务、心跳检测等。</p></li></ol><p>  通过以上的配合，epoll机制能够高效地处理大量并发连接，避免了传统的轮询方式的效率问题，提升了服务器的并发性能。</p><h3 id="_12、linux进程创建线程的流程是怎么样的" tabindex="-1"><a class="header-anchor" href="#_12、linux进程创建线程的流程是怎么样的" aria-hidden="true">#</a> 12、linux进程创建线程的流程是怎么样的？</h3><p>答：在Linux中，进程创建线程的流程可以通过以下步骤概括：</p><ol><li><p>创建线程：调用pthread_create()函数创建一个新的线程。该函数会将线程标识符（Thread ID）和线程属性作为参数，并指定一个函数作为线程的入口点。</p></li><li><p>初始化线程属性（可选）：如果需要对线程进行特殊处理，可以使用pthread_attr_init()函数初始化线程属性，并通过pthread_attr_set*()函数设置不同的属性，例如线程栈大小、线程优先级等。</p></li><li><p>线程执行：当创建的线程被调度执行时，它将开始执行之前指定的入口点函数。这个函数是由创建线程时传递给pthread_create()的函数。</p></li><li><p>线程执行结束：线程执行完入口点函数后，可以通过return语句返回一个值，也可以调用pthread_exit()函数显式地退出线程。</p></li></ol><p>  总体上，线程的创建流程包括了创建线程、设置线程属性（可选）、线程执行和线程执行结束。可以通过线程库（如pthread库）提供的函数来创建和操作线程。需要注意的是，不同的编程语言和线程库可能会有一些语法和细节上的差异，但基本的流程是相似的。</p><p>  这里以C语言和pthread库为例，演示创建一个简单的线程的流程：</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt;

// 入口点函数
void* threadFunction(void* arg) {
    printf(&quot;This is a thread.\\n&quot;);
    pthread_exit(NULL);
}

int main() {
    pthread_t tid; // 线程标识符

    // 创建线程
    int ret = pthread_create(&amp;tid, NULL, threadFunction, NULL);
    if (ret != 0) {
        fprintf(stderr, &quot;Failed to create thread.\\n&quot;);
        return 1;
    }

    // 等待线程结束
    pthread_join(tid, NULL);

    printf(&quot;Main thread exiting.\\n&quot;);

    return 0;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>  在上面的示例中，<code>pthread_create()</code>函数用于创建一个新的线程，<code>threadFunction()</code>函数作为线程入口点。在<code>main()</code>函数中，通过<code>pthread_join()</code>函数等待线程执行完毕。最后，主线程打印一条消息后退出。</p><h3 id="_13、线程共享进程的资源在linux中是怎么实现的" tabindex="-1"><a class="header-anchor" href="#_13、线程共享进程的资源在linux中是怎么实现的" aria-hidden="true">#</a> 13、线程共享进程的资源在linux中是怎么实现的？</h3><p>答：在Linux中，线程共享进程的资源是通过以下方式实现的：</p><ol><li><p>共享虚拟地址空间：线程属于同一进程，它们共享进程的虚拟地址空间。这意味着它们可以访1. 问和操作相同的内存区域，无需进行显式的内存拷贝或通信。</p></li><li><p>共享文件描述符：线程可以访问进程打开的文件描述符。当一个线程打开或关闭文件时，对其他线程也会产生影响。这使得多个线程可以方便地对文件进行读写操作，而无需进行额外的同步和通信。</p></li><li><p>共享信号处理：多个线程可以共享进程的信号处理代码。当进程接收到一个信号时，所有线程都可以对该信号进行捕获和处理。这样可以提供更灵活的信号处理机制，使得不同线程有不同的信号处理逻辑。</p></li><li><p>共享全局变量：线程可以直接访问和修改进程的全局变量。对全局变量的读写操作在所有线程之间具有可见性，因此需要进行适当的同步和互斥来保证数据一致性。</p></li><li><p>共享进程属性：线程可以访问和修改进程的属性，例如进程ID、进程组ID等。这些属性对于整个进程来说是共享的，因此对其进行修改会对所有线程产生影响。</p></li></ol><p>  需要注意的是，尽管线程共享进程的资源，在并发情况下仍然需要适当的同步和互斥机制来保护共享资源的一致性。例如，使用互斥锁、条件变量等机制来控制对共享数据的访问。这样可以避免多个线程同时修改共享资源而导致的数据竞争和不一致性。</p><h3 id="_14、线程有自己私有的栈-那么这个栈的内存是被分配到哪里的-是放在进程所属的内存里面-还是说放在独立于进程外部的内存中" tabindex="-1"><a class="header-anchor" href="#_14、线程有自己私有的栈-那么这个栈的内存是被分配到哪里的-是放在进程所属的内存里面-还是说放在独立于进程外部的内存中" aria-hidden="true">#</a> 14、线程有自己私有的栈，那么这个栈的内存是被分配到哪里的？是放在进程所属的内存里面，还是说放在独立于进程外部的内存中？</h3><p>答：线程的私有栈内存是分配在进程所属的内存中的。</p><p>  在大多数操作系统中，每个线程都有自己的栈空间用于存储局部变量、函数调用信息和其他线程私有的数据。这些栈空间通常是在进程创建线程时动态分配的，并且位于进程的虚拟地址空间中。</p><p>具体来说，在Linux系统中，进程的虚拟地址空间包括了以下几个区域：</p><ol><li><p>代码段（Text Segment）：存放程序的可执行代码。</p></li><li><p>数据段（Data Segment）：存放已初始化的全局变量和静态变量。</p></li><li><p>BSS段（Block Started by Symbol）：存放未初始化的全局变量和静态变量的内存。</p></li><li><p>堆（Heap）：由动态分配的内存组成，用于动态申请和释放内存。</p></li><li><p>栈（Stack）：用于存放函数调用的返回地址、局部变量等。</p></li></ol><p>  当创建一个线程时，操作系统会为这个线程分配一块栈空间，通常默认大小为几MB。这个栈空间会被映射到进程的虚拟地址空间的栈段中，位于栈段的底部。每个线程会有自己独立的栈空间，线程之间不会共享栈空间。</p><p>  需要注意的是，栈空间是有限的资源，并且在运行时会自动增长和收缩。当线程调用函数或者发生递归调用时，栈会扩展以容纳更多的局部变量和函数调用信息。而当函数返回或者递归结束时，栈会收缩回原来的大小，释放掉不再需要的空间。</p><p>  因此，线程的私有栈内存是被分配在进程所属的内存中，并且位于进程虚拟地址空间中的栈段。</p><h3 id="_15、什么是协程-协程有什么用" tabindex="-1"><a class="header-anchor" href="#_15、什么是协程-协程有什么用" aria-hidden="true">#</a> 15、什么是协程？协程有什么用？</h3><p>答：协程（Coroutine）是一种用户级的轻量级线程，也被称为“协作式多任务”或“非抢占式多任务”。与操作系统级线程（例如常见的多线程）相比，协程由用户代码主动控制，并且在不同协程之间没有强制切换和抢占的行为。</p><ul><li>协程的特点如下：</li></ul><ol><li><p>主动控制权：协程是由用户代码主动控制的。在一个协程执行时，它会负责运行直到主动让出控制权，然后切换到另一个协程继续执行。</p></li><li><p>非抢占式：与操作系统级线程不同，协程不存在强制的抢占行为。一个协程只有在自己主动让出控制权时，其他协程才能获得执行机会。</p></li><li><p>轻量级：相对于操作系统级线程，协程的资源消耗更小。协程的创建、销毁和切换开销较小，因此可以创建大量的协程而不会导致过多的资源占用。</p></li></ol><ul><li>协程有以下几个常见的用途和好处：</li></ul><ol><li><p>顺序逻辑简化：协程可以在一个函数内部实现多个逻辑片段的切换和执行，避免了复杂的回调机制或多线程间的同步问题。这使得代码更加简洁、易读，尤其适用于处理复杂的异步任务场景。</p></li><li><p>任务调度和协作：协程可以将一个长时间运行的任务分成多个部分执行，使得其他协程有机会执行而不会阻塞整个程序。通过主动让出控制权，协程能够实现高效的任务调度和协作。</p></li><li><p>高并发、高扩展性：由于协程的轻量级特性，可以创建大量的协程来处理并发任务，而不会因为线程或进程创建过多而导致资源耗尽。此外，协程也具备较好的扩展性，可以根据实际需求动态调整协程的数量。</p></li><li><p>状态保存和恢复：协程能够保存当前执行的上下文状态，并在切换回来时恢复状态，这使得协程在编写状态机、迭代器等复杂逻辑时非常方便。</p></li></ol><p>  需要注意的是，协程的具体实现方式和语法会因编程语言和库的不同而有所差异。在一些编程语言中，协程可能是原生支持的（如Go、Python的asyncio），而在其他语言中可能需要依赖第三方库来实现。</p><h3 id="_16、场景题-一致性哈希相关" tabindex="-1"><a class="header-anchor" href="#_16、场景题-一致性哈希相关" aria-hidden="true">#</a> 16、场景题：一致性哈希相关</h3>`,62),Ce={href:"https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247504513&idx=1&sn=4faa7afcd98b03ef3c24912860317e9e&chksm=f98d962bcefa1f3db85b9f3b3f690359d12089ab93200eb2ce92750ab4224e6d8f145e391402&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"},Ee=a('<h4 id="_17、进程与线程的区别和联系" tabindex="-1"><a class="header-anchor" href="#_17、进程与线程的区别和联系" aria-hidden="true">#</a> 17、进程与线程的区别和联系</h4><p>答：进程和线程是操作系统中的两个重要概念，它们分别代表了程序执行的不同方式。</p><ul><li>区别：</li></ul><ol><li><p>调度单位：进程是操作系统进行资源分配和调度的基本单位，而线程是进程中的一个执行单元。一个进程可以包含多个线程，线程共享进程的资源。进程是资源分配的最先单位，线程是计算机中独立执行、CPU调度的最小单位。</p></li><li><p>资源拥有：每个进程都有独立的地址空间、文件描述符和其他系统资源，而线程则共享进程的这些资源。</p></li><li><p>创建销毁开销：创建或销毁进程比线程更为耗时，因为进程创建时需要分配独立的资源空间，而线程的创建和销毁开销相对较小。</p></li><li><p>通信成本：由于线程共享进程的资源，线程之间的通信成本相对较低，而进程之间的通信成本较高，需要通过进程间通信机制（如管道、消息队列、共享内存等）进行数据传递。</p></li></ol><ul><li>联系：</li></ul><ol><li><p>并发执行：进程和线程都能实现程序的并发执行，提高系统的效率。</p></li><li><p>共享资源：进程和线程都可以访问和共享进程的资源，如内存、文件等。</p></li><li><p>隔离性：进程和线程都具有一定的隔离性，即一个进程或线程的错误不会直接影响其他进程或线程的执行。</p></li><li><p>同步与通信：进程和线程之间可以通过同步机制（如互斥锁、信号量）和通信机制（如管道、消息队列）进行数据交换和同步操作。</p></li></ol><p>  综上所述，进程和线程在调度单位、资源拥有、创建销毁开销、通信成本等方面存在差异。两者都有并发执行、共享资源、隔离性和同步通信等联系。选择使用进程还是线程取决于具体的应用场景和需求。</p><h3 id="_18、进程与线程共享哪些资源-不共享哪些资源" tabindex="-1"><a class="header-anchor" href="#_18、进程与线程共享哪些资源-不共享哪些资源" aria-hidden="true">#</a> 18、进程与线程共享哪些资源？不共享哪些资源？</h3><p>答：线程和进程在资源共享上存在一定的区别。</p><ul><li>共享资源：</li></ul><ol><li><p>内存空间：在同一个进程中的所有线程共享相同的地址空间，即它们可以访问进程的全局变量和堆内存。</p></li><li><p>文件描述符：所有线程都可以访问打开的文件，包括读取和写入文件。</p></li><li><p>共享库和全局变量：多个线程可以同时使用相同的共享库和全局变量。</p></li><li><p>信号处理器：进程中的信号处理器可以由任何线程处理。</p></li></ol><ul><li>不共享资源：</li></ul><ol><li><p>栈空间：每个线程拥有自己的栈空间，用于保存函数调用和局部变量。线程的栈空间是独立的，不共享。</p></li><li><p>寄存器和程序计数器：每个线程都有自己的寄存器集合和程序计数器，用于保存线程的执行状态。</p></li></ol><p>3、 线程特定数据（Thread-specific Data）：线程特定数据是绑定到特定线程的，每个线程都有自己的一份拷贝，不与其他线程共享。</p><ol start="4"><li>文件描述符的属性：线程之间共享文件描述符本身，但它们的属性（如文件偏移量、文件状态标志等）是独立的，不共享。</li></ol><p>  需要注意的是，虽然线程在某些资源上进行共享，但在对共享资源进行操作时，需要使用同步机制（如互斥锁、信号量）来确保线程之间的互斥和协调，以避免数据竞争和不一致性。</p>',16);function Oe(qe,Ie){const t=r("font"),i=r("ExternalLinkIcon");return d(),o("div",null,[h,c(" more "),v,e("ul",null,[b,e("li",null,[n("1）并发框架 （2） muduo_net库 "),e("ul",null,[e("li",null,[n("EventLoop 事件循环，就是任务在主线程不断进栈出栈的一个循环过程（同步任务）【"),l(t,{color:"red"},{default:s(()=>[n("负责事件监听")]),_:1}),n("】")]),e("li",null,[n("Channel 【"),l(t,{color:"red"},{default:s(()=>[n("负责注册和响应IO事件")]),_:1}),n("】")]),e("li",null,[n("Poller 【"),l(t,{color:"red"},{default:s(()=>[n("负责IO复用")]),_:1}),n("】")]),e("li",null,[n("关于muduo库（一个多线程服务器开发库，作者陈硕），参考"),e("a",m,[n("CSDN_muduo库的介绍"),l(i)]),n("和"),e("a",g,[n("CSDN_三种基本类的介绍"),l(i)])])])]),_,k,f,x,T,w,L,y]),S,e("p",null,[n("1）"),e("a",P,[n("社长博客"),l(i)]),n(" 2）"),e("a",C,[n("社长微信公众号_最新版的项目详解"),l(i)]),n(" 3）"),e("a",E,[n("社长微信公众号_旧版的项目详解"),l(i)]),n(" 4）"),e("a",O,[n("知乎_牛奶大佬的总结"),l(i)]),n(" 5）游双大佬的书：《Linux高性能服务器开发》 6）"),e("a",q,[n("代码随想录WebServer项目讲解"),l(i)]),n(" 7）"),e("a",I,[n("小林codeing的WebServer项目讲解"),l(i)])]),A,e("p",null,[n("参考资料："),e("a",U,[n("小白视角：一文读懂社长的TinyWebServer"),l(i)])]),W,e("ul",null,[N,e("li",null,[n("Proactor模式：将所有的I/O操作都交给主线程和内核来处理（进行读、写），工作线程仅负责处理逻辑，如主线程读完成后"),H,n("，选择一个工作线程来处理客户请求"),z,n("：处理逻辑："),j,n("。【主线程：监听事件+IO操作+分发任务；工作线程：具体的逻辑处理】"),l(t,{color:"red"},{default:s(()=>[n("该模式效率更高，但Linux下只能用模拟的Proactor")]),_:1}),n("。")])]),B,R,F,D,M,e("p",null,[n("  在完整版本的WebServer中"),e("a",G,[n("TingWebServer_full_version"),l(i)]),n("，1）[reactor模式在raw版本并没有]通过程序来模拟reactor模式，即主线程只负责监听事件，当时间发生后就从线程池中启动一个线程。该线程负责read_once()或write()，然后在调用process()函数来完成http服务。也就是说，主线程：事件监听和任务分发，工作线程：事件处理。2）完整版本也实现了proactor模式，该模式在raw版本也有。主线程：事件监听和具体的IO操作，如read_once()和write()；工作线程：只处理http逻辑：调用process()函数。")]),K,e("p",null,[n("  参考"),e("a",Q,[n("StackOverflow"),l(i)]),n("：线程池中的线程数量最直接的限制因素是中央处理器(CPU)的处理器(processors/cores)的数量N：如果你的CPU是4-cores的，对于CPU密集型的任务(如视频剪辑等消耗CPU计算资源的任务)来说，那线程池中的线程数量最好也设置为4（或者+1防止其他因素造成的线程阻塞）；对于IO密集型的任务，一般要多于CPU的核数，因为线程间竞争的不是CPU的计算资源而是IO，IO的处理一般较慢，多于cores数的线程将为CPU争取更多的任务，不至在线程处理IO的过程造成CPU空闲导致资源浪费，公式：最佳线程数 = CPU当前可使用的Cores数 * 当前CPU的利用率 * (1 + CPU等待时间 / CPU处理时间)（还有回答里面提到的Amdahl准则可以了解一下）")]),X,e("blockquote",null,[e("ul",null,[V,e("li",null,[e("p",null,[Y,n("，请求头部后面的空行是"),l(t,{color:"red"},{default:s(()=>[n("必须")]),_:1}),n("的，即使第四部分的请求数据为空，也必须有空行。")])]),Z])]),$,e("blockquote",null,[e("ul",null,[J,ee,e("li",null,[e("p",null,[n("空行，消息报头后面的空行是"),l(t,{color:"red"},{default:s(()=>[n("必须")]),_:1}),n("的。")])]),ne])]),le,e("p",null,[n("  但实际上，之前说到的游戏可以放到上⾯（是不是就有点像对战平台了），管理系统可以放到上⾯、存储引擎（卡哥的skipList："),e("a",ie,[n("https://github.com/youngyangyang04/Skiplist-CPP"),l(i)]),n(" ）等你能想到的都可以部署在 WebServer上，这样看来，WebServer 本身具备相当的⼯作量。")]),ae,e("p",null,[e("a",te,[n("linux高并发服务器开发-基础版[牛客]"),l(i)])]),e("p",null,[e("a",se,[n("linux高并发服务器开发-进阶版[牛客]"),l(i)])]),re,e("ul",null,[e("li",null,[n("sylar-yin/sylar: "),e("a",pe,[n("C++⾼性能分布式服务器框架"),l(i)]),n("（附带博主的视频链接："),e("a",de,[n("[C++⾼级教程]从零开始开发服务器框架(sylar)"),l(i)]),n("）")]),e("li",null,[n("qinguoyi/TinyWebServer: "),e("a",oe,[n("Linux下C++轻量级WebServer服务器学习"),l(i)])]),e("li",null,[n("linyacool/WebServer: "),e("a",ce,[n("A C++ High Performance Web Server"),l(i)])]),e("li",null,[n("markparticle/WebServer: "),e("a",ue,[n("C++ Linux WebServer服务器"),l(i)])])]),he,e("p",null,[e("a",ve,[n("TinyWebServer的项目问题"),l(i)])]),be,e("p",null,[n("参考资料："),e("a",me,[n("知乎"),l(i)])]),ge,e("p",null,[n("  参考链接："),e("a",_e,[n("小白视角：一文读懂社长的TinyWebServer"),l(i)])]),ke,e("p",null,[n("  参考"),e("a",fe,[n("微信公众号"),l(i)])]),xe,e("p",null,[n("参考链接："),e("a",Te,[n("不愧是微信，问的贼细_WebServer"),l(i)])]),we,e("p",null,[n("答：参考"),e("a",Le,[n("CSDN"),l(i)]),n(" 线程间的读写情况主要分为以下三类：")]),ye,e("p",null,[n("参考小林的微信公众号文章："),e("a",Se,[n("字节一面：服务端挂了，客户端的 TCP 连接还在吗？"),l(i)]),n(" 答：如果「服务端挂掉」指的是「服务端进程崩溃」，服务端的进程在发生崩溃的时候，内核会发送 FIN 报文，与客户端进行四次挥手。")]),Pe,e("p",null,[n("答：参考小林的微信公众号文章："),e("a",Ce,[n("一致性哈希是什么，使用场景，解决了什么问题？"),l(i)])]),Ee])}const Ue=p(u,[["render",Oe],["__file","1__WebServer学习笔记汇总.html.vue"]]);export{Ue as default};
