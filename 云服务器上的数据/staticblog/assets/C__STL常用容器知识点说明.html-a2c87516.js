import{$ as e,a0 as r,a1 as p,a6 as s,a2 as t,a5 as a}from"./framework-e783454b.js";const n={},o=t("div",{class:"hint-container tip"},[t("p",{class:"hint-container-title"},"提示"),t("p",null,"C++STL常用容器知识点说明")],-1),d=a('<h1 id="_0、总体概述" tabindex="-1"><a class="header-anchor" href="#_0、总体概述" aria-hidden="true">#</a> 0、总体概述</h1><p>STL就是标准模板库，从广义上分为容器、算法和迭代器。当然，具体细分的话，STL大体分为六大组件，分别是:容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器。</p><ol><li>容器：各种数据结构，如vector、list、deque、set、map等,用来存放数据。</li><li>算法：各种常用的算法，如sort、find、copy、for_each等</li><li>迭代器：扮演了容器与算法之间的胶合剂。</li><li>仿函数：行为类似函数，可作为算法的某种策略。</li><li>适配器：一种用来修饰容器或者仿函数或迭代器接口的东西。</li><li>空间配置器：负责空间的配置与管理。</li></ol><p>容器：就是将运用最广泛的一些数据结构实现出来，常用的数据结构：数组, 链表,树, 栈, 队列, 集合, 映射表等。这些容器分为序列式容器（值有顺序）和关联式容器（值之间有关联）。</p><p>算法：有限的步骤，解决逻辑或数学上的问题，这一门学科我们叫做算法(Algorithms)。分为质变算法和非质变算法。质变算法：是指运算过程中会更改区间内的元素的内容。例如拷贝，替换，删除等等。非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等。</p><h1 id="_0-1、迭代器" tabindex="-1"><a class="header-anchor" href="#_0-1、迭代器" aria-hidden="true">#</a> 0.1、迭代器</h1><p>迭代器：容器和算法的粘合剂。提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。迭代器使用非常类似于指针，初学阶段我们可以先理解迭代器为指针。</p><figure><img src="https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlHnVQZKTOp0Nxxcm/root/content" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>常用的容器中迭代器种类为双向迭代器，和随机访问迭代器。vector的begin和end是随机访问迭代器。</p><figure><img src="https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlHrrZeUQy92VIXNj/root/content" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h1 id="一、stl容器" tabindex="-1"><a class="header-anchor" href="#一、stl容器" aria-hidden="true">#</a> 一、STL容器</h1><p>这是STL常用容器知识点总结。（1）是构造函数；（2）是赋值；（3）是（string）查找、大小/容量与交换；（4）插入与删除；（5）数据存取；第六部分，其它补充内容。容器最常用的是vector和list</p><h2 id="_1、构造函数" tabindex="-1"><a class="header-anchor" href="#_1、构造函数" aria-hidden="true">#</a> 1、构造函数</h2><table><thead><tr><th></th><th>（1）构造函数</th></tr></thead><tbody><tr><td>string</td><td>1、无参构造string(); 2、拷贝构造string(const string&amp; str); 3、字符串构造string(const char* s)； 4、n个字符构造string(int n, char c);</td></tr><tr><td>vector</td><td>1、无参构造vector&lt;T&gt; v; 2、拷贝构造vector(const vector &amp;vec); 3、（迭代器）区间拷贝构造vector(v.begin(), v.end()); 4、n个元素构造vector(n, elem);</td></tr><tr><td>deque</td><td>1、无参构造deque&lt;T&gt; deq; 2、拷贝构造deque(const deque &amp;deq); 3、（迭代器）区间拷贝构造deque(beg, end); 4、n个元素构造deque(n, elem);</td></tr><tr><td>stack</td><td>1、无参构造stack&lt;T&gt; stk; 2、拷贝构造 stack(const stack &amp;stk);</td></tr><tr><td>queue</td><td>1、无参构造 queue&lt;T&gt; que; 2、拷贝构造 queue(const queue &amp;que);</td></tr><tr><td>List</td><td>1、无参构造list&lt;T&gt; lst; 2、拷贝构造 list(const list &amp;lst); 3、（迭代器）区间拷贝构造 list(beg,end); 4、n个元素构造list(n, elem);</td></tr><tr><td>set</td><td>1、无参构造 set&lt;T&gt; st; 2、拷贝构造 set(const set &amp;st);</td></tr><tr><td>map</td><td>1、无参构造 map&lt;T1,T2&gt; mp; 2、拷贝构造 map(const map &amp;mp);</td></tr></tbody></table><h2 id="_2、赋值" tabindex="-1"><a class="header-anchor" href="#_2、赋值" aria-hidden="true">#</a> 2、赋值</h2><table><thead><tr><th></th><th>（2）赋值</th></tr></thead><tbody><tr><td>string</td><td>- string&amp; operator=(const char* s); //char*类型字符串 赋值给当前的字符串 - string&amp; operator=(const string &amp;s); //把字符串s赋给当前的字符串 - string&amp; operator=(char c); //字符赋值给当前的字符串 - string&amp; assign(const char *s); //把字符串s赋给当前的字符串 - string&amp; assign(const char *s, int n); //把字符串s的前n个字符赋给当前的字符串 - string&amp; assign(const string &amp;s); //把字符串s赋给当前字符串 - string&amp; assign(int n, char c); //用n个字符c赋给当前字符串</td></tr><tr><td>vector</td><td>- vector&amp; operator=(const vector &amp;vec);//重载等号操作符 - assign(beg, end); //将[beg, end)区间中的数据拷贝赋值给本身。 - assign(n, elem); //将n个elem拷贝赋值给本身。</td></tr><tr><td>deque</td><td>- deque&amp; operator=(const deque &amp;deq); //重载等号操作符 - assign(beg, end); //将[beg, end)区间中的数据拷贝赋值给本身。 - assign(n, elem); //将n个elem拷贝赋值给本身。</td></tr><tr><td>stack</td><td>stack&amp; operator=(const stack &amp;stk); //重载等号操作符</td></tr><tr><td>queue</td><td>queue&amp; operator=(const queue &amp;que); //重载等号操作符</td></tr><tr><td>List</td><td>- assign(beg, end); //将[beg, end)区间中的数据拷贝赋值给本身。 - assign(n, elem); //将n个elem拷贝赋值给本身。 - list&amp; operator=(const list &amp;lst); //重载等号操作符</td></tr><tr><td>set</td><td>set&amp; operator=(const set &amp;st); //重载等号操作符</td></tr><tr><td>map</td><td>map&amp; operator=(const map &amp;mp); //重载等号操作符</td></tr></tbody></table><h2 id="_3、-string-查找、大小-容量与交换" tabindex="-1"><a class="header-anchor" href="#_3、-string-查找、大小-容量与交换" aria-hidden="true">#</a> 3、(string)查找、大小/容量与交换</h2><table><thead><tr><th></th><th><strong>（3）（string）查找、容量/大小与交换</strong></th></tr></thead><tbody><tr><td>string</td><td>--查找 - int find(const string&amp; str, int pos = 0) const; //查找str第一次出现位置,从pos开始查找 - int find(const char* s, int pos = 0) const; //查找s第一次出现位置,从pos开始查找 - int find(const char* s, int pos, int n) const;//从pos位置查找s的前n个字符第一次位置 - int find(const char c, int pos = 0) const; //查找字符c第一次出现位置 -int rfind(const string&amp; str, int pos = npos) const;//查找str最后一次位置,从pos开始查找 -int rfind(const char* s, int pos = npos) const;//查找s最后一次出现位置,从pos开始查找 - int rfind(const char* s, int pos, int n) const; //从pos查找s的前n个字符最后一次位置 - int rfind(const char c, int pos = 0) const; //查找字符c最后一次出现位置 --容量/大小 无 --交换 - string&amp; replace(int pos, int n, const string&amp; str); //替换从pos开始n个字符为字符串str - string&amp; replace(int pos, int n,const char* s); //替换从pos开始的n个字符为字符串s</td></tr><tr><td>vector</td><td>--查找 无 --容量/大小 - empty(); //判断容器是否为空 - capacity(); //容器的容量 - size(); //返回容器中元素的个数 - resize(int num); //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。//如果容器变短，则末尾超出容器长度的元素被删除。 -resize(int num, elem);//重新指定容器的长度为num，若容器变长，则以elem值填充新位置。//如果容器变短，则末尾超出容器长度的元素被删除 reserve(int len);//容器预留len个元素长度，预留位置不初始化，元素不可访问。自定义容器的容量 --交换 swap(vec); // 将vec与本身的元素互换</td></tr><tr><td>deque</td><td>--查找 无 --容量/大小 - deque.empty(); //判断容器是否为空 - deque.size(); //返回容器中元素的个数 - deque.resize(num); //重新指定容器的长度为num,若容器变长，则以默认值填充新位置。//如果容器变短，则末尾超出容器长度的元素被删除。 - deque.resize(num, elem); //重新指定容器的长度为num,若容器变长，则以elem值填充新位置。//如果容器变短，则末尾超出容器长度的元素被删除。 --交换 无</td></tr><tr><td>stack</td><td>--大小 - empty(); //判断堆栈是否为空 - size(); //返回栈的大小</td></tr><tr><td>queue</td><td>--大小 - empty(); //判断堆栈是否为空 - size(); //返回栈的大小</td></tr><tr><td>List</td><td>--大小 - size();//返回容器中元素的个数 - empty();//判断容器是否为空 - resize(num); //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。//如果容器变短，则末尾超出容器长度的元素被删除。 -resize(num, elem); //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。//如果容器变短，则末尾超出容器长度的元素被删除。 --交换 - swap(lst); //将lst与本身的元素互换。</td></tr><tr><td>set</td><td>--大小 - size(); //返回容器中元素的数目 - empty(); //判断容器是否为空 --交换 - swap(st); //交换两个集合容器</td></tr><tr><td>map</td><td>--大小 - size(); //返回容器中元素的数目 - empty(); //判断容器是否为空 --交换 - swap(st); //交换两个集合容器</td></tr></tbody></table><h2 id="_4、插入-删除" tabindex="-1"><a class="header-anchor" href="#_4、插入-删除" aria-hidden="true">#</a> 4、插入/删除</h2><table><thead><tr><th></th><th><strong>（4）插入/删除</strong></th></tr></thead><tbody><tr><td>string</td><td>- string&amp; insert(int pos, const char* s); //插入字符串 - string&amp; insert(int pos, const string&amp; str); //插入字符串 - string&amp; insert(int pos, int n, char c); //在指定位置插入n个字符c - string&amp; erase(int pos, int n = npos); //删除从Pos开始的n个字符</td></tr><tr><td>vector</td><td>- push_back(ele); //尾部插入元素ele - pop_back(); //删除最后一个元素 - insert(const_iterator pos, ele); //迭代器指向位置pos插入元素ele - insert(const_iterator pos, int count,ele);//迭代器指向位置pos插入count个元素ele - erase(const_iterator pos); //删除迭代器指向的元素 - erase(const_iterator start, const_iterator end);//删除迭代器从start到end之间的元素 - clear(); //删除容器中所有元素</td></tr><tr><td>deque</td><td>两端插入操作： - push_back(elem); //在容器尾部添加一个数据 - push_front(elem); //在容器头部插入一个数据 - pop_back(); //删除容器最后一个数据 - pop_front(); //删除容器第一个数据 指定位置操作： - insert(pos,elem); //在pos位置插入一个elem元素的拷贝，返回新数据的位置。 - insert(pos,n,elem); //在pos位置插入n个elem数据，无返回值。 - insert(pos,beg,end); //在pos位置插入[beg,end)区间的数据，无返回值。 - clear(); //清空容器的所有数据 - erase(beg,end); //删除[beg,end)区间的数据，返回下一个数据的位置。 - erase(pos); //删除pos位置的数据，返回下一个数据的位置。</td></tr><tr><td>stack</td><td>无</td></tr><tr><td>queue</td><td>无</td></tr><tr><td>List</td><td>- push_back(elem);//在容器尾部加入一个元素 - pop_back();//删除容器中最后一个元素 - push_front(elem);//在容器开头插入一个元素 - pop_front();//从容器开头移除第一个元素 - insert(pos,elem);//在pos位置插elem元素的拷贝，返回新数据的位置。 - insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值。 - insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值。 - clear();//移除容器的所有数据 - erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置。 - erase(pos);//删除pos位置的数据，返回下一个数据的位置。 - remove(elem);//删除容器中所有与elem值匹配的元素。</td></tr><tr><td>set</td><td>- insert(elem); //在容器中插入元素。 - clear(); //清除所有元素 - erase(pos); //删除pos迭代器所指的元素，返回下一个元素的迭代器。 - erase(beg, end); //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。 - erase(elem); //删除容器中值为elem的元素。</td></tr><tr><td>map</td><td>- insert(elem); //在容器中插入元素。 - clear(); //清除所有元素 - erase(pos); //删除pos迭代器所指的元素，返回下一个元素的迭代器。 - erase(beg, end); //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。 - erase(key); //删除容器中值为key的元素。</td></tr></tbody></table><h2 id="_5、数据存取" tabindex="-1"><a class="header-anchor" href="#_5、数据存取" aria-hidden="true">#</a> 5、数据存取</h2><table><thead><tr><th></th><th><strong>（5）数据存取</strong></th></tr></thead><tbody><tr><td>string</td><td>- char&amp; operator[](int n); //通过[]方式取字符 - char&amp; at(int n); //通过at方法获取字符</td></tr><tr><td>vector</td><td>- at(int idx); //返回索引idx所指的数据 - operator[]; //返回索引idx所指的数据 - front(); //返回容器中第一个数据元素 - back(); //返回容器中最后一个数据元素</td></tr><tr><td>deque</td><td>- at(int idx); //返回索引idx所指的数据 - operator[]; //返回索引idx所指的数据 - front(); //返回容器中第一个数据元素 - back(); //返回容器中最后一个数据元素</td></tr><tr><td>stack</td><td>- push(elem); //向栈顶添加元素 - pop(); //从栈顶移除第一个元素 - top(); //返回栈顶元素</td></tr><tr><td>queue</td><td>- push(elem); //往队尾添加元素 - pop(); //从队头移除第一个元素 - back(); //返回最后一个元素 - front(); //返回第一个元素</td></tr><tr><td>List</td><td>- front(); //返回第一个元素。 - back(); //返回最后一个元素。</td></tr><tr><td>set</td><td>无</td></tr><tr><td>map</td><td>无</td></tr></tbody></table><h2 id="_6、第六部分-补充内容" tabindex="-1"><a class="header-anchor" href="#_6、第六部分-补充内容" aria-hidden="true">#</a> 6、第六部分：补充内容</h2><p>注意：栈stack只有栈顶可以访问，所以不支持遍历行为；队列只有队头队尾才能被外界访问，因此队列也不支持遍历行为；</p><p>vector很像数组，常称为单端数组，他和数组的最大区别是数组等长，而vector可以动态扩展长度。deque是双端数组，可以头/尾插入或删除，deque可以动态扩展长度。在头插入上，vector效率低，deque头插入效率高；另一方面，vector访问元素的速度要比deque快，这与vector/deque内部的实现有关。</p><p>String、vector和deque的迭代器支持随机访问；stack/queue不提供迭代器，不支持随机访问；list容器的迭代器是双向迭代器，不支持随机访问</p><p>注：随机访问迭代器 ：读写操作，可以以跳跃的方式访问任意数据，功能最强的迭代器</p><p><strong>[string容器]</strong></p><p>►string字符串的拼接</p><p>- string&amp; operator+=(const char* str); //重载+=操作符</p><p>- string&amp; operator+=(const char c); //重载+=操作符</p><p>- string&amp; operator+=(const string&amp; str); //重载+=操作符</p><p>- string&amp; append(const char *s); //把字符串s连接到当前字符串结尾</p><p>- string&amp; append(const char *s, int n); //把字符串s的前n个字符连接到当前字符串结尾</p><p>- string&amp; append(const string &amp;s); //同operator+=(const string&amp; str)</p><p>- string&amp; append(const string &amp;s, int pos, int n);//字符串s中从pos开始的n个字符连接到字符串结尾</p><p>►string字符串的比较，按照字符的ASCII码值进行比较，相等返回0，大于返回1，小于返回-1</p><p>- int compare(const string &amp;s) const; //与字符串s比较</p><p>- int compare(const char *s) const; //与字符串s比较</p><p>►string字符串的子串</p><p>string substr(int pos = 0, int n = npos) const; //返回由pos开始的n个字符组成的字符串</p><p><strong>[vector容器]</strong></p><p>无</p><p><strong>[deque容器]</strong></p><p><strong>►deque排序</strong></p><p>sort(iterator beg, iterator end) //对beg和end区间内元素进行排序</p><p>[stack容器]</p><p>无</p><p><strong>[queue容器]</strong></p><p>无</p><p><strong>[list容器]</strong></p><p>►list的翻转和排序</p><p>- reverse(); //反转链表</p><p>- sort(); //链表排序</p><p><strong>[set容器]</strong></p><p>►set的查找和统计</p><p>- find(key); //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</p><p>- count(key); //统计key的元素个数</p><p>►set的排序（默认为从小到大，可以使用仿函数来更改排序规则）</p><p>class MyCompare</p><p>{</p><p>public:</p><p>bool operator()(int v1, int v2) {</p><p>return v1 &gt; v2;</p><p>}</p><p>};</p><p>set&lt;int,MyCompare&gt; s2; //自定义排序规则</p><p><strong>[map容器]</strong></p><p>►map的查找和统计</p><p>- find(key); //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</p><p>- count(key); //统计key的元素个数</p><p>►map的排序（使用自定义规则进行排序）</p><p>class MyCompare {</p><p>public:</p><p>bool operator()(int v1, int v2) {</p><p>return v1 &gt; v2;</p><p>}</p><p>};</p><p>map&lt;int, int, MyCompare&gt; m; //自定义排序规则</p><p>自定义函数用于排序的例子：</p><p><strong>b</strong>ool myCompare(int val1 , int val2)</p><p>{</p><p>return val1 &gt; val2;</p><p>}</p><h1 id="二、stl常用函数对象" tabindex="-1"><a class="header-anchor" href="#二、stl常用函数对象" aria-hidden="true">#</a> 二、STL常用函数对象</h1><p><strong>1、函数对象</strong></p><p>定义：重载函数调用操作符的类，其对象常称为函数对象。函数对象使用重载的（）号时，行为类似于函数调用，因此也称为仿函数。</p><p>本质：函数对象（仿函数）是一个类，不是一个函数</p><ol><li>函数对象的调用</li></ol><p>特点：</p><p>函数对象在使用时，可以像普通函数那样调用，可以有参数，可以有返回值</p><p>函数对象超出普通函数的概念，函数对象可以有自己的状态</p><p>函数对象可以作为参数传递</p><p>总结：仿函数写法非常灵活，可以作为参数进行传递。</p><p><strong>2、谓语</strong></p><p>返回值是bool类型的仿函数称为谓语，如果operator()接受一个参数，就是一元谓语；接受2个参数，就是二元谓语。</p><p><strong>3、内建函数对象</strong></p><p>STL内建了一些函数对象，分为算术仿函数，关系仿函数，逻辑仿函数。</p><p>这些仿函数所产生的对象，用法和普通函数一致，不过需要引入头文件&lt;functional&gt;</p><p>3.1算术仿函数</p><p>- template&lt;class T&gt; T plus&lt;T&gt; //加法仿函数</p><p>- template&lt;class T&gt; T minus&lt;T&gt; //减法仿函数</p><p>- template&lt;class T&gt; T multiplies&lt;T&gt; //乘法仿函数</p><p>- template&lt;class T&gt; T divides&lt;T&gt; //除法仿函数</p><p>- template&lt;class T&gt; T modulus&lt;T&gt; //取余仿函数%</p><p>- template&lt;class T&gt; T negate&lt;T&gt; //取反仿函数</p><p>3.2 关系仿函数 （谓语）</p><p>- template&lt;class T&gt; bool equal_to&lt;T&gt; //等于</p><p>- template&lt;class T&gt; bool not_equal_to&lt;T&gt; //不等于</p><p>- template&lt;class T&gt; bool greater&lt;T&gt; //大于</p><p>- template&lt;class T&gt; bool greater_equal&lt;T&gt; //大于等于</p><p>- template&lt;class T&gt; bool less&lt;T&gt; //小于</p><p>- template&lt;class T&gt; bool less_equal&lt;T&gt; //小于等于</p><p>3.3 逻辑仿函数（应用较少） （谓语）</p><p>- template&lt;class T&gt; bool logical_and&lt;T&gt; //逻辑与</p><p>- template&lt;class T&gt; bool logical_or&lt;T&gt; //逻辑或</p><p>- template&lt;class T&gt; bool logical_not&lt;T&gt; //逻辑非</p><h1 id="三、stl常用算法" tabindex="-1"><a class="header-anchor" href="#三、stl常用算法" aria-hidden="true">#</a> 三、STL常用算法</h1><p>使用STL算法，需要包含头&lt;algorithm&gt;</p><p>1、遍历算法</p><p><strong>（1）for_each遍历容器</strong></p><p>►for_each(iterator beg, iterator end, _func);</p><p>for_each是最常用的遍历算法，需要熟练掌握。功能函数有打印函数（自定义函数）、打印函数（类内函数，即仿函数）、算术操作函数或逻辑函数</p><p><strong>（2）transform 搬运容器到另一个容器中</strong></p><p>►transform(iterator beg1, iterator end1, iterator beg2, _func);</p><p>源容器的起点，源容器的终点，目标容器的起点，功能函数同上。注意：搬运的目标函数必须提前开辟空间，否则不能正常搬运。</p><p>2、查找算法</p><p>►find(iterator beg, iterator end, value); //按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置，返回值类型是 ‘容器’&lt;数据类型&gt;::iterator it</p><p>►find_if(iterator beg, iterator end, _Pred); //按条件查找元素(按值查找元素)，找到返回指定位置迭代器，找不到返回结束迭代器位置._Pred是函数或者谓词（谓词是返回bool类型的仿函数）</p><p>► adjacent_find(iterator beg, iterator end); //查找相邻重复元素,返回相邻元素的第一个位置的迭代器</p><p>► bool binary_search(iterator beg, iterator end, value); //二分查找法。查到返回true，否则返回false。注意在无序序列中不能用</p><p>► count(iterator beg, iterator end, value); //统计指定元素出现的个数</p><p>注意：统计自定义数据类型时，需要重载==</p><p>► count_if(iterator beg, iterator end, _Pred); //按条件统计元素个数，_Pred是指返回值为bool类型的仿函数</p><p>3、排序算法</p><p>► sort(iterator beg, iterator end, _Pred); //对容器内元素进行排序</p><p>sort属于开发中最常用的算法之一，需熟练掌握</p><p>► random_shuffle(iterator beg, iterator end); //随机洗牌，指定范围内的元素随机调整次序</p><p>random_shuffle洗牌算法比较实用，使用时记得加随机数种子</p><p>► merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest); // 容器元素合并，并存储到另一容器中。Beg1/end1容器1的起止迭代器，beg2/end2容器2的起止迭代器，dest是目标容器的开始迭代器</p><p>注意：两个容器必须是有序的，目标容器必须提前开辟空间</p><p>► reverse(iterator beg, iterator end); // 反转指定范围的元素</p><p>4、常用拷贝和替换算法</p><p>► copy(iterator beg, iterator end, iterator dest); //容器内指定范围的元素拷贝到另一容器中</p><p>► replace(iterator beg, iterator end, oldvalue, newvalue); //将容器内指定范围的旧元素修改为新元素</p><p>replace会替换区间内满足条件的元素</p><p>► replace_if(iterator beg, iterator end, _pred, newvalue); // 容器内指定范围满足条件的元素替换为新元素</p><p>按条件替换元素，满足条件的替换成指定元素。总结：replace_if按条件查找，可以利用仿函数灵活筛选满足的条件</p><p>► swap(container c1, container c2); // 互换两个容器的元素</p><p>总结：swap交换容器时，注意交换的容器要同种类型</p><p>5、常用算术生成算法</p><p>注意：算术生成算法属于小型算法，使用时包含的头文件为 #include &lt;numeric&gt;</p><p>► accumulate(iterator beg, iterator end, value); // 计算容器元素累计总和，返回值为int</p><p>► fill(iterator beg, iterator end, value); // 向容器中添加元素</p><p>6、常用集合算法</p><p>三个函数的返回值均是dest容器最后一个元素的迭代器iterator</p><p>► set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest); // 求两个容器的交集</p><p>注意:两个集合必须是有序序列。</p><p>总结：-求交集的两个集合必须的有序序列</p><p>- 目标容器开辟空间需要从两个容器中取小值</p><p>- set_intersection返回值既是交集中最后一个元素的位置</p><p>► set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest); //求两个容器的并集</p><p>注意:两个集合必须是有序序列</p><p>总结：- 求并集的两个集合必须的有序序列</p><p>- 目标容器开辟空间需要两个容器相加</p><p>- set_union返回值既是并集中最后一个元素的位置</p><p>► set_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest); // 求两个容器的差集</p><p>注意:两个集合必须是有序序列</p><p>总结：- 求差集的两个集合必须的有序序列</p><p>- 目标容器开辟空间需要从两个容器取较大值</p><p>- set_difference返回值既是差集中最后一个元素的位置</p>',171);function i(l,c){return r(),p("div",null,[o,s(" more "),d])}const m=e(n,[["render",i],["__file","C__STL常用容器知识点说明.html.vue"]]);export{m as default};
