import{$ as r,a0 as l,a1 as i,a6 as d,a2 as n,a3 as t,a4 as e,a9 as a,a5 as o,I as s}from"./framework-e783454b.js";const _={},m=n("div",{class:"hint-container tip"},[n("p",{class:"hint-container-title"},"提示"),n("p",null,"C++指针与常量知识点说明")],-1),u={href:"https://www.cnblogs.com/zpcdbky/p/4902688.html",target:"_blank",rel:"noopener noreferrer"},h=o(`<p>网上常见的说法似乎有误：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">*</span> p  <span class="token comment">//常量指针</span>
<span class="token keyword">int</span><span class="token operator">*</span> <span class="token keyword">const</span> p  <span class="token comment">//指针常量</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>在外文书籍中很少有这种说法。一种简洁易懂的说法是：</p><blockquote><p>指向常量的指针----<code>const int* p</code> 【常量指针】</p><p>本身是常量的指针----<code>int* const p</code> 【本身是常量的指针】，也是cpp中的引用</p></blockquote><p>判断方法： <strong>先找到*，然后看*的两边，右边是对指针p本身的限定，左边是对p所指向的东西的限定。</strong></p><p>说明：(顺带一提：*号优先级排第二，从右往左结合)</p><p>1.const int* p：</p>`,7),k=o('<p>注意，const int *p=&amp;a;只是说不能通过p来修改a，如果a本身不是const的，通过其它方式修改a自然是可以的（例如直接++a）。</p><p>另外一点，由于p本身只是一个普通的指针，所以允许在声明时不初始化。但需要注意的是，我们只是说可以，但并不提倡这样做。在任何时候都不应该让指针无所指，如果在声明一个指针时还不知道让它指向谁，就先将其初始化为nullptr或NULL（nullptr是cpp11新特性，用它比用NULL更安全些，这里不详细介绍）。</p><p>2.int* const p：</p><p>就是所谓的“本身是常量的指针”。关于“p本身不能修改但可以通过p修改其所指”这一点，我们在讲判断方法时已经说过，这里主要再说一下p的初始化。</p><p>由于p本身是const的，所以在编译的时候必须知道p的值（即p所指向的东西的地址），所以在声明p的同时必须初始化p。但要注意，对于 int* const p=&amp;a，我们只要求a的地址是确定的，但a的值可以不确定。</p><p>3.const int* cosnt p：</p><p>就是所谓的“所指和本身都是常量的指针”。它的语法特性就是前两者的结合，这里不再赘述。</p><p>4.补充说明：</p><p>引用生命是必须初始化，且必须左值初始化。这一点与“本身是敞亮的指针”(int* const p)的特性一样。事实上，我们完全可以借用“本身是常量的指针”来理解甚至定义引用：</p><h2 id="引用是一个指向不可变的、被编译器自动解引用的指针-即-引用是一个被编译器自动解引用的-本身是常量的指针-。" tabindex="-1"><a class="header-anchor" href="#引用是一个指向不可变的、被编译器自动解引用的指针-即-引用是一个被编译器自动解引用的-本身是常量的指针-。" aria-hidden="true">#</a> <strong>引用是一个指向不可变的、被编译器自动解引用的指针，即，引用是一个被编译器自动解引用的“本身是常量的指针”。</strong></h2>',10);function f(v,b){const c=s("ExternalLinkIcon"),p=s("font");return l(),i("div",null,[m,d(" more "),n("p",null,[n("a",u,[t("参考资料"),e(c)])]),h,n("p",null,[t("就是所谓的“指向常量的指针”。这里注意，"),e(p,{color:"blue"},{default:a(()=>[t("所谓“指向常量”只是这个指针的“一厢情愿”，只是一种效果上的等价。")]),_:1}),t("事实上，const int *p=&a;a既可以是常量(const int a=10;)又可以是变量(int a=10;)，但p一厢情愿地认为它所指的就是一个常量，所以它不允许通过自己来修改所指，这就造成一种效果上的等价——从p的角度看，它所指的“的确”是常量。所以，"),e(p,{color:"red"},{default:a(()=>[t("对“指向常量的指针”的最佳理解应为：我们不能通过该指针修改它所指向的东西（常量或者变量）。")]),_:1})]),k])}const x=r(_,[["render",f],["__file","c__指针与常量知识点专项说明.html.vue"]]);export{x as default};
