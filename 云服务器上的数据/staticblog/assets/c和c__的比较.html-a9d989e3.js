import{$ as i,a0 as l,a1 as u,a6 as r,a2 as s,a3 as n,a4 as a,a9 as e,a5 as o,I as c}from"./framework-e783454b.js";const k={},d=s("div",{class:"hint-container tip"},[s("p",{class:"hint-container-title"},"提示"),s("p",null,"C/C++的比较")],-1),v=s("h2",{id:"_1、第一部分-c-高級編程",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#_1、第一部分-c-高級編程","aria-hidden":"true"},"#"),n(" 1、第一部分 C++高級編程")],-1),m={href:"https://zhuanlan.zhihu.com/p/414375745",target:"_blank",rel:"noopener noreferrer"},b=s("code",null,"operator =",-1),w=o(`<div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>A <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>B <span class="token operator">&amp;</span>b<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	A a<span class="token punctuation">;</span>
    a<span class="token punctuation">.</span>Data<span class="token operator">=</span>b<span class="token punctuation">.</span>Data<span class="token punctuation">;</span>
    <span class="token keyword">return</span> a<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//或</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Distance</span>
<span class="token punctuation">{</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> feet<span class="token punctuation">;</span>
    <span class="token keyword">int</span> inches<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Distance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        feet<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
        inches<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">Distance</span><span class="token punctuation">(</span><span class="token keyword">int</span> f<span class="token punctuation">,</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">{</span>
        feet<span class="token operator">=</span>f<span class="token punctuation">;</span>
        inches<span class="token operator">=</span>i<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">void</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Distance <span class="token operator">&amp;</span>D<span class="token punctuation">)</span> <span class="token comment">//赋值运算符重载</span>
    <span class="token punctuation">{</span>
		feet<span class="token operator">=</span>D<span class="token punctuation">.</span>feet<span class="token punctuation">;</span>
        inches<span class="token operator">=</span>D<span class="token punctuation">.</span>inches<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">void</span> <span class="token function">displayDistance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
		cout<span class="token operator">&lt;&lt;</span><span class="token string">&quot;F: &quot;</span><span class="token operator">&lt;&lt;</span>feet<span class="token operator">&lt;&lt;</span><span class="token string">&quot;I: &quot;</span><span class="token operator">&lt;&lt;</span>inches<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	Distance <span class="token function">D1</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">D2</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	cout<span class="token operator">&lt;&lt;</span><span class="token string">&quot;First Distance : &quot;</span><span class="token punctuation">;</span>
	D1<span class="token punctuation">.</span><span class="token function">displayDistance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	cout<span class="token operator">&lt;&lt;</span><span class="token string">&quot;Second Distance : &quot;</span><span class="token punctuation">;</span>
	D2<span class="token punctuation">.</span><span class="token function">displayDistance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token comment">//使用赋值运算符</span>
	D1<span class="token operator">=</span>D2<span class="token punctuation">;</span>
	cout<span class="token operator">&lt;&lt;</span><span class="token string">&quot;then,the new First Distance :&quot;</span><span class="token punctuation">;</span>
	D1<span class="token punctuation">.</span><span class="token function">displayDistance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>5.函数入口处用assert检查 6.内存分配方式有三种, 从静态存储区域分配, 从栈上分配, 从堆上分配, 静态存储区包括全局变量, static变量等. 7.C++/C语言，没有办法知道指针所指的内存容量. 8.指针消亡了, 不表示所指的内存会被自动释放。内存被释放了, 不表示指针会消亡或者成了NULL指针. 9.指针被free或delete之后, 别忘记设置为NULL.</p>`,2),y=s("h2",{id:"_2、第二部分-cpp和c的区别",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#_2、第二部分-cpp和c的区别","aria-hidden":"true"},"#"),n(" 2、第二部分 cpp和C的区别")],-1),h={href:"https://zhuanlan.zhihu.com/p/414375745",target:"_blank",rel:"noopener noreferrer"},f=o(`<ul><li>C++三要素：封装、继承、多态。封装是class，继承是class的继承，多态是函数重载和运算符重载</li><li>面向对象： 对象：存在即合理，抽象性：物以类聚，封装：事物的封闭性，继承：事物的相似性，多态：事物的多样性。</li><li>面向对象的方法： <img src="https://s3.bmp.ovh/imgs/2022/07/25/b6c212804ba23100.jpg" alt="图1" loading="lazy"></li><li>cpp是什么？ cpp是c语言的超集；是面向对象编程；可移植性，不牺牲性能和底层功能。可以用cpp compiler将cpp代码翻译成c代码</li><li>cpp适合？ 算法、应用开发、C/cpp服务器</li><li>cpp设计原则 =1、cpp设计成使用静态型别机制、与C同样高效，可移植的，多用途程序设计语言。 =2、cpp设计成直接的和广泛的，支持多种程序设计风格（程序化程序设计、数据抽象化、面向对象程序设计、泛型程序设计）。 =3、cpp设计成给程序设计者，更多的选择，即使可能导致程序设计者选择错误。 =4、cpp设计成尽可能与C兼容，提供一个从C到cpp的平滑过渡。 =5、cpp避免平台限定，或没有普遍用途的特性。 =6、cpp不使用会带来额外开销的特性。 =7、cpp设计成无需复杂的程序设计环境。</li></ul><p>2、流的概念 cpp的I/O是以字节流的形式实现的，流(stream)实际上就是一个字节序列。 输入流: 在输入操作中，字节从输入设备(如键盘、磁盘、网络连接等)流向内存；输出流: 在输出操作中，字节从内存流向输出设备(如显示器、打印机、磁盘、网络连接等);这里“流”，试图说明字符，随着时间顺序生成或消耗的。输人/输出系统的任务，实际上就是以一种稳定、可靠的方式，在设备与内存之间传输数据。cpp并没有直接定义，进行输入输出的任何语句，这些功能是由标准IO库完成。</p><p>3、命名空间 实际上就是，一个由程序设计者命名的内存区域，程序设计者，可以根据需要指定一些有名字的空间域，把一些全局实体，分别放在各个命名空间中，从而与其它全局实体分隔开来。</p><p>命名空间是ANSIcpp引入的，可以由用户命名的作用域，用来处理程序中常见的同名冲突。 4、cpp程序的执行过程 预处理、汇编、编译、连接 5、C/cpp的字符串比较</p><p>① C语言字符串练习 char st[100]; ① cpp语言字符串练习 string str;</p><p>② 检测字符串长度 int len = strlen(st); ② 检测字符串长度 int len = str.length();</p><p>③ 字符串比较 strcmp(st1, st2); ③ 字符串比较 str1.compare(str2);</p><p>④ 在已有字符串后，追加新串 strcat(st1, st2); strncat(st1,st2,n); ④ 在已有字符串后，追加新串 str1 += str2; str1.append(str2);</p><p>⑤ 字符串拷贝 strcpy(st1,st2); strncpy(st1,st2, n); ⑤ 字符串拷贝 str2 = str1; str2 = str1.substr();</p><p>⑥ 字符串查找 where = strchr(st, ch) ⑥ 字符串查找 where = str1.find(str2);</p><p>6、c/cpp的数据类型和变量 数据类型： <img src="https://s3.bmp.ovh/imgs/2022/07/25/9a78f1d9dd477a24.jpg" alt="图3" loading="lazy"> 程序运行过程中，值能否发生改变，分为<strong>常量和变量</strong> 从变量作用域的大小考虑：全局变量，局部变量 全局变量：定义在所有的函数体之外，在程序开始运行时，分配存储空间，在程序结束时，释放存储空间 函数中定义的变量，称为局部变量（Local Variable） 从变量的生命周期考虑: 静态生存周期和动态生存周期 动态存储变量：变量仅在需要的时候，分配和占用内存 静态存储变量：变量在程序运行过程中，占用固定的内存 从变量的在内存中位置考虑：普通变量与指针变量</p><p>C语言中没有引用，cpp中才有引用，引用的主要用途，就是在函数传参和返回值上。如果既要利用引用提高使用效率，又要保护传递给函数的数据，不在函数中被改变，就应当使用常引用。</p><p>如果输入参数，以值传递的方式传递对象，宜改用“&amp;”引用方式来传递，这样可以省去临时对象的构造和析构过程，提高效率。特别是函数形参为类对象时，最好使用引用传递，而非值传递。</p><p>如果函数的返回值是一个对象，有些场合，用“引用传递”替换“值传递”，可以提高效率，有些场合不可以。</p><p>常引用</p><p>声明一个引用，不是新定义一个变量，只是该引用名是目标变量的一个别名，本身不是一种数据类型，引用不占存储单元。对引用取地址，就是对目标变量取地址。</p><p>还需注意，所谓常引用，这个“常”只对引用有效，对原数据是无效的。例如<code>int a=10;const int &amp;b=a;a=20；//该语句有效，b=20;//该语句无效！</code></p><p>警告：主函数不允许操作栈指针！（如何区分指针和引用？）</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">&amp;</span><span class="token function">getlnt</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token comment">//int&amp;返回引用，int* getlnt(*)是返回指针</span>
<span class="token punctuation">{</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">return</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token keyword">int</span> <span class="token operator">&amp;</span>n <span class="token operator">=</span> <span class="token function">getlnt</span><span class="token punctuation">(</span><span class="token number">123456789</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//出错！栈指针在函数退出时会立即释放，操作野指针是非法的！</span>
cout <span class="token operator">&lt;&lt;</span> n <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">*</span>pp <span class="token operator">=</span> <span class="token operator">&amp;</span>n<span class="token punctuation">;</span>
<span class="token keyword">delete</span> pp<span class="token punctuation">;</span> <span class="token comment">//删除失败</span>
<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>7、c/cpp函数说明 函数实现的三结构：函数申明、函数（体）实现、函数调用 函数体的构成：返回值类型、函数名、形参表、函数体 函数与指针：指针函数和函数指针 指针函数：本身是函数，返回值是指针。形如：<code>int* func_sum(int n)</code>，再次提醒：操作栈指针是非法的，对于返回值是指针的函数，这个指针①应当是指向静态变量static，或者该指针②全局变量指针。反正这个指针不能指向栈空间。 函数指针：本质是一个指针，他指向了函数。形如<code>ret (*p)(参数列表)</code>，其中p称为函数指针。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">return</span> a<span class="token operator">&gt;</span>b<span class="token operator">?</span>a<span class="token operator">:</span>b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">min</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">return</span> a<span class="token operator">&lt;</span>b<span class="token operator">?</span>a<span class="token operator">:</span>b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//或者int (*p)(int a,int b)</span>
    p<span class="token operator">=</span>max<span class="token punctuation">;</span> <span class="token comment">//给函数指针赋值</span>
    <span class="token keyword">int</span> ret1<span class="token operator">=</span><span class="token function">p</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    p<span class="token operator">=</span>min<span class="token punctuation">;</span>
    <span class="token keyword">int</span> ret2<span class="token operator">=</span><span class="token function">p</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>为什么要使用函数指针</strong></p><p>那么，有不少人就觉得，本来很简单的函数调用，搞那么复杂干什么？其实在这样比较简单的代码实现中不容易看出来，当项目比较大，代码变得复杂了以后，函数指针就体现出了其优越性。</p><p>举个例子，如果我们要实现数组的排序，我们知道，常用的数组排序方法有很多种，比如快排，插入排序，冒泡排序，选择排序等，如果不管内部实现，你会发现，除了函数名不一样之外，返回值，包括函数入参都是相同的，这时候如果要调用不同的排序方法，就可以使用指针函数来实现，我们只需要修改函数指针初始化的地方，而不需要去修改每个调用的地方（特别是当调用特别频繁的时候）。</p><p><strong>函数指针的典型应用：回调函数</strong> 函数指针的一个典型应用就是<strong>回调函数</strong>。回调函数就是一个通过函数指针来调用其他函数的函数。其将函数指针作为一个参数，传递给另一个函数。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h&gt;</span></span>

<span class="token comment">//函数功能：实现累加求和</span>
<span class="token keyword">int</span> <span class="token function">func_sum</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;n must be &gt; 0\\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
                sum <span class="token operator">+=</span> i<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//这个函数是回调函数，其中第二个参数为一个函数指针，通过该函数指针来调用求和函数，并把结果返回给主调函数</span>
<span class="token keyword">int</span> <span class="token function">callback</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">return</span> <span class="token function">p</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;please input number:&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">&quot;%d&quot;</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;the sum from 0 to %d is %d\\n&quot;</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> <span class="token function">callback</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> func_sum<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//此处直接调用回调函数，而不是直接调用func_sum函数</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这个简单的demo就是一个比较典型的回调函数的例子。在这个程序中，回调函数callback无需关心func_sum是怎么实现的，只需要去调用即可。</p><p>这样的好处就是，如果以后对求和函数有优化，比如新写了个func_sum2函数的实现，我们只需要在调用回调函数的地方将函数指针指向func_sum2即可，而无需去修改callback函数内部。</p><p>回调函数广泛用于开发场景中，比如信号函数、线程函数等，都使用到了回调函数的知识。</p><p>内存五区（按地址从低到高排序）：代码区、文字常量区（字符串常量）、全局区（静态区）、堆区、栈区。（来源百度） 内存四区：代码区（存放代码）、全局区（存放全局变量、静态变量和常量）、栈区、堆区。（黑马）</p><p>c/cpp增强了函数类型： 基础函数：内联函数（cpp新增，c语言在c99后也引入了）、函数重载、模板函数（泛型编程） 成员函数：构造/析构函数、常成员函数、静态成员函数、虚函数</p><p>内联函数inline：主要解决程序的运行效率问题。针对那种函数体代码量较小，但是又会频繁调用的函数，在编译阶段，编译器会将函数名直接替换成函数体，以节省函数调用出栈入栈的开销。</p><p>以代码量增加为代价，提高程序运行效率。</p><p>内联函数的定义，必须出现在该函数第一次被调用前;内联函数不能有复杂的控制语句，如switch，goto和while。递归函数不能是内联函数，（递归函数）自己调用自己的函数如果用于内联的话，反而会影响效率。 递归：自己调用自己；迭代：A调用B来获取新值。递归中一定含有迭代，迭代中不一定有递归。数据类型：树的打印函数使用了递归的方法。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">//迭代</span>
<span class="token keyword">void</span> <span class="token function">print_shu</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token function">print_shu</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">//迭代</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
	
<span class="token punctuation">}</span>
<span class="token comment">//递归</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://s3.bmp.ovh/imgs/2022/07/25/054dd7c396abe92b.png" alt="图4" loading="lazy"> 函数重载：形参个数不同、形参顺序不同或形参类型不同。（返回值类型不能作为重载依据） 函数形参默认值（缺省值）：如果同时存在函数声明和函数定义，默认值应在声明中给定，而不允许在定义中给定。默认值按从右到左的顺序。 形参的默认值，可以是全局常量、全局变量、表达式、函数调用，但不能为局部变量。例如，</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">funcl</span><span class="token punctuation">(</span>）
<span class="token punctuation">{</span>
<span class="token keyword">int</span> k；
<span class="token keyword">void</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token operator">=</span>k<span class="token punctuation">)</span>；<span class="token comment">//k为局部变量</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_3、第三部分-c-新特性" tabindex="-1"><a class="header-anchor" href="#_3、第三部分-c-新特性" aria-hidden="true">#</a> 3、第三部分 C++新特性</h2>`,38),g={href:"https://www.zhihu.com/people/wujitao/posts?page=4",target:"_blank",rel:"noopener noreferrer"};function _(D,x){const p=c("ExternalLinkIcon"),t=c("font");return l(),u("div",null,[d,r(" more "),v,s("p",null,[n("以下部分内容来源于"),s("a",m,[n("知乎：C++高级编程学习笔记"),a(p)]),n(" 1.头文件添加注释(文件名, 作者, 函数简介, 日期). （建议而非必要） 2.当头文件数目较多时, 应将头文件放在include目录下, 源文件放在source目录下. 3.const常量有数据类型, 宏常量#define没有数据类型. 4.对于重载赋值运算符"),b,n(', 应该用"引用传递"方式。形如：')]),w,s("p",null,[n("关于8和9的思考：先用指针开辟一个空间，然后在令指针为NULL。这时，指针消亡了，但是内存空间还在，只是不能使用了（内存泄漏）。对开启了空间的指针free或者delete，内存空间会被释放，但是指针还能使用（只是使用前需要重新在赋指针值）。 10.malloc不调用构造函数, new自动调用构造函数, free和delete类似. malloc是c语言的底层函数，new是C++的类方法。 11.为什么要用重载? (1) 便于记忆。(2) 不得不, 比如说类的多个构造函数 12.不能编译头文件 全局变量定义时, (直接赋值), extern无作用 全局变量声明时, extern告诉编译器, 定义部分在其它模块中 全局变量默认extern 13.重载: 同一个类中, 或都是全局函数. 覆盖: 分别位于派生类与基类中, 函数名与参数都相同，有virtual关键字，用于多态. 隐藏: 分别位于派生类与基类中, 只要同名, 且非覆盖, 均为隐藏. 14.函数参数的缺省值，只能出现在函数的"),a(t,{color:"red"},{default:e(()=>[n("声明")]),_:1}),n('中. 15.操作符重载。调用时, 普通函数参数出现在圆括号内, 对于运算符, 参数出现在其左右两侧。定义时，可定义为全局函数和类的成员函数，后者比前者少了一个参数。 16.类的构造次序，先构造基类，再构造构造函数的参数，再构造成员，再构造自己。析构完全相反。 17.String a("hello"); String b=a; 其实是调用了b的拷贝构造函数，最好写成String b(a). 18.对于一个类，编译器默认生成4个函数，无参构造函数，拷贝构造函数，析构函数，赋值函数(重载=运算符) 19.类的析构函数，应为虚函数, 多态 20.对于非内部数据类型的输入参数，应该将“值传递”的方式，改为“const 引用传递”，目的是提高效率。例如，将void Func(A a)，改为 void Func(const A &a)。其实实参在向形参传递值时，是用实参的值在栈上重新开辟了一块临时空间，再来装实参的值。如果使用引用的方法，就是单纯地指针传递，没有开辟空间这个步骤，节约时间，节约栈内存。 21.引用被创建的同时，必须被初始化，一旦引用被初始化，就不能改变引用的关系。引用的实质是'),a(t,{color:"red"},{default:e(()=>[n("指针常量")]),_:1}),n("。即："),a(t,{color:"red"},{default:e(()=>[n("指针常量：本质为常量，常量里面装的是指针。所以，指针的指向不能变，指向的内存空间中，存放的值可以变")]),_:1}),n("。 22.对比于C语言的函数，cpp增加了重载，内联，const和virtual四种新机制，重载和内联机制，既可以用于全局函数，也可用于类的成员函数，const与virtual机制，仅用于类的成员函数 23.赋值符号的重载，不能为友元，只能是类的成员函数")]),y,s("p",null,[n("紧接上文，还是参考"),s("a",h,[n("知乎专栏"),a(p)]),n(" 1、概述")]),f,s("p",null,[n("参考链接"),s("a",g,[n("南邮武三郎的文章"),a(p)])])])}const q=i(k,[["render",_],["__file","c和c__的比较.html.vue"]]);export{q as default};
