<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.61" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://haoxx.top/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html"><meta property="og:site_name" content="开心酒馆"><meta property="og:title" content="代码随想录学习笔记[总结]"><meta property="og:description" content="提示 这是在学习代码随想录网站上的知识时，所做的一部分笔记"><meta property="og:type" content="article"><meta property="og:image" content="https://w.wallhaven.cc/full/72/wallhaven-7286w9.png"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2023-11-24T13:28:29.000Z"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image:alt" content="代码随想录学习笔记[总结]"><meta property="article:author" content="Mr.HaoXX"><meta property="article:tag" content="刷题"><meta property="article:published_time" content="2023-04-12T00:00:00.000Z"><meta property="article:modified_time" content="2023-11-24T13:28:29.000Z"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"代码随想录学习笔记[总结]","image":["https://w.wallhaven.cc/full/72/wallhaven-7286w9.png"],"datePublished":"2023-04-12T00:00:00.000Z","dateModified":"2023-11-24T13:28:29.000Z","author":[{"@type":"Person","name":"Mr.HaoXX","url":"https://haoxx.top/"}]}</script><link rel="icon" href="/favicon.ico"><meta name="referrer" content="no-referrer-when-downgrade"><title>代码随想录学习笔记[总结] | 开心酒馆</title><meta name="description" content="提示 这是在学习代码随想录网站上的知识时，所做的一部分笔记">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d1e1f;
      }

      html,
      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="preload" href="/assets/style-0832a140.css" as="style"><link rel="stylesheet" href="/assets/style-0832a140.css">
    <link rel="modulepreload" href="/assets/app-cd86945f.js"><link rel="modulepreload" href="/assets/framework-e783454b.js"><link rel="modulepreload" href="/assets/代码随想录学习笔记_总结_.html-7afc4e78.js"><link rel="modulepreload" href="/assets/代码随想录学习笔记_总结_.html-def43b7a.js"><link rel="prefetch" href="/assets/index.html-0c6e80d8.js" as="script"><link rel="prefetch" href="/assets/visitorbook.html-90e15ff3.js" as="script"><link rel="prefetch" href="/assets/index.html-56d9107c.js" as="script"><link rel="prefetch" href="/assets/index.html-d27339fc.js" as="script"><link rel="prefetch" href="/assets/index.html-333f2f76.js" as="script"><link rel="prefetch" href="/assets/index.html-9b85df5f.js" as="script"><link rel="prefetch" href="/assets/关于我.html-124cb063.js" as="script"><link rel="prefetch" href="/assets/index.html-82f20127.js" as="script"><link rel="prefetch" href="/assets/index.html-4086d4fb.js" as="script"><link rel="prefetch" href="/assets/index.html-9158d331.js" as="script"><link rel="prefetch" href="/assets/index.html-6d8b73b1.js" as="script"><link rel="prefetch" href="/assets/index.html-b76a9fff.js" as="script"><link rel="prefetch" href="/assets/index.html-90e3434f.js" as="script"><link rel="prefetch" href="/assets/index.html-d48161b0.js" as="script"><link rel="prefetch" href="/assets/ALL_c__全面总结.html-6325208e.js" as="script"><link rel="prefetch" href="/assets/c__关键字说明.html-e57920d8.js" as="script"><link rel="prefetch" href="/assets/c__复习总攻略.html-16545d3d.js" as="script"><link rel="prefetch" href="/assets/c__指针与常量知识点专项说明.html-0f6f651a.js" as="script"><link rel="prefetch" href="/assets/c__部分内容(来源于牛客，自己增加).html-a662ce6d.js" as="script"><link rel="prefetch" href="/assets/c和c__字符串处理函数大汇总.html-31e478e4.js" as="script"><link rel="prefetch" href="/assets/C和C__学习思路.html-f9051988.js" as="script"><link rel="prefetch" href="/assets/c和c__的比较.html-c65b6570.js" as="script"><link rel="prefetch" href="/assets/python学习记录.html-c4fe7818.js" as="script"><link rel="prefetch" href="/assets/index.html-274a8eb6.js" as="script"><link rel="prefetch" href="/assets/内存分区问题.html-966164e4.js" as="script"><link rel="prefetch" href="/assets/参考资料汇总.html-69b3b0e3.js" as="script"><link rel="prefetch" href="/assets/结构体字节大小计算手册.html-d9017882.js" as="script"><link rel="prefetch" href="/assets/综合资料.html-9750832a.js" as="script"><link rel="prefetch" href="/assets/index.html-cf5d190b.js" as="script"><link rel="prefetch" href="/assets/大话数据结构和算法.html-e8344306.js" as="script"><link rel="prefetch" href="/assets/index.html-cda81d99.js" as="script"><link rel="prefetch" href="/assets/进程与线程.html-b93a32e6.js" as="script"><link rel="prefetch" href="/assets/IPv4学习记录.html-8e83d835.js" as="script"><link rel="prefetch" href="/assets/IP地址说明.html-ee8cc3b0.js" as="script"><link rel="prefetch" href="/assets/index.html-632b3c50.js" as="script"><link rel="prefetch" href="/assets/index.html-0e965c43.js" as="script"><link rel="prefetch" href="/assets/类的关系UML图.html-7ea4a2ee.js" as="script"><link rel="prefetch" href="/assets/设计模式总结.html-90f42962.js" as="script"><link rel="prefetch" href="/assets/docker记录.html-93188759.js" as="script"><link rel="prefetch" href="/assets/git提交命令.html-05330ad3.js" as="script"><link rel="prefetch" href="/assets/index.html-d2f1ad6f.js" as="script"><link rel="prefetch" href="/assets/tmux使用记录.html-d242b37a.js" as="script"><link rel="prefetch" href="/assets/使用clash代理需知.html-c18a24ff.js" as="script"><link rel="prefetch" href="/assets/关于cron和anacron.html-91517409.js" as="script"><link rel="prefetch" href="/assets/数据库mysql常用命令.html-10a4110d.js" as="script"><link rel="prefetch" href="/assets/终端美化记录.html-63d160ec.js" as="script"><link rel="prefetch" href="/assets/markdown之frontmatter设置.html-4ee0e780.js" as="script"><link rel="prefetch" href="/assets/markdown基本规则学习笔记.html-7c55d91e.js" as="script"><link rel="prefetch" href="/assets/index.html-39ab6932.js" as="script"><link rel="prefetch" href="/assets/1__WebServer学习笔记汇总.html-168f4dd7.js" as="script"><link rel="prefetch" href="/assets/2__小林coding的WebServer面试考点_独立版本.html-3ceb2023.js" as="script"><link rel="prefetch" href="/assets/3__Tiny综合学习_问答题综合_独立版本.html-1f104270.js" as="script"><link rel="prefetch" href="/assets/index.html-c375e18c.js" as="script"><link rel="prefetch" href="/assets/C__STL常用容器知识点说明.html-f48723c9.js" as="script"><link rel="prefetch" href="/assets/gdb调试手册.html-a6726557.js" as="script"><link rel="prefetch" href="/assets/index.html-e166b8b6.js" as="script"><link rel="prefetch" href="/assets/进程与线程笔记.html-c4e8e5e2.js" as="script"><link rel="prefetch" href="/assets/进程间通信学习内容.html-528e7174.js" as="script"><link rel="prefetch" href="/assets/部分有用网站记录.html-ad0b521e.js" as="script"><link rel="prefetch" href="/assets/index.html-62fde04a.js" as="script"><link rel="prefetch" href="/assets/index.html-29b7affc.js" as="script"><link rel="prefetch" href="/assets/index.html-8df85f88.js" as="script"><link rel="prefetch" href="/assets/index.html-19964234.js" as="script"><link rel="prefetch" href="/assets/index.html-c1b8d55b.js" as="script"><link rel="prefetch" href="/assets/index.html-9abae9df.js" as="script"><link rel="prefetch" href="/assets/404.html-15810e32.js" as="script"><link rel="prefetch" href="/assets/index.html-35c573c7.js" as="script"><link rel="prefetch" href="/assets/index.html-f1788570.js" as="script"><link rel="prefetch" href="/assets/index.html-ac95d164.js" as="script"><link rel="prefetch" href="/assets/index.html-9267dacb.js" as="script"><link rel="prefetch" href="/assets/index.html-5929313d.js" as="script"><link rel="prefetch" href="/assets/index.html-938d4764.js" as="script"><link rel="prefetch" href="/assets/index.html-e155b649.js" as="script"><link rel="prefetch" href="/assets/index.html-6b3eea3a.js" as="script"><link rel="prefetch" href="/assets/index.html-bf670873.js" as="script"><link rel="prefetch" href="/assets/index.html-3a1d6b0a.js" as="script"><link rel="prefetch" href="/assets/index.html-509e3521.js" as="script"><link rel="prefetch" href="/assets/index.html-deb86756.js" as="script"><link rel="prefetch" href="/assets/index.html-b18e713d.js" as="script"><link rel="prefetch" href="/assets/index.html-140b867f.js" as="script"><link rel="prefetch" href="/assets/index.html-07494391.js" as="script"><link rel="prefetch" href="/assets/index.html-1d054f09.js" as="script"><link rel="prefetch" href="/assets/index.html-5eac0c74.js" as="script"><link rel="prefetch" href="/assets/index.html-b12aef45.js" as="script"><link rel="prefetch" href="/assets/index.html-8ca6a783.js" as="script"><link rel="prefetch" href="/assets/index.html-917eeab2.js" as="script"><link rel="prefetch" href="/assets/index.html-f7365fb2.js" as="script"><link rel="prefetch" href="/assets/index.html-fab9cd16.js" as="script"><link rel="prefetch" href="/assets/index.html-3bf71061.js" as="script"><link rel="prefetch" href="/assets/index.html-bbebb3b0.js" as="script"><link rel="prefetch" href="/assets/index.html-9411c908.js" as="script"><link rel="prefetch" href="/assets/index.html-1879a8b9.js" as="script"><link rel="prefetch" href="/assets/index.html-ca696026.js" as="script"><link rel="prefetch" href="/assets/index.html-7cd66b0a.js" as="script"><link rel="prefetch" href="/assets/index.html-e15c1014.js" as="script"><link rel="prefetch" href="/assets/index.html-66a159e7.js" as="script"><link rel="prefetch" href="/assets/index.html-73892771.js" as="script"><link rel="prefetch" href="/assets/index.html-51b2f747.js" as="script"><link rel="prefetch" href="/assets/visitorbook.html-4f68fb5d.js" as="script"><link rel="prefetch" href="/assets/index.html-fa07182e.js" as="script"><link rel="prefetch" href="/assets/index.html-c5274f30.js" as="script"><link rel="prefetch" href="/assets/index.html-ec2c88b3.js" as="script"><link rel="prefetch" href="/assets/index.html-5db74b66.js" as="script"><link rel="prefetch" href="/assets/关于我.html-20221ae0.js" as="script"><link rel="prefetch" href="/assets/index.html-c556656f.js" as="script"><link rel="prefetch" href="/assets/index.html-17e278d1.js" as="script"><link rel="prefetch" href="/assets/index.html-d1273f11.js" as="script"><link rel="prefetch" href="/assets/index.html-e2732ecd.js" as="script"><link rel="prefetch" href="/assets/index.html-554e581b.js" as="script"><link rel="prefetch" href="/assets/index.html-145c6170.js" as="script"><link rel="prefetch" href="/assets/index.html-67f2fb49.js" as="script"><link rel="prefetch" href="/assets/ALL_c__全面总结.html-71e84f90.js" as="script"><link rel="prefetch" href="/assets/c__关键字说明.html-23cf2ac3.js" as="script"><link rel="prefetch" href="/assets/c__复习总攻略.html-67c5ab3b.js" as="script"><link rel="prefetch" href="/assets/c__指针与常量知识点专项说明.html-95f23508.js" as="script"><link rel="prefetch" href="/assets/c__部分内容(来源于牛客，自己增加).html-9b724353.js" as="script"><link rel="prefetch" href="/assets/c和c__字符串处理函数大汇总.html-0c89e5a2.js" as="script"><link rel="prefetch" href="/assets/C和C__学习思路.html-f9dbef1f.js" as="script"><link rel="prefetch" href="/assets/c和c__的比较.html-a9d989e3.js" as="script"><link rel="prefetch" href="/assets/python学习记录.html-8841674e.js" as="script"><link rel="prefetch" href="/assets/index.html-3b8e7727.js" as="script"><link rel="prefetch" href="/assets/内存分区问题.html-85c8bd02.js" as="script"><link rel="prefetch" href="/assets/参考资料汇总.html-8bc3d5bd.js" as="script"><link rel="prefetch" href="/assets/结构体字节大小计算手册.html-12a2f0ce.js" as="script"><link rel="prefetch" href="/assets/综合资料.html-ae88d9ca.js" as="script"><link rel="prefetch" href="/assets/index.html-65af008c.js" as="script"><link rel="prefetch" href="/assets/大话数据结构和算法.html-e14ce945.js" as="script"><link rel="prefetch" href="/assets/index.html-8b226710.js" as="script"><link rel="prefetch" href="/assets/进程与线程.html-64582975.js" as="script"><link rel="prefetch" href="/assets/IPv4学习记录.html-58ff4c7e.js" as="script"><link rel="prefetch" href="/assets/IP地址说明.html-4e329233.js" as="script"><link rel="prefetch" href="/assets/index.html-048b1345.js" as="script"><link rel="prefetch" href="/assets/index.html-8d43775e.js" as="script"><link rel="prefetch" href="/assets/类的关系UML图.html-42290e71.js" as="script"><link rel="prefetch" href="/assets/设计模式总结.html-65386c99.js" as="script"><link rel="prefetch" href="/assets/docker记录.html-21def323.js" as="script"><link rel="prefetch" href="/assets/git提交命令.html-8e79988c.js" as="script"><link rel="prefetch" href="/assets/index.html-1203c22e.js" as="script"><link rel="prefetch" href="/assets/tmux使用记录.html-18509a05.js" as="script"><link rel="prefetch" href="/assets/使用clash代理需知.html-31c20cd2.js" as="script"><link rel="prefetch" href="/assets/关于cron和anacron.html-1a802f6c.js" as="script"><link rel="prefetch" href="/assets/数据库mysql常用命令.html-dcef07a8.js" as="script"><link rel="prefetch" href="/assets/终端美化记录.html-cd5190ba.js" as="script"><link rel="prefetch" href="/assets/markdown之frontmatter设置.html-3b885be9.js" as="script"><link rel="prefetch" href="/assets/markdown基本规则学习笔记.html-3306698f.js" as="script"><link rel="prefetch" href="/assets/index.html-387124b8.js" as="script"><link rel="prefetch" href="/assets/1__WebServer学习笔记汇总.html-72117f24.js" as="script"><link rel="prefetch" href="/assets/2__小林coding的WebServer面试考点_独立版本.html-a689fc68.js" as="script"><link rel="prefetch" href="/assets/3__Tiny综合学习_问答题综合_独立版本.html-1cbe2f5f.js" as="script"><link rel="prefetch" href="/assets/index.html-da82e235.js" as="script"><link rel="prefetch" href="/assets/C__STL常用容器知识点说明.html-a2c87516.js" as="script"><link rel="prefetch" href="/assets/gdb调试手册.html-e1e66ac1.js" as="script"><link rel="prefetch" href="/assets/index.html-99ec40a4.js" as="script"><link rel="prefetch" href="/assets/进程与线程笔记.html-27a9bdae.js" as="script"><link rel="prefetch" href="/assets/进程间通信学习内容.html-849da8bc.js" as="script"><link rel="prefetch" href="/assets/部分有用网站记录.html-82b409c3.js" as="script"><link rel="prefetch" href="/assets/index.html-4de4de6c.js" as="script"><link rel="prefetch" href="/assets/index.html-aa7d17f3.js" as="script"><link rel="prefetch" href="/assets/index.html-7005c79a.js" as="script"><link rel="prefetch" href="/assets/index.html-12d9e9f8.js" as="script"><link rel="prefetch" href="/assets/index.html-aefe17d6.js" as="script"><link rel="prefetch" href="/assets/index.html-40d27344.js" as="script"><link rel="prefetch" href="/assets/404.html-f4089c89.js" as="script"><link rel="prefetch" href="/assets/index.html-ae0df1bc.js" as="script"><link rel="prefetch" href="/assets/index.html-73c2740f.js" as="script"><link rel="prefetch" href="/assets/index.html-4540c1f3.js" as="script"><link rel="prefetch" href="/assets/index.html-bee6acac.js" as="script"><link rel="prefetch" href="/assets/index.html-ff9798bd.js" as="script"><link rel="prefetch" href="/assets/index.html-27dea863.js" as="script"><link rel="prefetch" href="/assets/index.html-3621cee8.js" as="script"><link rel="prefetch" href="/assets/index.html-1abc2fc4.js" as="script"><link rel="prefetch" href="/assets/index.html-0efc1941.js" as="script"><link rel="prefetch" href="/assets/index.html-9a4a9cb8.js" as="script"><link rel="prefetch" href="/assets/index.html-d8044145.js" as="script"><link rel="prefetch" href="/assets/index.html-1ddff557.js" as="script"><link rel="prefetch" href="/assets/index.html-6606fff1.js" as="script"><link rel="prefetch" href="/assets/index.html-79ee8eb8.js" as="script"><link rel="prefetch" href="/assets/index.html-83499417.js" as="script"><link rel="prefetch" href="/assets/index.html-eccaca47.js" as="script"><link rel="prefetch" href="/assets/index.html-e6ec9749.js" as="script"><link rel="prefetch" href="/assets/index.html-13270fee.js" as="script"><link rel="prefetch" href="/assets/index.html-47178326.js" as="script"><link rel="prefetch" href="/assets/index.html-917c11b9.js" as="script"><link rel="prefetch" href="/assets/index.html-6627f487.js" as="script"><link rel="prefetch" href="/assets/index.html-591c91bc.js" as="script"><link rel="prefetch" href="/assets/index.html-261d9c5b.js" as="script"><link rel="prefetch" href="/assets/index.html-2e422d17.js" as="script"><link rel="prefetch" href="/assets/index.html-498cd3ec.js" as="script"><link rel="prefetch" href="/assets/index.html-fc393400.js" as="script"><link rel="prefetch" href="/assets/index.html-0d9a25d0.js" as="script"><link rel="prefetch" href="/assets/index.html-ea0ff583.js" as="script"><link rel="prefetch" href="/assets/index.html-ef229e81.js" as="script"><link rel="prefetch" href="/assets/index.html-a00083d2.js" as="script"><link rel="prefetch" href="/assets/index.html-b845ce7a.js" as="script"><link rel="prefetch" href="/assets/dash.all.min-971bb768.js" as="script"><link rel="prefetch" href="/assets/mpegts-57a989ba.js" as="script"><link rel="prefetch" href="/assets/hls.min-dcc0ca18.js" as="script"><link rel="prefetch" href="/assets/artplayer-d52464c4.js" as="script"><link rel="prefetch" href="/assets/plyr.min-65d8b78a.js" as="script"><link rel="prefetch" href="/assets/plyr.min-65d8b78a.js" as="script"><link rel="prefetch" href="/assets/auto-fa8841cf.js" as="script"><link rel="prefetch" href="/assets/index-b03bef79.js" as="script"><link rel="prefetch" href="/assets/flowchart-d65a1d8e.js" as="script"><link rel="prefetch" href="/assets/mermaid.core-11a48a09.js" as="script"><link rel="prefetch" href="/assets/highlight.esm-75b11b9d.js" as="script"><link rel="prefetch" href="/assets/markdown.esm-0191f9da.js" as="script"><link rel="prefetch" href="/assets/math.esm-70a288c8.js" as="script"><link rel="prefetch" href="/assets/notes.esm-a106bb2c.js" as="script"><link rel="prefetch" href="/assets/reveal.esm-ab04f0b1.js" as="script"><link rel="prefetch" href="/assets/search.esm-7e6792e2.js" as="script"><link rel="prefetch" href="/assets/zoom.esm-b83b91d0.js" as="script"><link rel="prefetch" href="/assets/VuePlayground-0a52d59d.js" as="script"><link rel="prefetch" href="/assets/photoswipe.esm-36cd6c3c.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">跳至主要內容</a><!--]--><div class="theme-container has-toc"><!--[--><header class="navbar auto-hide" id="navbar"><div class="navbar-start"><button type="button" class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><!----><!--]--><!--[--><a href="/" class="brand"><img class="logo" src="/site_logo.png" alt="开心酒馆"><!----><span class="site-name hide-in-pad">开心酒馆</span></a><!--]--><!--[--><!----><!--]--></div><div class="navbar-center"><!--[--><!----><!--]--><!--[--><nav class="nav-links"><div class="nav-item hide-in-mobile"><a href="/" class="nav-link" aria-label="首页"><span class="font-icon icon iconfont icon-home" style=""></span>首页<!----></a></div><div class="nav-item hide-in-mobile"><a href="/quicknav/" class="nav-link" aria-label="快速导航"><span class="font-icon icon iconfont icon-navigation" style=""></span>快速导航<!----></a></div><div class="nav-item hide-in-mobile"><a href="/blog/" class="nav-link" aria-label="博客主页"><span class="font-icon icon iconfont icon-blog" style=""></span>博客主页<!----></a></div><div class="nav-item hide-in-mobile"><a href="/docs/" class="nav-link active" aria-label="代码笔记"><span class="font-icon icon iconfont icon-code" style=""></span>代码笔记<!----></a></div><div class="nav-item hide-in-mobile"><a href="/floatinglife/" class="nav-link" aria-label="浮生杂记"><span class="font-icon icon iconfont icon-note" style=""></span>浮生杂记<!----></a></div><div class="nav-item hide-in-mobile"><a href="/projects/" class="nav-link" aria-label="开源项目"><span class="font-icon icon iconfont icon-free" style=""></span>开源项目<!----></a></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button type="button" class="dropdown-title" aria-label="资源宝库"><span class="title"><span class="font-icon icon iconfont icon-advance" style=""></span>资源宝库</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/resources/books/" class="nav-link" aria-label="书籍资源"><span class="font-icon icon iconfont icon-animation" style=""></span>书籍资源<!----></a></li><li class="dropdown-item"><a href="/resources/videos/" class="nav-link" aria-label="影音资源"><span class="font-icon icon iconfont icon-play" style=""></span>影音资源<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><a href="/visitorbook.html" class="nav-link" aria-label="留言板"><span class="font-icon icon iconfont icon-mark" style=""></span>留言板<!----></a></div><div class="nav-item hide-in-mobile"><a href="/control/" class="nav-link" aria-label="管理员平台"><span class="font-icon icon iconfont icon-operate" style=""></span>管理员平台<!----></a></div></nav><!--]--><!--[--><!----><!--]--></div><div class="navbar-end"><!--[--><!----><!--]--><!--[--><!----><div class="nav-item"><a class="repo-link" href="https://github.com/XiaoYuer2022" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="github icon" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><div class="nav-item hide-in-mobile"><button type="button" class="outlook-button" tabindex="-1" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" class="icon outlook-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="outlook icon"><path d="M224 800c0 9.6 3.2 44.8 6.4 54.4 6.4 48-48 76.8-48 76.8s80 41.6 147.2 0 134.4-134.4 38.4-195.2c-22.4-12.8-41.6-19.2-57.6-19.2C259.2 716.8 227.2 761.6 224 800zM560 675.2l-32 51.2c-51.2 51.2-83.2 32-83.2 32 25.6 67.2 0 112-12.8 128 25.6 6.4 51.2 9.6 80 9.6 54.4 0 102.4-9.6 150.4-32l0 0c3.2 0 3.2-3.2 3.2-3.2 22.4-16 12.8-35.2 6.4-44.8-9.6-12.8-12.8-25.6-12.8-41.6 0-54.4 60.8-99.2 137.6-99.2 6.4 0 12.8 0 22.4 0 12.8 0 38.4 9.6 48-25.6 0-3.2 0-3.2 3.2-6.4 0-3.2 3.2-6.4 3.2-6.4 6.4-16 6.4-16 6.4-19.2 9.6-35.2 16-73.6 16-115.2 0-105.6-41.6-198.4-108.8-268.8C704 396.8 560 675.2 560 675.2zM224 419.2c0-28.8 22.4-51.2 51.2-51.2 28.8 0 51.2 22.4 51.2 51.2 0 28.8-22.4 51.2-51.2 51.2C246.4 470.4 224 448 224 419.2zM320 284.8c0-22.4 19.2-41.6 41.6-41.6 22.4 0 41.6 19.2 41.6 41.6 0 22.4-19.2 41.6-41.6 41.6C339.2 326.4 320 307.2 320 284.8zM457.6 208c0-12.8 12.8-25.6 25.6-25.6 12.8 0 25.6 12.8 25.6 25.6 0 12.8-12.8 25.6-25.6 25.6C470.4 233.6 457.6 220.8 457.6 208zM128 505.6C128 592 153.6 672 201.6 736c28.8-60.8 112-60.8 124.8-60.8-16-51.2 16-99.2 16-99.2l316.8-422.4c-48-19.2-99.2-32-150.4-32C297.6 118.4 128 291.2 128 505.6zM764.8 86.4c-22.4 19.2-390.4 518.4-390.4 518.4-22.4 28.8-12.8 76.8 22.4 99.2l9.6 6.4c35.2 22.4 80 12.8 99.2-25.6 0 0 6.4-12.8 9.6-19.2 54.4-105.6 275.2-524.8 288-553.6 6.4-19.2-3.2-32-19.2-32C777.6 76.8 771.2 80 764.8 86.4z"></path></svg><div class="outlook-dropdown"><!----></div></button></div><form class="search-box" role="search"><input type="search" placeholder="搜索本站" autocomplete="off" spellcheck="false" value><!----></form><!--]--><!--[--><!----><!--]--><button type="button" class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside class="sidebar" id="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"><li><section class="sidebar-group"><button class="sidebar-heading clickable" type="button"><span class="font-icon icon iconfont icon-c" style=""></span><span class="title">编程语言基础</span><span class="arrow end"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable" type="button"><span class="font-icon icon iconfont icon-engine" style=""></span><span class="title">数据结构与算法</span><span class="arrow end"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable" type="button"><span class="font-icon icon iconfont icon-frame" style=""></span><span class="title">操作系统与计算机基础</span><span class="arrow end"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable" type="button"><span class="font-icon icon iconfont icon-ability" style=""></span><span class="title">计算机网络</span><span class="arrow end"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable" type="button"><span class="font-icon icon iconfont icon-mysql" style=""></span><span class="title">设计模式</span><span class="arrow end"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable active" type="button"><span class="font-icon icon iconfont icon-tool" style=""></span><span class="title">找工作相关</span><span class="arrow down"></span></button><ul class="sidebar-links"><li><!--[--><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html" class="router-link-active router-link-exact-active nav-link active sidebar-link sidebar-page active" aria-label="代码随想录学习笔记[总结]"><span class="font-icon icon iconfont icon-write" style=""></span>代码随想录学习笔记[总结]<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#一、数组" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="一、数组"><!---->一、数组<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_1-1-二分查找" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.1 二分查找"><!---->1.1 二分查找<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_1-2-移除元素" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.2 移除元素"><!---->1.2 移除元素<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_1-3-有序数组的平方" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.3 有序数组的平方"><!---->1.3 有序数组的平方<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_1-4-长度最小的子数组" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.4 长度最小的子数组"><!---->1.4 长度最小的子数组<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_1-5-螺旋矩阵2" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.5 螺旋矩阵2"><!---->1.5 螺旋矩阵2<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_1-6-总结篇" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.6 总结篇"><!---->1.6 总结篇<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_2-2-设计链表" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2.2 设计链表"><!---->2.2 设计链表<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_2-3-翻转链表" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2.3 翻转链表"><!---->2.3 翻转链表<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_2-4-两两交换链表中的节点" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2.4 两两交换链表中的节点"><!---->2.4 两两交换链表中的节点<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_2-5-删除链表的倒数第n个节点" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2.5 删除链表的倒数第N个节点"><!---->2.5 删除链表的倒数第N个节点<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_2-6-链表相交" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2.6 链表相交"><!---->2.6 链表相交<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_2-7-环形链表2" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2.7 环形链表2"><!---->2.7 环形链表2<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_2-8-总结篇" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2.8 总结篇"><!---->2.8 总结篇<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#三、哈希表" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="三、哈希表"><!---->三、哈希表<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_3-1-哈希表的理论基础" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.1 哈希表的理论基础"><!---->3.1 哈希表的理论基础<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_3-2-有效的字母异位词" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.2 有效的字母异位词"><!---->3.2 有效的字母异位词<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_3-3-两个数组的交集" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.3 两个数组的交集"><!---->3.3 两个数组的交集<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_3-4-快乐数" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.4 快乐数"><!---->3.4 快乐数<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_3-5-两数之和" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.5 两数之和"><!---->3.5 两数之和<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_3-6-四数相加2" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.6 四数相加2"><!---->3.6 四数相加2<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_3-7-赎金信" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.7 赎金信"><!---->3.7 赎金信<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_3-8-三数之和" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.8 三数之和"><!---->3.8 三数之和<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_3-9-四数之和" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.9 四数之和"><!---->3.9 四数之和<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_3-10-总结" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.10 总结"><!---->3.10 总结<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#四、字符串" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="四、字符串"><!---->四、字符串<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_4-1-反转字符串1" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.1 反转字符串1"><!---->4.1 反转字符串1<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_4-2-反转字符串2" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.2 反转字符串2"><!---->4.2 反转字符串2<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_4-3-替换空格" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.3 替换空格"><!---->4.3 替换空格<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_4-4-翻转字符串里的单词" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.4 翻转字符串里的单词"><!---->4.4 翻转字符串里的单词<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_4-5-左旋转字符串" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.5 左旋转字符串"><!---->4.5 左旋转字符串<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_4-6-实现strstr" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.6 实现strStr()"><!---->4.6 实现strStr()<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_4-7-重复的子字符串" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.7 重复的子字符串"><!---->4.7 重复的子字符串<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_4-8-总结" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.8 总结"><!---->4.8 总结<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#五、双指针法" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="五、双指针法"><!---->五、双指针法<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#六、栈与队列" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="六、栈与队列"><!---->六、栈与队列<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#七、二叉树" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="七、二叉树"><!---->七、二叉树<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#八、回溯算法" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="八、回溯算法"><!---->八、回溯算法<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#九、贪心算法" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="九、贪心算法"><!---->九、贪心算法<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#十、动态规划" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="十、动态规划"><!---->十、动态规划<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#十一、单调栈" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="十一、单调栈"><!---->十一、单调栈<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#十二、额外题目" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="十二、额外题目"><!---->十二、额外题目<!----></a><ul class="sidebar-sub-headers"></ul></li></ul><!--]--></li><li><!--[--><a href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/1__WebServer%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%B1%87%E6%80%BB.html" class="nav-link sidebar-link sidebar-page" aria-label="1__WebServer学习笔记汇总"><span class="font-icon icon iconfont icon-write" style=""></span>1__WebServer学习笔记汇总<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/2__%E5%B0%8F%E6%9E%97coding%E7%9A%84WebServer%E9%9D%A2%E8%AF%95%E8%80%83%E7%82%B9_%E7%8B%AC%E7%AB%8B%E7%89%88%E6%9C%AC.html" class="nav-link sidebar-link sidebar-page" aria-label="2__小林coding的WebServer面试考点_独立版本"><span class="font-icon icon iconfont icon-write" style=""></span>2__小林coding的WebServer面试考点_独立版本<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/3__Tiny%E7%BB%BC%E5%90%88%E5%AD%A6%E4%B9%A0_%E9%97%AE%E7%AD%94%E9%A2%98%E7%BB%BC%E5%90%88_%E7%8B%AC%E7%AB%8B%E7%89%88%E6%9C%AC.html" class="nav-link sidebar-link sidebar-page" aria-label="3__Tiny综合学习_问答题综合_独立版本"><span class="font-icon icon iconfont icon-write" style=""></span>3__Tiny综合学习_问答题综合_独立版本<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable" type="button"><span class="font-icon icon iconfont icon-tool" style=""></span><span class="title">Linux运行维护相关</span><span class="arrow end"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable" type="button"><span class="font-icon icon iconfont icon-read" style=""></span><span class="title">MarkDown书写规则</span><span class="arrow end"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable" type="button"><span class="font-icon icon iconfont icon-read" style=""></span><span class="title">未分类</span><span class="arrow end"></span></button><!----></section></li></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!--[--><!----><img class="page-cover" src="https://w.wallhaven.cc/full/72/wallhaven-7286w9.png" alt="代码随想录学习笔记[总结]" no-view><nav class="breadcrumb disable"></nav><div class="page-title"><h1><!---->代码随想录学习笔记[总结]</h1><div class="page-info"><span class="page-author-info" aria-label="作者🖊" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="page-author-item" href="https://haoxx.top/" target="_blank" rel="noopener noreferrer">Mr.HaoXX</a></span><span property="author" content="Mr.HaoXX"></span></span><!----><span class="page-date-info" aria-label="写作日期📅" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span><!----></span><meta property="datePublished" content="2023-04-12T00:00:00.000Z"></span><!----><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 95 分钟</span><meta property="timeRequired" content="PT95M"></span><span class="page-category-info" aria-label="分类🌈" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon category-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="category icon"><path d="M148.41 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H148.41c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.311-40.31zM147.556 553.478H429.73c22.263 0 40.311 18.048 40.311 40.31v282.176c0 22.263-18.048 40.312-40.31 40.312H147.555c-22.263 0-40.311-18.049-40.311-40.312V593.79c0-22.263 18.048-40.311 40.31-40.311zM593.927 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H593.927c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.31-40.31zM730.22 920.502H623.926c-40.925 0-74.22-33.388-74.22-74.425V623.992c0-41.038 33.387-74.424 74.425-74.424h222.085c41.038 0 74.424 33.226 74.424 74.067v114.233c0 10.244-8.304 18.548-18.547 18.548s-18.548-8.304-18.548-18.548V623.635c0-20.388-16.746-36.974-37.33-36.974H624.13c-20.585 0-37.331 16.747-37.331 37.33v222.086c0 20.585 16.654 37.331 37.126 37.331H730.22c10.243 0 18.547 8.304 18.547 18.547 0 10.244-8.304 18.547-18.547 18.547z"></path></svg><!--[--><span class="page-category-item category1 clickable" role="navigation">找工作</span><!--]--><meta property="articleSection" content="找工作"></span><span class="page-tag-info" aria-label="标签🏷" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon tag-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="tag icon"><path d="M939.902 458.563L910.17 144.567c-1.507-16.272-14.465-29.13-30.737-30.737L565.438 84.098h-.402c-3.215 0-5.726 1.005-7.634 2.913l-470.39 470.39a10.004 10.004 0 000 14.164l365.423 365.424c1.909 1.908 4.42 2.913 7.132 2.913s5.223-1.005 7.132-2.913l470.39-470.39c2.01-2.11 3.014-5.023 2.813-8.036zm-240.067-72.121c-35.458 0-64.286-28.828-64.286-64.286s28.828-64.285 64.286-64.285 64.286 28.828 64.286 64.285-28.829 64.286-64.286 64.286z"></path></svg><!--[--><span class="page-tag-item tag2 clickable" role="navigation">刷题</span><!--]--><meta property="keywords" content="刷题"></span></div><hr></div><div class="toc-place-holder"><aside id="toc"><!--[--><!----><!--]--><div class="toc-header">此页内容<button type="button" class="print-button" title="打印"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button></div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#一、数组" class="router-link-active router-link-exact-active toc-link level2">一、数组</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_1-1-二分查找" class="router-link-active router-link-exact-active toc-link level3">1.1 二分查找</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_1-2-移除元素" class="router-link-active router-link-exact-active toc-link level3">1.2 移除元素</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_1-3-有序数组的平方" class="router-link-active router-link-exact-active toc-link level3">1.3 有序数组的平方</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_1-4-长度最小的子数组" class="router-link-active router-link-exact-active toc-link level3">1.4 长度最小的子数组</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_1-5-螺旋矩阵2" class="router-link-active router-link-exact-active toc-link level3">1.5 螺旋矩阵2</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_1-6-总结篇" class="router-link-active router-link-exact-active toc-link level3">1.6 总结篇</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_2-2-设计链表" class="router-link-active router-link-exact-active toc-link level3">2.2 设计链表</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_2-3-翻转链表" class="router-link-active router-link-exact-active toc-link level3">2.3 翻转链表</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_2-4-两两交换链表中的节点" class="router-link-active router-link-exact-active toc-link level3">2.4 两两交换链表中的节点</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_2-5-删除链表的倒数第n个节点" class="router-link-active router-link-exact-active toc-link level3">2.5 删除链表的倒数第N个节点</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_2-6-链表相交" class="router-link-active router-link-exact-active toc-link level3">2.6 链表相交</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_2-7-环形链表2" class="router-link-active router-link-exact-active toc-link level3">2.7 环形链表2</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_2-8-总结篇" class="router-link-active router-link-exact-active toc-link level3">2.8 总结篇</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#三、哈希表" class="router-link-active router-link-exact-active toc-link level2">三、哈希表</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_3-1-哈希表的理论基础" class="router-link-active router-link-exact-active toc-link level3">3.1 哈希表的理论基础</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_3-2-有效的字母异位词" class="router-link-active router-link-exact-active toc-link level3">3.2 有效的字母异位词</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_3-3-两个数组的交集" class="router-link-active router-link-exact-active toc-link level3">3.3 两个数组的交集</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_3-4-快乐数" class="router-link-active router-link-exact-active toc-link level3">3.4 快乐数</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_3-5-两数之和" class="router-link-active router-link-exact-active toc-link level3">3.5 两数之和</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_3-6-四数相加2" class="router-link-active router-link-exact-active toc-link level3">3.6 四数相加2</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_3-7-赎金信" class="router-link-active router-link-exact-active toc-link level3">3.7 赎金信</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_3-8-三数之和" class="router-link-active router-link-exact-active toc-link level3">3.8 三数之和</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_3-9-四数之和" class="router-link-active router-link-exact-active toc-link level3">3.9 四数之和</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_3-10-总结" class="router-link-active router-link-exact-active toc-link level3">3.10 总结</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#四、字符串" class="router-link-active router-link-exact-active toc-link level2">四、字符串</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_4-1-反转字符串1" class="router-link-active router-link-exact-active toc-link level3">4.1 反转字符串1</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_4-2-反转字符串2" class="router-link-active router-link-exact-active toc-link level3">4.2 反转字符串2</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_4-3-替换空格" class="router-link-active router-link-exact-active toc-link level3">4.3 替换空格</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_4-4-翻转字符串里的单词" class="router-link-active router-link-exact-active toc-link level3">4.4 翻转字符串里的单词</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_4-5-左旋转字符串" class="router-link-active router-link-exact-active toc-link level3">4.5 左旋转字符串</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_4-6-实现strstr" class="router-link-active router-link-exact-active toc-link level3">4.6 实现strStr()</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_4-7-重复的子字符串" class="router-link-active router-link-exact-active toc-link level3">4.7 重复的子字符串</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_4-8-总结" class="router-link-active router-link-exact-active toc-link level3">4.8 总结</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#五、双指针法" class="router-link-active router-link-exact-active toc-link level2">五、双指针法</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#六、栈与队列" class="router-link-active router-link-exact-active toc-link level2">六、栈与队列</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#七、二叉树" class="router-link-active router-link-exact-active toc-link level2">七、二叉树</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#八、回溯算法" class="router-link-active router-link-exact-active toc-link level2">八、回溯算法</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#九、贪心算法" class="router-link-active router-link-exact-active toc-link level2">九、贪心算法</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#十、动态规划" class="router-link-active router-link-exact-active toc-link level2">十、动态规划</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#十一、单调栈" class="router-link-active router-link-exact-active toc-link level2">十一、单调栈</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#十二、额外题目" class="router-link-active router-link-exact-active toc-link level2">十二、额外题目</a></li><!----><!--]--></ul><div class="toc-marker" style="top:-1.7rem;"></div></div><!--[--><!----><!--]--></aside></div><!----><div class="theme-hope-content"><div class="hint-container tip"><p class="hint-container-title">提示</p><p>这是在学习代码随想录网站上的知识时，所做的一部分笔记</p></div><!-- more --><p>代码随想录学习笔记--文章修订记录：</p><ul><li>2023/04/11 第一版仍在撰写</li></ul><nav class="table-of-contents"><ul><li><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#一、数组" class="router-link-active router-link-exact-active">一、数组</a><ul><li><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_1-1-二分查找" class="router-link-active router-link-exact-active">1.1 二分查找</a></li><li><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_1-2-移除元素" class="router-link-active router-link-exact-active">1.2 移除元素</a></li><li><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_1-3-有序数组的平方" class="router-link-active router-link-exact-active">1.3 有序数组的平方</a></li><li><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_1-4-长度最小的子数组" class="router-link-active router-link-exact-active">1.4 长度最小的子数组</a></li><li><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_1-5-螺旋矩阵2" class="router-link-active router-link-exact-active">1.5 螺旋矩阵2</a></li><li><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_1-6-总结篇" class="router-link-active router-link-exact-active">1.6 总结篇</a></li><li><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_2-2-设计链表" class="router-link-active router-link-exact-active">2.2 设计链表</a></li><li><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_2-3-翻转链表" class="router-link-active router-link-exact-active">2.3 翻转链表</a></li><li><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_2-4-两两交换链表中的节点" class="router-link-active router-link-exact-active">2.4 两两交换链表中的节点</a></li><li><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_2-5-删除链表的倒数第n个节点" class="router-link-active router-link-exact-active">2.5 删除链表的倒数第N个节点</a></li><li><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_2-6-链表相交" class="router-link-active router-link-exact-active">2.6 链表相交</a></li><li><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_2-7-环形链表2" class="router-link-active router-link-exact-active">2.7 环形链表2</a></li><li><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_2-8-总结篇" class="router-link-active router-link-exact-active">2.8 总结篇</a></li></ul></li><li><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#三、哈希表" class="router-link-active router-link-exact-active">三、哈希表</a><ul><li><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_3-1-哈希表的理论基础" class="router-link-active router-link-exact-active">3.1 哈希表的理论基础</a></li><li><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_3-2-有效的字母异位词" class="router-link-active router-link-exact-active">3.2 有效的字母异位词</a></li><li><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_3-3-两个数组的交集" class="router-link-active router-link-exact-active">3.3 两个数组的交集</a></li><li><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_3-4-快乐数" class="router-link-active router-link-exact-active">3.4 快乐数</a></li><li><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_3-5-两数之和" class="router-link-active router-link-exact-active">3.5 两数之和</a></li><li><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_3-6-四数相加2" class="router-link-active router-link-exact-active">3.6 四数相加2</a></li><li><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_3-7-赎金信" class="router-link-active router-link-exact-active">3.7 赎金信</a></li><li><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_3-8-三数之和" class="router-link-active router-link-exact-active">3.8 三数之和</a></li><li><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_3-9-四数之和" class="router-link-active router-link-exact-active">3.9 四数之和</a></li><li><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_3-10-总结" class="router-link-active router-link-exact-active">3.10 总结</a></li></ul></li><li><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#四、字符串" class="router-link-active router-link-exact-active">四、字符串</a><ul><li><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_4-1-反转字符串1" class="router-link-active router-link-exact-active">4.1 反转字符串1</a></li><li><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_4-2-反转字符串2" class="router-link-active router-link-exact-active">4.2 反转字符串2</a></li><li><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_4-3-替换空格" class="router-link-active router-link-exact-active">4.3 替换空格</a></li><li><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_4-4-翻转字符串里的单词" class="router-link-active router-link-exact-active">4.4 翻转字符串里的单词</a></li><li><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_4-5-左旋转字符串" class="router-link-active router-link-exact-active">4.5 左旋转字符串</a></li><li><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_4-6-实现strstr" class="router-link-active router-link-exact-active">4.6 实现strStr()</a></li><li><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_4-7-重复的子字符串" class="router-link-active router-link-exact-active">4.7 重复的子字符串</a></li><li><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#_4-8-总结" class="router-link-active router-link-exact-active">4.8 总结</a></li></ul></li><li><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#五、双指针法" class="router-link-active router-link-exact-active">五、双指针法</a></li><li><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#六、栈与队列" class="router-link-active router-link-exact-active">六、栈与队列</a></li><li><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#七、二叉树" class="router-link-active router-link-exact-active">七、二叉树</a></li><li><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#八、回溯算法" class="router-link-active router-link-exact-active">八、回溯算法</a></li><li><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#九、贪心算法" class="router-link-active router-link-exact-active">九、贪心算法</a></li><li><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#十、动态规划" class="router-link-active router-link-exact-active">十、动态规划</a></li><li><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#十一、单调栈" class="router-link-active router-link-exact-active">十一、单调栈</a></li><li><a aria-current="page" href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%80%BB%E7%BB%93_.html#十二、额外题目" class="router-link-active router-link-exact-active">十二、额外题目</a></li></ul></nav><h2 id="一、数组" tabindex="-1"><a class="header-anchor" href="#一、数组" aria-hidden="true">#</a> 一、数组</h2><p>数组和链表是数组结构中的基本数据结构。数组的特点是查询方便，链表的特点是插入/删除方便。还有个特点是，数组一般长度固定，二链表长度可以扩展。在存储方面的特点是，数组元素连续存储，链表元素不连续。</p><p>数组是存放在连续内存空间上的想同类型数据的集合。数组的特点是元素下标从0开始，元素存储空间连续。数组的元素不能删，只能覆盖。</p><p>二维数组在内存中如何存储的？对于cpp而言，二维数组在内存空间中也是连续存储的。对于Java而言，同一行下的数组元素存储式连续的，二不同行之间的数据不是连续存储的。类似于哈希表一样，用链表将多个行数组串联起来。</p><p>在数组部分的知识点有：</p><ul><li>二分查找</li><li>移除元素</li><li>有序数组的平方</li><li>长度最小的子数组</li><li>螺旋矩阵2</li></ul><h3 id="_1-1-二分查找" tabindex="-1"><a class="header-anchor" href="#_1-1-二分查找" aria-hidden="true">#</a> 1.1 二分查找</h3><p>前提必须是有序、不重复数组才能使用二分查找（已经按照从小到大或者从大到小的顺序排好了）。通过将数组中间元素值作为分割点，将数组分割为两部分，来减小一半的搜索量。通过比较数组中间元素值和target值，来更新left和right索引值。</p><p>这里强调无重复元素是因为一旦有重复元素就会使得二分查找的返回值不唯一。二分查找的关键在于边界条件的框定。区间的定义是不变量，在循环过程中要遵循循环不变量原则。如果一开始就定义区间为左闭右闭，那就在循环中移植保持这种状态不改变。</p><ol><li>第一种写法：左闭右闭。定义target在[left,right]区间中，所以有以下两点：</li></ol><ul><li><code>while(left &lt;= right) </code>要用<code> &lt;=</code> ，因为<code>left == right</code>是有意义的；</li><li><code>if (nums[middle] &gt; target)</code> 目标值偏小，搜索区间选择左侧子空间。那么right要赋值为<code>middle-1</code>，因为当前这个<code>nums[middle]</code>一定不是target，那么接下来要查找的左侧子区间的右端下标位置就从<code>middle-1</code>开始。</li></ul><ol start="2"><li>第二种写法：左闭右开。定义target在[left,right )区间中，所以有以下两点：</li></ol><ul><li><code>while(left &lt; right)</code> 要用 &lt; ，因为<code>left == right</code>是没有意义的，数组值不能够取值right；</li><li><code>if (nums[middle] &gt; target) </code>目标值偏小，搜索区间选择左侧子空间。那么right要赋值为middle，因为当前这个<code>nums[middle]</code>不等于target，那么接下来要查找的左侧子区间的右端下标位置就从middle开始。</li></ul><h3 id="_1-2-移除元素" tabindex="-1"><a class="header-anchor" href="#_1-2-移除元素" aria-hidden="true">#</a> 1.2 移除元素</h3><p><strong>问题描述</strong>：给你一个数组和一个val，你需要原地移除数组中所有值等于val的元素，并返回移除后数组的新长度。要求：不能使用额外的数组空间，你必须使用O(1)额外空间并原地修改输入数组。例如，给定数组nums=[0,1,2,3,0,2,1,0,9,8,0,3],val=0,则新数组为[1,2,3,2,1,9,8,3]，返回长度为8。当然，返回数组的元素是否需要保存原有的相对位置并未作出限制。</p><p>如何解决呢？1）使用双层for循环的暴力解法可以解决。外层for循环用来遍历数组，内层for循环用来更新删除元素后面的数组元素，将后面的元素依次向前挪一位来覆盖待删除的元素。时间复杂度为O(n2)。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">removeElement</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span>nums<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">int</span> size <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>val <span class="token operator">==</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> size<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
					nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		i<span class="token operator">--</span><span class="token punctuation">;</span> <span class="token comment">//因为下标i以后的数据往前挪了一位，所以i也往前挪一位</span>
		size<span class="token operator">--</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span> 
	<span class="token keyword">return</span> size<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>//上述代码的时间复杂度为O(n^2)，空间复杂度为O(1)。</p><p>2）使用双指针法。通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。<strong>快指针</strong>：遍历整个数组，用来寻找新数组的元素，新数组就是不含目标元素值的数组。<strong>慢指针</strong>：指向更新后的新数组最后元素的下标。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> fastIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> fastIndex <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> fastIndex<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>val <span class="token operator">!=</span> nums<span class="token punctuation">[</span>fastIndex<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	nums<span class="token punctuation">[</span>slowIndex<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>fastIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>//上述代码的时间复杂度为O(n)，空间复杂度为O(1)。</p><h3 id="_1-3-有序数组的平方" tabindex="-1"><a class="header-anchor" href="#_1-3-有序数组的平方" aria-hidden="true">#</a> 1.3 有序数组的平方</h3><p>在这部分，主要考虑不管是包含负数还是不包含负数，数组元素的平方最大值一定在两端，绝不会在中间。所以对于题目要求的给定一个非递减顺序排序的整数数组，返回每个元素的平方组成的新数组，要求也按照非递减的顺序排序。可以确定的是，平方后的元素最大值一定在两端，所以最后的结果数组可以先从nums.size()-1元素先填值，最后在填充nums[0]的值。综上所述，有：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">sortedSquares</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span>A<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">result</span><span class="token punctuation">(</span>A<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> k <span class="token operator">=</span> A<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> – <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token comment">//注意：这里要i &lt;= j，因为最后要处理两个元素</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token keyword">int</span> j <span class="token operator">=</span> A<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> A<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i <span class="token operator">&lt;=</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">*</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> A<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">*</span>A<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
				result<span class="token punctuation">[</span>k<span class="token operator">--</span><span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">*</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
				i<span class="token operator">++</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token keyword">else</span> <span class="token punctuation">{</span>
			result<span class="token punctuation">[</span>k<span class="token operator">--</span><span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">*</span>A<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
			j<span class="token operator">--</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>双指针法的时间复杂度为O(n)。</p><p>补充说明：暴力解法：先平方，再排序。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">sortedSquares</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> A<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> A<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">*=</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">sort</span><span class="token punctuation">(</span>A<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>A<span class="token punctuation">,</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//快速排序</span>
	<span class="token keyword">return</span> A<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>时间复杂度为<code>O(n+nlogn)</code>，可以说是<code>O(nlogn)</code>。</p><h3 id="_1-4-长度最小的子数组" tabindex="-1"><a class="header-anchor" href="#_1-4-长度最小的子数组" aria-hidden="true">#</a> 1.4 长度最小的子数组</h3><p><strong>题目</strong>：给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。例如输入：s = 7, nums = [2,3,1,2,4,3] 输出：2 解释：子数组 [4,3] 是该条件下的长度最小的子数组。</p><p>先介绍暴力解法：使用双层for循环来求解。外层for[i]循环用来遍历整个数组，内层for[j]循环从i开始遍历，直至元素之和大于等于s后才停止，然后此时就计算单次数组长度subLength，并更新整体最小数组长度result。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">minSubArrayLen</span><span class="token punctuation">(</span><span class="token keyword">int</span> s<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token operator">&amp;</span>nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token keyword">int</span> result <span class="token operator">=</span> INT32_MAX<span class="token punctuation">;</span>
<span class="token keyword">int</span> subLength <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>i <span class="token punctuation">;</span> j<span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		sum <span class="token operator">+=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">&gt;=</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			subLength <span class="token operator">=</span> j<span class="token operator">-</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
			result <span class="token operator">=</span> result <span class="token operator">&lt;</span> subLength <span class="token operator">?</span> result <span class="token operator">:</span> subLength<span class="token punctuation">;</span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token keyword">return</span> result <span class="token operator">==</span> INT32_MAX<span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>前面讲了暴力算法是用两个for循环来实现的，外层的for[i]的作用是遍历整个数组并提供窗口的起始位置，内层for[j]的作用设置满足条件的窗口终止位置。这样的缺点就是时间复杂度高，为O(n2)。类似的，我们可以考虑用滑动窗口来替换一个for循环，降低时间复杂度。那个滑动窗口的起始点如何确定呢？</p><p>接下来就开始介绍数组操作中另一个重要的方法：滑动窗口。所谓滑动窗口，<strong>就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果</strong>。</p><p>在暴力解法中，是一个for循环滑动窗口的起始位置，一个for循环为滑动窗口的终止位置，用两个for循环完成了一个不断搜索区间的过程。那么滑动窗口如何用一个for循环来完成这个操作呢。首先要思考如果用一个for循环，那么应该表示滑动窗口的起始位置，还是终止位置。</p><p>如果用for[i]来指定滑动窗口的起始位置，那最终就会陷入暴力算法的怪圈，所以for[i]应当是来指定滑动窗口的终止位置。</p><blockquote><p>滑动窗口的终止位置（如何移动）：由for[i]指定，就是遍历数组的指针 滑动窗口内的元素：满足其和大于等于s条件最短子数组 滑动窗口的起始条件（如何移动）：如果窗口内的元素之和大于等于s之后，需要向前进来缩小窗口内的值。</p></blockquote><p>下面这段代码就是滑动窗口，此代码的精髓就在于动态调节滑动窗口的起始位置：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">while</span><span class="token punctuation">(</span>sum <span class="token operator">&gt;=</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	subLength <span class="token operator">=</span> j – i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//取子序列的长度</span>
	result <span class="token operator">=</span> result <span class="token operator">&lt;</span> subLength <span class="token operator">?</span> result <span class="token operator">:</span> subLength<span class="token punctuation">;</span>
	sum <span class="token operator">-=</span> nums<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//这里体现出滑动窗口的精髓之处，不断变更i（子序列的起始位置）</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用滑动窗口法（单for循环）来解题：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">minSubArrayLen</span><span class="token punctuation">(</span><span class="token keyword">int</span> s<span class="token punctuation">,</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token operator">&amp;</span>nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">int</span> subLength <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> result <span class="token operator">=</span> INT32_MAX<span class="token punctuation">;</span>
	<span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//窗口的起始位置</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		sum<span class="token operator">+=</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>sum <span class="token operator">&gt;=</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			subLength <span class="token operator">=</span> j – i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
			result <span class="token operator">=</span> result <span class="token operator">&lt;</span> subLength <span class="token operator">?</span> result <span class="token operator">:</span> subLength<span class="token punctuation">;</span>
			sum<span class="token operator">-=</span>nums<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 这里体现出滑动窗口的精髓之处，不断变更i（子序列的起始位置）</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> result <span class="token operator">==</span> INT32_MAX <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_1-5-螺旋矩阵2" tabindex="-1"><a class="header-anchor" href="#_1-5-螺旋矩阵2" aria-hidden="true">#</a> 1.5 螺旋矩阵2</h3><p><strong>题目</strong>：给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。例如，给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。</p><p>这道题目可以说在面试中出现频率较高的题目，本题并不涉及到什么算法，就是模拟过程，但却十分考察对代码的掌控能力。</p><p>在之前二分查找法中就提到过的循环不变量原则，这里同样适用。这里是模拟顺时针画矩阵的过程：</p><ul><li>填充上行从左到右；</li><li>填充右行从上到下；</li><li>填充下行从右到左；</li><li>填充左行从下到上；</li></ul><p>由外向内一圈一圈这样画下去。这里一圈下来，我们要画每四条边，这四条边怎么画，每画一条边都要坚持一致的左闭右开，或者左开右闭的原则，这样这一圈才能按照统一的规则画下来。下图是按照左闭右开的原则来画的。</p><div align="center"><img src="https://s3.bmp.ovh/imgs/2023/03/24/eea1feac93f415db.png"></div> 最后，整体cpp代码如下所示： <div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> <span class="token function">generateMatrix</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> <span class="token function">res</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 使用vector定义一个二维数组</span>
	<span class="token keyword">int</span> startx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> starty <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 定义每循环一个圈的起始位置</span>
	<span class="token keyword">int</span> loop <span class="token operator">=</span>n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token comment">//每个圈循环几次，例如n为奇数3，那么loop=1只是循环一圈，矩阵中间的值需要单独处理</span>
	<span class="token keyword">int</span> mid <span class="token operator">=</span> n <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 矩阵中间的位置，例如：n为3， 中间的位置就是(1，1)，n为5，中间位置为(2, 2)</span>
	<span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 用来给矩阵中每一个空格赋值</span>
	<span class="token keyword">int</span> offset <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 需要控制每一条边遍历的长度，每次循环右边界收缩一位</span>
	<span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>loop <span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		i <span class="token operator">=</span> startx<span class="token punctuation">;</span>
		j <span class="token operator">=</span> starty<span class="token punctuation">;</span>
		<span class="token comment">// 下面开始的四个for就是模拟转了一圈</span>
		<span class="token comment">// 模拟填充上行从左到右(左闭右开)</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> starty<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n <span class="token operator">-</span> offset<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			res<span class="token punctuation">[</span>startx<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> count<span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token comment">// 模拟填充右列从上到下(左闭右开)</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> startx<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> offset<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			res<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> count<span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token comment">// 模拟填充下行从右到左(左闭右开)</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> j <span class="token operator">&gt;</span> starty<span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			res<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> count<span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token comment">// 模拟填充左列从下到上(左闭右开)</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> i <span class="token operator">&gt;</span> startx<span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			res<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> count<span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token comment">// 第二圈开始的时候，起始位置要各自加1，例如：第一圈起始位置是(0, 0)，第二圈起始位置是(1, 1)</span>
		startx<span class="token operator">++</span><span class="token punctuation">;</span>
		starty<span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token comment">// offset 控制每一圈里每一条边遍历的长度</span>
		offset <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// 如果n为奇数的话，需要单独给矩阵最中间的位置赋值</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		 res<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">=</span> count<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_1-6-总结篇" tabindex="-1"><a class="header-anchor" href="#_1-6-总结篇" aria-hidden="true">#</a> 1.6 总结篇</h3><p>数组是非常基础的数据结构，它是存放在连续内存空间上的相同类型数据的集合。需要注意的是，数组下标从0开始，且数组内存空间地址都是连续的。正因为数组在内存空间上的地址是连续的，所以在增删元素时就难免需要移动其他元素。数组元素不能删除，只能覆盖。对于二维数组，在cpp中是连续存储的，而Java中单行数组是连续存储的，而行与行之间是连接在一个链表上，并非连续存储。所以Java的二维数组在内存中不是完全连续的地址空间，而是由（行数）条连续地址空间构成，每个连续地址空间的长度是列数。</p><div align="center"><img src="https://s3.bmp.ovh/imgs/2023/03/24/f9f79f108b25c45d.png"></div> 数组基础的一些经典题目有二分查找、双指针法、滑动窗口法还有模拟行为。 <div align="center"><img src="https://s3.bmp.ovh/imgs/2023/03/24/65074287759d1295.png"></div> ## 二、链表 链表与数组一样，都是线性结构，不过数组各个元素之间是连续存储，而链表是分散存储。也正因为该特性，链表在增删方面的效率要高于数组，但是相对的在查找方面的效率要低于数组。链表的种类有：单链表、双向链表、循环链表。循环链表可以用来解决约瑟夫环问题。 <p>约瑟夫环问题：0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。<strong>例如</strong>：0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p><p>链表的定义(//单链表)：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">ListNode</span> <span class="token punctuation">{</span>
	<span class="token keyword">int</span> val<span class="token punctuation">;</span>
	ListNode <span class="token operator">*</span>next<span class="token punctuation">;</span>
	<span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">val</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">//节点的构造函数</span>
<span class="token punctuation">}</span>；
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意，你也可以不定义构造函数，cpp会自动生成默认的构造函数，但该构造函数不会初始化任何成员变量。使用默认的构造函数来初始化节点：<code>ListNode* head = new ListNode(),head-&gt;val = 5</code>。使用自定的节点构造函数则为：<code>ListNode* head = new ListNode(5)</code>;所以，对于使用默认的构造函数，是不能再定义时直接赋值的。链表的头指针是一定存在的，它指向第一个节点，是链表的标志。头结点不一定存在，<strong>但是如果头结点存在，那么操作第一个节点的增删就和其他节点的增删操作是一样的了</strong>。如果在链表的listcreat创建函数中有开辟空间的操作，一般就是有头结点的（例如以前写的C语言链表操作）。在这里的cpp代码中链表的创建是通过结构体和new操作的，没有创建额外的空间，是没有头结点的。头结点就是在头指针和第一个节点之间，添加的节点值为无效值的节点。</p><p><strong>链表的操作</strong>：删除节点、增加节点。对于C/cpp的链表删除节点操作，最好要进行内存的手动释放，避免内存泄漏，而Java和Python无需手动释放。下面是单链表的添加节点和删除节点操作。</p><div align="center"><img src="https://s3.bmp.ovh/imgs/2023/03/24/8564202a88941271.png"></div> F节点为new节点，C节点为p，则**添加**新节点可以表达为1）`new-&gt;next=p-&gt;next;2）p-&gt;next=new`。 <div align="center"><img src="https://s3.bmp.ovh/imgs/2023/03/24/9cb09bc8cb8823ba.png"></div> **删除**节点可以表达为：`if(p-&gt;next-&gt;val == val)，ListNode* tmp=p-&gt;next;1）p-&gt;next=p-&gt;next-&gt;next;2）delete tmp`; <p>循环链表就是头尾相连的链表，将单链表的尾结点的next指针从NULL指向头结点，便使得整个单链表形成了一个环，这种头尾相接的单链表称为单循环链表，简称循环链表。为了使得空链表的处理与非空链表一致，我们通常设置一个头结点，但是不是说循环链表一定要头结点，这点要注意。</p><p>其实，循环链表与单链表的差异就在循环的判断条件上，原来试试判断<code>p-&gt;next==NULL</code>，现在是判断<code>p-&gt;next</code>等于头结点，则循环结束。</p><p>对循环链表进行改造，使用尾指针而非头指针，可以使得对尾结点的访问为O(1)，并且对头结点的访问也是O(1)。举个程序的例子，需要将两个循环链表合并为一个链表时，使用为指针就十分方便了。</p><div align="center"><img src="https://s3.bmp.ovh/imgs/2023/03/24/ef20cbea2d6919e6.png"></div><div align="center"><img src="https://s3.bmp.ovh/imgs/2023/03/24/28e9daa9809379b3.png"></div> 使用以下代码块来实现： ```cpp p=rearA-&gt;next; //保存A表的头结点，即① rearA-&gt;next=rearB-&gt;next-&gt;next; //舍弃B表的头结点，将本是指向B表的第一个节点（不是头结点）赋值给rearA-&gt;next，即② rearB-&gt;next=p; //将原来A表的头结点赋值给rearB-&gt;next，即③ free(p); //释放p ``` 双向链表就是在单链表的基础上新增了一个向前的指针，有双指针prior和next，还可以组合成双向循环链表。另外，对于双向链表，节点后继的前驱、节点前驱的后继都是节点本身，如：`p-&gt;next-&gt;prior=p=p-&gt;prior-&gt;next`。下面开始介绍双向链表的插入和删除操作。 <p>我们假设存储元素e的新节点为s，要将新节点插入到节点p和p-&gt;next之间有以下几步，如下图所示。</p><div align="center"><img src="https://s3.bmp.ovh/imgs/2023/03/24/cd2a6675b201a79d.png"></div> 代码块如下所示： ```cpp s-&gt;prior=p; s-&gt;next=p-&gt;next; p-&gt;next-&gt;prior=s; p-&gt;next=s; ``` 关键点在于它们的顺序，由于最后三步都用到了p-&gt;next，所以如果第四步先执行会出错。注意：如果把第四步提前，会失去对a~i+1~节点的控制，造成插入节点出错的问题。 <div align="center"><img src="https://s3.bmp.ovh/imgs/2023/03/24/d5b28bb5a3bf7c52.png"></div> 代码块如下所示： ```cpp p-&gt;prior-next=p-&gt;next; //仔细观察，删除节点p对外指向的指针不需要变动 p-&gt;next-&gt;prior=p-&gt;prior;//主要变动指向节点p的指针，即ai-1-&gt;next和ai+1-&gt;prior free(p); ``` ### 2.1移除链表元素 **题意**：删除链表中等于给定值 val 的所有节点 <p>注意：对于含头结点的节点删除，第一个节点的操作与其他节点的操作是一致的；对于不含头结点的节点删除，删除第一个节点的操作就是头指针后移+第一个节点内存释放。下面是cpp代码示例。</p><p><strong>直接使用原来的链表进行节点删除操作</strong></p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>ListNode<span class="token operator">*</span> <span class="token function">removeElements</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token comment">// 删除头结点</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>head <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> head<span class="token operator">-&gt;</span>val <span class="token operator">==</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 注意这里不是if</span>
	ListNode<span class="token operator">*</span> tmp <span class="token operator">=</span> head<span class="token punctuation">;</span>
	head <span class="token operator">=</span> head<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	<span class="token keyword">delete</span> tmp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 删除非头结点</span>
ListNode<span class="token operator">*</span> cur <span class="token operator">=</span> head<span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> cur<span class="token operator">-&gt;</span>next<span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>val <span class="token operator">==</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		ListNode<span class="token operator">*</span> tmp <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
		cur<span class="token operator">-&gt;</span>next <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
		<span class="token keyword">delete</span> tmp<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
	cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">return</span> head<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>直接使用原来的链表进行节点删除操作</strong></p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>ListNode<span class="token operator">*</span> <span class="token function">removeElements</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	ListNode<span class="token operator">*</span> dummyHead <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 设置一个虚拟头结点</span>
	dummyHead<span class="token operator">-&gt;</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span> <span class="token comment">// 将虚拟头结点指向head，这样方面后面做删除操作</span>
	ListNode<span class="token operator">*</span> cur <span class="token operator">=</span> dummyHead<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>next <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>val <span class="token operator">==</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			ListNode<span class="token operator">*</span> tmp <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
			cur<span class="token operator">-&gt;</span>next <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
			<span class="token keyword">delete</span> tmp<span class="token punctuation">;</span>
		<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
			cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	head <span class="token operator">=</span> dummyHead<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	<span class="token keyword">delete</span> dummyHead<span class="token punctuation">;</span>
	<span class="token keyword">return</span> head<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-2-设计链表" tabindex="-1"><a class="header-anchor" href="#_2-2-设计链表" aria-hidden="true">#</a> 2.2 设计链表</h3><p><strong>题意</strong>：设计一个基本的链表类，它应当具有以下功能：</p><ul><li><code>get(index)</code>：获取链表中第index个节点的值。如果索引无效，则返回-1。</li><li><code>addAtHead(val)</code>：在链表的第一个元素之前添加一个值为val的节点。插入后，新节点将成为链表的第一个节点。</li><li><code>addAtTail(val)</code>：将值为val的节点追加到链表的最后一个元素。</li><li><code>addAtIndex(index,val)</code>：在链表中的第index个节点之前添加值为val的节点。如果index等于链表的长度，则该节点将附加到链表的末尾。如果index大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。</li><li><code>deleteAtIndex(index)</code>：如果索引index有效，则删除链表中的第index个节点。</li></ul><p>示例：</p><div align="center"><img src="https://s3.bmp.ovh/imgs/2023/03/24/ee4506ef4a51361b.png"></div><p>这道题目设计链表的五个接口：</p><ul><li>获取链表第index个节点的数值</li><li>在链表的最前面插入一个节点</li><li>在链表的最后面插入一个节点</li><li>在链表第index个节点前面插入一个节点</li><li>删除链表的第index个节点</li></ul><p>可以说这五个接口，已经覆盖了链表的常见操作，是练习链表操作非常好的一道题目。</p><p><strong>链表操作的两种方式</strong></p><ol><li>直接使用原来的链表进行操作</li><li>设置一个虚拟的头结点在进行操作</li></ol><p>下面分别是cpp和C语言的链表设计：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">/*************cpp实现链表设计****************/</span>
<span class="token keyword">class</span> <span class="token class-name">MyLinkedList</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
<span class="token comment">// 定义链表节点结构体</span>
<span class="token keyword">struct</span> <span class="token class-name">LinkedNode</span> <span class="token punctuation">{</span>
	<span class="token keyword">int</span> val<span class="token punctuation">;</span>
	LinkedNode<span class="token operator">*</span> next<span class="token punctuation">;</span>
	<span class="token function">LinkedNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">val</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// 初始化链表</span>
<span class="token function">MyLinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	_dummyHead <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">LinkedNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 这里定义的头结点是一个虚拟头结点，而不是真正的链表头结点</span>
	_size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 获取到第index个节点数值，如果index是非法数值直接返回-1， 注意index是从0开始的，第0个节点就是头结点</span>
<span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">&gt;</span> <span class="token punctuation">(</span>_size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">||</span> index <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	LinkedNode<span class="token operator">*</span> cur <span class="token operator">=</span> _dummyHead<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>index<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">// 如果--index 就会陷入死循环</span>
		cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> cur<span class="token operator">-&gt;</span>val<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 在链表最前面插入一个节点，插入完成后，新插入的节点为链表的新的头结点</span>
<span class="token keyword">void</span> <span class="token function">addAtHead</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	LinkedNode<span class="token operator">*</span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">LinkedNode</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
	newNode<span class="token operator">-&gt;</span>next <span class="token operator">=</span> _dummyHead<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	_dummyHead<span class="token operator">-&gt;</span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
	_size<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 在链表最后面添加一个节点</span>
<span class="token keyword">void</span> <span class="token function">addAtTail</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	LinkedNode<span class="token operator">*</span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">LinkedNode</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
	LinkedNode<span class="token operator">*</span> cur <span class="token operator">=</span> _dummyHead<span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>next <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	cur<span class="token operator">-&gt;</span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
	_size<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 在第index个节点之前插入一个新节点，例如index为0，那么新插入的节点为链表的新头节点。</span>
<span class="token comment">// 如果index 等于链表的长度，则说明是新插入的节点为链表的尾结点</span>
<span class="token comment">// 如果index大于链表的长度，则返回空</span>
<span class="token comment">// 如果index小于0，则在头部插入节点</span>
<span class="token keyword">void</span> <span class="token function">addAtIndex</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>index <span class="token operator">&gt;</span> _size<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>index <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        
	LinkedNode<span class="token operator">*</span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">LinkedNode</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
	LinkedNode<span class="token operator">*</span> cur <span class="token operator">=</span> _dummyHead<span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>index<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	newNode<span class="token operator">-&gt;</span>next <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	cur<span class="token operator">-&gt;</span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
	_size<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//删除第index个节点，如果index大于等于链表的长度，直接return，注意index是从0开始的</span>
<span class="token keyword">void</span> <span class="token function">deleteAtIndex</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">&gt;=</span> _size <span class="token operator">||</span> index <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	LinkedNode<span class="token operator">*</span> cur <span class="token operator">=</span> _dummyHead<span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>index<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		cur <span class="token operator">=</span> cur <span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	LinkedNode<span class="token operator">*</span> tmp <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	cur<span class="token operator">-&gt;</span>next <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	<span class="token keyword">delete</span> tmp<span class="token punctuation">;</span>
	_size<span class="token operator">--</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 打印链表</span>
<span class="token keyword">void</span> <span class="token function">printLinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	LinkedNode<span class="token operator">*</span> cur <span class="token operator">=</span> _dummyHead<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>next <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		cout <span class="token operator">&lt;&lt;</span> cur<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>val <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span><span class="token punctuation">;</span>
		cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _size<span class="token punctuation">;</span>
	LinkedNode<span class="token operator">*</span> _dummyHead<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面是用C语言来实现链表：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">/*************C语言实现链表设计****************/</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">MyLinkedList</span> <span class="token punctuation">{</span>
	<span class="token keyword">int</span> val<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">MyLinkedList</span><span class="token operator">*</span> next<span class="token punctuation">;</span>
<span class="token punctuation">}</span>MyLinkedList<span class="token punctuation">;</span>
<span class="token comment">/**在这里初始化你的结构体数据**/</span>
MyLinkedList<span class="token operator">*</span> <span class="token function">myLinkedListCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token comment">//这个题必须用虚拟头指针,参数都是一级指针,头节点确定后没法改指向了!!!</span>
	MyLinkedList<span class="token operator">*</span> head <span class="token operator">=</span> <span class="token punctuation">(</span>MyLinkedList <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span> <span class="token punctuation">(</span>MyLinkedList<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	head<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> head<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">/**根据索引获取到链表的值**/</span>
<span class="token keyword">int</span> <span class="token function">myLinkedListGet</span><span class="token punctuation">(</span>MyLinkedList<span class="token operator">*</span> obj<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	MyLinkedList <span class="token operator">*</span>cur <span class="token operator">=</span> obj<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> cur <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> index<span class="token punctuation">)</span><span class="token punctuation">{</span>
			<span class="token keyword">return</span> cur<span class="token operator">-&gt;</span>val<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span><span class="token punctuation">{</span>
			cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">/**在头节点前添加新节点**/</span>
<span class="token keyword">void</span> <span class="token function">myLinkedListAddAtHead</span><span class="token punctuation">(</span>MyLinkedList<span class="token operator">*</span> obj<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	MyLinkedList <span class="token operator">*</span>nhead <span class="token operator">=</span> <span class="token punctuation">(</span>MyLinkedList <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span> <span class="token punctuation">(</span>MyLinkedList<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	nhead<span class="token operator">-&gt;</span>val <span class="token operator">=</span> val<span class="token punctuation">;</span>
	nhead<span class="token operator">-&gt;</span>next <span class="token operator">=</span> obj<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	obj<span class="token operator">-&gt;</span>next <span class="token operator">=</span> nhead<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">/**在尾部插入新节点**/</span>
<span class="token keyword">void</span> <span class="token function">myLinkedListAddAtTail</span><span class="token punctuation">(</span>MyLinkedList<span class="token operator">*</span> obj<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	MyLinkedList <span class="token operator">*</span>cur <span class="token operator">=</span> obj<span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>next <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	MyLinkedList <span class="token operator">*</span>ntail <span class="token operator">=</span> <span class="token punctuation">(</span>MyLinkedList <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span> <span class="token punctuation">(</span>MyLinkedList<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	ntail<span class="token operator">-&gt;</span>val <span class="token operator">=</span> val<span class="token punctuation">;</span>
	ntail<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
	cur<span class="token operator">-&gt;</span>next <span class="token operator">=</span> ntail<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">/**在指定索引节点后插入，如果索引值为0表示头插，如果索引值大于长度就插入无效*/</span>
<span class="token keyword">void</span> <span class="token function">myLinkedListAddAtIndex</span><span class="token punctuation">(</span>MyLinkedList<span class="token operator">*</span> obj<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">myLinkedListAddAtHead</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	MyLinkedList <span class="token operator">*</span>cur <span class="token operator">=</span> obj<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span>cur <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> index<span class="token punctuation">)</span><span class="token punctuation">{</span>
			MyLinkedList<span class="token operator">*</span> newnode <span class="token operator">=</span> <span class="token punctuation">(</span>MyLinkedList <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span> <span class="token punctuation">(</span>MyLinkedList<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			newnode<span class="token operator">-&gt;</span>val <span class="token operator">=</span> val<span class="token punctuation">;</span>
			newnode<span class="token operator">-&gt;</span>next <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
			cur<span class="token operator">-&gt;</span>next <span class="token operator">=</span> newnode<span class="token punctuation">;</span>
			<span class="token keyword">return</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span><span class="token punctuation">{</span>
			cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">/** 按索引来删除节点，删除索引值后的一个节点 **/</span>
<span class="token keyword">void</span> <span class="token function">myLinkedListDeleteAtIndex</span><span class="token punctuation">(</span>MyLinkedList<span class="token operator">*</span> obj<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		MyLinkedList <span class="token operator">*</span>tmp <span class="token operator">=</span> obj<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>tmp <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
			obj<span class="token operator">-&gt;</span>next <span class="token operator">=</span> tmp<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
			<span class="token function">free</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>     
	 	<span class="token punctuation">}</span>
		<span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	MyLinkedList <span class="token operator">*</span>cur <span class="token operator">=</span> obj<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span>cur <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> cur<span class="token operator">-&gt;</span>next <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> index<span class="token punctuation">)</span><span class="token punctuation">{</span>
			MyLinkedList <span class="token operator">*</span>tmp <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>tmp <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
				cur<span class="token operator">-&gt;</span>next <span class="token operator">=</span> tmp<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
				<span class="token function">free</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">return</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span><span class="token punctuation">{</span>
			cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">myLinkedListFree</span><span class="token punctuation">(</span>MyLinkedList<span class="token operator">*</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>obj <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		MyLinkedList <span class="token operator">*</span>tmp <span class="token operator">=</span> obj<span class="token punctuation">;</span>
		obj <span class="token operator">=</span> obj<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
		<span class="token function">free</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">/**
 *你可以如此调用你的程序:
 * MyLinkedList* obj = myLinkedListCreate();
 * int param_1 = myLinkedListGet(obj, index);
 * myLinkedListAddAtHead(obj, val);
 * myLinkedListAddAtTail(obj, val);
 * myLinkedListAddAtIndex(obj, index, val);
 * myLinkedListDeleteAtIndex(obj, index);
 * myLinkedListFree(obj);
*/</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-3-翻转链表" tabindex="-1"><a class="header-anchor" href="#_2-3-翻转链表" aria-hidden="true">#</a> 2.3 翻转链表</h3><p><strong>题意</strong>：翻转链表，即输入：1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL 输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL <strong>思路</strong>：关键在于链表next指针的翻转。</p><div align="center"><img src="https://s3.bmp.ovh/imgs/2023/03/24/abb4acd8d087c152.png"></div> + 首先定义一个cur指针，指向头结点，再定义一个pre指针，初始化为null。 + 然后就要开始反转了，首先要把 cur-&gt;next 节点用tmp指针保存一下，也就是保存一下这个节点。 + 为什么要保存一下这个节点呢，因为接下来要改变 cur-&gt;next 的指向了，将cur-&gt;next 指向pre ，此时已经反转了第一个节点了。 + 接下来，就是循环走如下代码逻辑了，继续移动pre和cur指针。 + 最后，cur 指针已经指向了null，循环结束，链表也反转完毕了。 此时我们return pre指针就可以了，pre指针就指向了新的头结点。 <!---->：<div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>ListNode<span class="token operator">*</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	ListNode<span class="token operator">*</span> tmp<span class="token punctuation">;</span> <span class="token comment">//保存cur的下一个节点</span>
	ListNode<span class="token operator">*</span> cur <span class="token operator">=</span> head<span class="token punctuation">;</span>
	ListNode<span class="token operator">*</span> pre <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	tmp <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	cur<span class="token operator">-&gt;</span>next <span class="token operator">=</span> pre<span class="token punctuation">;</span> 	<span class="token comment">// 翻转操作</span>
	pre <span class="token operator">=</span> cur<span class="token punctuation">;</span>
	cur <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> pre<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><!---->：<p>递归法相对抽象一些，但是其实和双指针法是一样的逻辑，同样是当cur为空的时候循环结束，不断将cur指向pre的过程。 关键是初始化的地方，可能有的同学会不理解，可以看到双指针法中初始化 cur = head，pre = NULL，在递归法中可以从如下代码看出初始化的逻辑也是一样的，只不过写法变了。<strong>双指针法写出来之后，理解如下递归写法就不难了，代码逻辑都是一样的</strong>。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>ListNode<span class="token operator">*</span> <span class="token function">reverse</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> pre<span class="token punctuation">,</span>ListNode<span class="token operator">*</span> cur<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>cur <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> pre<span class="token punctuation">;</span>
	ListNode <span class="token operator">*</span>tmp <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	cur<span class="token operator">-&gt;</span>next <span class="token operator">=</span> pre<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token function">reverse</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
ListNode<span class="token operator">*</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们可以发现，上面的递归写法和双指针法实质上都是从前往后翻转指针指向，其实还有另外一种与双指针法不同思路的递归写法：从后往前翻转指针指向。</p><!---->：<div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>ListNode<span class="token operator">*</span> <span class="token function">reverseList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">//边缘条件检测</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>head<span class="token operator">-&gt;</span>next <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token punctuation">)</span> <span class="token keyword">return</span> head<span class="token punctuation">;</span>
	<span class="token comment">//递归调用</span>
	ListNode<span class="token operator">*</span> last <span class="token operator">=</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>head<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>
	head<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>
	head<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> last<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><!---->：<div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>ListNode<span class="token operator">*</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	ListNode<span class="token operator">*</span> dumpyHead <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	dumpyHead<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
	ListNode<span class="token operator">*</span> cur <span class="token operator">=</span> head<span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>cur<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		ListNode<span class="token operator">*</span> tmp <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
		<span class="token comment">//头插法：把第一个节点拆下来，插在虚拟头结点后头；把第二个节点拆下来，再插在虚拟头结点后头。就实现节点1和2的翻转，后面的类似操作即可。</span>
		<span class="token comment">//感觉和双指针法差不多，cur指向当前，tmp保存cur-&gt;next，然后cur指向pre，最后pre由cur更新，cur由tmp更新。而这里的虚拟头插法相当于把pre换成了虚拟头dumptHead。</span>
		cur<span class="token operator">-&gt;</span>next <span class="token operator">=</span> dumpyHead<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
		dumpyHead <span class="token operator">-&gt;</span>next <span class="token operator">=</span> cur<span class="token punctuation">;</span>
		cur <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> dumpyHead <span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><!---->：<p>首先把所有节点入栈，然后cur指向虚拟头结点，再然后循环出栈，每出来一个元素就把它加入到虚拟头结点为头结点的链表当中，最后返回即可。</p><p><strong>采用这种方法需要注意一点。就是当整个出栈循环结束以后，cur正好指向原来链表的第一个结点，而此时结点1中的next指向的是结点2，因此最后还需要<code>cur.next = null</code></strong>。</p><div align="center"><img src="https://s3.bmp.ovh/imgs/2023/03/24/f35d9150f6961bd6.png"></div><figure><img src="https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlHgdz7m76yDUi9PH/root/content" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>注意</strong>：代码随想录的上述原代码在力扣实际测试时，有些问题，更正为上述代码后正常运行（实际上网站提供的是Java代码，我改成了cpp，所以有些方法名不对头）。例如在STL中的栈名字叫stack而非Stack，且没有isEmpty()方法而是empty()方法。此外第三点就是pop()方法的返回值是void，要想获取栈顶值应当使用top()方法，在使用pop()方法弹出元素。</p><h3 id="_2-4-两两交换链表中的节点" tabindex="-1"><a class="header-anchor" href="#_2-4-两两交换链表中的节点" aria-hidden="true">#</a> 2.4 两两交换链表中的节点</h3><p><strong>题目</strong>：给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。<em>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换</em>。</p><p>示例：</p><div align="center"><img src="https://s3.bmp.ovh/imgs/2023/03/24/a14cd19641a753e9.png"></div> 对于输入head=[1,2,3,4],输出为[2,1,4,3] <p><strong>思路</strong>：建议使用虚拟头结点，这样会方便很多，要不然每次针对头结点（没有前一个指针指向头结点），还要单独处理。 <img src="https://s3.bmp.ovh/imgs/2023/03/24/c5275104b2c0b5f5.png" alt="两两交换链表中的节点--程序设计示意图" loading="lazy"></p><p>仔细分析上述示意图，可以知道至少需要两个tmp临时指针来保存节点指针才能正确实现“每两个节点进行一次互换”的操作，cpp代码如下：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>ListNode<span class="token operator">*</span> <span class="token function">swapPairs</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	ListNode<span class="token operator">*</span> dummyHead <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	dummyHead<span class="token operator">-&gt;</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>
	ListNode<span class="token operator">*</span> cur <span class="token operator">=</span> dummyHead<span class="token punctuation">;</span><span class="token comment">//设置虚拟节点，并为cur指针赋初始值</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>next<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token operator">&amp;&amp;</span>cur<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>next<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		ListNode<span class="token operator">*</span> tmp <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span> <span class="token comment">//cur后的第一个节点</span>
		ListNode<span class="token operator">*</span> tmp2 <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span><span class="token comment">//cur后的第三个节点</span>
		
		cur<span class="token operator">-&gt;</span>next <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span> <span class="token comment">//步骤一</span>
		cur<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>next <span class="token operator">=</span> tmp<span class="token punctuation">;</span> <span class="token comment">//步骤二</span>
		cur<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>next <span class="token operator">=</span> tmp2<span class="token punctuation">;</span> <span class="token comment">//步骤三</span>
		
		cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> dummyHead<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	<span class="token comment">//时间复杂度O(n)，空间复杂度O(1)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>【关于<!---->】</p><p>在代码随想录二叉树递归遍历那一章，讲了一下递归的三要素：</p><ol><li><p><strong>确定递归函数的参数和返回值</strong>： 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</p></li><li><p><strong>确定终止条件</strong>： 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。</p></li><li><p><strong>确定单层递归的逻辑</strong>： 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</p></li></ol><p>下面以本次两两交换链表中的节点为例，再来强化一遍。本次递归程序设计中，1）递归的参数和返回值都是链表头指针。2）终止条件就是链表访问结束，有NULL。就是cur-&gt;next和cur-&gt;next-&gt;next为NULL。3）单层递归的逻辑，就是每两个节点为一对，1）本对的第一个节点指向下一对，2）对内，第二个节点指向第一个节点，3）第二个节点坐标作为一个结构体返回。下图是程序设计示意图。</p><figure><img src="https://s3.bmp.ovh/imgs/2023/03/24/67a571af0d281e5a.png" alt="程序设计示意图" tabindex="0" loading="lazy"><figcaption>程序设计示意图</figcaption></figure><p>C语言实现两两交换链表中的节点（递归版本)</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">//单链表的格式为：</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">node</span> <span class="token punctuation">{</span>
	<span class="token keyword">int</span> val<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">node</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span>ListNode<span class="token punctuation">;</span>
<span class="token comment">//递归版本 （该代码认为链表没有头结点，第一个head节点就是有效节点）</span>
ListNode<span class="token operator">*</span> <span class="token function">swapPairs</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token comment">//递归结束条件：头节点不存在或头节点的下一个节点不存在。此时不需要交换，直接返回head</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>head <span class="token operator">||</span> <span class="token operator">!</span>head<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span>
		<span class="token keyword">return</span> head<span class="token punctuation">;</span>
	<span class="token comment">//创建一个节点指针类型保存头结点下一个节点</span>
	ListNode<span class="token operator">*</span> newHead <span class="token operator">=</span> head<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	<span class="token comment">//更改头结点+2位节点后的值，并将头结点的next指针指向这个更改过的list</span>
	head<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token function">swapPairs</span><span class="token punctuation">(</span>newHead<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//将新的头结点的next指针指向老的头节点</span>
	newHead<span class="token operator">-&gt;</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>
	<span class="token keyword">return</span> newHead<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>C语言实现两两交换链表中的节点（迭代版本）</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">//迭代版本</span>
<span class="token keyword">struct</span> <span class="token class-name">ListNode</span><span class="token operator">*</span> <span class="token function">swapPairs</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ListNode</span><span class="token operator">*</span> head<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">//使用双指针避免使用中间变量</span>
    <span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">ListNode</span> ListNode<span class="token punctuation">;</span>
    ListNode <span class="token operator">*</span>fakehead <span class="token operator">=</span> <span class="token punctuation">(</span>ListNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>ListNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    fakehead<span class="token operator">-&gt;</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>
    ListNode<span class="token operator">*</span> right <span class="token operator">=</span> fakehead<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
    ListNode<span class="token operator">*</span> left <span class="token operator">=</span> fakehead<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&amp;&amp;</span> right <span class="token operator">&amp;&amp;</span> right<span class="token operator">-&gt;</span>next <span class="token punctuation">)</span><span class="token punctuation">{</span>
        left<span class="token operator">-&gt;</span>next <span class="token operator">=</span> right<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
        right<span class="token operator">-&gt;</span>next <span class="token operator">=</span> left<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
        left<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>next <span class="token operator">=</span> right<span class="token punctuation">;</span>
        left <span class="token operator">=</span> right<span class="token punctuation">;</span>
        right <span class="token operator">=</span> left<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> fakehead<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-5-删除链表的倒数第n个节点" tabindex="-1"><a class="header-anchor" href="#_2-5-删除链表的倒数第n个节点" aria-hidden="true">#</a> 2.5 删除链表的倒数第N个节点</h3><p><strong>题意</strong>：删除链表的倒数第N个节点</p><p><strong>思路</strong>：采用双指针的方法来实现：定义两个指针，fast指针先走N+1步，然后slow指针再走。当fast指针走到NULL时，slow指针刚好就在待删除节点的前一个节点。</p><h3 id="_2-6-链表相交" tabindex="-1"><a class="header-anchor" href="#_2-6-链表相交" aria-hidden="true">#</a> 2.6 链表相交</h3><p><strong>题意</strong>：给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。</p><p>题目数据 保证 整个链式结构中不存在环。注意，函数返回结果后，链表必须 保持其原始结构 。图示两个链表在节点 c1 开始相交： <img src="https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlEiHrW36nF7-bhD4/root/content" alt="" loading="lazy"><strong>思路</strong>：采用双指针的方法来解决，考虑到两链表相交一定是在后面有相同点，所以1）将两链表尾端对齐，2）然后长链表的指针移动（两个链表长度之差的）距离，3）循环，判断什么时候两指针相等。此时我们就可以比较curA和curB是否相同，如果不相同，同时向后移动curA和curB，如果遇到curA == curB，则找到交点。如果<code>curA == NULL</code>则说明链表不相交思路如下图所示：</p><figure><img src="https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlEn2uZpsaGxK5jgn/root/content" alt="链表相交的思路" tabindex="0" loading="lazy"><figcaption>链表相交的思路</figcaption></figure><p>cpp代码示例：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>ListNode <span class="token operator">*</span><span class="token function">getIntersectionNode</span><span class="token punctuation">(</span>ListNode <span class="token operator">*</span>headA<span class="token punctuation">,</span> ListNode <span class="token operator">*</span>headB<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        ListNode<span class="token operator">*</span> curA <span class="token operator">=</span> headA<span class="token punctuation">;</span>
        ListNode<span class="token operator">*</span> curB <span class="token operator">=</span> headB<span class="token punctuation">;</span>
        <span class="token keyword">int</span> lenA <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> lenB <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>curA <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 求链表A的长度</span>
            lenA<span class="token operator">++</span><span class="token punctuation">;</span>
            curA <span class="token operator">=</span> curA<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>curB <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 求链表B的长度</span>
            lenB<span class="token operator">++</span><span class="token punctuation">;</span>
            curB <span class="token operator">=</span> curB<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        curA <span class="token operator">=</span> headA<span class="token punctuation">;</span>
        curB <span class="token operator">=</span> headB<span class="token punctuation">;</span>
        <span class="token comment">// 让curA为最长链表的头，lenA为其长度</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>lenB <span class="token operator">&gt;</span> lenA<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">swap</span> <span class="token punctuation">(</span>lenA<span class="token punctuation">,</span> lenB<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">swap</span> <span class="token punctuation">(</span>curA<span class="token punctuation">,</span> curB<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 求长度差</span>
        <span class="token keyword">int</span> gap <span class="token operator">=</span> lenA <span class="token operator">-</span> lenB<span class="token punctuation">;</span>
        <span class="token comment">// 让curA和curB在同一起点上（末尾位置对齐）</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>gap<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            curA <span class="token operator">=</span> curA<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 遍历curA 和 curB，遇到相同则直接返回</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>curA <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>curA <span class="token operator">==</span> curB<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> curA<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            curA <span class="token operator">=</span> curA<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
            curB <span class="token operator">=</span> curB<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意：时间复杂度是O(m+n)</p><h3 id="_2-7-环形链表2" tabindex="-1"><a class="header-anchor" href="#_2-7-环形链表2" aria-hidden="true">#</a> 2.7 环形链表2</h3><p><strong>题意</strong>：环形链表2，这题是给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。为了表示给定链表中的环，使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。【给定一个链表，判断是否有环，有环的话返回环的入口节点地址】</p><p><strong>说明</strong>：不允许修改给定的链表</p><p><strong>示例</strong>：输入：head = [3,2,0,-4], pos = 1 ; 输出 tail connects to node index 1 ; 解释：链表中有一个环，其尾部连接到第二个节点。本示例的图示如下：</p><figure><img src="https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlEpR5iFQiiqqWqzH/root/content" alt="示例" tabindex="0" loading="lazy"><figcaption>示例</figcaption></figure><p><strong>思路</strong>：这道题不仅要考链表操作，还考察数学运算。主要考察两个知识点：</p><ul><li>判断链表是否有环；</li><li>如果有环，如何找到这个环的入口</li></ul><p>1）<strong>判断链表是否有环</strong></p><p>方法：可以使用快慢指针法，分别定义 fast 和 slow 指针，从头结点出发，fast指针每次移动两个节点，slow指针每次移动一个节点，如果 fast 和 slow指针在途中相遇 ，说明这个链表有环。</p><p>原理：首先第一点：<strong>fast指针一定先进入环中，如果fast指针和slow指针相遇的话，一定是在环中相遇，这是毋庸置疑的</strong>。其实相对于slow来说，<strong>fast是一个节点一个节点的靠近slow的，所以fast一定可以和slow重合</strong>。</p><figure><img src="https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlEyj6F0jegrnBGxW/root/content" alt="双指针法：判断是否有环" tabindex="0" loading="lazy"><figcaption>双指针法：判断是否有环</figcaption></figure><p>2）<strong>如果有环，如何找到这个环的入口</strong> （要用到数学知识了）</p><p><strong>方法&amp;&amp;原理</strong>：假设从头结点到环形入口节点 的节点数为x。 <strong>环形入口</strong>节点到 fast指针与slow指针<strong>相遇节点</strong>节点数为y。 从相遇节点 再到环形入口节点节点数为 z。 如图所示：</p><figure><img src="https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlE0iChKekHjyQs1F/root/content" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>那么相遇时：slow指针走过的节点数位<code>x+y</code>，fast指针走过的节点数为：<code>x+y+n(y+z)</code>，n为fast指针在环内走了n圈才遇到slow指针， （y+z）为 一圈内节点的个数A。因为fast指针是一步走两个节点，slow指针一步走一个节点， 所以 fast指针走过的节点数 = slow指针走过的节点数 * 2：</p><pre><code>                                    `(x+y)*2 = x+y+n(y+z)`
</code></pre><p>两边消掉一个<code>(x+y)</code>：即：<code>x+y = n (y+z)</code></p><p>因为要找环形的入口，那么要求的是x，因为x表示 头结点到 环形入口节点的的距离。</p><p>所以要求x ，将x单独放在左面：x = n (y + z) - y ,</p><p>再从n(y+z)中提出一个 （y+z）来，整理公式之后为如下公式：x = (n - 1) (y + z) + z 注意这里n一定是大于等于1的，因为 fast指针至少要多走一圈才能相遇slow指针。</p><p>这个公式说明什么呢？</p><p><strong>情况1）</strong>：先拿n为1的情况来举例，意味着fast指针在环形里转了一圈之后，就遇到了 slow指针了。当 n为1的时候，公式就化解为 x = z，这就意味着，<strong>从头结点出发一个指针，从相遇节点 也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是 环形入口的节点</strong>。</p><p>也就是在相遇节点处，定义一个指针index1，在头结点处定一个指针index2。让index1和index2同时移动，每次移动一个节点， 那么他们相遇的地方就是 环形入口的节点。如下面的动图所示：</p><figure><img src="https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlE7bx0qLRJ9_JVDz/root/content" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>情况2）</strong>：那么 n如果大于1是什么情况呢，就是fast指针在环形转n圈之后才遇到 slow指针。</p><p>其实这种情况和n为1的时候 效果是一样的，一样可以通过这个方法找到 环形的入口节点，只不过，index1 指针在环里 多转了(n-1)圈，然后再遇到index2，相遇点依然是环形的入口节点。</p><p>代码如下：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */</span>
<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    ListNode <span class="token operator">*</span><span class="token function">detectCycle</span><span class="token punctuation">(</span>ListNode <span class="token operator">*</span>head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        ListNode<span class="token operator">*</span> fast <span class="token operator">=</span> head<span class="token punctuation">;</span>
        ListNode<span class="token operator">*</span> slow <span class="token operator">=</span> head<span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>fast <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> fast<span class="token operator">-&gt;</span>next <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            slow <span class="token operator">=</span> slow<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
            fast <span class="token operator">=</span> fast<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
            <span class="token comment">// 快慢指针相遇，此时从head 和 相遇点，同时查找直至相遇</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>slow <span class="token operator">==</span> fast<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                ListNode<span class="token operator">*</span> index1 <span class="token operator">=</span> fast<span class="token punctuation">;</span>
                ListNode<span class="token operator">*</span> index2 <span class="token operator">=</span> head<span class="token punctuation">;</span>
                <span class="token keyword">while</span> <span class="token punctuation">(</span>index1 <span class="token operator">!=</span> index2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    index1 <span class="token operator">=</span> index1<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
                    index2 <span class="token operator">=</span> index2<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">return</span> index2<span class="token punctuation">;</span> <span class="token comment">// 返回环的入口</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>补充</strong>：</p><p>在推理过程中，大家可能有一个疑问就是：为什么第一次在环中相遇，slow的步数是 x+y 而不是 x + 若干环的长度 + y 呢？</p><p>首先slow进环的时候，fast一定是先进环来了。如果slow进环入口，fast也在环入口，那么把这个环展开成直线，就是如下图的样子：</p><figure><img src="https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlE_T1DmcUQ4sVEFJ/root/content" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>可以看出如果slow 和 fast同时在环入口开始走，一定会在环入口3相遇，slow走了一圈，fast走了两圈。重点来了，slow进环的时候，fast一定是在环的任意一个位置，如图：</p><figure><img src="https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlFDmQaMBFYVeFEDo/root/content" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>那么fast指针走到环入口3的时候，已经走了k + n 个节点，slow相应的应该走了(k + n) / 2 个节点。</p><p>因为k是小于n的（图中可以看出），所以(k + n) / 2 一定小于n。</p><p>也就是说slow一定没有走到环入口3，而fast已经到环入口3了。</p><p>这说明什么呢？</p><p>在slow开始走的那一环已经和fast相遇了。</p><p>那有同学又说了，为什么fast不能跳过去呢？ 在刚刚已经说过一次了，fast相对于slow是一次移动一个节点，所以不可能跳过去。</p><h3 id="_2-8-总结篇" tabindex="-1"><a class="header-anchor" href="#_2-8-总结篇" aria-hidden="true">#</a> 2.8 总结篇</h3><p>在本章，主要讲了链表的基础知识，讲了链表的基本构造，还有移除链表元素、翻转链表（双指针法或递归法）、两两交换链表中的节点、删除链表的倒数第N个节点、链表相交（双指针法）、环形链表2等题目。上述问题都能通过双指针法解决：</p><ul><li>** 翻转链表**：一个cur指向当前指针，一个pre在前一个指针，还需要tmp指针记录下一次cur跳转的位置。趁cur指向还没改变，先记录tmp即cur的下一跳。然后，原来是pre指向cur的，现在将cur指向pre即可，最后给cur、pre赋值，进行下一次循环；</li><li><strong>两两交换链表中的节点</strong>：两两个节点一对来进行操作，但是为了和下一对联系起来，实际上操作时需要有三个节点参与。同时需要两个临时指针来记录节点1和节点3的地址。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>tmp1 <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
tmp2 <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
cur<span class="token operator">-&gt;</span>next <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
cur<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>next <span class="token operator">=</span> tmp1<span class="token punctuation">;</span>
cur<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>next <span class="token operator">=</span> tmp2<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>删除链表的倒数第N个节点</strong>：双指针法，让fast指针先出发N+1步，然后slow指针再出发。当fast到达NULL时，slow刚好就在待删除节点的前一个位置；</li><li><strong>链表相交</strong>：先求两个链表的长度，然后链表尾端对齐。长链表那个指针先移动两个链表长度之差的步数，然后两个链表指针在同时移动。当两个链表指针相等时，即为找到相交节点地址了；</li><li><strong>环形链表2</strong>：思路是fast指针每次走两步，slow指针每次走一步，如果他两相遇了则存在环。然后，指针index1从头结点出发，指针index2从相遇节点出发，他们两个的再次相遇点就是环的入口节点地址了。</li></ul><p>另外，对于<strong>反转链表</strong>问题，建议先学透迭代法，然后再看递归法，因为递归法比较绕，如果迭代还写不明白，递归基本也写不明白了。</p><p>最后，下图是对上述知识点的总结：</p><figure><img src="https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlFEAlN4E-tIPYtjg/root/content" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="三、哈希表" tabindex="-1"><a class="header-anchor" href="#三、哈希表" aria-hidden="true">#</a> 三、哈希表</h2><h3 id="_3-1-哈希表的理论基础" tabindex="-1"><a class="header-anchor" href="#_3-1-哈希表的理论基础" aria-hidden="true">#</a> 3.1 哈希表的理论基础</h3><p>哈希表，又或称散列表，它是<strong>根据关键码的值而直接进行访问的数据结构</strong>。它主要解决的问题就是元素的快速搜索，用来快速判断一个元素是否出现集合里。直白来讲，数组就是一张哈希表，哈希表的关键码就是数组索引下标，然后通过下标来直接访问数组元素。然后，将元素值映射到哈希表上与特定的关键码对应，就用到了<strong>哈希函数</strong>。</p><p>特点：查找元素的速度很快，但是牺牲了空间来换取时间。</p><p>哈希函数与哈希碰撞，哈希碰撞的解决方法有：拉链法和线性探测法。拉链法：多个元素在一个哈希值上冲突，就把这多个元素做成一个链表插在该位置上；线性探测法：当前位置冲突了，就顺次找下一个不冲突的位置，这种方法就要求哈希表长度必须大于数据个数才行。（略）</p><p>常见的哈希结构：当我们想使用哈希法来解决问题的时候，我们一般会选择如下三种数据结构。</p><ul><li>数组</li><li>set集合</li><li>map映射</li></ul><p>这里数据就没啥好说的了，我们来看看set和map。在cpp中，set 和 map 分别提供以下三种数据结构，其底层实现以及优劣如下表所示：</p><table><thead><tr><th>集合</th><th>底层实现</th><th>是否有序</th><th>数值是否可以重复</th><th>能否更改数值</th><th>查询效率</th><th>增删效率</th></tr></thead><tbody><tr><td>std::set</td><td>红黑树</td><td>有序</td><td>否</td><td>否</td><td>O(log n)</td><td>O(log n)</td></tr><tr><td>std::multiset</td><td>红黑树</td><td>有序</td><td>是</td><td>否</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td>std::unordered_set</td><td>哈希表</td><td>无序</td><td>否</td><td>否</td><td>O(1)</td><td>O(1)</td></tr></tbody></table><p>std::unordered_set底层实现为哈希表，std::set 和std::multiset 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。</p><table><thead><tr><th>映射</th><th>底层实现</th><th>是否有序</th><th>数值是否可以重复</th><th>能否更改数值</th><th>查询效率</th><th>增删效率</th></tr></thead><tbody><tr><td>std::map</td><td>红黑树</td><td>key有序</td><td>key不可重复</td><td>key不可修改</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td>std::multimap</td><td>红黑树</td><td>key有序</td><td>key可重复</td><td>key不可修改</td><td>O(log n)</td><td>O(log n)</td></tr><tr><td>std::unordered_map</td><td>哈希表</td><td>key无序</td><td>key不可重复</td><td>key不可修改</td><td>O(1)</td><td>O(1)</td></tr></tbody></table><p>std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）</p><p>当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset。</p><p>那么再来看一下map ，在map 是一个key value 的数据结构，map中，对key是有限制，对value没有限制的，因为key的存储方式使用红黑树实现的。</p><p>其他语言例如：java里的HashMap ，TreeMap 都是一样的原理。可以灵活贯通。</p><p>虽然std::set、std::multiset 的底层实现是红黑树，不是哈希表，std::set、std::multiset 使用红黑树来索引和存储，不过给我们的使用方式，还是哈希法的使用方式，即key和value。所以使用这些数据结构来解决映射问题的方法，我们依然称之为哈希法。 map也是一样的道理。</p><p>这里在说一下，一些cpp的经典书籍上 例如STL源码剖析，说到了hash_set hash_map，这个与unordered_set，unordered_map又有什么关系呢？</p><p>实际上功能都是一样一样的， 但是unordered_set在cpp11的时候被引入标准库了，而hash_set并没有，所以建议还是使用unordered_set比较好，这就好比一个是官方认证的，hash_set，hash_map 是cpp11标准之前民间高手自发造的轮子。</p><figure><img src="https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlFLHzQIWbM3ru_iG/root/content" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>总结一下，<strong>当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法</strong>。</p><p>但是哈希法也是<strong>牺牲了空间换取了时间</strong>，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。</p><p>如果在做面试题目的时候遇到需要判断一个元素是否出现过的场景也应该第一时间想到哈希法！</p><h3 id="_3-2-有效的字母异位词" tabindex="-1"><a class="header-anchor" href="#_3-2-有效的字母异位词" aria-hidden="true">#</a> 3.2 有效的字母异位词</h3><p><strong>题意</strong>：给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。示例 1: 输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot; 输出: true。示例 2: 输入: s = &quot;rat&quot;, t = &quot;car&quot; 输出: false。<strong>说明</strong>: 你可以假设字符串只包含小写字母。【字母异位词，即字母的种类和个数全部相同，只是字母的位置不相同的两个单词，可以用哈希表或map存储起来比较，得出结论】</p><p><strong>思路</strong>：1）暴力解法就是两层for循环；2）<strong>数组其实就是一个简单哈希表</strong>，而且这道题目中字母串只有小写字符，那么就可以定义一个数组record，来记录字符串s中字符的出现次数，定义数组长度为26。例如：对于字符串a=&quot;aea&quot;，有record[0]=2,record[4]=1；同样的，对于字符串b=&quot;eaa&quot;，也有record[0]=2,record[4]=1。所以字符串a和b是字母异位词。</p><p><strong>步骤</strong>：1）不需要记住具体是哪个字符a-z，只需要判断字符的相对位置，定义数组record[26]，字符&#39;a&#39;对应record[0]，字符record[25]对应&#39;z&#39;。2）在遍历字符串a时，只需要将record[a[i]-&#39;a&#39;]元素值+1即可，并不需要记住字符a的ASCII值。这样就把字符串a中字符出现的次数统计出来了。</p><p>3）在遍历字符串b，将record[b[i]-&#39;a&#39;]的值-1，如果每一个数组元素的值不为0，那就是某个位多了一个字符或少了一个字符，则返回false，如果每一个数组元素都为0，满足题意返回true。</p><p>cpp代码块如下所示：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">bool</span> <span class="token function">isAnagram</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span> string t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> record<span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 并不需要记住字符a的ASCII，只要求出一个相对数值就可以了</span>
        record<span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">&#39;a&#39;</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> t<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	record<span class="token punctuation">[</span>t<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">&#39;a&#39;</span><span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">26</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token keyword">if</span> <span class="token punctuation">(</span>record<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token comment">// record数组如果有的元素不为零0，说明字符串s和t 一定是谁多了字符或者谁少了字符。</span>
    	<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    	<span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token comment">// record数组所有元素都为零0，说明字符串s和t是字母异位词</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-3-两个数组的交集" tabindex="-1"><a class="header-anchor" href="#_3-3-两个数组的交集" aria-hidden="true">#</a> 3.3 两个数组的交集</h3><p><strong>题意</strong>：编写一个函数，来判断两个数组的交集。注意：输出结果中的每个元素应当是唯一的，且不考虑输出结果的顺序。举例：输入nums1=[1,2,2,1]，nums2=[2,2]，输出：[2]；举例2：nums1=[4,9,5]，nums2=[9,4,9,8,4]，输出：[9,4]。</p><p><strong>思路</strong>：注意：前一题使用数组来做哈希表是因为题目限定了数值的大小，元素最大不会超过26。但是这里的话，1）<strong>数值没有明显边界</strong>，不建议使用数组。2）其次，<strong>如果哈希值比较少、特别分散、跨度特别大</strong>，也无法使用数组来做哈希表。</p><p>此时就要使用另一种结构体了，set ，关于set，cpp 给提供了如下三种可用的数据结构：</p><ul><li>std::set</li><li>std::multiset</li><li>std::unordered_set</li></ul><p>std::set和std::multiset底层实现都是红黑树，std::unordered_set的底层实现是哈希表， 使用unordered_set 读写效率是最高的，并不需要对数据进行排序，而且还不要让数据重复，所以选择unordered_set。这里主要是学会使用一种哈希数据结构：<strong>unordered_set</strong>。该数据结构无序、不允许重复。</p><p>思路如下图所示：</p><figure><img src="https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlFN3LVBY8kwU0hs1/root/content" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>Vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">intersection</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums1<span class="token punctuation">,</span> vecotr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	unordered_set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> result_set<span class="token punctuation">;</span> <span class="token comment">//存放结果，之所以用unordered_set是为了去重</span>
	<span class="token comment">//第一步，将nums1将存入unordered_set中，这里是使用迭代器构造</span>
	unordered_set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">nums_set</span><span class="token punctuation">(</span>nums1<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>nums1<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//第二步，比较unordered_set和nums2</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>nums_set<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token operator">!=</span> nums_set<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			result_set<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>result_set<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>result_set<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>无序集合unordered_set内部元素不可重复，没有顺序，值也不可修改。对于无序集合unordered_set，有以下几种初始化方法：</p><ul><li>直接创建空的set：<code>unordered_set&lt;int&gt; set1;</code></li><li>拷贝构造：<code>unordered_set&lt;int&gt; set2(set1);</code></li><li>使用迭代器构造：<code>unordered_set&lt;int&gt; set3(set1.begin(),set1.end());</code></li><li>使用数组作为其初始值进行构造：<code>unordered_set&lt;int&gt; set4(arr,arr+5);</code></li><li>移动构造：<code>unordered_set&lt;int&gt; set5(move(set2));</code></li><li>使用初值列表来进行构造：<code>unordered_set&lt;int&gt; set6 {1,2,10,10};</code></li></ul><p><strong>注意</strong>：学到这，我们已经学习了unordered_set和数组两种哈希数据结构，但是要注意各自存在的缺点，数组对数据的长度有限制，且对于分布离散的数据而言存取效率低。而unordered_set内部元素不重复，不排序，十分适合需要数据去重的情况。但是相对于数组而言，不仅占用空间比数组大，而且速度要比数组慢，set把数值映射到key上都要做hash计算的。</p><p><strong>说明</strong>：后来力扣改了数据，对数组的长度做了限制，数据长度在0~1000，所以可以考虑用数组来做哈希算法。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">intersection</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span>nums1<span class="token punctuation">,</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span>nums2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	unordered_set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> result_set<span class="token punctuation">;</span> <span class="token comment">//选择set是为了去重</span>
	<span class="token keyword">int</span> hash<span class="token punctuation">[</span><span class="token number">1005</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums1<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		hash<span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>hash<span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			result_set<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>result_set<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>result_set<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-4-快乐数" tabindex="-1"><a class="header-anchor" href="#_3-4-快乐数" aria-hidden="true">#</a> 3.4 快乐数</h3><p><strong>题意</strong>:编写一个算法来判断一个数是不是快乐数。<strong>快乐数</strong>：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为 1，那么这个数就是快乐数。</p><p>如果是快乐数就返回True，否则返回False。</p><p><strong>示例</strong>： <code>输入</code>：19 <code>输出</code>：true <code>解释</code>： 1^2 + 9^2 = 82 8^2 + 2^2 = 68 6^2 + 8^2 = 100 1^2 + 0^2 + 0^2 = 1</p><p><strong>思路</strong>:这道题目看上去貌似一道数学问题，其实并不是！题目中说了会<strong>无限循环</strong>，那么也就是说<strong>求和的过程中，sum会重复出现，这对解题很重要</strong>！</p><p>难点1）判断一个数是否重复出现？难点2）就是对一个数每个位上的操作，求和的过程。</p><p><strong>当我们遇到需要快速判断一个元素是否存在与一个集合中时，就要用到哈希算法了</strong>。所以这道题目使用哈希法，来判断这个sum是否重复出现，如果重复了就是return false， 否则一直找到sum为1为止。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">//求每个位上的单数之和</span>
<span class="token keyword">int</span> <span class="token function">getSum</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		sum <span class="token operator">+=</span> <span class="token punctuation">(</span>n <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>n <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		n <span class="token operator">/=</span> <span class="token number">10</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> sum<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">bool</span> <span class="token function">isHappy</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	unordered_set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> set<span class="token punctuation">;</span>
	<span class="token keyword">int</span> n_temp <span class="token operator">=</span> n<span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token function">getSum</span><span class="token punctuation">(</span>n_temp<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
        <span class="token comment">// 如果这个sum曾经出现过，说明已经陷入了无限循环了，立即return false</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>set<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span> <span class="token operator">!=</span> set<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            set<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
		n_temp <span class="token operator">=</span> sum<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-5-两数之和" tabindex="-1"><a class="header-anchor" href="#_3-5-两数之和" aria-hidden="true">#</a> 3.5 两数之和</h3><p><strong>题意</strong>:给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那<strong>两个</strong>整数，并返回他们的数组下标。假设每种输入只会对应一个答案。注意，数组中同一个元素不能使用两遍。例如，给定 nums = [2, 7, 11, 15], target = 9，因为 nums[0] + nums[1] = 2 + 7 = 9，所以返回 [0, 1]。</p><p>在强调一下<strong>什么时候使用哈希法</strong>，当我们需要查询一个元素是否出现过，或者一个元素是否在集合里的时候，就要第一时间想到哈希法。</p><p>本题需要一个集合来存放我们遍历过的元素，然后在遍历数组的时候去询问这个集合，某元素是否遍历过，也就是是否出现在这个集合。</p><p>因为本题中不仅要知道元素的值，还要记录元素的下标索引，所以用map更加合适。</p><p>再来看一下使用数组和set来做哈希法的局限。</p><ul><li><strong>数组</strong>的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。</li><li><strong>set</strong>是一个集合，里面放的元素只能是一个key，而两数之和这道题目，不仅要判断y是否存在而且还要记录y的下标位置，因为要返回x 和 y的下标。所以set 也不能用。</li></ul><p>cpp中的map，有三种类型：</p><table><thead><tr><th><strong>映射</strong></th><th><strong>底层实现</strong></th><th><strong>是否有序</strong></th><th><strong>数值是否可以重复</strong></th><th><strong>能否更改数值</strong></th><th><strong>查询效率</strong></th><th><strong>增删效率</strong></th></tr></thead><tbody><tr><td>std::map</td><td>红黑树</td><td>key有序</td><td>key不可重复</td><td>key不可修改</td><td><code>O(logn)</code></td><td><code>O(logn)</code></td></tr><tr><td>std::mutilmap</td><td>红黑树</td><td>key有序</td><td><!----></td><td>key不可修改</td><td><code>O(logn)</code></td><td><code>O(logn)</code></td></tr><tr><td>std::unordered_map</td><td>红黑树</td><td><!----></td><td>key不可重复</td><td>key不可修改</td><td><code>O(1)</code></td><td><code>O(1)</code></td></tr></tbody></table><p>这道题目中并不需要key有序，选择std::unordered_map 效率更高！</p><p>接下来需要明确两点：</p><ul><li><strong>map用来做什么</strong></li><li><strong>map中key和value分别表示什么</strong></li></ul><p>map目的用来存放我们访问过的元素，因为遍历数组的时候，需要记录我们之前遍历过哪些元素和对应的下标，这样才能找到与当前元素相匹配的（也就是相加等于target）</p><p>map中key和value分别表示什么?这道题 我们需要处理数组的每个元素，判断这个元素是否出现过，如果出现过，返回这个元素的下标。那么判断元素是否出现，这个元素就要作为key，所以数组中的元素作为key，有key对应的就是value，value用来存下标。所以 map中的存储结构为<code>{key：数据元素，value：数组元素对应的下标}</code>。</p><p>在遍历数组的时候，只需要向map去查询是否有和目前遍历元素匹配的数值，如果有，就找到的匹配对，如果没有，就把目前遍历的元素放进map中，因为map存放的就是我们访问过的元素。</p><p>过程如下：</p><figure><img src="https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlFS9JsCzF1wX-qId/root/content" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlFUyAhmd6WUtK3mO/root/content" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">//注意：map的key为元素值，value为元素下标</span>
vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">twoSum</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	std<span class="token double-colon punctuation">::</span>unordered_map <span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">&gt;</span> map<span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token comment">// 遍历当前元素，并在map中寻找是否有匹配的key。找到一个合适的，立即返回</span>
        <span class="token keyword">auto</span> iter <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>target <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
        <span class="token keyword">if</span><span class="token punctuation">(</span>iter <span class="token operator">!=</span> map<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        	<span class="token keyword">return</span> <span class="token punctuation">{</span>iter<span class="token operator">-&gt;</span>second<span class="token punctuation">,</span> i<span class="token punctuation">}</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token comment">// 如果没找到匹配对，就把访问过的元素和下标加入到map中</span>
		map<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">pair</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
	<span class="token punctuation">}</span>
	<span class="token comment">//循环结束后还没return说明没找到，就返回空vector</span>
	<span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>总结</strong>: 本题其实有四个重点：</p><ul><li>为什么会想到用哈希表</li><li>哈希表为什么用map</li><li>本题map是用来存什么的</li><li>map中的key和value用来存什么的</li></ul><p>本题的目的就是从一个数组中找到两个不同的元素，要求他们的和满足target。换句话说，我们拧着一个元素，然后在map中去找<code>target - 元素值</code>，如果找到了就直接返回。如果没找到，就将当前元素值存入map，然后进入下一次循环。最终循环结束后，没有返回return，说明没找到。</p><h3 id="_3-6-四数相加2" tabindex="-1"><a class="header-anchor" href="#_3-6-四数相加2" aria-hidden="true">#</a> 3.6 四数相加2</h3><p><strong>题意</strong>：给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -2^28 到 2^28 - 1 之间，最终结果不会超过 2^31 - 1 。</p><p>例如：</p><p>输入：</p><ul><li>A = [ 1, 2] B = [-2,-1] C = [-1, 2] D = [ 0, 2]</li></ul><p>输出：</p><ul><li>2</li></ul><p><strong>解释</strong>：两个元组如下：</p><ol><li>(0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0</li><li>(1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0</li></ol><p><strong>思路</strong>：本题是使用哈希法的经典题目，而后面的<strong>三数之和</strong>、<strong>四数之和</strong>并不适合使用哈希法。因为三数之和和四数之和这两道题目使用哈希法在不超时的情况下做到对结果去重是很困难的，很有多细节需要处理。</p><p>而这道题目是四个独立的数组，只要找到A[i] + B[j] + C[k] + D[l] = 0就可以，不用考虑有重复的四个元素相加等于0的情况，所以相对于题目18. 四数之和，题目15.三数之和，还是简单了不少！</p><p>如果本题想难度升级：就是给出一个数组（而不是四个数组），在这里找出四个元素相加等于0，答案中不可以包含重复的四元组，大家可以思考一下，后续的文章我也会讲到的。</p><p><strong>本题解题步骤</strong>：</p><ol><li>首先定义 一个unordered_map，key放a和b两数之和，value 放a和b两数之和出现的次数。</li><li>遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中。</li><li>定义int变量count，用来统计 a+b+c+d = 0 出现的次数。</li><li>在遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就用count把map中key对应的value也就是出现次数统计出来。</li><li>最后返回统计值 count 就可以了</li></ol><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">//这道题相对于“四数之和”，简单点在于不需要去重。本次时间复杂度为O(n^2)</span>
<span class="token keyword">int</span> <span class="token function">fourSumCount</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> A<span class="token punctuation">,</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> B<span class="token punctuation">,</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> C<span class="token punctuation">,</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> D<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">&gt;</span> umap<span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> a <span class="token operator">:</span> A<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> b <span class="token operator">:</span> B<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			umap<span class="token punctuation">[</span>a<span class="token operator">+</span>b<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> c <span class="token operator">:</span> C<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> d <span class="token operator">:</span> D<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>umap<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">-</span><span class="token punctuation">(</span>c<span class="token operator">+</span>d<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> umap<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
				count <span class="token operator">+=</span> umap<span class="token punctuation">[</span><span class="token number">0</span><span class="token operator">-</span><span class="token punctuation">(</span>c<span class="token operator">+</span>d<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> count<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-7-赎金信" tabindex="-1"><a class="header-anchor" href="#_3-7-赎金信" aria-hidden="true">#</a> 3.7 赎金信</h3><p><strong>题意</strong>：给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串 ransom 能不能由第二个字符串 magazines 里面的字符构成。如果可以构成，返回 true ；否则返回 false。</p><p>(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。杂志字符串中的每个字符只能在赎金信字符串中使用一次。)</p><p>注意：</p><p>你可以假设两个字符串均只含有小写字母，下面三个是示例： <code>canConstruct(&quot;a&quot;, &quot;b&quot;) -&gt; false</code><code>canConstruct(&quot;aa&quot;, &quot;ab&quot;) -&gt; false</code><code>canConstruct(&quot;aa&quot;, &quot;aab&quot;) -&gt; true</code></p><p><strong>思路</strong>：这道题和“有效的字母异位词”很像。<strong>字母异位词</strong>是字符串a和b的字符类型和数量应当完全相同，才能相互组成，而这里只需要保证字符串a中的字符类型和数量<code>&lt;=</code>字符串b中的字符类型和数量，即字符串b完全能组成a，而a能否组成b不需要考虑。</p><p>方法1：暴力解法，直接用双重for循环解决。外层循环是长字符串，内层循环是短字符串，每找到一个字符，就在对应位置删除掉短字符串上对应的字符，当短字符串长度为0时，返回true，否则返回false。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">bool</span> <span class="token function">canConstruct</span><span class="token punctuation">(</span>string ransomNote<span class="token punctuation">,</span> string magazine<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> magazine<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> ransomNote<span class="token punctuation">.</span><span class="token function">lenth</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>magazine<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> ransomNote<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
				ransomNote<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>ransomNote<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">break</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>ransomNote<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token comment">//这里时间复杂度是比较高的O(n^2)，而且里面还有一个字符串删除也就是erase的操作，也是费时的</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>方法2：哈希解法（大的是magazine，小的字符串是ransomNote）</p><p>因为题目所只有小写字母，那可以采用空间换取时间的哈希策略， 用一个长度为26的数组还记录magazine里字母出现的次数。然后再用ransomNote去验证这个数组是否包含了ransomNote所需要的所有字母。一般来说，哈希数据结构的话，能用数组就用数组。使用map的空间消耗要比数组大一些的，因为map要维护红黑树或者哈希表，而且还要做哈希函数，是费时的！数据量大的话就能体现出来差别了。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">//补充说明：string容器求长度用length()或size()方法都可以</span>
<span class="token keyword">bool</span> <span class="token function">canConstruct</span><span class="token punctuation">(</span>string ransomNote<span class="token punctuation">,</span> string magazine<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">int</span> record<span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>ransomNote<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> magazine<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> magazine<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		record<span class="token punctuation">[</span>magazine<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token char">&#39;a&#39;</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> ransomNote<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		record<span class="token punctuation">[</span>ransomNote<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">-</span><span class="token char">&#39;a&#39;</span><span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>record<span class="token punctuation">[</span>ransomNote<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">-</span><span class="token char">&#39;a&#39;</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-8-三数之和" tabindex="-1"><a class="header-anchor" href="#_3-8-三数之和" aria-hidden="true">#</a> 3.8 三数之和</h3><p><strong>题意</strong>：给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。 <strong>注意</strong>：答案中不可以包含重复的三元组。<strong>再次注意</strong>：注意[0,0,0,0]这组数据。</p><p>示例：给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ]</p><p><strong>回忆</strong>：两数之和也是在一个数组中找到两个不同的元素，其和为target。该题的做法建立一个map数据结构，key为元素值，value为下标索引。然后遍历每个元素，在map中寻找是否存在[target-key]的值存在；如果存在就找到，直接返回；如果不存在就将当前元素存入map，继续遍历。遍历结束后仍为返回就return {}空vector。</p><p><strong>解法1）哈希法</strong>（不推荐）：</p><p>两层for循环就可以确定 a 和b 的数值了，可以使用哈希法来确定 0-(a+b) 是否在 数组里出现过，其实这个思路是正确的，但是我们有一个非常棘手的问题，就是题目中说的不可以包含重复的三元组。把符合条件的三元组放进vector中，然后再去重，这样是非常费时的，很容易超时，也是这道题目通过率如此之低的根源所在。</p><p>时间复杂度可以做到O(n^2)，但还是比较费时的，因为不好做剪枝操作。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> <span class="token function">threeSum</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> result<span class="token punctuation">;</span>
	unordered_set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> set<span class="token punctuation">;</span>
	<span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token comment">// 排序之后如果第一个元素已经大于零，那么不可能凑成三元组</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//三元组元素a去重</span>
			<span class="token keyword">continue</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span> j <span class="token operator">&gt;</span> i <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
				<span class="token keyword">continue</span><span class="token punctuation">;</span> <span class="token comment">//三元组的元素b去重</span>
			<span class="token punctuation">}</span>
		<span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">0</span> <span class="token operator">-</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>set<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">!=</span> set<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			result<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token punctuation">{</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>c<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			set<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//三元组去重c</span>
		<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
			set<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>解法2）双指针</strong>：</p><p>动画效果如下：</p><figure><img src="https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlFh1FaSArZZ1UxyE/root/content" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>拿这个nums数组来举例，首先将数组排序，然后有一层for循环，i从下标0的地方开始，同时定一个下标left 定义在i+1的位置上，定义下标right 在数组结尾的位置上。依然还是在数组中找到 abc 使得a + b +c =0，我们这里相当于 a = nums[i]，b = nums[left]，c = nums[right]。</p><p>接下来如何移动left 和right呢？1） 如果nums[i] + nums[left] + nums[right] &gt; 0 就说明 此时三数之和大了，因为数组是排序后了，所以right下标就应该向左移动，这样才能让三数之和小一些。2）如果 nums[i] + nums[left] + nums[right] &lt; 0 说明 此时 三数之和小了，left 就向右移动，才能让三数之和大一些，直到left与right相遇为止。时间复杂度：O(n^2)。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> <span class="token function">threeSum</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> result<span class="token punctuation">;</span>
	<span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 排序之后如果第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，直接返回结果就可以了</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> result<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 错误去重a方法，将会漏掉-1,-1,2 这种情况</span>
        <span class="token comment">/*
        if (nums[i] == nums[i + 1]) {
        continue;
        }
        */</span>
        <span class="token comment">// 正确去重a方法</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">int</span> left <span class="token operator">=</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>right <span class="token operator">&gt;</span> left<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token comment">// 去重复逻辑如果放在这里，0，0，0 的情况，可能直接导致 right&lt;=left 了，从而漏掉了 0,0,0 这种三元组	</span>
			<span class="token comment">/*
			while (right &gt; left &amp;&amp; nums[right] == nums[right - 1]) right--;
			while (right &gt; left &amp;&amp; nums[left] == nums[left + 1]) left++;
			*/</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> right<span class="token operator">--</span><span class="token punctuation">;</span>
			<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> left<span class="token operator">++</span><span class="token punctuation">;</span>
			<span class="token keyword">else</span> <span class="token punctuation">{</span>
				result<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token comment">//去重逻辑应该放在找到一个三元组后，对b和c去重</span>
				<span class="token keyword">while</span><span class="token punctuation">(</span>right <span class="token operator">&gt;</span> left <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>right<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> right<span class="token operator">--</span><span class="token punctuation">;</span>
				<span class="token keyword">while</span><span class="token punctuation">(</span>right <span class="token operator">&gt;</span> left <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>left<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> left<span class="token operator">++</span><span class="token punctuation">;</span>
				找到答案时，双指针同时收缩
				left<span class="token operator">++</span><span class="token punctuation">;</span>
				right<span class="token operator">--</span><span class="token punctuation">;</span>			
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>去重逻辑的思考</strong>：</p><p><strong>a的去重</strong>：</p><p>说到去重，其实主要考虑三个数的去重。 a, b ,c, 对应的就是 nums[i]，nums[left]，nums[right]。</p><p>a 如果重复了怎么办，a是nums里遍历的元素，那么应该直接跳过去。但这里有一个问题，是判断 nums[i] 与 nums[i + 1]是否相同，还是判断 nums[i] 与 nums[i-1] 是否相同。有同学可能想，这不都一样吗。其实不一样！都是和 nums[i]进行比较，是比较它的前一个，还是比较他的后一个。如果我们的写法是：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">continue</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那就我们就把三元组中出现重复元素的情况直接pass掉了。 例如{-1, -1 ,2} 这组数据，当遍历到第一个-1 的时候，判断下一个也是-1，那这组数据就pass了。这样就会出现漏判。<strong>我们要做的是不能有重复的三元组，但三元组内的元素是可以重复的！</strong> 那么应该这么写：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">continue</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这么写就是当前使用 nums[i]，我们判断前一位是不是一样的元素，在看 {-1, -1 ,2} 这组数据，当遍历到 第一个 -1 的时候，只要前一位没有-1，那么 {-1, -1 ,2} 这组数据一样可以收录到结果集里。</p><p><strong>b与c的去重</strong>：</p><p>类似于a的考虑，遍历b和c的时候，是不是也需要在每一步进行去重呢？代码如下：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">while</span> <span class="token punctuation">(</span>eight <span class="token operator">&gt;</span> left<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		right<span class="token operator">--</span><span class="token punctuation">;</span>
		<span class="token comment">//while(left &lt; right &amp;&amp; nums[right]==nums[right+1]) right--;</span>
	<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		left<span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token comment">//while(left &lt; eight &amp;&amp; nums[left] == nums[left-1]) left++;</span>
	<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
		<span class="token comment">//Todo</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上文注释掉的部分就是思考的过程，似乎按照a的思路，在每次遍历的时候，需要与前一个已经遍历过的值进行比较，若相同就需要去重（不能与后一个值进行比较去重，不然会丢失诸如-1，-1，2这组值）。但仔细观察又会发现，b和c遍历的过程本身就是去重的过程，在遍历b和c时，如果三数之和大于0，则按照规则应该是右指针right左移++，类似的，下一次循环时，如果righ是重复值，也会走这个if语句，继续right++。所以遍历时就已经去重，不需要额外在用while来去重了（上述代码中被注释掉的部分）。</p><p><strong>思考</strong>：</p><p>既然三数之和可以使用哈希法和双指针法，那我们之前讲过的两数之和可以使用双指针法吗？</p><p><strong>回忆</strong>：两数之和：从一个数组中找到两个不同的值，其和为target。只需要找到一组答案即可。<strong>解法</strong>：以元素值为map的key，以元素下标作为map的value，建立哈希数据结构unordered_map来求解。遍历整个数组，如果找到<code>map.find(target-nums[i])!=map.end()</code>，就直接返回<code>vector&lt;int&gt;{iter-&gt;second,i}</code>；如果未找到就将当前<code>nums[i]</code>和<code>i</code>存入<code>ma</code>p并进行下一次循环。循环结束后仍为<code>return</code>就直接返回空<code>vector{}</code>，表示未找到。</p><p>本题三数之和也是从一个数组中找多个不同元素满足其和为target，但是本体的返回结果有多个且不允许重复。所以单纯使用哈希法来求解需要多考虑去重的问题，更麻烦。那两数之和能用双指针法求解吗？<strong>不能</strong>：因为两数之和返回的是元素下标，而在本题中使用双指针法必须对数组元素进行排序，一旦排序，下标就变了。如果两数之和的题目改成返回元素值那么就可以使用双指针法。</p><h3 id="_3-9-四数之和" tabindex="-1"><a class="header-anchor" href="#_3-9-四数之和" aria-hidden="true">#</a> 3.9 四数之和</h3><p><strong>题意</strong>：给定一个数组nums和一个target目标值，判断nums中是否存在四个元素满足其和为target，找出所有满足条件且不重复的四元组。</p><p><strong>注意</strong>：</p><p>答案中不可以包含重复的四元组。示例： 给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。 满足要求的四元组集合为： [ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2] ]</p><p><strong>回忆</strong>：前面两数之和、三数之和都是从一个数组中找到k个元素满足其和为target，两数之和是找到任意一对且返回元素下标；三数之和是找到全部且返回的是由元素组成的vector。还有四数之和2是从四个数组中分别找到四个数满足其和为target的条件，且返回的值是满足条件的元组个数。</p><p><strong>回忆2</strong>：四数之和2是采用的哈希法，a组和b组用双for循环和unordered_map来统计，c组和d组也用双for循环和unordered_map[0-(a+b)]来找符合条件的元组，并统计个数，最后的返回值是满足条件的元组个数。</p><p><strong>思路</strong>：</p><p>四数之和，和15.三数之和是一个思路，都是使用双指针法, 基本解法就是在15.三数之和的基础上再套一层for循环。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> <span class="token function">fourSum</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> result<span class="token punctuation">;</span>
	<span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>k<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token comment">//剪枝处理</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">&gt;</span> target <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">&gt;=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
			<span class="token keyword">break</span><span class="token punctuation">;</span><span class="token comment">//这里使用break统一最后return处理</span>
		<span class="token punctuation">}</span>
		<span class="token comment">//对nums[k]去重</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>k<span class="token operator">&gt;</span><span class="token number">0</span><span class="token operator">&amp;&amp;</span>nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>k<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token keyword">continue</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token comment">//2级剪枝处理</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&gt;</span>target <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&gt;=</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment">//已经不满足条件了</span>
			<span class="token punctuation">}</span>
			<span class="token comment">//对nums[i]去重</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">&gt;</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>nms<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>nums<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
				<span class="token keyword">continue</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			
			<span class="token keyword">int</span> left<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
			<span class="token keyword">int</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
			<span class="token keyword">while</span><span class="token punctuation">(</span>right <span class="token operator">&gt;</span> left<span class="token punctuation">)</span> <span class="token punctuation">{</span>
				<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">&gt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
					right<span class="token operator">--</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
					left<span class="token operator">++</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                    result<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">while</span><span class="token punctuation">(</span>righ<span class="token operator">&gt;</span>left <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">==</span>nums<span class="token punctuation">[</span>left<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                        left<span class="token operator">++</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                    <span class="token keyword">while</span><span class="token punctuation">(</span>right<span class="token operator">&gt;</span>left <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token operator">==</span> nums<span class="token punctuation">[</span>right<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        right<span class="token operator">--</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                    right<span class="token operator">--</span><span class="token punctuation">;</span>
                    left<span class="token operator">++</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-10-总结" tabindex="-1"><a class="header-anchor" href="#_3-10-总结" aria-hidden="true">#</a> 3.10 总结</h3><p>在哈希表这部分，我们主要介绍了数据、集合和映射三种哈希数据结构，并解决了字母异位词、两个数组交集、快乐数、四数相加2、书尽心和两数之和、三数之和、四数之和等问题。</p><p>数组作为最基础最简单的哈希数据结构，应用简单且广泛，但也有它的局限性。首先，他只适合于数据长度有限且分布不要太过分散的情况。如果数据分散的太开，反而会造成效率和内存上的浪费。unordered_set（注：set和mutilset使用的是红黑树，unordered_set使用的是哈希表）就没有数据长度上的限制了，但是它的存储数据知识值类型，对于既要存储数组元素值又要存储数组下标的情况就得使用map映射了。类似的，只有unordered_map的底层是使用的哈希表，map和mutilmap使用的都是红黑树。使用map或set既要维护哈希表（或红黑树），又要去做哈希函数，所以效率上肯定是比不过数组的。综上，三种数据结构各有优劣，应该要视情况来选定。</p><p>字母异位词和赎金信都是字母，而且还是小写字母，这样的话用长度为26的字符数组来做哈希算法的话就很容易了。这两者不同的是，字母异位是两个字符串的字符种类和数量要完全相同，而赎金信则是b的字符和数量要大于等于字符串a才行。</p><p>快乐数是求一个数的每一位上数值的平方值和，其和是否为1，若不为1就再次进行计算。如果最终为1了就是快乐数，如果后面陷入了死循环就是非快乐数。这里的数据长度不固定，不能用数组，且数组为单一数值类型，还有解题的关键点在于从已有数据中找某个元素，因此选用哈希法解题，且使用unordered_set来解决。</p><p>两个数组的交集，这题也是使用unordered_set来解题。先将nums1数组中的元素全部存入set中，然后在遍历数组nums2，查看nums2中的元素是否在set中，存在就加入result，最后再返回return result即可。</p><p>四数相加2是从四个数组中找四个数，要找满足这四个数之和为target的元组个数。这里可以使用哈希法解决，且又要记录元素又要记录次数，所以采用unordered_map的数据结构。数组a和B使用双层for循环来统计（a+b)和的次数，如：<code>umap[a+b]++;</code>，初始化count值，然后数组c和d组成一个双层for循环，在umap中寻找满足元素值等于<code>target-(c+d)</code>的键值对，并用count变量将该键值对的值累加，最后返回count即可。</p><p>两数之和、三数之和、四数之和都是从一个数组里面，找k个不重复的元素，要求其和为target。两数之和要求找出至少一队并返回该元组，三数之和、四数之和要求返回所有满足条件且不重复的元组集合。</p><ul><li>两数之和因为只需找出一队，且返回的是元素下标，所以采用unordered_map来求解。遍历数组，如果在umap中找到了满足条件<code>umap.find(target-nums[i])</code>的元素，就返回<code>vector&lt;int&gt;{i,iter-&gt;second}</code>，否则就将当前元素存入umap:<code>map.insert(pair&lt;int,int&gt;(nums[i],i))</code>。</li><li>三数之和可以使用哈希法，但是针对去重这个问题就比较麻烦。1）哈希法：第一层for，索引为i，从0到nums.size()-1;第二层for，索引为j，从i+1到nums.size()-1；然后在定义一个uset，从这个uset里面找满足条件<code>0-(nums[i]+nums[j])</code>的元素，找到了就插入到result中，代码片段如：<code>1/int c=0-nums[i]-nums[j]；2/if(uset.find(c)!=set.end()) 3/result.push_back({nums[i],nums[j],c});</code>(代码中还有对元素a,b,c的去重操作，这里未展示)。2）使用双指针法：使用双指针法的时间复杂度也是O(n^2)，但没有使用umap，少去了维护哈希表和做哈希映射的操作，更加高效。第一层for，索引为i，从0到nums.size()-1；定义left为i+1;定义right为nums.size()-1;然后第二层while(left&lt;right)循环。在第二层循环中做这几样事：1/判断三数之和是否大于target，是的话就让right--；2/判断三数之和是否小于target，是的话就让left++；3/三数之和恰好等于target，满足题意，存入result(代码中还有对元素a,b,c的去重操作，这里未展示)。</li><li>四数之和类似的道理，只不过增加了一层循环。第一层for，索引为i，从0到nums.size()-1；第二层for，索引为j，从i+1到nums.size()-1；然后定义left为j+1;定义right为nums.size()-1;然后第三层while(left&lt;right)循环。</li></ul><h2 id="四、字符串" tabindex="-1"><a class="header-anchor" href="#四、字符串" aria-hidden="true">#</a> 四、字符串</h2><h3 id="_4-1-反转字符串1" tabindex="-1"><a class="header-anchor" href="#_4-1-反转字符串1" aria-hidden="true">#</a> 4.1 反转字符串1</h3><p><strong>题意</strong>：对于用char[]给出的字符串，如果反转字符串，使用输入[&#39;H&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;]，输出[&#39;o&#39;,&#39;l&#39;,&#39;l&#39;,&#39;e&#39;,&#39;H&#39;]?且要求不分配额外的内存空间。</p><p><strong>思路</strong>：可以直接用库函数reverse()解决，但是有些场合不建议直接套用库函数。这里的反转字符串和反转链表很像，可以用双指针法解决。使用swap()函数来调换两个字符。</p><p>swap有两种实现方式：1）使用tmp变量的值替换和2）通过为运算。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">//1、值替换</span>
<span class="token keyword">int</span> tmp<span class="token operator">=</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>tmp<span class="token punctuation">;</span>
<span class="token comment">//2、位运算</span>
s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">^=</span> s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
s<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">^=</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">^=</span> s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最终的cpp代码如下：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">reverseString</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>j<span class="token operator">=</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">,</span>j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_4-2-反转字符串2" tabindex="-1"><a class="header-anchor" href="#_4-2-反转字符串2" aria-hidden="true">#</a> 4.2 反转字符串2</h3><p><strong>题意</strong>： 给定一个字符串 s 和一个整数 k，从字符串开头算起, 每计数至 2k 个字符，就反转这 2k 个字符中的前 k 个字符。如果剩余字符少于 k 个，则将剩余字符全部反转。如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。</p><p>示例：</p><p>输入：s=&quot;abcdefg&quot;,k=2</p><p>输出：&quot;bacdfeg&quot;</p><p><strong>思路</strong>：这里的终点就是i+=(2*k)，i 每次移动 2 * k 就可以了，然后判断是否需要有反转的区间。 使用库函数reverse来求解（reverse函数不是本题的问题核心，可以使用）：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>string <span class="token function">reverseStr</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span><span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span> <span class="token punctuation">;</span>i<span class="token operator">&lt;</span>s<span class="token punctuation">.</span><span class="token function">zise</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">+=</span><span class="token number">2</span><span class="token operator">*</span>k<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token comment">//1. 每隔2k个字符的前k个字符进行反转</span>
		<span class="token comment">//2. 剩余字符小于2k但大于等于k个的，则反转前k个</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">+</span>k <span class="token operator">&lt;=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token function">reverse</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span>i<span class="token punctuation">,</span>s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span>i<span class="token operator">+</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
			<span class="token comment">//3. 剩余字符小于k，就全部翻转</span>
			<span class="token function">reverse</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span>i<span class="token punctuation">,</span>s<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> s<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>另一种方法是实现自己的reverse函数，下面的reverse函数时左闭右闭区间的，代码如下：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">reverse</span><span class="token punctuation">(</span>string<span class="token operator">&amp;</span> s<span class="token punctuation">,</span><span class="token keyword">int</span> start<span class="token punctuation">,</span><span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>start<span class="token punctuation">,</span>j<span class="token operator">=</span>end<span class="token punctuation">;</span>i<span class="token operator">&lt;</span>j<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">,</span>j<span class="token operator">--</span><span class="token punctuation">)</span>
		<span class="token function">swap</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
string <span class="token function">reverseStr</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">+=</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> k<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 1. 每隔 2k 个字符的前 k 个字符进行反转</span>
        <span class="token comment">// 2. 剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> k <span class="token operator">&lt;=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">reverse</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> i<span class="token punctuation">,</span> i <span class="token operator">+</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 3. 剩余字符少于 k 个，则将剩余字符全部反转。</span>
        <span class="token function">reverse</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> i<span class="token punctuation">,</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> s<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_4-3-替换空格" tabindex="-1"><a class="header-anchor" href="#_4-3-替换空格" aria-hidden="true">#</a> 4.3 替换空格</h3><p><strong>题意</strong>:将字符串中的空格替换成&quot;%20&quot;。</p><p><strong>思路</strong>：不使用额外的辅助空间。首先，扩充数组到每隔空格替换成&quot;%20&quot;之后的大小，然后从后往前替换空格，也就是双指针法。i指向新长度的末尾，j指向旧长度的末尾，过程如下：</p><figure><img src="https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlFkgwS4cMqYe6Hq2/root/content" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>其实很多数组填充类的问题，都可以先预先给数组扩容带填充后的大小，然后在从后向前进行操作</strong>。</p><p>这么做有两个好处：</p><ol><li>不用申请新数组。</li><li>从后向前填充元素，避免了从前向后填充元素时，每次添加元素都要将添加元素之后的所有元素向后移动的问题。</li></ol><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>string <span class="token function">replaceSpace</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//统计空格的数量</span>
	<span class="token keyword">int</span> sOldSize <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>sOldSize<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">&#39; &#39;</span><span class="token punctuation">)</span> count<span class="token operator">++</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//扩充字符串的大小，也就是每个空格替换成&quot;%20&quot;之后的大小</span>
	s<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span>count<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> sNewSize <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//从后往前将空格替换成&quot;%20&quot;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>sNewSize<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>j<span class="token operator">=</span>sOldSize<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>i<span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">,</span>j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token char">&#39; &#39;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
			s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
			s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token char">&#39;0&#39;</span><span class="token punctuation">;</span>
			s<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token char">&#39;2&#39;</span><span class="token punctuation">;</span>
			s<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token char">&#39;%&#39;</span><span class="token punctuation">;</span>
			i<span class="token operator">-=</span><span class="token number">2</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> s<span class="token punctuation">;</span><span class="token comment">//时间和空间复杂度都为O(1)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_4-4-翻转字符串里的单词" tabindex="-1"><a class="header-anchor" href="#_4-4-翻转字符串里的单词" aria-hidden="true">#</a> 4.4 翻转字符串里的单词</h3><ul><li>这是一道考察字符串操作的好题。</li></ul><p><strong>题意</strong>：给定一个字符串，逐个翻转字符串中的每个单词。请注意，是反转单词，而非字符，示例：输入&quot;hello world! &quot;，输出：&quot;world! hello&quot;。说明：若两个单词之间有多个空格，应减少到只包含一个，若字符串末尾有多余的空格，也应该删掉。</p><p><strong>思路</strong>：这道题综合考察了字符串的许多操作。一些同学会使用split库函数，分隔单词，然后定义一个新的string字符串，最后再把单词倒序相加，那么这道题题目就是一道水题了，失去了它的意义。所以，提高一下本题的难度：<strong>不要使用辅助空间，空间复杂度为O(1)</strong>。</p><p>想一下，我们将整个字符串都反转过来，那么单词的顺序指定是倒序了，只不过单词本身也倒序了，那么再把单词反转一下，单词不就正过来了。所以解题思路如下：</p><ul><li>移除多余空格</li><li>将整个字符串反转</li><li>将每个单词反转</li></ul><p>举个例子，源字符串为：&quot;the sky is blue &quot;:</p><ul><li>移除多余空格 : &quot;the sky is blue&quot;</li><li>字符串反转：&quot;eulb si yks eht&quot;</li><li>单词反转：&quot;blue is sky the&quot;</li></ul><p>代码上的细节：</p><p>1）移除多余空格：一些同学可能会上来写如下代码（使用erase的方法来删除空格，时间复杂度会很高）：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">removeExtraSpaces</span><span class="token punctuation">(</span>string<span class="token operator">&amp;</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&gt;</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>s<span class="token punctuation">[</span>i<span class="token operator">--</span><span class="token punctuation">]</span><span class="token operator">&amp;&amp;</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token char">&#39; &#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			s<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//删除字符串最后面的空格</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span><span class="token char">&#39; &#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		s<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//删除最前面的空格</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">&#39; &#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		s<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>问题在哪</strong>:上述代码一琢磨似乎时间复杂度为O(n)，但其实erase()的时间复杂度为也是O(n)，所以实际的时间复杂度就是O(n^2)。有的同学可能发现用erase来移除空格，在leetcode上性能也还行。主要是以下几点：</p><ul><li>leetcode上的测试集里，字符串的长度不够长，如果足够长，性能差距会非常明显。</li><li>leetcode的测程序耗时不是很准确的。</li></ul><p>2）使用双指针的方法按照去除最前面的空格、中间部分的空格和末尾空格的思路来写代码</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">//版本一 </span>
<span class="token keyword">void</span> <span class="token function">removeExtraSpaces</span><span class="token punctuation">(</span>string<span class="token operator">&amp;</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> slowIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> fastIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 定义快指针，慢指针</span>
    <span class="token comment">// 去掉字符串前面的空格</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> fastIndex <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>fastIndex<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">&#39; &#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        fastIndex<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> fastIndex <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> fastIndex<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 去掉字符串中间部分的冗余空格</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>fastIndex <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">&gt;</span> <span class="token number">0</span>
                <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>fastIndex <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> s<span class="token punctuation">[</span>fastIndex<span class="token punctuation">]</span>
                <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>fastIndex<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">&#39; &#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            s<span class="token punctuation">[</span>slowIndex<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">[</span>fastIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>slowIndex <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>slowIndex <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">&#39; &#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 去掉字符串末尾的空格</span>
        s<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>slowIndex <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        s<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>slowIndex<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 重新设置字符串大小</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>仔细考虑这个问题，是不是和数组操作的&quot;移除指定元素&quot;这个操作比较像？还是使用双指针法，将所有空格都视作需要被移除的对象，然后手动为每个单词后添加空格：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// 版本二 使用双指针法，快指针为索引，遍历所有元素，慢指针只接受满足条件的元素</span>
<span class="token keyword">void</span> <span class="token function">removeExtraSpaces</span><span class="token punctuation">(</span>string<span class="token operator">&amp;</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//去除所有空格并在相邻单词之间添加空格, 快慢指针。</span>
    <span class="token keyword">int</span> slow <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token comment">//整体思想参考https://programmercarl.com/0027.移除元素.html</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">&#39; &#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//遇到非空格就处理，即删除所有空格。</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>slow <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> s<span class="token punctuation">[</span>slow<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">&#39; &#39;</span><span class="token punctuation">;</span> <span class="token comment">//手动控制空格，给单词之间添加空格。slow != 0说明不是第一个单词，需要在单词前添加空格。</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">&#39; &#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//补上该单词，遇到空格说明单词结束。</span>
                s<span class="token punctuation">[</span>slow<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    s<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>slow<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//slow的大小即为去除多余空格后的大小。</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>3）实现反转字符串的功能，这在上文已经讲了：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// 反转字符串s中左闭右闭的区间[start, end]</span>
<span class="token keyword">void</span> <span class="token function">reverse</span><span class="token punctuation">(</span>string<span class="token operator">&amp;</span> s<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">,</span> j <span class="token operator">=</span> end<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> j<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">,</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">swap</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>综上，翻转字符串里的单词这道题的最终代码为：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">reverse</span><span class="token punctuation">(</span>string<span class="token operator">&amp;</span> s<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">//翻转，区间写法：左闭右闭 []</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">,</span> j <span class="token operator">=</span> end<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> j<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">,</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token function">swap</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">removeExtraSpaces</span><span class="token punctuation">(</span>string<span class="token operator">&amp;</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//去除所有空格并在相邻单词之间添加空格, 快慢指针。</span>
	<span class="token keyword">int</span> slow <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token comment">//整体思想参考https://programmercarl.com/0027.移除元素.html</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">&#39; &#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//遇到非空格就处理，即删除所有空格。</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>slow <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> s<span class="token punctuation">[</span>slow<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">&#39; &#39;</span><span class="token punctuation">;</span> <span class="token comment">//手动控制空格，给单词之间添加空格。slow != 0说明不是第一个单词，需要在单词前添加空格。</span>
			<span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">&#39; &#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//补上该单词，遇到空格说明单词结束。</span>
				s<span class="token punctuation">[</span>slow<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	s<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>slow<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//slow的大小即为去除多余空格后的大小。</span>
<span class="token punctuation">}</span>

string <span class="token function">reverseWords</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token function">removeExtraSpaces</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//去除多余空格，保证单词之间之只有一个空格，且字符串首尾没空格。</span>
	<span class="token function">reverse</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//removeExtraSpaces后保证第一个单词的开始下标一定是0。</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">&#39; &#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//到达空格或者串尾，说明一个单词结束。进行翻转。</span>
			<span class="token function">reverse</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> start<span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//翻转，注意是左闭右闭 []的翻转。</span>
			start <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//更新下一个单词的开始下标start</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> s<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_4-5-左旋转字符串" tabindex="-1"><a class="header-anchor" href="#_4-5-左旋转字符串" aria-hidden="true">#</a> 4.5 左旋转字符串</h3><p><strong>题意</strong>：字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串&quot;abcdefg&quot;和数字2，该函数将返回左旋转两位得到的结果&quot;cdefgab&quot;。</p><p><strong>思路</strong>：如果能申请额外空间的话，就可以用提取子串的方法substr()将前n个字符提取出来，然后在追加到原字符串末尾就行了(但是substr()方法需要申请额外的空间)。为了让本题更有意义，提升一下本题难度：<strong>不能申请额外空间，只能在本串上操作</strong>。回顾上一题，翻转字符串里的单词，是使用整体反转+局部反转的方式来实现反转单词顺序的目的。这道题也类似，具体步骤为：</p><ol><li>反转区间为前n的子串；</li><li>反转区间为n到末尾的子串；</li><li>反转整个字符串</li></ol><figure><img src="https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlFpfBs6U4gvnd_wZ/root/content" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>cpp代码如下所示：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>string <span class="token function">reverseLeftWords</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token function">reverse</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">reverse</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> n<span class="token punctuation">,</span> s<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">reverse</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> s<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> s<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>总结</strong>：</p><p>此时我们已经反转过很多次字符串了，一起来回顾一下。</p><p>在&quot;反转字符串1&quot;中，第一次降到反转一个字符串该怎么做，使用了双指针法。</p><p>在&quot;反转字符串2&quot;中，对反转限定了条件，要求前2k个字符只翻转前k个，需要固定规律一段一段去处理字符串的时候，就要在for循环的表达式上去做文章。</p><p>在&quot;反转字符串里的单词&quot;中，要对一句话里的单词顺序进行反转，发现先整体反转、在局部反转是个不错的思路。</p><p>最后在讲到本题，本题是先局部反转再整体反转，也是一种新思路。</p><p>最后补充说明一下，substr()这个方法和反转时间复杂度都是一样的，都是O(n)，但是substr()需要申请额外空间。</p><h3 id="_4-6-实现strstr" tabindex="-1"><a class="header-anchor" href="#_4-6-实现strstr" aria-hidden="true">#</a> 4.6 实现strStr()</h3><p><strong>题意</strong>：实现 strStr() 函数。给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。例如：输入: haystack = &quot;hello&quot;, needle = &quot;ll&quot; 输出: 2。说明: 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。</p><p><strong>思路</strong>：本题是KMP的经典题目。KMP的经典思想就是:<strong>当出现字符串不匹配时，可以记录一部分之前已经匹配的文本内容，利用这些信息避免从头再去做匹配</strong>。</p><p><strong>KMP算法</strong>： 字符串的匹配算法有两种：1）BF算法(Brute-Force，暴力解法)，就是目标串和模式串都从0开始比较，当遇到不匹配的字符时，模式串索引值j直接返回到起点0，而目标串的索引<code>i=i-j+2</code>。为什么加2呢？如下图所示，因为理论上模式串匹配完一次后，如果没匹配上，模式串j直接回到0，而目标串i回到遍历的下一个位置（下图中手写笔画的位置，也就是索引1的位置）。但是在上一次的匹配过程中，i已经走到了3号的位置，所以不仅是j要回头开头，i也要回溯。这也是暴力解法时间复杂度高的原因所在O(m*n)。</p><figure><img src="https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlFxIwhkqFTYq0xCx/root/content" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>2）KMP算法原理：KMP算法就是让目标串的i不要回溯，向遍历指针一样一直往前走。并且分析模式串字符构成特点，尽量让j不要回到0处重复匹配来提高匹配效率。通过分析模式串的字符构成特点，来设计一个&quot;如果匹配失败就指示下次跳转的位置的数组&quot;，这个数组就是next[]数组。KMP的主要思想是<strong>当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了</strong>。</p><p>前缀表：前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。前缀表是<strong>记录下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。</strong></p><p>前缀：是指不包含最后一个字符的所有以第一个字符开头的连续子串。</p><p>后缀：是指不包含第一个字符的所有以最后一个字符结尾的连续子串。</p><p>前缀表：要求的就是最大的相同前后缀的长度。</p><p><strong>为什么一定要使用前缀表</strong>：</p><p>刚刚匹配的过程在下标5的地方遇到不匹配，模式串是指向f，如下图：</p><figure><img src="https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlF2fBMmjPS2yUa3A/root/content" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>然后就找到了下标2，指向b，继续匹配：如图：</p><figure><img src="https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlF5rdletPm7T6ZJH/root/content" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>以下这句话，对于理解为什么使用前缀表可以告诉我们匹配失败之后跳到哪里重新匹配 非常重要！</p><p><strong>下标5之前这部分的字符串（也就是字符串<code>aabaa</code>）的最长相等的前缀 和 后缀字符串是 子字符串<code>aa</code> ，因为找到了最长相等的前缀和后缀，匹配失败的位置是后缀子串的后面，那么我们找到与其相同的前缀的后面重新匹配就可以了。</strong></p><p>所以前缀表具有告诉我们当前位置匹配失败，跳到之前已经匹配过的地方的能力。</p><p>前缀表与next数组：</p><p>有的是直接把next数组做前缀表，有的是把next数组每一位减一后的数组做next数组，有的是把next数组统一右移一位做next数组。注意：这题的next数组是从下表索引0开始计算的，而很多课程或教材，例如《大话数据结构》是从数组下标1开始计算的。</p><p><strong>时间复杂度分析</strong>：</p><p>暴力算法是O(m*n)，使用KMP算法是O(m+n)，不过KMP算法针对模式串中有较多重复字符时才能提高搜索效率，这点也需注意。</p><p><strong>一、构造next数组</strong>：</p><p><strong>构造next数组其实就是计算模式串s，前缀表的过程</strong>。 主要有如下三步：</p><ul><li>初始化</li><li>处理前后缀不相同的情况</li><li>处理前后缀相同的情况</li></ul><p>接下来详细叙述一下（直接使用next数组做前缀表，且next数组从数组下标0开始）：</p><ol><li>初始化</li></ol><p>定义两个指针i和j，j指向前缀末尾位置，i指向后缀末尾位置。然后还要对next数组进行初始化赋值，如下：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
next<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//next[i] 表示 i（包括i）之前最长相等的前后缀长度（其实就是j）所以初始化next[0] = j 。</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>处理前后缀不相同的情况</li></ol><p>遍历模式串的循环下标索引从1开始，因为下标为0时，显然最大公共前后缀为0，即next[0]的初始值； <code>for(int i=1;i&lt;s.size();i++) {</code> 如果 s[i] 与 s[j]不相同，也就是遇到前后缀末尾不相同的情况，就要向前回退。使用next数组来回退：<code>j=next[j-1]</code>。</p><ol start="3"><li>处理前后缀相同的情况 如果 s[i] 与 s[j + 1] 相同，那么就同时向后移动i 和j 说明找到了相同的前后缀，同时还要将j（前缀的长度）赋给next[i], 因为next[i]要记录相同前后缀的长度。</li></ol><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	j<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
next<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>j<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>二、使用next数组来做匹配</strong>：</p><ol><li>目标串（主串）从0开始遍历字符串数组：</li></ol><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ol start="2"><li>接下来就是<code>s[i]</code> 与 <code>t[j]</code> （因为j从0开始的） 进行比较。</li></ol><p>如果 <code>s[i]</code> 与 <code>t[j + 1]</code> 不相同，j就要从next数组里寻找下一个匹配的位置。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">while</span><span class="token punctuation">(</span>j<span class="token operator">&gt;=</span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span>t<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	j<span class="token operator">=</span>next<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li>如果s[i]和t[j]相同，那么i和j同时往后移动</li></ol><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>if (s[i] == t[j]) {
	j++;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如何判断在文本串s里出现了模式串t呢，如果j指向了模式串t的末尾，那么就说明模式串t完全匹配文本串s里的某个子串了。</p><p>本题要在文本串字符串中找出模式串出现的第一个位置 (从0开始)，所以返回当前在文本串匹配模式串的位置i 减去 模式串的长度，就是文本串字符串中出现模式串的第一个位置。</p><p>代码如下：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>i <span class="token operator">-</span> t<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>所有代码如下：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">getNext</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> next<span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	next<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			j <span class="token operator">=</span> next<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			j<span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		next<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">strStr</span><span class="token punctuation">(</span>string haystack<span class="token punctuation">,</span> string needle<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>needle<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">int</span> next<span class="token punctuation">[</span>needle<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token function">getNext</span><span class="token punctuation">(</span>next<span class="token punctuation">,</span> needle<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> haystack<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">while</span><span class="token punctuation">(</span>j <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> haystack<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> needle<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		j <span class="token operator">=</span> next<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>haystack<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> needle<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			j<span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> needle<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token keyword">return</span> <span class="token punctuation">(</span>i <span class="token operator">-</span> needle<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>总结</strong>：</p><p>我们介绍了什么是KMP，KMP可以解决什么问题，然后分析KMP算法里的next数组，知道了next数组就是前缀表，再分析为什么要是前缀表而不是什么其他表。</p><p>接着从给出的模式串中，我们一步一步的推导出了前缀表，得出前缀表无论是统一减一还是不减一得到的next数组仅仅是kmp的实现方式的不同。</p><p>其中还分析了KMP算法的时间复杂度，并且和暴力方法做了对比。</p><p>然后先用前缀表统一减一得到的next数组，求得文本串s里是否出现过模式串t，并给出了具体分析代码。</p><p>又给出了直接用前缀表作为next数组，来做匹配的实现代码。</p><p><strong>求next数组的小技巧（以下图为例）</strong>：</p><figure><img src="https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlGG-X8nEvHZ1plBp/root/content" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>第一个字符a，无前缀后缀，所以为0； 第二个字符串as，无最长公共前后缀，所以为0； 第三个字符串asd，无最长公共前后缀，所以为0； ... 第五个字符串asdfa,最长公共前后缀是a，所以是1； 类似的，第9个字符串asdfasdfa,（最长前缀是asdfasdf，最长后缀是sdfasdfa。不相同，所以不是8）最长公共前后缀asdfa：前缀是asdfa(从[0]到[4]),后缀是asdfa(从[4]到[8])，随意最长公共前后缀为5 ... 上述计算结束后，每一位在统一减一，就可以得到上图中的next数组了。</p><h3 id="_4-7-重复的子字符串" tabindex="-1"><a class="header-anchor" href="#_4-7-重复的子字符串" aria-hidden="true">#</a> 4.7 重复的子字符串</h3><p><strong>题意</strong>：给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。示例：输入：&quot;abab&quot;，输出True. <strong>思路</strong>：主要有三种方法：1）暴力解法：第一层循环遍历整个字符串，第二层来寻找最小子串，子串的起点始终为起点，终点为当前遍历点，然后看这个子串能否构成整个大串。2）移动匹配法；3）KMP算法。</p><p><strong>移动匹配</strong>：</p><p>当一个字符串s：<code>abcabc</code>，内部由重复的子串组成，那么这个字符串的结构一定是由前后相同的子串组成。那么既然前面有相同的子串，后面有相同的子串，用 s + s，这样组成的字符串中，后面的子串做前串，前后的子串做后串，就一定还能组成一个s。<strong>所以判断字符串s是否由重复子串组成，只要两个s拼接在一起，里面还出现一个s的话，就说明是由重复子串组成</strong>。也就是说，假设字符串s由a和b组成，若<code>s=a+b</code>，当<code>a+b+a+b</code>中仍然存在一个s时，说明<code>s=b+a</code>，说明a和b是一样的，也就是说s可以由重复子串a(或b)构成。</p><p>当然，我们在判断 s + s 拼接的字符串里是否出现一个s的的时候，<strong>要刨除 s + s 的首字符和尾字符</strong>，这样避免在s+s中搜索出原来的s，我们要保证搜索的是中间拼接出来的s。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">bool</span> <span class="token function">repeatedSubstringPattern</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	string t <span class="token operator">=</span> s <span class="token operator">+</span> s<span class="token punctuation">;</span>
	t<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//掐头去尾</span>
	t<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">!=</span> std<span class="token double-colon punctuation">::</span>string<span class="token double-colon punctuation">::</span>npos<span class="token punctuation">)</span><span class="token comment">//std::string::npos</span>
		<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注：</p><p>关于std::string::npos的使用说明：</p><ul><li>（1）它是一个常量静态成员值，对于 size_t 类型的元素具有最高可能值。</li><li>（2）它实际上意味着直到字符串的末尾。</li><li>（3）它用作字符串成员函数中长度参数的值。</li><li>（4）作为返回值，它通常用于表示没有匹配项。</li><li>（5）数据类型为size_t的话string:npos常量被定义为-1，因为size_t是无符号整数类型，-1是该类型的最大可能表示值。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">//1、std::string::npos一般最常见用于表示未找到的情况</span>
string str <span class="token operator">=</span> <span class="token string">&quot;I am cver&quot;</span><span class="token punctuation">;</span>
size_t index <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token char">&#39;.&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//字符没找到</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">==</span> string<span class="token double-colon punctuation">::</span>npos<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	cout<span class="token operator">&lt;&lt;</span><span class="token string">&quot;this does not contain any period!&quot;</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
	cout<span class="token operator">&lt;&lt;</span>index<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//2、作字符串成员函数中长度参数的值</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	string str <span class="token operator">=</span> <span class="token string">&quot;I am cver.&quot;</span><span class="token punctuation">;</span>
	size_t index <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token char">&#39;.&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
	<span class="token keyword">if</span><span class="token punctuation">(</span>index <span class="token operator">==</span> string<span class="token double-colon punctuation">::</span>npos<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;This does not contain any period!&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		cout <span class="token operator">&lt;&lt;</span> index <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span>
	<span class="token punctuation">{</span>
		str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> string<span class="token double-colon punctuation">::</span>npos<span class="token punctuation">,</span> <span class="token string">&quot;!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//string&amp; replace(int p0, int n0,const char *s);删除从p0开始的n0个字符，然后在p0处插入串s</span>
		cout <span class="token operator">&lt;&lt;</span> str <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		cout <span class="token operator">&lt;&lt;</span> index <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>		
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>不过这种解法还有一个问题，就是 我们最终还是要判断 一个字符串（s + s）是否出现过 s 的过程，大家可能直接用contains，find 之类的库函数。 却忽略了实现这些函数的时间复杂度（暴力解法是m * n，一般库函数实现为 O(m + n)）。如果我们做过 28.实现strStr (opens new window)题目的话，其实就知道，实现一个 高效的算法来判断 一个字符串中是否出现另一个字符串是很复杂的，这里就涉及到了KMP算法。</p><p><strong>KMP</strong>：</p><p>&lt;为什么使用MKP算法&gt;？</p><p>在一个串中查找是否出现过另一个串，这是KMP的看家本领。那么寻找重复子串怎么也涉及到KMP算法了呢？</p><p>在由重复子串组成的字符串中，最长相等前后缀不包含的子串就是最小重复子串，这里拿字符串s：abababab 来举例，ab就是最小重复单位，如图所示：</p><figure><img src="https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlF8PCVBCA1rDlM4M/root/content" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>&lt;如何找到最小重复子串&gt;？</p><p>步骤一：因为 这是相等的前缀和后缀，t[0] 与 k[0]相同， t[1] 与 k[1]相同，所以 s[0] 一定和 s[2]相同，s[1] 一定和 s[3]相同，即：，s[0]s[1]与s[2]s[3]相同 。</p><p>步骤二： 因为在同一个字符串位置，所以 t[2] 与 k[0]相同，t[3] 与 k[1]相同。</p><p>步骤三： 因为 这是相等的前缀和后缀，t[2] 与 k[2]相同 ，t[3]与k[3] 相同，所以，s[2]一定和s[4]相同，s[3]一定和s[5]相同，即：s[2]s[3] 与 s[4]s[5]相同。</p><p>步骤四：循环往复。</p><p>所以字符串s，s[0]s[1]与s[2]s[3]相同， s[2]s[3] 与 s[4]s[5]相同，s[4]s[5] 与 s[6]s[7] 相同。</p><p>正是因为 最长相等前后缀的规则，当一个字符串由重复子串组成的，最长相等前后缀不包含的子串就是最小重复子串。</p><figure><img src="https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlGCHOJOsongi-3Eh/root/content" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>简单推理</strong>：</p><p>这里再给出一个数学推导，就容易理解很多。</p><p>假设字符串s使用多个重复子串构成（这个子串是最小重复单位），重复出现的子字符串长度是x，所以s是由n * x组成。</p><p>因为字符串s的最长相同前后缀的长度一定是不包含s本身，所以 最长相同前后缀长度必然是m * x，而且 n - m = 1，（这里如果不懂，看上面的推理）</p><p>所以如果 nx % (n - m)x = 0，就可以判定有重复出现的子字符串。</p><p>next 数组记录的就是最长相同前后缀 字符串：KMP算法精讲 (opens new window)这里介绍了什么是前缀，什么是后缀，什么又是最长相同前后缀)， 如果 next[len - 1] != -1，则说明字符串有最长相同的前后缀（就是字符串里的前缀子串和后缀子串相同的最长长度）。</p><p>最长相等前后缀的长度为：next[len - 1] + 1。(这里的next数组是以统一减一的方式计算的，因此需要+1，两种计算next数组的具体区别看这里：字符串：KMP算法精讲 (opens new window))</p><p>数组长度为：len。</p><p>如果len % (len - (next[len - 1] + 1)) == 0 ，则说明数组的长度正好可以被 (数组长度-最长相等前后缀的长度) 整除 ，说明该字符串有重复的子字符串。</p><p><strong>数组长度减去最长相同前后缀的长度相当于是第一个周期的长度，也就是一个周期的长度，如果这个周期可以被整除，就说明整个数组就是这个周期的循环。</strong></p><p>例如下图：</p><figure><img src="https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlGG-X8nEvHZ1plBp/root/content" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><code>next[len - 1] = 7，next[len - 1] + 1 = 8</code>，8就是此时字符串asdfasdfasdf的最长相同前后缀的长度。</p><p><code>(len - (next[len - 1] + 1))</code> 也就是： 12(字符串的长度) - 8(最长公共前后缀的长度) = 4， 4正好可以被 12(字符串的长度) 整除，所以说明有重复的子字符串（asdf）。</p><p>cpp代码实现：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">getNext</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> next<span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span> s<span class="token punctuation">)</span><span class="token punctuation">{</span>
	next<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		 <span class="token keyword">while</span><span class="token punctuation">(</span>j <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			 j <span class="token operator">=</span> next<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			j<span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		next<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">bool</span> <span class="token function">repeatedSubstringPattern</span> <span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">int</span> next<span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token function">getNext</span><span class="token punctuation">(</span>next<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> len <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>next<span class="token punctuation">[</span>len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> len <span class="token operator">%</span> <span class="token punctuation">(</span>len <span class="token operator">-</span> <span class="token punctuation">(</span>next<span class="token punctuation">[</span>len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_4-8-总结" tabindex="-1"><a class="header-anchor" href="#_4-8-总结" aria-hidden="true">#</a> 4.8 总结</h3><p><strong>什么是字符串</strong>：</p><p>字符串是若干字符组成的有限序列，也可以理解为是一个字符数组，但是很多语言对字符串做了特殊的规定，接下来我来说一说C/cpp中的字符串。在C语言中，把一个字符串存入一个数组时，也把结束符 &#39;\0&#39;存入数组，并以此作为该字符串是否结束的标志。</p><p>在cpp中，提供一个string类，string类会提供 size接口，可以用来判断string类字符串是否结束，就不用&#39;\0&#39;来判断是否结束。</p><p>字符串的长度计算有<code>size()</code>也可以用<code>length()</code>，那么<code>vector&lt;char&gt;</code>和string的区别在哪？基本上没差别，不过string提供了更多的字符串处理的相关接口，例如string重载了+，而vector却没有。</p><p><strong>双指针法</strong>：</p><p>在<strong>反转字符串1</strong>中，是反转字符串中的所有字符，可以使用双指针，两个指针一个从头开始，一个从未开始进行交换，以实现题目的功能。</p><p>在<strong>字符串：替换空格</strong>中，我们需要将空格全部替换成指定的字符串，本题中是将空格替换成“%20”。<strong>其实很多数组填充类的问题，都可以先预先给数组扩容带填充后的大小，然后在从后向前进行操作</strong>。</p><p>在<strong>翻转字符串中的单词</strong>中，与之前<strong>移除数组元素</strong>类似，双指针法，一个快指针做遍历，另一个慢指针来保留有用的元素。在这里，我们将空格全部当成需要移除的元素来处理，就与以前移除数组元素的操作相同了。然后，后面在对每个单词后面添加一个空格。这样就达到了“移除字符串中多余空格的目的”。</p><p>需要注意的是，库函数erase()的时间复杂度为O(n)。</p><p><strong>反转系列</strong>：</p><p>反转其实实在考察队代码的掌控能力。</p><p>在<strong>反转字符串2</strong>中，每隔2k字符就翻转前k个字符，不足k的话就翻转全部字符。其实，当需要固定规律一段一段去处理字符串时，可以在for循环的表达式上坐坐文章。</p><p>在<strong>翻转字符串里的单词</strong>中要求翻转字符串里面的单词，这道题目可以说是考察了字符串的多种操作，是考察字符串的一道好题。解法是：1）先去掉多余的空格；2）在整体反转，3）再局部反转。</p><p>还有一个字符串的左转：剑指Offer58-II.左旋转字符串：给定字符串和一个数字，实现将数字前的字符移动到字符串末尾，如：输入&quot;abcdefg&quot;和2，得到&quot;cdefgab&quot;。这道题的思路是：1）先反转前n个字符，2）再反转n到末尾的字符，3）最后在反转整个字符串。而这三步骤，其核心就是”给定一个字符串，反转其全部字符“，就是本章节的第一题，使用双指针从头和从尾两端同时替换即可。</p><p><strong>KMP系列</strong>：</p><p>问题1是实现子串问题，判断字符串2是不是字符串1的子串。采用KMP的方法，先对子串2进行分析，得到其next数组（该next数组反映了子串2的字符排列特点，可以在与主串的匹配查找过程中提供指针跳转的参考依据）。然后就是在next数组的基础上进行两字符串匹配的过程了。</p><p>问题2是重复子串问题，就是说一个字符串能否由它的子串完整构成，例如主串&quot;abababab&quot;可以有子串&quot;ab&quot;完整构成。方法主要有移动匹配和KMP算法。移动构造：判断字符串s是否可以由子串构成，就1）构造s+s的字符串，2）刨除首字符和尾字符，3）判断剩余的字符中有无字符串s。有就是满足题意。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">bool</span> <span class="token function">repeatSubstring</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	string t <span class="token operator">=</span> s <span class="token operator">+</span> s<span class="token punctuation">;</span>
	t<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	t<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">!=</span> std<span class="token double-colon punctuation">::</span>string<span class="token double-colon punctuation">::</span>npos<span class="token punctuation">)</span> 
		<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意，一般暴力解法的复杂度是O(N^2)，库函数（如contains、find)的复杂度是O(m+n)。</p><h2 id="五、双指针法" tabindex="-1"><a class="header-anchor" href="#五、双指针法" aria-hidden="true">#</a> 五、双指针法</h2><p>本章节主要是复习前面的内容。双指针法在数组、链表和字符串中很常用。</p><p><strong>数组</strong>：</p><ol><li>移除元素</li></ol><p><strong>链表</strong>：</p><ol><li>翻转链表</li><li>删除链表的倒数第N个节点</li><li>链表相交</li><li>环形链表2</li></ol><p><strong>哈希表</strong>：</p><ol><li>三数之和</li><li>四数之和</li></ol><p><strong>字符串</strong>：</p><ol><li>反转字符串(单个字符串内的全部字符)</li><li>替换空格</li><li>反转字符串中的单词</li></ol><p><strong><strong>总结</strong></strong>： 在【数组篇】中有删除元素一节，一些同学可能会写出下列代码(伪代码)：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&gt;</span>array<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		array<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个代码看着是只有O(n)的复杂度，其实是O(n^2)的复杂度，因为erase操作也是O(n)的操作。数组本身不能真正的删除元素，只能覆盖。</p><p>在【链表篇】中，使用双指针法来翻转链表、确定单链表是否有环和环入口。</p><p>在【哈希表篇】中，使用双指针法实现了N数之和。</p><p>在【字符串篇】中，使用双指针法实现了反转字符串、替换空格和删除冗余空格。</p><h2 id="六、栈与队列" tabindex="-1"><a class="header-anchor" href="#六、栈与队列" aria-hidden="true">#</a> 六、栈与队列</h2><h2 id="七、二叉树" tabindex="-1"><a class="header-anchor" href="#七、二叉树" aria-hidden="true">#</a> 七、二叉树</h2><h2 id="八、回溯算法" tabindex="-1"><a class="header-anchor" href="#八、回溯算法" aria-hidden="true">#</a> 八、回溯算法</h2><h2 id="九、贪心算法" tabindex="-1"><a class="header-anchor" href="#九、贪心算法" aria-hidden="true">#</a> 九、贪心算法</h2><h2 id="十、动态规划" tabindex="-1"><a class="header-anchor" href="#十、动态规划" aria-hidden="true">#</a> 十、动态规划</h2><h2 id="十一、单调栈" tabindex="-1"><a class="header-anchor" href="#十一、单调栈" aria-hidden="true">#</a> 十一、单调栈</h2><h2 id="十二、额外题目" tabindex="-1"><a class="header-anchor" href="#十二、额外题目" aria-hidden="true">#</a> 十二、额外题目</h2></div><!----><footer class="page-meta"><div class="meta-item edit-link"><a href="https://github.com/XiaoYuer2022/XiaoYuer2022.github.io/edit/main/src/docs/找工作/代码随想录学习笔记[总结].md" rel="noopener noreferrer" target="_blank" aria-label="在 GitHub 上编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="edit icon"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->在 GitHub 上编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item git-info"><div class="update-time"><span class="label">上次编辑于: </span><!----></div><div class="contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: 508506630@qq.com">haoxx</span><!--]--><!--]--></div></div></footer><nav class="page-nav"><!----><a href="/docs/%E6%89%BE%E5%B7%A5%E4%BD%9C/1__WebServer%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%B1%87%E6%80%BB.html" class="nav-link next" aria-label="1__WebServer学习笔记汇总"><div class="hint">下一页<span class="arrow end"></span></div><div class="link">1__WebServer学习笔记汇总<span class="font-icon icon iconfont icon-write" style=""></span></div></a></nav><!----><!----><!--]--></main><!--]--><footer class="footer-wrapper"><div class="footer"><a href="https://beian.miit.gov.cn/#/Integrated/index">渝ICP备2023001651号</a></div><div class="copyright">Copyright © 2023 Mr.HaoXX</div></footer></div><!--]--><!----><!--]--></div>
    <script type="module" src="/assets/app-cd86945f.js" defer></script>
  </body>
</html>
