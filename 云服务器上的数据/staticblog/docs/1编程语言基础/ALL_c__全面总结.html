<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.61" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://haoxx.top/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html"><meta property="og:site_name" content="开心酒馆"><meta property="og:title" content="全面内容综述"><meta property="og:description" content="提示 全面内容综述"><meta property="og:type" content="article"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2023-05-18T13:40:37.000Z"><meta property="article:author" content="Mr.HaoXX"><meta property="article:published_time" content="2022-10-30T00:00:00.000Z"><meta property="article:modified_time" content="2023-05-18T13:40:37.000Z"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"全面内容综述","image":[""],"datePublished":"2022-10-30T00:00:00.000Z","dateModified":"2023-05-18T13:40:37.000Z","author":[{"@type":"Person","name":"Mr.HaoXX","url":"https://haoxx.top/"}]}</script><link rel="icon" href="/favicon.ico"><meta name="referrer" content="no-referrer-when-downgrade"><title>全面内容综述 | 开心酒馆</title><meta name="description" content="提示 全面内容综述">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d1e1f;
      }

      html,
      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="preload" href="/assets/style-0832a140.css" as="style"><link rel="stylesheet" href="/assets/style-0832a140.css">
    <link rel="modulepreload" href="/assets/app-cd86945f.js"><link rel="modulepreload" href="/assets/framework-e783454b.js"><link rel="modulepreload" href="/assets/ALL_c__全面总结.html-6325208e.js"><link rel="modulepreload" href="/assets/ALL_c__全面总结.html-71e84f90.js"><link rel="prefetch" href="/assets/index.html-0c6e80d8.js" as="script"><link rel="prefetch" href="/assets/visitorbook.html-90e15ff3.js" as="script"><link rel="prefetch" href="/assets/index.html-56d9107c.js" as="script"><link rel="prefetch" href="/assets/index.html-d27339fc.js" as="script"><link rel="prefetch" href="/assets/index.html-333f2f76.js" as="script"><link rel="prefetch" href="/assets/index.html-9b85df5f.js" as="script"><link rel="prefetch" href="/assets/关于我.html-124cb063.js" as="script"><link rel="prefetch" href="/assets/index.html-82f20127.js" as="script"><link rel="prefetch" href="/assets/index.html-4086d4fb.js" as="script"><link rel="prefetch" href="/assets/index.html-9158d331.js" as="script"><link rel="prefetch" href="/assets/index.html-6d8b73b1.js" as="script"><link rel="prefetch" href="/assets/index.html-b76a9fff.js" as="script"><link rel="prefetch" href="/assets/index.html-90e3434f.js" as="script"><link rel="prefetch" href="/assets/index.html-d48161b0.js" as="script"><link rel="prefetch" href="/assets/c__关键字说明.html-e57920d8.js" as="script"><link rel="prefetch" href="/assets/c__复习总攻略.html-16545d3d.js" as="script"><link rel="prefetch" href="/assets/c__指针与常量知识点专项说明.html-0f6f651a.js" as="script"><link rel="prefetch" href="/assets/c__部分内容(来源于牛客，自己增加).html-a662ce6d.js" as="script"><link rel="prefetch" href="/assets/c和c__字符串处理函数大汇总.html-31e478e4.js" as="script"><link rel="prefetch" href="/assets/C和C__学习思路.html-f9051988.js" as="script"><link rel="prefetch" href="/assets/c和c__的比较.html-c65b6570.js" as="script"><link rel="prefetch" href="/assets/python学习记录.html-c4fe7818.js" as="script"><link rel="prefetch" href="/assets/index.html-274a8eb6.js" as="script"><link rel="prefetch" href="/assets/内存分区问题.html-966164e4.js" as="script"><link rel="prefetch" href="/assets/参考资料汇总.html-69b3b0e3.js" as="script"><link rel="prefetch" href="/assets/结构体字节大小计算手册.html-d9017882.js" as="script"><link rel="prefetch" href="/assets/综合资料.html-9750832a.js" as="script"><link rel="prefetch" href="/assets/index.html-cf5d190b.js" as="script"><link rel="prefetch" href="/assets/大话数据结构和算法.html-e8344306.js" as="script"><link rel="prefetch" href="/assets/index.html-cda81d99.js" as="script"><link rel="prefetch" href="/assets/进程与线程.html-b93a32e6.js" as="script"><link rel="prefetch" href="/assets/IPv4学习记录.html-8e83d835.js" as="script"><link rel="prefetch" href="/assets/IP地址说明.html-ee8cc3b0.js" as="script"><link rel="prefetch" href="/assets/index.html-632b3c50.js" as="script"><link rel="prefetch" href="/assets/index.html-0e965c43.js" as="script"><link rel="prefetch" href="/assets/类的关系UML图.html-7ea4a2ee.js" as="script"><link rel="prefetch" href="/assets/设计模式总结.html-90f42962.js" as="script"><link rel="prefetch" href="/assets/docker记录.html-93188759.js" as="script"><link rel="prefetch" href="/assets/git提交命令.html-05330ad3.js" as="script"><link rel="prefetch" href="/assets/index.html-d2f1ad6f.js" as="script"><link rel="prefetch" href="/assets/tmux使用记录.html-d242b37a.js" as="script"><link rel="prefetch" href="/assets/使用clash代理需知.html-c18a24ff.js" as="script"><link rel="prefetch" href="/assets/关于cron和anacron.html-91517409.js" as="script"><link rel="prefetch" href="/assets/数据库mysql常用命令.html-10a4110d.js" as="script"><link rel="prefetch" href="/assets/终端美化记录.html-63d160ec.js" as="script"><link rel="prefetch" href="/assets/markdown之frontmatter设置.html-4ee0e780.js" as="script"><link rel="prefetch" href="/assets/markdown基本规则学习笔记.html-7c55d91e.js" as="script"><link rel="prefetch" href="/assets/index.html-39ab6932.js" as="script"><link rel="prefetch" href="/assets/1__WebServer学习笔记汇总.html-168f4dd7.js" as="script"><link rel="prefetch" href="/assets/2__小林coding的WebServer面试考点_独立版本.html-3ceb2023.js" as="script"><link rel="prefetch" href="/assets/3__Tiny综合学习_问答题综合_独立版本.html-1f104270.js" as="script"><link rel="prefetch" href="/assets/index.html-c375e18c.js" as="script"><link rel="prefetch" href="/assets/代码随想录学习笔记_总结_.html-7afc4e78.js" as="script"><link rel="prefetch" href="/assets/C__STL常用容器知识点说明.html-f48723c9.js" as="script"><link rel="prefetch" href="/assets/gdb调试手册.html-a6726557.js" as="script"><link rel="prefetch" href="/assets/index.html-e166b8b6.js" as="script"><link rel="prefetch" href="/assets/进程与线程笔记.html-c4e8e5e2.js" as="script"><link rel="prefetch" href="/assets/进程间通信学习内容.html-528e7174.js" as="script"><link rel="prefetch" href="/assets/部分有用网站记录.html-ad0b521e.js" as="script"><link rel="prefetch" href="/assets/index.html-62fde04a.js" as="script"><link rel="prefetch" href="/assets/index.html-29b7affc.js" as="script"><link rel="prefetch" href="/assets/index.html-8df85f88.js" as="script"><link rel="prefetch" href="/assets/index.html-19964234.js" as="script"><link rel="prefetch" href="/assets/index.html-c1b8d55b.js" as="script"><link rel="prefetch" href="/assets/index.html-9abae9df.js" as="script"><link rel="prefetch" href="/assets/404.html-15810e32.js" as="script"><link rel="prefetch" href="/assets/index.html-35c573c7.js" as="script"><link rel="prefetch" href="/assets/index.html-f1788570.js" as="script"><link rel="prefetch" href="/assets/index.html-ac95d164.js" as="script"><link rel="prefetch" href="/assets/index.html-9267dacb.js" as="script"><link rel="prefetch" href="/assets/index.html-5929313d.js" as="script"><link rel="prefetch" href="/assets/index.html-938d4764.js" as="script"><link rel="prefetch" href="/assets/index.html-e155b649.js" as="script"><link rel="prefetch" href="/assets/index.html-6b3eea3a.js" as="script"><link rel="prefetch" href="/assets/index.html-bf670873.js" as="script"><link rel="prefetch" href="/assets/index.html-3a1d6b0a.js" as="script"><link rel="prefetch" href="/assets/index.html-509e3521.js" as="script"><link rel="prefetch" href="/assets/index.html-deb86756.js" as="script"><link rel="prefetch" href="/assets/index.html-b18e713d.js" as="script"><link rel="prefetch" href="/assets/index.html-140b867f.js" as="script"><link rel="prefetch" href="/assets/index.html-07494391.js" as="script"><link rel="prefetch" href="/assets/index.html-1d054f09.js" as="script"><link rel="prefetch" href="/assets/index.html-5eac0c74.js" as="script"><link rel="prefetch" href="/assets/index.html-b12aef45.js" as="script"><link rel="prefetch" href="/assets/index.html-8ca6a783.js" as="script"><link rel="prefetch" href="/assets/index.html-917eeab2.js" as="script"><link rel="prefetch" href="/assets/index.html-f7365fb2.js" as="script"><link rel="prefetch" href="/assets/index.html-fab9cd16.js" as="script"><link rel="prefetch" href="/assets/index.html-3bf71061.js" as="script"><link rel="prefetch" href="/assets/index.html-bbebb3b0.js" as="script"><link rel="prefetch" href="/assets/index.html-9411c908.js" as="script"><link rel="prefetch" href="/assets/index.html-1879a8b9.js" as="script"><link rel="prefetch" href="/assets/index.html-ca696026.js" as="script"><link rel="prefetch" href="/assets/index.html-7cd66b0a.js" as="script"><link rel="prefetch" href="/assets/index.html-e15c1014.js" as="script"><link rel="prefetch" href="/assets/index.html-66a159e7.js" as="script"><link rel="prefetch" href="/assets/index.html-73892771.js" as="script"><link rel="prefetch" href="/assets/index.html-51b2f747.js" as="script"><link rel="prefetch" href="/assets/visitorbook.html-4f68fb5d.js" as="script"><link rel="prefetch" href="/assets/index.html-fa07182e.js" as="script"><link rel="prefetch" href="/assets/index.html-c5274f30.js" as="script"><link rel="prefetch" href="/assets/index.html-ec2c88b3.js" as="script"><link rel="prefetch" href="/assets/index.html-5db74b66.js" as="script"><link rel="prefetch" href="/assets/关于我.html-20221ae0.js" as="script"><link rel="prefetch" href="/assets/index.html-c556656f.js" as="script"><link rel="prefetch" href="/assets/index.html-17e278d1.js" as="script"><link rel="prefetch" href="/assets/index.html-d1273f11.js" as="script"><link rel="prefetch" href="/assets/index.html-e2732ecd.js" as="script"><link rel="prefetch" href="/assets/index.html-554e581b.js" as="script"><link rel="prefetch" href="/assets/index.html-145c6170.js" as="script"><link rel="prefetch" href="/assets/index.html-67f2fb49.js" as="script"><link rel="prefetch" href="/assets/c__关键字说明.html-23cf2ac3.js" as="script"><link rel="prefetch" href="/assets/c__复习总攻略.html-67c5ab3b.js" as="script"><link rel="prefetch" href="/assets/c__指针与常量知识点专项说明.html-95f23508.js" as="script"><link rel="prefetch" href="/assets/c__部分内容(来源于牛客，自己增加).html-9b724353.js" as="script"><link rel="prefetch" href="/assets/c和c__字符串处理函数大汇总.html-0c89e5a2.js" as="script"><link rel="prefetch" href="/assets/C和C__学习思路.html-f9dbef1f.js" as="script"><link rel="prefetch" href="/assets/c和c__的比较.html-a9d989e3.js" as="script"><link rel="prefetch" href="/assets/python学习记录.html-8841674e.js" as="script"><link rel="prefetch" href="/assets/index.html-3b8e7727.js" as="script"><link rel="prefetch" href="/assets/内存分区问题.html-85c8bd02.js" as="script"><link rel="prefetch" href="/assets/参考资料汇总.html-8bc3d5bd.js" as="script"><link rel="prefetch" href="/assets/结构体字节大小计算手册.html-12a2f0ce.js" as="script"><link rel="prefetch" href="/assets/综合资料.html-ae88d9ca.js" as="script"><link rel="prefetch" href="/assets/index.html-65af008c.js" as="script"><link rel="prefetch" href="/assets/大话数据结构和算法.html-e14ce945.js" as="script"><link rel="prefetch" href="/assets/index.html-8b226710.js" as="script"><link rel="prefetch" href="/assets/进程与线程.html-64582975.js" as="script"><link rel="prefetch" href="/assets/IPv4学习记录.html-58ff4c7e.js" as="script"><link rel="prefetch" href="/assets/IP地址说明.html-4e329233.js" as="script"><link rel="prefetch" href="/assets/index.html-048b1345.js" as="script"><link rel="prefetch" href="/assets/index.html-8d43775e.js" as="script"><link rel="prefetch" href="/assets/类的关系UML图.html-42290e71.js" as="script"><link rel="prefetch" href="/assets/设计模式总结.html-65386c99.js" as="script"><link rel="prefetch" href="/assets/docker记录.html-21def323.js" as="script"><link rel="prefetch" href="/assets/git提交命令.html-8e79988c.js" as="script"><link rel="prefetch" href="/assets/index.html-1203c22e.js" as="script"><link rel="prefetch" href="/assets/tmux使用记录.html-18509a05.js" as="script"><link rel="prefetch" href="/assets/使用clash代理需知.html-31c20cd2.js" as="script"><link rel="prefetch" href="/assets/关于cron和anacron.html-1a802f6c.js" as="script"><link rel="prefetch" href="/assets/数据库mysql常用命令.html-dcef07a8.js" as="script"><link rel="prefetch" href="/assets/终端美化记录.html-cd5190ba.js" as="script"><link rel="prefetch" href="/assets/markdown之frontmatter设置.html-3b885be9.js" as="script"><link rel="prefetch" href="/assets/markdown基本规则学习笔记.html-3306698f.js" as="script"><link rel="prefetch" href="/assets/index.html-387124b8.js" as="script"><link rel="prefetch" href="/assets/1__WebServer学习笔记汇总.html-72117f24.js" as="script"><link rel="prefetch" href="/assets/2__小林coding的WebServer面试考点_独立版本.html-a689fc68.js" as="script"><link rel="prefetch" href="/assets/3__Tiny综合学习_问答题综合_独立版本.html-1cbe2f5f.js" as="script"><link rel="prefetch" href="/assets/index.html-da82e235.js" as="script"><link rel="prefetch" href="/assets/代码随想录学习笔记_总结_.html-def43b7a.js" as="script"><link rel="prefetch" href="/assets/C__STL常用容器知识点说明.html-a2c87516.js" as="script"><link rel="prefetch" href="/assets/gdb调试手册.html-e1e66ac1.js" as="script"><link rel="prefetch" href="/assets/index.html-99ec40a4.js" as="script"><link rel="prefetch" href="/assets/进程与线程笔记.html-27a9bdae.js" as="script"><link rel="prefetch" href="/assets/进程间通信学习内容.html-849da8bc.js" as="script"><link rel="prefetch" href="/assets/部分有用网站记录.html-82b409c3.js" as="script"><link rel="prefetch" href="/assets/index.html-4de4de6c.js" as="script"><link rel="prefetch" href="/assets/index.html-aa7d17f3.js" as="script"><link rel="prefetch" href="/assets/index.html-7005c79a.js" as="script"><link rel="prefetch" href="/assets/index.html-12d9e9f8.js" as="script"><link rel="prefetch" href="/assets/index.html-aefe17d6.js" as="script"><link rel="prefetch" href="/assets/index.html-40d27344.js" as="script"><link rel="prefetch" href="/assets/404.html-f4089c89.js" as="script"><link rel="prefetch" href="/assets/index.html-ae0df1bc.js" as="script"><link rel="prefetch" href="/assets/index.html-73c2740f.js" as="script"><link rel="prefetch" href="/assets/index.html-4540c1f3.js" as="script"><link rel="prefetch" href="/assets/index.html-bee6acac.js" as="script"><link rel="prefetch" href="/assets/index.html-ff9798bd.js" as="script"><link rel="prefetch" href="/assets/index.html-27dea863.js" as="script"><link rel="prefetch" href="/assets/index.html-3621cee8.js" as="script"><link rel="prefetch" href="/assets/index.html-1abc2fc4.js" as="script"><link rel="prefetch" href="/assets/index.html-0efc1941.js" as="script"><link rel="prefetch" href="/assets/index.html-9a4a9cb8.js" as="script"><link rel="prefetch" href="/assets/index.html-d8044145.js" as="script"><link rel="prefetch" href="/assets/index.html-1ddff557.js" as="script"><link rel="prefetch" href="/assets/index.html-6606fff1.js" as="script"><link rel="prefetch" href="/assets/index.html-79ee8eb8.js" as="script"><link rel="prefetch" href="/assets/index.html-83499417.js" as="script"><link rel="prefetch" href="/assets/index.html-eccaca47.js" as="script"><link rel="prefetch" href="/assets/index.html-e6ec9749.js" as="script"><link rel="prefetch" href="/assets/index.html-13270fee.js" as="script"><link rel="prefetch" href="/assets/index.html-47178326.js" as="script"><link rel="prefetch" href="/assets/index.html-917c11b9.js" as="script"><link rel="prefetch" href="/assets/index.html-6627f487.js" as="script"><link rel="prefetch" href="/assets/index.html-591c91bc.js" as="script"><link rel="prefetch" href="/assets/index.html-261d9c5b.js" as="script"><link rel="prefetch" href="/assets/index.html-2e422d17.js" as="script"><link rel="prefetch" href="/assets/index.html-498cd3ec.js" as="script"><link rel="prefetch" href="/assets/index.html-fc393400.js" as="script"><link rel="prefetch" href="/assets/index.html-0d9a25d0.js" as="script"><link rel="prefetch" href="/assets/index.html-ea0ff583.js" as="script"><link rel="prefetch" href="/assets/index.html-ef229e81.js" as="script"><link rel="prefetch" href="/assets/index.html-a00083d2.js" as="script"><link rel="prefetch" href="/assets/index.html-b845ce7a.js" as="script"><link rel="prefetch" href="/assets/dash.all.min-971bb768.js" as="script"><link rel="prefetch" href="/assets/mpegts-57a989ba.js" as="script"><link rel="prefetch" href="/assets/hls.min-dcc0ca18.js" as="script"><link rel="prefetch" href="/assets/artplayer-d52464c4.js" as="script"><link rel="prefetch" href="/assets/plyr.min-65d8b78a.js" as="script"><link rel="prefetch" href="/assets/plyr.min-65d8b78a.js" as="script"><link rel="prefetch" href="/assets/auto-fa8841cf.js" as="script"><link rel="prefetch" href="/assets/index-b03bef79.js" as="script"><link rel="prefetch" href="/assets/flowchart-d65a1d8e.js" as="script"><link rel="prefetch" href="/assets/mermaid.core-11a48a09.js" as="script"><link rel="prefetch" href="/assets/highlight.esm-75b11b9d.js" as="script"><link rel="prefetch" href="/assets/markdown.esm-0191f9da.js" as="script"><link rel="prefetch" href="/assets/math.esm-70a288c8.js" as="script"><link rel="prefetch" href="/assets/notes.esm-a106bb2c.js" as="script"><link rel="prefetch" href="/assets/reveal.esm-ab04f0b1.js" as="script"><link rel="prefetch" href="/assets/search.esm-7e6792e2.js" as="script"><link rel="prefetch" href="/assets/zoom.esm-b83b91d0.js" as="script"><link rel="prefetch" href="/assets/VuePlayground-0a52d59d.js" as="script"><link rel="prefetch" href="/assets/photoswipe.esm-36cd6c3c.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">跳至主要內容</a><!--]--><div class="theme-container has-toc"><!--[--><header class="navbar auto-hide" id="navbar"><div class="navbar-start"><button type="button" class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><!----><!--]--><!--[--><a href="/" class="brand"><img class="logo" src="/site_logo.png" alt="开心酒馆"><!----><span class="site-name hide-in-pad">开心酒馆</span></a><!--]--><!--[--><!----><!--]--></div><div class="navbar-center"><!--[--><!----><!--]--><!--[--><nav class="nav-links"><div class="nav-item hide-in-mobile"><a href="/" class="nav-link" aria-label="首页"><span class="font-icon icon iconfont icon-home" style=""></span>首页<!----></a></div><div class="nav-item hide-in-mobile"><a href="/quicknav/" class="nav-link" aria-label="快速导航"><span class="font-icon icon iconfont icon-navigation" style=""></span>快速导航<!----></a></div><div class="nav-item hide-in-mobile"><a href="/blog/" class="nav-link" aria-label="博客主页"><span class="font-icon icon iconfont icon-blog" style=""></span>博客主页<!----></a></div><div class="nav-item hide-in-mobile"><a href="/docs/" class="nav-link active" aria-label="代码笔记"><span class="font-icon icon iconfont icon-code" style=""></span>代码笔记<!----></a></div><div class="nav-item hide-in-mobile"><a href="/floatinglife/" class="nav-link" aria-label="浮生杂记"><span class="font-icon icon iconfont icon-note" style=""></span>浮生杂记<!----></a></div><div class="nav-item hide-in-mobile"><a href="/projects/" class="nav-link" aria-label="开源项目"><span class="font-icon icon iconfont icon-free" style=""></span>开源项目<!----></a></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button type="button" class="dropdown-title" aria-label="资源宝库"><span class="title"><span class="font-icon icon iconfont icon-advance" style=""></span>资源宝库</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/resources/books/" class="nav-link" aria-label="书籍资源"><span class="font-icon icon iconfont icon-animation" style=""></span>书籍资源<!----></a></li><li class="dropdown-item"><a href="/resources/videos/" class="nav-link" aria-label="影音资源"><span class="font-icon icon iconfont icon-play" style=""></span>影音资源<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><a href="/visitorbook.html" class="nav-link" aria-label="留言板"><span class="font-icon icon iconfont icon-mark" style=""></span>留言板<!----></a></div><div class="nav-item hide-in-mobile"><a href="/control/" class="nav-link" aria-label="管理员平台"><span class="font-icon icon iconfont icon-operate" style=""></span>管理员平台<!----></a></div></nav><!--]--><!--[--><!----><!--]--></div><div class="navbar-end"><!--[--><!----><!--]--><!--[--><!----><div class="nav-item"><a class="repo-link" href="https://github.com/XiaoYuer2022" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="github icon" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><div class="nav-item hide-in-mobile"><button type="button" class="outlook-button" tabindex="-1" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" class="icon outlook-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="outlook icon"><path d="M224 800c0 9.6 3.2 44.8 6.4 54.4 6.4 48-48 76.8-48 76.8s80 41.6 147.2 0 134.4-134.4 38.4-195.2c-22.4-12.8-41.6-19.2-57.6-19.2C259.2 716.8 227.2 761.6 224 800zM560 675.2l-32 51.2c-51.2 51.2-83.2 32-83.2 32 25.6 67.2 0 112-12.8 128 25.6 6.4 51.2 9.6 80 9.6 54.4 0 102.4-9.6 150.4-32l0 0c3.2 0 3.2-3.2 3.2-3.2 22.4-16 12.8-35.2 6.4-44.8-9.6-12.8-12.8-25.6-12.8-41.6 0-54.4 60.8-99.2 137.6-99.2 6.4 0 12.8 0 22.4 0 12.8 0 38.4 9.6 48-25.6 0-3.2 0-3.2 3.2-6.4 0-3.2 3.2-6.4 3.2-6.4 6.4-16 6.4-16 6.4-19.2 9.6-35.2 16-73.6 16-115.2 0-105.6-41.6-198.4-108.8-268.8C704 396.8 560 675.2 560 675.2zM224 419.2c0-28.8 22.4-51.2 51.2-51.2 28.8 0 51.2 22.4 51.2 51.2 0 28.8-22.4 51.2-51.2 51.2C246.4 470.4 224 448 224 419.2zM320 284.8c0-22.4 19.2-41.6 41.6-41.6 22.4 0 41.6 19.2 41.6 41.6 0 22.4-19.2 41.6-41.6 41.6C339.2 326.4 320 307.2 320 284.8zM457.6 208c0-12.8 12.8-25.6 25.6-25.6 12.8 0 25.6 12.8 25.6 25.6 0 12.8-12.8 25.6-25.6 25.6C470.4 233.6 457.6 220.8 457.6 208zM128 505.6C128 592 153.6 672 201.6 736c28.8-60.8 112-60.8 124.8-60.8-16-51.2 16-99.2 16-99.2l316.8-422.4c-48-19.2-99.2-32-150.4-32C297.6 118.4 128 291.2 128 505.6zM764.8 86.4c-22.4 19.2-390.4 518.4-390.4 518.4-22.4 28.8-12.8 76.8 22.4 99.2l9.6 6.4c35.2 22.4 80 12.8 99.2-25.6 0 0 6.4-12.8 9.6-19.2 54.4-105.6 275.2-524.8 288-553.6 6.4-19.2-3.2-32-19.2-32C777.6 76.8 771.2 80 764.8 86.4z"></path></svg><div class="outlook-dropdown"><!----></div></button></div><form class="search-box" role="search"><input type="search" placeholder="搜索本站" autocomplete="off" spellcheck="false" value><!----></form><!--]--><!--[--><!----><!--]--><button type="button" class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside class="sidebar" id="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"><li><section class="sidebar-group"><button class="sidebar-heading clickable active" type="button"><span class="font-icon icon iconfont icon-c" style=""></span><span class="title">编程语言基础</span><span class="arrow down"></span></button><ul class="sidebar-links"><li><!--[--><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html" class="router-link-active router-link-exact-active nav-link active sidebar-link sidebar-page active" aria-label="ALL_C++全面总结"><span class="font-icon icon iconfont icon-write" style=""></span>ALL_C++全面总结<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_1、c-基础" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1、C++基础"><!---->1、C++基础<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_1-1-简述c-语言的特点" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.1 简述C++语言的特点"><!---->1.1 简述C++语言的特点<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_1-2-说说c语言与c-语言的区别" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.2 说说C语言与C++语言的区别"><!---->1.2 说说C语言与C++语言的区别<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_1-3-说说c-中struct和class的区别" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.3 说说C++中struct和class的区别"><!---->1.3 说说C++中struct和class的区别<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_1-4-说说c中结构体和c-中结构体的区别" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.4 说说C中结构体和C++中结构体的区别"><!---->1.4 说说C中结构体和C++中结构体的区别<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_1-5-说说include头文件的顺序以及双引号-和尖括号-的区别" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.5 说说include头文件的顺序以及双引号“”和尖括号&lt;&gt;的区别"><!---->1.5 说说include头文件的顺序以及双引号“”和尖括号&lt;&gt;的区别<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_1-6-导入c函数的关键字是什么-c-编译的时候与c有什么区别" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.6 导入C函数的关键字是什么，C++编译的时候与C有什么区别"><!---->1.6 导入C函数的关键字是什么，C++编译的时候与C有什么区别<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_1-7-简述c-从代码到可执行二进制文件的过程" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.7 简述C++从代码到可执行二进制文件的过程"><!---->1.7 简述C++从代码到可执行二进制文件的过程<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_1-8-说说-static关键字的作用" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.8 说说 static关键字的作用"><!---->1.8 说说 static关键字的作用<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_1-9-说说数组和指针的区别" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.9 说说数组和指针的区别"><!---->1.9 说说数组和指针的区别<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_1-10-说说什么是函数指针-如何定义函数指针-有什么使用场景" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.10 说说什么是函数指针，如何定义函数指针，有什么使用场景"><!---->1.10 说说什么是函数指针，如何定义函数指针，有什么使用场景<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_1-11-说说静态变量什么时候初始化" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.11 说说静态变量什么时候初始化"><!---->1.11 说说静态变量什么时候初始化<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_1-12-nullptr可以调用成员函数吗-为什么" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.12 nullptr可以调用成员函数吗，为什么？"><!---->1.12 nullptr可以调用成员函数吗，为什么？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_1-13-什么是野指针-怎么产生的-如何避免" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.13 什么是野指针，怎么产生的，如何避免？"><!---->1.13 什么是野指针，怎么产生的，如何避免？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_1-14-说说静态局部变量-全局变量-局部变量的特点-以及使用场景" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.14 说说静态局部变量，全局变量，局部变量的特点，以及使用场景"><!---->1.14 说说静态局部变量，全局变量，局部变量的特点，以及使用场景<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_1-15-说说内联函数和宏函数的区别" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.15 说说内联函数和宏函数的区别"><!---->1.15 说说内联函数和宏函数的区别<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_1-16-说说运算符i-和-i的区别" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.16 说说运算符i++和++i的区别"><!---->1.16 说说运算符i++和++i的区别<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_1-17-说说new和malloc的区别-各自底层实现原理" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.17 说说new和malloc的区别，各自底层实现原理"><!---->1.17 说说new和malloc的区别，各自底层实现原理<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_1-18-说说const和define的区别" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.18 说说const和define的区别"><!---->1.18 说说const和define的区别<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_1-19-说说c-中函数指针和指针函数的区别" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.19 说说C++中函数指针和指针函数的区别"><!---->1.19 说说C++中函数指针和指针函数的区别<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_1-20-说说const-int-a-int-const-a-const-int-a-int-const-a-const-int-const-a分别是什么-有什么特点。" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.20 说说const int *a, int const *a, const int a, int *const a, const int *const a分别是什么，有什么特点。"><!---->1.20 说说const int *a, int const *a, const int a, int *const a, const int *const a分别是什么，有什么特点。<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_1-21-说说使用指针需要注意什么" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.21 说说使用指针需要注意什么？"><!---->1.21 说说使用指针需要注意什么？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_1-22-说说内联函数和函数的区别-内联函数的作用" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.22 说说内联函数和函数的区别，内联函数的作用"><!---->1.22 说说内联函数和函数的区别，内联函数的作用<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_1-23-简述c-有几种传值方式-之间的区别是什么" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.23 简述C++有几种传值方式，之间的区别是什么？"><!---->1.23 简述C++有几种传值方式，之间的区别是什么？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_1-24-简述const-星号-和-星号-const的区别" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.24 简述const（星号）和（星号）const的区别"><!---->1.24 简述const（星号）和（星号）const的区别<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_2、c-c-内存问题" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2、C/C++内存问题"><!---->2、C/C++内存问题<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_2-1-简述一下堆和栈的区别" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2.1 简述一下堆和栈的区别"><!---->2.1 简述一下堆和栈的区别<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_2-2-简述c-的内存管理" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2.2 简述C++的内存管理"><!---->2.2 简述C++的内存管理<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_2-3-malloc和局部变量分配在堆还是栈" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2.3 malloc和局部变量分配在堆还是栈？"><!---->2.3 malloc和局部变量分配在堆还是栈？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_2-4-程序有哪些section-分别的作用-程序启动的过程-怎么判断数据分配在栈上还是堆上" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2.4 程序有哪些section，分别的作用？程序启动的过程？怎么判断数据分配在栈上还是堆上？"><!---->2.4 程序有哪些section，分别的作用？程序启动的过程？怎么判断数据分配在栈上还是堆上？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_2-5-初始化为0的全局变量在bss还是data" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2.5 初始化为0的全局变量在bss还是data"><!---->2.5 初始化为0的全局变量在bss还是data<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_2-6-请简述一下atomoic内存顺序" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2.6 请简述一下atomoic内存顺序"><!---->2.6 请简述一下atomoic内存顺序<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_2-7-简述c-中内存对齐的使用场景" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2.7 简述C++中内存对齐的使用场景"><!---->2.7 简述C++中内存对齐的使用场景<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_3、c-面向对象" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3、C++面向对象"><!---->3、C++面向对象<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_3-1-简述一下什么是面向对象" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.1 简述一下什么是面向对象"><!---->3.1 简述一下什么是面向对象<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_3-2-简述一下面向对象的三大特征" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.2 简述一下面向对象的三大特征"><!---->3.2 简述一下面向对象的三大特征<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_3-3-简述一下c-的重写与重载-以及他们之间的区别" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.3 简述一下C++的重写与重载，以及他们之间的区别"><!---->3.3 简述一下C++的重写与重载，以及他们之间的区别<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_3-4-c-如何实现重写与重载的-在c语言中怎么实现函数重载" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.4 C++如何实现重写与重载的？在C语言中怎么实现函数重载？"><!---->3.4 C++如何实现重写与重载的？在C语言中怎么实现函数重载？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_3-5-构造函数分为哪几种" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.5 构造函数分为哪几种？"><!---->3.5 构造函数分为哪几种？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_3-6-只定义析构函数-会自动生成哪些构造函数" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.6 只定义析构函数，会自动生成哪些构造函数"><!---->3.6 只定义析构函数，会自动生成哪些构造函数<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_3-7-说说一个类-默认会生成哪些函数" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.7 说说一个类，默认会生成哪些函数"><!---->3.7 说说一个类，默认会生成哪些函数<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_3-8-说说-c-类对象的初始化顺序-有多重继承情况下的顺序" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.8 说说 C++ 类对象的初始化顺序，有多重继承情况下的顺序"><!---->3.8 说说 C++ 类对象的初始化顺序，有多重继承情况下的顺序<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_3-9-简述下向上转型和向下转型" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.9 简述下向上转型和向下转型"><!---->3.9 简述下向上转型和向下转型<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_3-10-简述下深拷贝和浅拷贝-如何实现深拷贝" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.10 简述下深拷贝和浅拷贝，如何实现深拷贝"><!---->3.10 简述下深拷贝和浅拷贝，如何实现深拷贝<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_3-11-简述一下c-中的多态" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.11 简述一下C++中的多态"><!---->3.11 简述一下C++中的多态<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_3-12-为什么要虚析构-为什么不能虚构造" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.12 为什么要虚析构，为什么不能虚构造？"><!---->3.12 为什么要虚析构，为什么不能虚构造？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_3-13-说说模板类是在什么时候实现的" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.13 说说模板类是在什么时候实现的"><!---->3.13 说说模板类是在什么时候实现的<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_3-14-说说类继承时-派生类对不同关键字修饰的基类方法的访问权限" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.14 说说类继承时，派生类对不同关键字修饰的基类方法的访问权限"><!---->3.14 说说类继承时，派生类对不同关键字修饰的基类方法的访问权限<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_3-15-简述一下移动构造函数-什么库用到了这个函数" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.15 简述一下移动构造函数，什么库用到了这个函数？"><!---->3.15 简述一下移动构造函数，什么库用到了这个函数？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_3-16-请你回答一下-c-类内可以定义引用数据成员吗" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.16 请你回答一下 C++ 类内可以定义引用数据成员吗？"><!---->3.16 请你回答一下 C++ 类内可以定义引用数据成员吗？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_3-17-简述一下什么是常函数-有什么作用" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.17 简述一下什么是常函数，有什么作用"><!---->3.17 简述一下什么是常函数，有什么作用<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_3-18-说说什么是虚继承-解决什么问题-如何实现" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.18 说说什么是虚继承，解决什么问题，如何实现？"><!---->3.18 说说什么是虚继承，解决什么问题，如何实现？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_3-19-简述一下虚函数和纯虚函数-以及实现原理" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.19 简述一下虚函数和纯虚函数，以及实现原理"><!---->3.19 简述一下虚函数和纯虚函数，以及实现原理<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_3-20-说说纯虚函数能实例化吗-为什么-派生类要实现吗-为什么" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.20 说说纯虚函数能实例化吗，为什么？派生类要实现吗，为什么？"><!---->3.20 说说纯虚函数能实例化吗，为什么？派生类要实现吗，为什么？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_3-21-说说c-中虚函数与纯虚函数的区别" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.21 说说C++中虚函数与纯虚函数的区别"><!---->3.21 说说C++中虚函数与纯虚函数的区别<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_3-22-说说-c-中什么是菱形继承问题-如何解决" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.22 说说 C++ 中什么是菱形继承问题，如何解决"><!---->3.22 说说 C++ 中什么是菱形继承问题，如何解决<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_3-23-请问构造函数中的能不能调用虚方法" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.23 请问构造函数中的能不能调用虚方法"><!---->3.23 请问构造函数中的能不能调用虚方法<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_3-24-请问拷贝构造函数的参数是什么传递方式-为什么" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.24 请问拷贝构造函数的参数是什么传递方式，为什么"><!---->3.24 请问拷贝构造函数的参数是什么传递方式，为什么<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_3-25-如何理解抽象类" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.25 如何理解抽象类？"><!---->3.25 如何理解抽象类？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_3-26-什么是多态-除了虚函数-还有什么方式能实现多态" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.26 什么是多态？除了虚函数，还有什么方式能实现多态？"><!---->3.26 什么是多态？除了虚函数，还有什么方式能实现多态？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_3-27-简述一下虚析构函数-什么作用" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.27 简述一下虚析构函数，什么作用"><!---->3.27 简述一下虚析构函数，什么作用<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_3-28-说说什么是虚基类-可否被实例化" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.28 说说什么是虚基类，可否被实例化？"><!---->3.28 说说什么是虚基类，可否被实例化？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_3-29-简述一下拷贝赋值和移动赋值" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.29  简述一下拷贝赋值和移动赋值？"><!---->3.29  简述一下拷贝赋值和移动赋值？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_3-30-仿函数了解吗-有什么作用" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.30 仿函数了解吗？有什么作用"><!---->3.30 仿函数了解吗？有什么作用<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_3-31-c-中哪些函数不能被声明为虚函数" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.31 C++ 中哪些函数不能被声明为虚函数？"><!---->3.31 C++ 中哪些函数不能被声明为虚函数？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_3-32-解释下-c-中类模板和模板类的区别" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.32 解释下 C++ 中类模板和模板类的区别"><!---->3.32 解释下 C++ 中类模板和模板类的区别<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_3-33-虚函数表里存放的内容是什么时候写进去的" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.33 虚函数表里存放的内容是什么时候写进去的？"><!---->3.33 虚函数表里存放的内容是什么时候写进去的？<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_4、标准模板库stl" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4、标准模板库STL"><!---->4、标准模板库STL<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_5、c-新特性" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5、C++新特性"><!---->5、C++新特性<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_5-1-c-新特性" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5.1 C++新特性"><!---->5.1 C++新特性<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_5-2-说说-c-中智能指针和指针的区别是什么" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5.2 说说 C++ 中智能指针和指针的区别是什么？"><!---->5.2 说说 C++ 中智能指针和指针的区别是什么？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_5-3" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5.3"><!---->5.3<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_6、c-操作系统-linux相关" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6、C++操作系统（Linux相关）"><!---->6、C++操作系统（Linux相关）<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_7、计算机网络" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="7、计算机网络"><!---->7、计算机网络<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_8、设计模式-摘选" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="8、设计模式（摘选）"><!---->8、设计模式（摘选）<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_9、常见编程大题" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="9、常见编程大题"><!---->9、常见编程大题<!----></a><ul class="sidebar-sub-headers"></ul></li></ul><!--]--></li><li><!--[--><a href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/c__%E9%83%A8%E5%88%86%E5%86%85%E5%AE%B9(%E6%9D%A5%E6%BA%90%E4%BA%8E%E7%89%9B%E5%AE%A2%EF%BC%8C%E8%87%AA%E5%B7%B1%E5%A2%9E%E5%8A%A0).html" class="nav-link sidebar-link sidebar-page" aria-label="C++部分内容(来源于牛客，自己增加)"><span class="font-icon icon iconfont icon-write" style=""></span>C++部分内容(来源于牛客，自己增加)<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/c__%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%94%BB%E7%95%A5.html" class="nav-link sidebar-link sidebar-page" aria-label="c++复习总攻略.md"><span class="font-icon icon iconfont icon-write" style=""></span>c++复习总攻略.md<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/c__%E6%8C%87%E9%92%88%E4%B8%8E%E5%B8%B8%E9%87%8F%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%93%E9%A1%B9%E8%AF%B4%E6%98%8E.html" class="nav-link sidebar-link sidebar-page" aria-label="C++指针与常量知识点专项说明"><span class="font-icon icon iconfont icon-write" style=""></span>C++指针与常量知识点专项说明<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/c%E5%92%8Cc__%E7%9A%84%E6%AF%94%E8%BE%83.html" class="nav-link sidebar-link sidebar-page" aria-label="C和C++的比较"><span class="font-icon icon iconfont icon-write" style=""></span>C和C++的比较<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/C%E5%92%8CC__%E5%AD%A6%E4%B9%A0%E6%80%9D%E8%B7%AF.html" class="nav-link sidebar-link sidebar-page" aria-label="C和C++学习思路"><span class="font-icon icon iconfont icon-write" style=""></span>C和C++学习思路<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/c%E5%92%8Cc__%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%E5%A4%A7%E6%B1%87%E6%80%BB.html" class="nav-link sidebar-link sidebar-page" aria-label="C和C++字符串处理函数大汇总"><span class="font-icon icon iconfont icon-write" style=""></span>C和C++字符串处理函数大汇总<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/python%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.html" class="nav-link sidebar-link sidebar-page" aria-label="Python学习记录"><span class="font-icon icon iconfont icon-write" style=""></span>Python学习记录<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99%E6%B1%87%E6%80%BB.html" class="nav-link sidebar-link sidebar-page" aria-label="参考资料汇总"><span class="font-icon icon iconfont icon-write" style=""></span>参考资料汇总<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA%E9%97%AE%E9%A2%98.html" class="nav-link sidebar-link sidebar-page" aria-label="内存分区问题"><span class="font-icon icon iconfont icon-write" style=""></span>内存分区问题<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E7%BB%93%E6%9E%84%E4%BD%93%E5%AD%97%E8%8A%82%E5%A4%A7%E5%B0%8F%E8%AE%A1%E7%AE%97%E6%89%8B%E5%86%8C.html" class="nav-link sidebar-link sidebar-page" aria-label="结构体字节大小计算手册"><span class="font-icon icon iconfont icon-write" style=""></span>结构体字节大小计算手册<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E7%BB%BC%E5%90%88%E8%B5%84%E6%96%99.html" class="nav-link sidebar-link sidebar-page" aria-label="综合资料"><span class="font-icon icon iconfont icon-write" style=""></span>综合资料<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable" type="button"><span class="font-icon icon iconfont icon-engine" style=""></span><span class="title">数据结构与算法</span><span class="arrow end"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable" type="button"><span class="font-icon icon iconfont icon-frame" style=""></span><span class="title">操作系统与计算机基础</span><span class="arrow end"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable" type="button"><span class="font-icon icon iconfont icon-ability" style=""></span><span class="title">计算机网络</span><span class="arrow end"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable" type="button"><span class="font-icon icon iconfont icon-mysql" style=""></span><span class="title">设计模式</span><span class="arrow end"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable" type="button"><span class="font-icon icon iconfont icon-tool" style=""></span><span class="title">找工作相关</span><span class="arrow end"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable" type="button"><span class="font-icon icon iconfont icon-tool" style=""></span><span class="title">Linux运行维护相关</span><span class="arrow end"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable" type="button"><span class="font-icon icon iconfont icon-read" style=""></span><span class="title">MarkDown书写规则</span><span class="arrow end"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable" type="button"><span class="font-icon icon iconfont icon-read" style=""></span><span class="title">未分类</span><span class="arrow end"></span></button><!----></section></li></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!--[--><!----><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><!---->全面内容综述</h1><div class="page-info"><span class="page-author-info" aria-label="作者🖊" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="page-author-item" href="https://haoxx.top/" target="_blank" rel="noopener noreferrer">Mr.HaoXX</a></span><span property="author" content="Mr.HaoXX"></span></span><!----><span class="page-date-info" aria-label="写作日期📅" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span><!----></span><meta property="datePublished" content="2022-10-30T00:00:00.000Z"></span><!----><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 101 分钟</span><meta property="timeRequired" content="PT101M"></span><span class="page-category-info" aria-label="分类🌈" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon category-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="category icon"><path d="M148.41 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H148.41c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.311-40.31zM147.556 553.478H429.73c22.263 0 40.311 18.048 40.311 40.31v282.176c0 22.263-18.048 40.312-40.31 40.312H147.555c-22.263 0-40.311-18.049-40.311-40.312V593.79c0-22.263 18.048-40.311 40.31-40.311zM593.927 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H593.927c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.31-40.31zM730.22 920.502H623.926c-40.925 0-74.22-33.388-74.22-74.425V623.992c0-41.038 33.387-74.424 74.425-74.424h222.085c41.038 0 74.424 33.226 74.424 74.067v114.233c0 10.244-8.304 18.548-18.547 18.548s-18.548-8.304-18.548-18.548V623.635c0-20.388-16.746-36.974-37.33-36.974H624.13c-20.585 0-37.331 16.747-37.331 37.33v222.086c0 20.585 16.654 37.331 37.126 37.331H730.22c10.243 0 18.547 8.304 18.547 18.547 0 10.244-8.304 18.547-18.547 18.547z"></path></svg><!--[--><span class="page-category-item category6 clickable" role="navigation">1编程语言基础</span><!--]--><meta property="articleSection" content="1编程语言基础"></span><!----></div><hr></div><div class="toc-place-holder"><aside id="toc"><!--[--><!----><!--]--><div class="toc-header">此页内容<button type="button" class="print-button" title="打印"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button></div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_1、c-基础" class="router-link-active router-link-exact-active toc-link level2">1、C++基础</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_1-1-简述c-语言的特点" class="router-link-active router-link-exact-active toc-link level3">1.1 简述C++语言的特点</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_1-2-说说c语言与c-语言的区别" class="router-link-active router-link-exact-active toc-link level3">1.2 说说C语言与C++语言的区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_1-3-说说c-中struct和class的区别" class="router-link-active router-link-exact-active toc-link level3">1.3 说说C++中struct和class的区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_1-4-说说c中结构体和c-中结构体的区别" class="router-link-active router-link-exact-active toc-link level3">1.4 说说C中结构体和C++中结构体的区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_1-5-说说include头文件的顺序以及双引号-和尖括号-的区别" class="router-link-active router-link-exact-active toc-link level3">1.5 说说include头文件的顺序以及双引号“”和尖括号&lt;&gt;的区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_1-6-导入c函数的关键字是什么-c-编译的时候与c有什么区别" class="router-link-active router-link-exact-active toc-link level3">1.6 导入C函数的关键字是什么，C++编译的时候与C有什么区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_1-7-简述c-从代码到可执行二进制文件的过程" class="router-link-active router-link-exact-active toc-link level3">1.7 简述C++从代码到可执行二进制文件的过程</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_1-8-说说-static关键字的作用" class="router-link-active router-link-exact-active toc-link level3">1.8 说说 static关键字的作用</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_1-9-说说数组和指针的区别" class="router-link-active router-link-exact-active toc-link level3">1.9 说说数组和指针的区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_1-10-说说什么是函数指针-如何定义函数指针-有什么使用场景" class="router-link-active router-link-exact-active toc-link level3">1.10 说说什么是函数指针，如何定义函数指针，有什么使用场景</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_1-11-说说静态变量什么时候初始化" class="router-link-active router-link-exact-active toc-link level3">1.11 说说静态变量什么时候初始化</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_1-12-nullptr可以调用成员函数吗-为什么" class="router-link-active router-link-exact-active toc-link level3">1.12 nullptr可以调用成员函数吗，为什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_1-13-什么是野指针-怎么产生的-如何避免" class="router-link-active router-link-exact-active toc-link level3">1.13 什么是野指针，怎么产生的，如何避免？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_1-14-说说静态局部变量-全局变量-局部变量的特点-以及使用场景" class="router-link-active router-link-exact-active toc-link level3">1.14 说说静态局部变量，全局变量，局部变量的特点，以及使用场景</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_1-15-说说内联函数和宏函数的区别" class="router-link-active router-link-exact-active toc-link level3">1.15 说说内联函数和宏函数的区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_1-16-说说运算符i-和-i的区别" class="router-link-active router-link-exact-active toc-link level3">1.16 说说运算符i++和++i的区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_1-17-说说new和malloc的区别-各自底层实现原理" class="router-link-active router-link-exact-active toc-link level3">1.17 说说new和malloc的区别，各自底层实现原理</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_1-18-说说const和define的区别" class="router-link-active router-link-exact-active toc-link level3">1.18 说说const和define的区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_1-19-说说c-中函数指针和指针函数的区别" class="router-link-active router-link-exact-active toc-link level3">1.19 说说C++中函数指针和指针函数的区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_1-20-说说const-int-a-int-const-a-const-int-a-int-const-a-const-int-const-a分别是什么-有什么特点。" class="router-link-active router-link-exact-active toc-link level3">1.20 说说const int *a, int const *a, const int a, int *const a, const int *const a分别是什么，有什么特点。</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_1-21-说说使用指针需要注意什么" class="router-link-active router-link-exact-active toc-link level3">1.21 说说使用指针需要注意什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_1-22-说说内联函数和函数的区别-内联函数的作用" class="router-link-active router-link-exact-active toc-link level3">1.22 说说内联函数和函数的区别，内联函数的作用</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_1-23-简述c-有几种传值方式-之间的区别是什么" class="router-link-active router-link-exact-active toc-link level3">1.23 简述C++有几种传值方式，之间的区别是什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_1-24-简述const-星号-和-星号-const的区别" class="router-link-active router-link-exact-active toc-link level3">1.24 简述const（星号）和（星号）const的区别</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_2、c-c-内存问题" class="router-link-active router-link-exact-active toc-link level2">2、C/C++内存问题</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_2-1-简述一下堆和栈的区别" class="router-link-active router-link-exact-active toc-link level3">2.1 简述一下堆和栈的区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_2-2-简述c-的内存管理" class="router-link-active router-link-exact-active toc-link level3">2.2 简述C++的内存管理</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_2-3-malloc和局部变量分配在堆还是栈" class="router-link-active router-link-exact-active toc-link level3">2.3 malloc和局部变量分配在堆还是栈？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_2-4-程序有哪些section-分别的作用-程序启动的过程-怎么判断数据分配在栈上还是堆上" class="router-link-active router-link-exact-active toc-link level3">2.4 程序有哪些section，分别的作用？程序启动的过程？怎么判断数据分配在栈上还是堆上？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_2-5-初始化为0的全局变量在bss还是data" class="router-link-active router-link-exact-active toc-link level3">2.5 初始化为0的全局变量在bss还是data</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_2-6-请简述一下atomoic内存顺序" class="router-link-active router-link-exact-active toc-link level3">2.6 请简述一下atomoic内存顺序</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_2-7-简述c-中内存对齐的使用场景" class="router-link-active router-link-exact-active toc-link level2">2.7 简述C++中内存对齐的使用场景</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_3、c-面向对象" class="router-link-active router-link-exact-active toc-link level2">3、C++面向对象</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_3-1-简述一下什么是面向对象" class="router-link-active router-link-exact-active toc-link level3">3.1 简述一下什么是面向对象</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_3-2-简述一下面向对象的三大特征" class="router-link-active router-link-exact-active toc-link level3">3.2 简述一下面向对象的三大特征</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_3-3-简述一下c-的重写与重载-以及他们之间的区别" class="router-link-active router-link-exact-active toc-link level3">3.3 简述一下C++的重写与重载，以及他们之间的区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_3-4-c-如何实现重写与重载的-在c语言中怎么实现函数重载" class="router-link-active router-link-exact-active toc-link level3">3.4 C++如何实现重写与重载的？在C语言中怎么实现函数重载？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_3-5-构造函数分为哪几种" class="router-link-active router-link-exact-active toc-link level3">3.5 构造函数分为哪几种？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_3-6-只定义析构函数-会自动生成哪些构造函数" class="router-link-active router-link-exact-active toc-link level3">3.6 只定义析构函数，会自动生成哪些构造函数</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_3-7-说说一个类-默认会生成哪些函数" class="router-link-active router-link-exact-active toc-link level3">3.7 说说一个类，默认会生成哪些函数</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_3-8-说说-c-类对象的初始化顺序-有多重继承情况下的顺序" class="router-link-active router-link-exact-active toc-link level3">3.8 说说 C++ 类对象的初始化顺序，有多重继承情况下的顺序</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_3-9-简述下向上转型和向下转型" class="router-link-active router-link-exact-active toc-link level3">3.9 简述下向上转型和向下转型</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_3-10-简述下深拷贝和浅拷贝-如何实现深拷贝" class="router-link-active router-link-exact-active toc-link level3">3.10 简述下深拷贝和浅拷贝，如何实现深拷贝</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_3-11-简述一下c-中的多态" class="router-link-active router-link-exact-active toc-link level3">3.11 简述一下C++中的多态</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_3-12-为什么要虚析构-为什么不能虚构造" class="router-link-active router-link-exact-active toc-link level3">3.12 为什么要虚析构，为什么不能虚构造？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_3-13-说说模板类是在什么时候实现的" class="router-link-active router-link-exact-active toc-link level3">3.13 说说模板类是在什么时候实现的</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_3-14-说说类继承时-派生类对不同关键字修饰的基类方法的访问权限" class="router-link-active router-link-exact-active toc-link level3">3.14 说说类继承时，派生类对不同关键字修饰的基类方法的访问权限</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_3-15-简述一下移动构造函数-什么库用到了这个函数" class="router-link-active router-link-exact-active toc-link level3">3.15 简述一下移动构造函数，什么库用到了这个函数？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_3-16-请你回答一下-c-类内可以定义引用数据成员吗" class="router-link-active router-link-exact-active toc-link level3">3.16 请你回答一下 C++ 类内可以定义引用数据成员吗？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_3-17-简述一下什么是常函数-有什么作用" class="router-link-active router-link-exact-active toc-link level3">3.17 简述一下什么是常函数，有什么作用</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_3-18-说说什么是虚继承-解决什么问题-如何实现" class="router-link-active router-link-exact-active toc-link level3">3.18 说说什么是虚继承，解决什么问题，如何实现？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_3-19-简述一下虚函数和纯虚函数-以及实现原理" class="router-link-active router-link-exact-active toc-link level3">3.19 简述一下虚函数和纯虚函数，以及实现原理</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_3-20-说说纯虚函数能实例化吗-为什么-派生类要实现吗-为什么" class="router-link-active router-link-exact-active toc-link level3">3.20 说说纯虚函数能实例化吗，为什么？派生类要实现吗，为什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_3-21-说说c-中虚函数与纯虚函数的区别" class="router-link-active router-link-exact-active toc-link level3">3.21 说说C++中虚函数与纯虚函数的区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_3-22-说说-c-中什么是菱形继承问题-如何解决" class="router-link-active router-link-exact-active toc-link level3">3.22 说说 C++ 中什么是菱形继承问题，如何解决</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_3-23-请问构造函数中的能不能调用虚方法" class="router-link-active router-link-exact-active toc-link level3">3.23 请问构造函数中的能不能调用虚方法</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_3-24-请问拷贝构造函数的参数是什么传递方式-为什么" class="router-link-active router-link-exact-active toc-link level3">3.24 请问拷贝构造函数的参数是什么传递方式，为什么</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_3-25-如何理解抽象类" class="router-link-active router-link-exact-active toc-link level3">3.25 如何理解抽象类？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_3-26-什么是多态-除了虚函数-还有什么方式能实现多态" class="router-link-active router-link-exact-active toc-link level3">3.26 什么是多态？除了虚函数，还有什么方式能实现多态？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_3-27-简述一下虚析构函数-什么作用" class="router-link-active router-link-exact-active toc-link level3">3.27 简述一下虚析构函数，什么作用</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_3-28-说说什么是虚基类-可否被实例化" class="router-link-active router-link-exact-active toc-link level3">3.28 说说什么是虚基类，可否被实例化？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_3-29-简述一下拷贝赋值和移动赋值" class="router-link-active router-link-exact-active toc-link level3">3.29  简述一下拷贝赋值和移动赋值？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_3-30-仿函数了解吗-有什么作用" class="router-link-active router-link-exact-active toc-link level3">3.30 仿函数了解吗？有什么作用</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_3-31-c-中哪些函数不能被声明为虚函数" class="router-link-active router-link-exact-active toc-link level3">3.31 C++ 中哪些函数不能被声明为虚函数？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_3-32-解释下-c-中类模板和模板类的区别" class="router-link-active router-link-exact-active toc-link level3">3.32 解释下 C++ 中类模板和模板类的区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_3-33-虚函数表里存放的内容是什么时候写进去的" class="router-link-active router-link-exact-active toc-link level3">3.33 虚函数表里存放的内容是什么时候写进去的？</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_4、标准模板库stl" class="router-link-active router-link-exact-active toc-link level2">4、标准模板库STL</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_5、c-新特性" class="router-link-active router-link-exact-active toc-link level2">5、C++新特性</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_5-1-c-新特性" class="router-link-active router-link-exact-active toc-link level3">5.1 C++新特性</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_5-2-说说-c-中智能指针和指针的区别是什么" class="router-link-active router-link-exact-active toc-link level3">5.2 说说 C++ 中智能指针和指针的区别是什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_5-3" class="router-link-active router-link-exact-active toc-link level3">5.3</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_6、c-操作系统-linux相关" class="router-link-active router-link-exact-active toc-link level2">6、C++操作系统（Linux相关）</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_7、计算机网络" class="router-link-active router-link-exact-active toc-link level2">7、计算机网络</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_8、设计模式-摘选" class="router-link-active router-link-exact-active toc-link level2">8、设计模式（摘选）</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/ALL_c__%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html#_9、常见编程大题" class="router-link-active router-link-exact-active toc-link level2">9、常见编程大题</a></li><!----><!--]--></ul><div class="toc-marker" style="top:-1.7rem;"></div></div><!--[--><!----><!--]--></aside></div><!----><div class="theme-hope-content"><div class="hint-container tip"><p class="hint-container-title">提示</p><p>全面内容综述</p></div><!-- more --><p>第一部分是C++基础，第二部分是C/C++内存问题，第三部分是C++面向对象，第四部分是C++标准模板库STL，第五部分是C++新特性，第六部分是C++操作系统内容，第七部分是C++计算机网络，第八部分提到了部分常用的设计模式，第九部分举了一些常见的编程题。</p><p>内容参考自<a href="https://www.nowcoder.com/issue/tutorial?zhuanlanId=Gj56lM&amp;uuid=0d542159b96c424f8b35bd6f9a278609" target="_blank" rel="noopener noreferrer">牛客<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><h2 id="_1、c-基础" tabindex="-1"><a class="header-anchor" href="#_1、c-基础" aria-hidden="true">#</a> 1、C++基础</h2><h3 id="_1-1-简述c-语言的特点" tabindex="-1"><a class="header-anchor" href="#_1-1-简述c-语言的特点" aria-hidden="true">#</a> 1.1 简述C++语言的特点</h3><ol><li>C++在C语言基础上引入了<strong>面向对象</strong>的机制，同时也<strong>兼容C语言</strong>。</li><li>C++有三大特性：封装、继承、多态</li><li>C++语言编写出的程序结构清晰、易于扩充，程序可读性好</li><li>C++生成的代码质量高，运行效率高，仅比汇编语言慢10%～20%</li><li>C++更加安全，增加了const常量、引用、四类cast转换（static_cast、dynamic_cast、const_cast、reinterpret_cast）、智能指针、try—catch等等</li><li>C++可复用性高，C++引入了模板的概念，后面在此基础上，实现了方便开发的标准模板库STL（Standard Template Library）</li><li>同时，C++是<strong>不断在发展</strong>的语言。C++后续版本更是发展了不少新特性，如C++11中引入了nullptr、auto变量、Lambda匿名函数、右值引用、智能指针。</li></ol><h3 id="_1-2-说说c语言与c-语言的区别" tabindex="-1"><a class="header-anchor" href="#_1-2-说说c语言与c-语言的区别" aria-hidden="true">#</a> 1.2 说说C语言与C++语言的区别</h3><ol><li>C语言是C++的子集，C++可以很好兼容C语言。但是C++又有很多<strong>新特性</strong>，如引用、智能指针、auto变量等。</li><li>C++是<strong>面对对象</strong>的编程语言；C语言是面对过程的编程语言</li><li>C语言有一些不安全的语言特性，如指针使用的潜在危险、强制转换的不确定性、内存泄露等。而C++对此增加了不少新特性来<strong>改善安全性</strong>，如const常量、引用、cast转换、智能指针、try—catch等等</li><li>C++<strong>可复用性高</strong>，C++引入了<strong>模板</strong>的概念，后面在此基础上，实现了方便开发的标准模板库STL。C++的STL库相对于C语言的函数库<strong>更灵活、更通用</strong></li></ol><h3 id="_1-3-说说c-中struct和class的区别" tabindex="-1"><a class="header-anchor" href="#_1-3-说说c-中struct和class的区别" aria-hidden="true">#</a> 1.3 说说C++中struct和class的区别</h3><ol><li>struct一般用于描述一个数据结构集合，而class是对一个对象数据的封装；</li><li>struct的默认访问权限是public，而class默认权限是private；</li></ol><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">A</span><span class="token punctuation">{</span>
	<span class="token keyword">int</span> iNum<span class="token punctuation">;</span>  <span class="token comment">//默认访问控制权限是public</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">{</span>
	<span class="token keyword">int</span> iNum<span class="token punctuation">;</span>  <span class="token comment">//默认访问控制权限是private</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li>在继承关系上，struct是public继承，而class是private继承；</li><li>class关键字可以用于定义模板参数，就像typename，而struct不能用于定义模板参数。</li></ol><h3 id="_1-4-说说c中结构体和c-中结构体的区别" tabindex="-1"><a class="header-anchor" href="#_1-4-说说c中结构体和c-中结构体的区别" aria-hidden="true">#</a> 1.4 说说C中结构体和C++中结构体的区别</h3><ol><li>C的结构体内不允许有函数存在，C++允许有内部成员函数，且允许该函数是虚函数</li><li>C的结构体对内部成员变量的访问权限只能是public，而C++允许public,protected,private三种</li><li>C语言的结构体是不可以继承的，C++的结构体是可以从其他的结构体或者类继承过来的</li><li>C 中使用结构体需要加上 struct 关键字，或者对结构体使用 typedef 取别名，而 C++ 中可以省略 struct 关键字直接使用</li></ol><p>小总结一波：①C与C++在声明时的区别在于：</p><table><thead><tr><th style="text-align:center;"></th><th style="text-align:center;">C</th><th style="text-align:center;">C++</th></tr></thead><tbody><tr><td style="text-align:center;">成员函数</td><td style="text-align:center;">不能有</td><td style="text-align:center;">可以</td></tr><tr><td style="text-align:center;">静态成员</td><td style="text-align:center;">不能有</td><td style="text-align:center;">可以</td></tr><tr><td style="text-align:center;">访问控制</td><td style="text-align:center;">默认public，不可修改</td><td style="text-align:center;">public/private/protected</td></tr><tr><td style="text-align:center;">继承关系</td><td style="text-align:center;">不可以继承</td><td style="text-align:center;">可从类或其他结构体继承</td></tr><tr><td style="text-align:center;">初始化</td><td style="text-align:center;">不能直接初始化数据成员</td><td style="text-align:center;">可以</td></tr></tbody></table><p>②使用时的区别：</p><p>C 中使用结构体需要加上 struct 关键字，或者对结构体使用 typedef 取别名，而 C++ 中可以省略 struct 关键字直接使用，例如：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">Student</span><span class="token punctuation">{</span>
	<span class="token keyword">int</span> iAge<span class="token punctuation">;</span>
	string strName<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">Student</span> Student2<span class="token punctuation">;</span> <span class="token comment">//C中给结构体取别名</span>

stuct Student stu1<span class="token punctuation">;</span>   <span class="token comment">//C中正常使用</span>
Student2 stu2<span class="token punctuation">;</span>      <span class="token comment">//C中通过取别名来使用</span>
Student stu3<span class="token punctuation">;</span>      <span class="token comment">// C++中使用结构体可以省略关键字struct</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_1-5-说说include头文件的顺序以及双引号-和尖括号-的区别" tabindex="-1"><a class="header-anchor" href="#_1-5-说说include头文件的顺序以及双引号-和尖括号-的区别" aria-hidden="true">#</a> 1.5 说说include头文件的顺序以及双引号“”和尖括号&lt;&gt;的区别</h3><ol><li>区别 （1）尖括号的头文件是系统文件，双引号的文件是自定义文件； （2）编译器预处理阶段查找头文件的路径不一样</li><li>查找路径 （1）使用尖括号&lt;&gt;的头文件的查找路径：编译器设置的头文件路径--&gt;系统变量 （2）使用双引号“”的头文件的查找路径：当前头文件目录--&gt;编译器设置的头文件路径--&gt;系统变量</li></ol><h3 id="_1-6-导入c函数的关键字是什么-c-编译的时候与c有什么区别" tabindex="-1"><a class="header-anchor" href="#_1-6-导入c函数的关键字是什么-c-编译的时候与c有什么区别" aria-hidden="true">#</a> 1.6 导入C函数的关键字是什么，C++编译的时候与C有什么区别</h3><ol><li><strong>关键字</strong>：在C++中，导入C函数的关键字是extern，表达形式为extern “C”， extern &quot;C&quot;的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern &quot;C&quot;后，会指示编译器这部分代码按C语言的进行编译，而不是C++的。</li><li><strong>编译区别</strong>：由于C++支持函数重载，因此编译器编译函数的过程中会将函数的<strong>参数类型</strong>也加到编译后的代码中，而不仅仅是<strong>函数名</strong>；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括<strong>函数名</strong>。 程序示例：</li></ol><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">//extern示例</span>
<span class="token comment">//在C++程序里边声明该函数，会指示编译器这部分代码按C语言的进行编译</span>
<span class="token keyword">extern</span> <span class="token string">&quot;C&quot;</span> <span class="token keyword">int</span> <span class="token function">strcmp</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>s1<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//在C++程序里边声明该函数</span>
<span class="token keyword">extern</span> <span class="token string">&quot;C&quot;</span><span class="token punctuation">{</span>
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span><span class="token comment">//string.h里边包含了要调用的C函数的声明</span></span>
<span class="token punctuation">}</span>

<span class="token comment">//两种不同的语言，有着不同的编译规则，比如一个函数fun，可能C语言编译的时候为_fun，而C++则是__fun__</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_1-7-简述c-从代码到可执行二进制文件的过程" tabindex="-1"><a class="header-anchor" href="#_1-7-简述c-从代码到可执行二进制文件的过程" aria-hidden="true">#</a> 1.7 简述C++从代码到可执行二进制文件的过程</h3><p>C++和C语言类似，一个C++程序从源码到执行文件，有四个过程，<strong>预处理、编译、汇编、链接</strong>。</p><ol><li>预处理：这个过程主要的处理操作如下： （1） 将所有的#define删除，并且展开所有的宏定义 （2） 处理所有的条件预编译指令，如#if、#ifdef （3） 处理#include预编译指令，将被包含的文件插入到该预编译指令的位置。 （4） 过滤所有的注释 （5） 添加行号和文件名标识。</li><li>编译：这个过程主要的处理操作如下： （1） 词法分析：将源代码的字符序列分割成一系列的记号。 （2） 语法分析：对记号进行语法分析，产生语法树。 （3） 语义分析：判断表达式是否有意义。 （4） 代码优化： （5） 目标代码生成：生成汇编代码。 （6） 目标代码优化：</li><li>汇编：这个过程主要是将汇编代码转变成机器可以执行的指令。</li><li>链接：将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。</li></ol><p>链接分为静态链接和动态链接。</p><p>静态链接，是在链接的时候就已经把要调用的函数或者过程链接到了生成的可执行文件中，就算你在去把静态库删除也不会影响可执行程序的执行；生成的静态链接库，Windows下以.lib为后缀，Linux下以.a为后缀。</p><p>而动态链接，是在链接的时候没有把调用的函数代码链接进去，而是在执行的过程中，再去找要链接的函数，生成的可执行文件中没有函数代码，只包含函数的重定位信息，所以当你删除动态库时，可执行程序就不能运行。生成的动态链接库，Windows下以.dll为后缀，Linux下以.so为后缀。</p><h3 id="_1-8-说说-static关键字的作用" tabindex="-1"><a class="header-anchor" href="#_1-8-说说-static关键字的作用" aria-hidden="true">#</a> 1.8 说说 static关键字的作用</h3><p><strong>static关键字的作用</strong>：一方面她延长了函数和变量的作用时间；另一方面，它也限制了函数和变量的作用范围。</p><ol><li><strong>定义全局静态变量和局部静态变量</strong>：在变量前面加上static关键字。初始化的静态变量会在数据段（.data）分配内存，未初始化的静态变量会在BSS段（.bss）分配内存。直到程序结束，静态变量始终会维持前值。只不过全局静态变量和局部静态变量的作用域不一样；</li><li><strong>定义静态函数</strong>：在函数返回类型前加上static关键字，函数即被定义为静态函数。静态函数只能在本源文件中使用；</li><li>在变量类型前加上static关键字，变量即被定义为静态变量。静态变量只能在本源文件中使用；</li><li>在C++中，static关键字可以用于定义类中的静态成员变量：使用静态数据成员，它既可以被当成全局变量那样去存储，但又被隐藏在类的内部。类中的static静态数据成员拥有一块单独的存储区，而不管创建了多少个该类的对象。所有这些对象的静态数据成员都共享这一块静态存储空间；</li><li>在C++中，static关键字可以用于定义类中的静态成员函数：与静态成员变量类似，类里面同样可以定义静态成员函数。只需要在函数前加上关键字static即可。如静态成员函数也是类的一部分，而不是对象的一部分。所有这些对象的静态数据成员都共享这一块静态存储空间。</li></ol><p><strong>关于第五点的补充说明</strong>：当调用一个对象的非静态成员函数时，系统会把该对象的起始地址赋给成员函数的this指针。而静态成员函数不属于任何一个对象，因此C++规定静态成员函数没有this指针（划重点，面试题常考）。既然它没有指向某一对象，也就无法对一个对象中的非静态成员进行访问。</p><h3 id="_1-9-说说数组和指针的区别" tabindex="-1"><a class="header-anchor" href="#_1-9-说说数组和指针的区别" aria-hidden="true">#</a> 1.9 说说数组和指针的区别</h3><p>1、概念： （1）数组：数组是用于储存多个相同类型数据的集合。数组名是首元素的地址 （2）指针：指针相当于一个变量，但是它和不同变量不一样，它存放的是其它变量在<strong>内存中的地址</strong>。指针名指向了内存的首地址</p><ol start="2"><li>区别： （1）<strong>赋值</strong>：同类型指针变量可以相互赋值；数组不行，只能一个一个元素的赋值或拷贝 （2）<strong>存储方式</strong>：</li></ol><p>数组：数组在内存中是连续存放的，开辟一块连续的内存空间。数组是根据数组的下标进行访问的，数组的存储空间，不是在静态区就是在栈上。</p><p>指针：指针很灵活，它可以指向任意类型的数据。指针的类型说明了它所指向地址空间的内存。由于指针本身就是一个变量，再加上它所存放的也是变量，所以指针的存储空间不能确定。 （3）<strong>求sizeof</strong>：</p><p>数组所占存储空间的内存大小是sizeof(数组)，计算数组中元素个数：sizeof（数组名）/sizeof（数据类型）</p><p>在32位平台下，无论指针的类型是什么，sizeof（指针名）都是4，在64位平台下，无论指针的类型是什么，sizeof（指针名）都是8。 （4）<strong>初始化</strong>：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// 数组</span>
<span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> b<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&quot;Hello&quot;</span><span class="token punctuation">;</span>    <span class="token comment">// 按字符串初始化，大小为6</span>
<span class="token keyword">char</span> c<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token char">&#39;H&#39;</span><span class="token punctuation">,</span><span class="token char">&#39;e&#39;</span><span class="token punctuation">,</span><span class="token char">&#39;l&#39;</span><span class="token punctuation">,</span><span class="token char">&#39;l&#39;</span><span class="token punctuation">,</span><span class="token char">&#39;o&#39;</span><span class="token punctuation">,</span><span class="token char">&#39;\0&#39;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment">// 按字符初始化</span>
<span class="token keyword">int</span><span class="token operator">*</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">// 动态创建一维数组</span>

<span class="token comment">// 指针</span>
<span class="token comment">// 指向对象的指针</span>
<span class="token keyword">int</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">delete</span> p<span class="token punctuation">;</span>
<span class="token comment">// 指向数组的指针</span>
<span class="token keyword">int</span><span class="token operator">*</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> p1<span class="token punctuation">;</span>
<span class="token comment">// 指向类的指针：</span>
string<span class="token operator">*</span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> string<span class="token punctuation">;</span>
<span class="token keyword">delete</span> p2<span class="token punctuation">;</span>
<span class="token comment">// 指向指针的指针（二级指针）</span>
<span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">*</span> pp <span class="token operator">=</span> <span class="token operator">&amp;</span>p<span class="token punctuation">;</span>
<span class="token operator">*</span><span class="token operator">*</span>pp <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>（5）<strong>指针操作</strong>：</p><p>数组名的指针操作：</p><p><code>int (*p)[4]</code>定义了一个数组指针，该指针指向一个包含4个元素的数组。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  
<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">//该语句是定义一个数组指针，指向含4个元素的一维数组</span>
p <span class="token operator">=</span> a<span class="token punctuation">;</span>        <span class="token comment">//将该二维数组的首地址赋给p，也就是a[0]或&amp;a[0][0]</span>
p<span class="token operator">++</span><span class="token punctuation">;</span>          <span class="token comment">//该语句执行过后，也就是p=p+1；p跨过行a[0][]指向了行a[1][]</span>
              <span class="token comment">//所以数组指针也称指向一维数组的指针，亦称行指针。</span>
<span class="token comment">//访问数组中第i行j列的一个元素，有几种操作方式：</span>
<span class="token comment">//*(p[i]+j)、*(*(p+i)+j)、(*(p+i))[j]、p[i][j]。其中，优先级：()&gt;[]&gt;*。</span>
<span class="token comment">//这几种操作方式都是合法的。</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>指针变量的数据操作：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">char</span> <span class="token operator">*</span>str <span class="token operator">=</span> <span class="token string">&quot;hello,douya!&quot;</span><span class="token punctuation">;</span>
str<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">&#39;a&#39;</span><span class="token punctuation">;</span>
<span class="token operator">*</span><span class="token punctuation">(</span>str<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token char">&#39;b&#39;</span><span class="token punctuation">;</span>
<span class="token comment">//这两种操作方式都是合法的。</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>补充：int *p[4]和int (<em>p)[4]的区别和区分：因为[]的优先级要比*高，所以前者是p先和[ ]结合，表示一个数组，然后再与</em>结合，表示int指针类型的数组。（本质上是数组，不过是int指针类型的数组）这数组里每个元素都是int类型的指针，储存的是int类型变量的地址。</p><p>而int(*p)[4]，p先和*结合，表示p是一个指针，int ［4］就是他的类型，表示这是一个数组类型的指针，即p是一个指向一个长度为4数组的指针，它的本质是一个指针，这个指针的类型是int类型长度为4的数组。表示，这个指针存的是int类型长度为4的数组的地址。（不是其中某个元素的地址）</p><h3 id="_1-10-说说什么是函数指针-如何定义函数指针-有什么使用场景" tabindex="-1"><a class="header-anchor" href="#_1-10-说说什么是函数指针-如何定义函数指针-有什么使用场景" aria-hidden="true">#</a> 1.10 说说什么是函数指针，如何定义函数指针，有什么使用场景</h3><ol><li><strong>概念</strong>：函数指针就是指向函数的指针变量。每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址</li><li><strong>定义</strong>形式如下：</li></ol><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>f<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>  
f <span class="token operator">=</span> <span class="token operator">&amp;</span>func<span class="token punctuation">;</span>  
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li>函数指针的<strong>应用场景</strong>：<strong>回调</strong>(callback)。我们调用别人提供的 API函数(Application Programming Interface,应用程序编程接口)，称为Call；如果别人的库里面调用我们的函数，就叫回调Callback。</li></ol><p>我们用系统的API叫调用，系统用我们的API叫回调。</p><p>程序示例：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">//以库函数qsort排序函数为例，它的原型如下：</span>
<span class="token keyword">void</span> <span class="token function">qsort</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>base<span class="token punctuation">,</span><span class="token comment">//void*类型，代表原始数组</span>
           size_t nmemb<span class="token punctuation">,</span> <span class="token comment">//第二个是size_t类型，代表数据数量</span>
           size_t size<span class="token punctuation">,</span> <span class="token comment">//第三个是size_t类型，代表单个数据占用空间大小</span>
           <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span>compar<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token comment">//第四个参数是函数指针</span>
          <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//第四个参数告诉qsort，应该使用哪个函数来比较元素，即只要我们告诉qsort比较大小的规则，它就可以帮我们对任意数据类型的数组进行排序。在库函数qsort调用我们自定义的比较函数，这就是回调的应用。</span>

<span class="token comment">//示例</span>
<span class="token keyword">int</span> num<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">cmp_int</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span> _a <span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span> _b<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//参数格式固定</span>
    <span class="token keyword">int</span><span class="token operator">*</span> a <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span>_a<span class="token punctuation">;</span>    <span class="token comment">//强制类型转换</span>
    <span class="token keyword">int</span><span class="token operator">*</span> b <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span>_b<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token operator">*</span>a <span class="token operator">-</span> <span class="token operator">*</span>b<span class="token punctuation">;</span>　　
<span class="token punctuation">}</span>
<span class="token function">qsort</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>num<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>cmp_int<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//回调</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_1-11-说说静态变量什么时候初始化" tabindex="-1"><a class="header-anchor" href="#_1-11-说说静态变量什么时候初始化" aria-hidden="true">#</a> 1.11 说说静态变量什么时候初始化</h3><!----><!----><ol><li><strong>作用域</strong>：C++里作用域可分为6种：全局，局部，类，语句，命名空间和文件作用域</li></ol><p>全局变量：全局作用域+文件作用域，可以通过extern作用于其他非定义的源文件。 静态全局变量 ：全局作用域，所以无法在其他文件中使用。 静态局部变量 ：局部作用域，只被初始化一次，直到程序结束。 类静态成员变量：类作用域。</p><ol start="2"><li><p><strong>所在空间</strong>：都在静态存储区。因为静态变量都在静态存储区，所以下次调用函数的时候还是能取到原来的值</p></li><li><p><strong>生命周期</strong>：静态全局变量、静态局部变量都在静态存储区，直到程序结束才会回收内存。类静态成员变量在静态存储区，当超出类作用域时回收内存</p></li></ol><h3 id="_1-12-nullptr可以调用成员函数吗-为什么" tabindex="-1"><a class="header-anchor" href="#_1-12-nullptr可以调用成员函数吗-为什么" aria-hidden="true">#</a> 1.12 nullptr可以调用成员函数吗，为什么？</h3><p>答案：能。 原因：因为在编译时对象就绑定了函数地址，和指针空不空没关系。</p><p>因为在编译时对象就绑定了函数地址，和指针空不空没关系。pAn-&gt;breathe();编译的时候，函数的地址就和指针pAn绑定了；调用breath(*this), this就等于pAn。由于函数中没有需要解引用this的地方，所以函数运行不会出错，但是若用到this，因为this=nullptr，运行出错。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">//给出实例</span>
<span class="token keyword">class</span> <span class="token class-name">animal</span><span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;animal sleep&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">void</span> <span class="token function">breathe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;animal breathe haha&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">fish</span> <span class="token operator">:</span><span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">animal</span></span><span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">breathe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;fish bubble&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    animal <span class="token operator">*</span>pAn<span class="token operator">=</span><span class="token keyword">nullptr</span><span class="token punctuation">;</span>
    pAn<span class="token operator">-&gt;</span><span class="token function">breathe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 输出：animal breathe haha</span>
    fish <span class="token operator">*</span>pFish <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
    pFish<span class="token operator">-&gt;</span><span class="token function">breathe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出：fish bubble</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>  
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_1-13-什么是野指针-怎么产生的-如何避免" tabindex="-1"><a class="header-anchor" href="#_1-13-什么是野指针-怎么产生的-如何避免" aria-hidden="true">#</a> 1.13 什么是野指针，怎么产生的，如何避免？</h3><ol><li><strong>概念</strong>：野指针就是指针指向的位置是不可知的（随机的、不正确的、没有明确限制的）</li><li><strong>产生原因</strong>：释放内存后指针不及时置空（野指针），依然指向了该内存，那么可能出现非法访问的错误。这些我们都要注意避免，如：</li></ol><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">char</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token function">strcpy</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> <span class="token string">&quot;Douya&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//p所指向的内存被释放，但是p所指的地址仍然不变  </span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  
<span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//没有起到防错作用  </span>
    <span class="token function">strcpy</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> <span class="token string">&quot;hello, Douya!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//出错  </span>
<span class="token punctuation">}</span>  
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li>避免办法： （1）初始化置为NULL （2）申请内存后判空 （3）指针释放后置NULL （4）使用智能指针</li></ol><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">//初始化置NULL</span>
p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">*</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//申请n个int内存空间  </span>
<span class="token function">assert</span><span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//判空，防错设计</span>
<span class="token comment">//C 库函数 void *realloc(void *ptr, size_t size) 尝试重新调整之前调用 malloc 或 calloc 所分配的 ptr 所指向的内存块的大小。</span>
<span class="token comment">//注意：如果大小为 0，且 ptr 指向一个已存在的内存块，则 ptr 所指向的内存块会被释放，并返回一个空指针。</span>
p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">realloc</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//重新分配内存, p 所指向的内存块会被释放并分配一个新的内存地址</span>
<span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>  
p <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">//释放后置空</span>

<span class="token keyword">int</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">//初始化置NULL</span>
calloc默认设置分配的内存数据为<span class="token number">0</span>
p1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">calloc</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//申请n个int内存空间同时初始化为0 </span>
<span class="token function">assert</span><span class="token punctuation">(</span>p1 <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//判空，防错设计</span>
<span class="token function">free</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span>  
p1 <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">//释放后置空</span>

<span class="token keyword">int</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">//初始化置NULL</span>
p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//申请n个int内存空间  </span>
<span class="token function">assert</span><span class="token punctuation">(</span>p2 <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//判空，防错设计</span>
<span class="token keyword">delete</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>p2<span class="token punctuation">;</span>  
p2 <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span> <span class="token comment">//释放后置空  </span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_1-14-说说静态局部变量-全局变量-局部变量的特点-以及使用场景" tabindex="-1"><a class="header-anchor" href="#_1-14-说说静态局部变量-全局变量-局部变量的特点-以及使用场景" aria-hidden="true">#</a> 1.14 说说静态局部变量，全局变量，局部变量的特点，以及使用场景</h3><ol><li><strong>首先从作用域考虑</strong>：C++里作用域可分为6种：全局，局部，类，语句，命名空间和文件作用域。 全局变量：全局作用域+文件作用域，可以通过extern作用于其他非定义的源文件。 静态全局变量 ：全局作用域，所以无法在其他文件中使用。 局部变量：局部作用域，比如函数的参数，函数内的局部变量等等。 静态局部变量 ：局部作用域，只被初始化一次，直到程序结束。</li><li><strong>从所在空间考虑</strong>：除了局部变量在栈上外，其他都在静态存储区。因为静态变量都在静态存储区，所以下次调用函数的时候还是能取到原来的值。</li><li><strong>生命周期</strong>： 局部变量在栈上，出了作用域就回收内存；而全局变量、静态全局变量、静态局部变量都在静态存储区，直到程序结束才会回收内存。</li><li><strong>使用场景</strong>：从它们各自特点就可以看出各自的应用场景，不再赘述。</li></ol><h3 id="_1-15-说说内联函数和宏函数的区别" tabindex="-1"><a class="header-anchor" href="#_1-15-说说内联函数和宏函数的区别" aria-hidden="true">#</a> 1.15 说说内联函数和宏函数的区别</h3><p>区别：</p><ol><li><p><strong>宏定义不是函数</strong>，但是使用起来像函数。预处理器用复制宏代码的方式代替函数的调用，省去了函数压栈退栈过程，提高了效率；而<strong>内联函数本质上是一个函数</strong>，内联函数一般用于函数体的代码比较简单的函数，不能包含复杂的控制语句，while、switch，并且内联函数本身不能直接调用自身(内联函数不能用于迭代)。</p></li><li><p><strong>宏定义</strong>是在预编译的时候把所有的宏名用宏体来替换，简单的说就是字符串替换 ；而<strong>内联函数</strong>则是在编译的时候进行代码插入，编译器会在每处调用内联函数的地方直接把内联函数的内容展开，这样可以省去函数的调用的开销，提高效率</p></li><li><p><strong>宏定义</strong>是没有类型检查的，无论对还是错都是直接替换；而<strong>内联函数</strong>在编译的时候会进行类型的检查，内联函数满足函数的性质，比如有返回值、参数列表等</p></li></ol><p><strong>说人话</strong>：相同点是，宏定义和内联函数，相比于函数体内代码较短，逻辑简单的普通函数而言，避免了出栈入栈的开销，提高了运行效率。不同的在于，宏定义本质不是函数。只是简单的字符替换，而且不会进行检查；内联函数本质是函数，是进行代码插入，有检错（宏定义不会对传入的参数进行检查），有形参，有返回值。</p><p>代码示例如下：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">//宏定义示例</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">MAX</span><span class="token expression"><span class="token punctuation">(</span>a，b<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token operator">?</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token operator">:</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>
<span class="token function">MAX</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span><span class="token string">&quot;Hello&quot;</span><span class="token punctuation">)</span>； <span class="token comment">//错误地比较int和字符串，没有参数类型检查</span>

<span class="token comment">//内联函数示例</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> a<span class="token punctuation">;</span>
    a <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;a+b=%d\n&quot;</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//以上a = add(1, 2);处在编译时将被展开为：a = (a + b);</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>1、使用时的一些注意事项：</p><ul><li><p>使用宏定义一定要注意错误情况的出现，比如宏定义函数没有类型检查，可能传进来任意类型，从而带来错误，如举例。还有就是括号的使用，宏在定义时要小心处理宏参数，一般用括号括起来，否则容易出现二义性</p></li><li><p>inline函数一般用于比较小的，频繁调用的函数，这样可以减少函数调用带来的开销。只需要在函数返回类型前加上关键字inline，即可将函数指定为inline函数。</p></li><li><p>同其它函数不同的是，最好将inline函数定义在头文件，而不仅仅是声明，因为编译器在处理inline函数时，需要在调用点内联展开该函数，所以仅需要函数声明是不够的。</p></li></ul><p>2、内联函数使用的条件：</p><ul><li><p>内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。以下情况不宜使用内联：</p></li><li><p>（1）如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。</p></li><li><p>（2）如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。</p></li><li><p>内联不是什么时候都能展开的，一个好的编译器将会根据函数的定义体，自动地取消不符合要求的内联。</p></li></ul><h3 id="_1-16-说说运算符i-和-i的区别" tabindex="-1"><a class="header-anchor" href="#_1-16-说说运算符i-和-i的区别" aria-hidden="true">#</a> 1.16 说说运算符i++和++i的区别</h3><p>先看代码示例：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    j <span class="token operator">+=</span> i<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">//先赋值后加</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;i= %d, j= %d\n&quot;</span><span class="token punctuation">,</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//i= 3, j= 4</span>
    i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    j <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    j <span class="token operator">+=</span> <span class="token operator">++</span>i<span class="token punctuation">;</span> <span class="token comment">//先加后赋值</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;i= %d, j= %d&quot;</span><span class="token punctuation">,</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//i= 3, j= 5</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>区别：</p><ol><li>赋值顺序不同：++ i 是先加后赋值；i ++ 是先赋值后加；++i和i++都是分两步完成的。</li><li>效率不同：<!---->。</li><li>i++ 不能作为左值，而++i 可以：</li></ol><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token operator">&amp;</span>（<span class="token operator">++</span>i）；<span class="token comment">//正确</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token operator">&amp;</span>（i<span class="token operator">++</span>）；<span class="token comment">//错误</span>
<span class="token operator">++</span>i <span class="token operator">=</span> <span class="token number">1</span>；<span class="token comment">//正确</span>
i<span class="token operator">++</span> <span class="token operator">=</span> <span class="token number">1</span>；<span class="token comment">//错误</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="4"><li>两者都不是原子操作</li></ol><h3 id="_1-17-说说new和malloc的区别-各自底层实现原理" tabindex="-1"><a class="header-anchor" href="#_1-17-说说new和malloc的区别-各自底层实现原理" aria-hidden="true">#</a> 1.17 说说new和malloc的区别，各自底层实现原理</h3><ol><li>new是操作符，而malloc是函数。</li><li>new在调用的时候先分配内存，在调用构造函数，释放的时候调用析构函数；而malloc没有构造函数和析构函数。</li><li>malloc需要给定申请内存的大小，返回的指针需要强转；new会调用构造函数，不用指定内存的大小，返回指针不用强转。</li><li>new可以被重载；malloc不行</li><li>new分配内存更直接和安全。</li><li>new发生错误抛出异常，malloc返回null</li></ol><p>答案解析：</p><p><strong>malloc底层实现</strong>：当开辟的空间小于 128K 时，调用 brk（）函数；当开辟的空间大于 128K 时，调用mmap（）。malloc采用的是内存池的管理方式，以减少内存碎片。先申请大块内存作为堆区，然后将堆区分为多个内存块。当用户申请内存时，直接从堆区分配一块合适的空闲快。采用隐式链表将所有空闲块，每一个空闲块记录了一个未分配的、连续的内存地址。</p><p><strong>new底层实现</strong>：关键字new在调用构造函数的时候实际上进行了如下的几个步骤：</p><ol><li>创建一个新的对象</li><li>将构造函数的作用域赋值给这个新的对象（因此this指向了这个新的对象）</li><li>执行构造函数中的代码（为这个新对象添加属性）</li><li>返回新对象</li></ol><h3 id="_1-18-说说const和define的区别" tabindex="-1"><a class="header-anchor" href="#_1-18-说说const和define的区别" aria-hidden="true">#</a> 1.18 说说const和define的区别</h3><p>const用于定义常量；而define用于定义宏，而宏也可以用于定义常量。都用于常量定义时，它们的 区别有：</p><ol><li>const生效于编译的阶段；define生效于预处理阶段。</li><li>const定义的常量，在C语言中是存储在内存中、需要额外的内存空间的；define定义的常量，运行时是直接的操作数，并不会存放在内存中。</li><li>const定义的常量是带类型的；define定义的常量不带类型。因此define定义的常量不利于类型检查。</li></ol><h3 id="_1-19-说说c-中函数指针和指针函数的区别" tabindex="-1"><a class="header-anchor" href="#_1-19-说说c-中函数指针和指针函数的区别" aria-hidden="true">#</a> 1.19 说说C++中函数指针和指针函数的区别</h3><ol><li><p>定义不同 指针函数本质是一个函数，其返回值为指针。 函数指针本质是一个指针，其指向一个函数。</p></li><li><p>写法不同</p></li></ol><blockquote><p>指针函数：int *fun(int x,int y); 函数指针：int (*fun)(int x,int y);</p></blockquote><ol start="3"><li>用法不同</li></ol><p>用法参考以下代码示例：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">//指针函数示例</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">_Data</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> a<span class="token punctuation">;</span>
    <span class="token keyword">int</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>Data<span class="token punctuation">;</span>
<span class="token comment">//指针函数</span>
Data<span class="token operator">*</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>
    Data <span class="token operator">*</span> data <span class="token operator">=</span> <span class="token keyword">new</span> Data<span class="token punctuation">;</span>
    <span class="token comment">//...</span>
    <span class="token keyword">return</span> data<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">//调用指针函数</span>
    Data <span class="token operator">*</span> myData <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//Data * myData = static_cast&lt;Data*&gt;(f(4,5));</span>
   <span class="token comment">//...</span>
<span class="token punctuation">}</span>

<span class="token comment">//函数指针示例</span>
<span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> x<span class="token operator">+</span>y<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//函数指针</span>
<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>fun<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//赋值</span>
fun <span class="token operator">=</span> add<span class="token punctuation">;</span>
<span class="token comment">//调用</span>
cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;(*fun)(1,2) = &quot;</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token operator">*</span>fun<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
<span class="token comment">//输出结果</span>
<span class="token comment">//(*fun)(1,2) =  3</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_1-20-说说const-int-a-int-const-a-const-int-a-int-const-a-const-int-const-a分别是什么-有什么特点。" tabindex="-1"><a class="header-anchor" href="#_1-20-说说const-int-a-int-const-a-const-int-a-int-const-a-const-int-const-a分别是什么-有什么特点。" aria-hidden="true">#</a> 1.20 说说const int *a, int const *a, const int a, int *const a, const int *const a分别是什么，有什么特点。</h3><p>参考答案：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token number">1.</span> <span class="token keyword">const</span> <span class="token keyword">int</span> a<span class="token punctuation">;</span>     <span class="token comment">//指的是a是一个常量，不允许修改。</span>
<span class="token number">2.</span> <span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>a<span class="token punctuation">;</span>    <span class="token comment">//a指针所指向的内存里的值不变，即（*a）不变</span>
<span class="token number">3.</span> <span class="token keyword">int</span> <span class="token keyword">const</span> <span class="token operator">*</span>a<span class="token punctuation">;</span>    <span class="token comment">//同const int *a;</span>
<span class="token number">4.</span> <span class="token keyword">int</span> <span class="token operator">*</span><span class="token keyword">const</span> a<span class="token punctuation">;</span>    <span class="token comment">//a指针所指向的内存地址不变，即a不变</span>
<span class="token number">5.</span> <span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span><span class="token keyword">const</span> a<span class="token punctuation">;</span>   <span class="token comment">//都不变，即（*a）不变，a也不变</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_1-21-说说使用指针需要注意什么" tabindex="-1"><a class="header-anchor" href="#_1-21-说说使用指针需要注意什么" aria-hidden="true">#</a> 1.21 说说使用指针需要注意什么？</h3><ol><li>定义指针时，先初始化为NULL。</li><li>用malloc或new申请内存之后，应该立即检查指针值是否为NULL。防止使用指针值为NULL的内存。</li><li>不要忘记为数组和动态内存赋初值。防止将未被初始化的内存作为右值使用。</li><li>避免数字或指针的下标越界，特别要当心发生“多1”或者“少1”操作</li><li>动态内存的申请与释放必须配对，防止内存泄漏</li><li>用free或delete释放了内存之后，立即将指针设置为NULL，防止“野指针”</li></ol><p>示例代码：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">//（1）初始化置NULL</span>
<span class="token comment">//（2）申请内存后判空</span>
<span class="token comment">//（3）指针释放后置NULL</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">//初始化置NULL</span>
p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">*</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//申请n个int内存空间  </span>
<span class="token function">assert</span><span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//判空，防错设计</span>
p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">realloc</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//重新分配内存, p 所指向的内存块会被释放并分配一个新的内存地址</span>
<span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>  
p <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">//释放后置空</span>

<span class="token keyword">int</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">//初始化置NULL</span>
p1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">calloc</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//申请n个int内存空间同时初始化为0 </span>
<span class="token function">assert</span><span class="token punctuation">(</span>p1 <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//判空，防错设计</span>
<span class="token function">free</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span>  
p1 <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">//释放后置空</span>

<span class="token keyword">int</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">//初始化置NULL</span>
p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//申请n个int内存空间  </span>
<span class="token function">assert</span><span class="token punctuation">(</span>p2 <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//判空，防错设计</span>
<span class="token keyword">delete</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>p2<span class="token punctuation">;</span>  
p2 <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span> <span class="token comment">//释放后置空  </span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_1-22-说说内联函数和函数的区别-内联函数的作用" tabindex="-1"><a class="header-anchor" href="#_1-22-说说内联函数和函数的区别-内联函数的作用" aria-hidden="true">#</a> 1.22 说说内联函数和函数的区别，内联函数的作用</h3><ol><li>内联函数比普通函数多了关键字inline</li><li>内联函数避免了函数调用的开销；普通函数有调用的开销</li><li>普通函数在被调用的时候，需要寻址（函数入口地址）；内联函数不需要寻址。</li><li>内联函数有一定的限制，内联函数体要求代码简单，不能包含复杂的结构控制语句；普通函数没有这个要求。</li></ol><p><strong>内联函数的作用</strong>：内联函数在调用时，是将调用表达式用内联函数体来替换。避免函数调用的开销。</p><p>在使用内联函数时，应注意如下几点：</p><ol><li>在内联函数内不允许用循环语句和开关语句。</li></ol><p>如果内联函数有这些语句，则编译将该函数视同普通函数那样产生函数调用代码,递归函数是不能被用来做内联函数的。内联函数只适合于只有1～5行的小函数。对一个含有许多语句的大函数，函数调用和返回的开销相对来说微不足道，所以也没有必要用内联函数实现。　 2. 内联函数的定义必须出现在内联函数第一次被调用之前。</p><h3 id="_1-23-简述c-有几种传值方式-之间的区别是什么" tabindex="-1"><a class="header-anchor" href="#_1-23-简述c-有几种传值方式-之间的区别是什么" aria-hidden="true">#</a> 1.23 简述C++有几种传值方式，之间的区别是什么？</h3><p>传参方式有这三种：<strong>值传递</strong>、<strong>引用传递</strong>、<strong>指针传递</strong></p><ol><li>值传递：形参即使在函数体内值发生变化，也不会影响实参的值；</li><li>引用传递：形参在函数体内值发生变化，会影响实参的值；</li><li>指针传递：在指针指向没有发生改变的前提下，形参在函数体内值发生变化，会影响实参的值；</li></ol><p>值传递用于对象时，整个对象会拷贝一个副本，这样效率低；而引用传递用于对象时，不发生拷贝行为，只是绑定对象，更高效；指针传递同理，但不如引用传递安全。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">//代码示例</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">testfunc</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>b<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>c<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//形参a值发生了改变，但是没有影响实参i的值；但形参*b、c的值发生了改变，影响到了实参*j、k的值</span>
    a <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">(</span><span class="token operator">*</span>b<span class="token punctuation">)</span> <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    c <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;a= %d, b= %d, c= %d\n&quot;</span><span class="token punctuation">,</span>a<span class="token punctuation">,</span><span class="token operator">*</span>b<span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//a= 2, b= 2, c= 2</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
       <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>j <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>
    <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token function">testfunc</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;i= %d, j= %d, k= %d\n&quot;</span><span class="token punctuation">,</span>i<span class="token punctuation">,</span><span class="token operator">*</span>j<span class="token punctuation">,</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//i= 1, j= 2, k= 2</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_1-24-简述const-星号-和-星号-const的区别" tabindex="-1"><a class="header-anchor" href="#_1-24-简述const-星号-和-星号-const的区别" aria-hidden="true">#</a> 1.24 简述const（星号）和（星号）const的区别</h3><p>代码示例：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">//const* 是常量指针，*const 是指针常量</span>

<span class="token keyword">int</span> <span class="token keyword">const</span> <span class="token operator">*</span>a<span class="token punctuation">;</span>    <span class="token comment">//a指针所指向的内存里的值不变，即（*a）不变</span>
<span class="token keyword">int</span> <span class="token operator">*</span><span class="token keyword">const</span> a<span class="token punctuation">;</span>    <span class="token comment">//a指针所指向的内存地址不变，即a不变</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_2、c-c-内存问题" tabindex="-1"><a class="header-anchor" href="#_2、c-c-内存问题" aria-hidden="true">#</a> 2、C/C++内存问题</h2><h3 id="_2-1-简述一下堆和栈的区别" tabindex="-1"><a class="header-anchor" href="#_2-1-简述一下堆和栈的区别" aria-hidden="true">#</a> 2.1 简述一下堆和栈的区别</h3><ol><li><strong>堆栈空间分配不同</strong>。栈由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等；堆一般由程序员分配释放。</li><li><strong>堆栈缓存方式不同</strong>。栈使用的是一级缓存， 它们通常都是被调用时处于存储空间中，调用完毕立即释放；堆则是存放在二级缓存中，速度要慢些。</li><li><strong>堆栈数据结构不同</strong>。堆类似数组结构；栈类似栈结构，先进后出。</li></ol><h3 id="_2-2-简述c-的内存管理" tabindex="-1"><a class="header-anchor" href="#_2-2-简述c-的内存管理" aria-hidden="true">#</a> 2.2 简述C++的内存管理</h3><ol><li>内存分配方式 在C++中，内存分成5个区，他们分别是堆、栈、自由存储区、全局/静态存储区和常量存储区。</li></ol><blockquote><!---->，在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。<!---->，就是那些由malloc/realloc/calloc分配的内存块，一般一个malloc就要对应一个free。<!---->，就是那些由new分配的内存块，和堆是十分相似的，不过是用delete来结束自己的生命。 【补充说明】<!---->，全局变量和静态变量被分配到同一块内存中<!---->，这是一块比较特殊的存储区，里面存放的是常量，不允许修改。</blockquote><p>【<strong>补充说明</strong>】：</p><p>如果我接着问你自由存储区与堆有什么区别，你或许这样回答：“malloc在堆上分配的内存块，使用free释放内存，而new所申请的内存则是在自由存储区上，使用delete来释放。”</p><p>这样听起来似乎也没错，但如果我接着问：</p><p>自由存储区与堆是两块不同的内存区域吗？它们有可能相同吗？</p><p>你可能就懵了。</p><p><strong>尽管C++标准没有要求，但很多编译器的new/delete都是以malloc/free为基础来实现的。那么请问：借以malloc实现的new，所申请的内存是在堆上还是在自由存储区上？ 明显，此时的堆与自由存储区所代表的空间是相同的。</strong></p><p>如果，你重载了new运算符，使其不在堆上开辟空间，那么对于自动存储区的概念就完全不相同了。</p><p>从技术上来说，堆（heap）是C语言和操作系统的术语。堆是操作系统所维护的一块特殊内存，它提供了动态分配的功能，当运行程序调用malloc()时就会从中分配，稍后调用free可把内存交还。而自由存储是C++中通过new和delete动态分配和释放对象的抽象概念，通过new来申请的内存区域可称为自由存储区。基本上，所有的C++编译器默认使用堆来实现自由存储，也即是缺省的全局运算符new和delete也许会按照malloc和free的方式来被实现，这时藉由new运算符分配的对象，说它在堆上也对，说它在自由存储区上也正确。但程序员也可以通过重载操作符，改用其他内存来实现自由存储，例如全局变量做的对象池，这时自由存储区就区别于堆了。我们所需要记住的就是：</p><blockquote><!----></blockquote><p>【<strong>补充说明结束</strong>】 2. 常见的内存错误和对策</p><p>（1）内存分配未成功，却使用了它。</p><p>（2）内存分配虽然成功，但是尚未初始化就引用它。</p><p>（3）内存分配成功并且已经初始化，但操作越过了内存的边界。</p><p>（4）忘记了释放内存，造成内存泄露。</p><p>（5）释放了内存却继续使用它。</p><p>对策：</p><p>（1）定义指针时，先初始化为NULL。</p><p>（2）用malloc或new申请内存之后，应该立即检查指针值是否为NULL。防止使用指针值为NULL的内存。</p><p>（3）不要忘记为数组和动态内存赋初值。防止将未被初始化的内存作为右值使用。</p><p>（4）避免数字或指针的下标越界，特别要当心发生“多1”或者“少1”操作</p><p>（5）动态内存的申请与释放必须配对，防止内存泄漏</p><p>（6）用free或delete释放了内存之后，立即将指针设置为NULL，防止“野指针”</p><p>（7）使用智能指针。</p><ol start="3"><li>内存泄漏及解决办法</li></ol><p><strong>什么是内存泄露？</strong></p><p>简单地说就是申请了一块内存空间，使用完毕后没有释放掉。（1）new和malloc申请资源使用后，没有用delete和free释放；（2）子类继承父类时，父类析构函数不是虚函数。（3）Windows句柄资源使用后没有释放。</p><p><strong>怎么检测？</strong></p><p>第一：良好的编码习惯，使用了内存分配的函数，一旦使用完毕,要记得使用其相应的函数释放掉。</p><p>第二：将分配的内存的指针以链表的形式自行管理，使用完毕之后从链表中删除，程序结束时可检查改链表。</p><p>第三：使用智能指针。</p><p>第四：一些常见的工具插件，如ccmalloc、Dmalloc、Leaky、Valgrind等等。</p><h3 id="_2-3-malloc和局部变量分配在堆还是栈" tabindex="-1"><a class="header-anchor" href="#_2-3-malloc和局部变量分配在堆还是栈" aria-hidden="true">#</a> 2.3 malloc和局部变量分配在堆还是栈？</h3><p>malloc是在堆上分配内存，需要程序员自己回收内存；局部变量是在栈中分配内存，超过作用域就自动回收。</p><h3 id="_2-4-程序有哪些section-分别的作用-程序启动的过程-怎么判断数据分配在栈上还是堆上" tabindex="-1"><a class="header-anchor" href="#_2-4-程序有哪些section-分别的作用-程序启动的过程-怎么判断数据分配在栈上还是堆上" aria-hidden="true">#</a> 2.4 程序有哪些section，分别的作用？程序启动的过程？怎么判断数据分配在栈上还是堆上？</h3><figure><img src="https://s3.bmp.ovh/imgs/2022/08/29/91e07f9f6bdac247.png" alt="图1" tabindex="0" loading="lazy"><figcaption>图1</figcaption></figure><p><strong>一个程序有哪些section</strong>：</p><p>如上图，从低地址到高地址，一个程序由<strong>代码段、数据段、 BSS 段</strong>组成。</p><p>【1】、<strong>数据段</strong>：存放程序中已初始化的全局变量和静态变量的一块内存区域。</p><p>【2】、<strong>代码段</strong>：存放程序执行代码的一块内存区域。只读，代码段的头部还会包含一些<!---->。(全局常量和字符串常量位于全局区/静态区还是代码区，还有待商榷)</p><p>【3】、<strong>BSS 段</strong>：存放程序中未初始化的全局变量和静态变量的一块内存区域。</p><p>【4】、可执行程序在运行时又会多出两个区域：堆区和栈区。</p><p><strong>堆区</strong>：动态申请内存用。堆从低地址向高地址增长。</p><p><strong>栈区</strong>：存储局部变量、函数参数值。栈从高地址向低地址增长。是一块连续的空间。</p><p>【5】、最后还有一个<strong>文件映射区</strong>，位于堆和栈之间。</p><!---->根据观察和代码验证，字符串数组是变量，存放在栈区；字符串指针是常量，存放在全局/静态区。还有一点，全局/静态区是低地址，栈是高地址。<div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword">void</span> <span class="token function">test01</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token keyword">char</span> str1<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&quot;abcd&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> str2<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&quot;abcd&quot;</span><span class="token punctuation">;</span>
 
<span class="token keyword">const</span> <span class="token keyword">char</span> str3<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&quot;abcd&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">char</span> str4<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&quot;abcd&quot;</span><span class="token punctuation">;</span>
 
<span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>str5 <span class="token operator">=</span> <span class="token string">&quot;abcd&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>str6 <span class="token operator">=</span> <span class="token string">&quot;abcd&quot;</span><span class="token punctuation">;</span>
 
<span class="token keyword">char</span> <span class="token operator">*</span>str7 <span class="token operator">=</span> <span class="token string">&quot;abcd&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> <span class="token operator">*</span>str8 <span class="token operator">=</span> <span class="token string">&quot;abcd&quot;</span><span class="token punctuation">;</span>

<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;str1: %p\n&quot;</span><span class="token punctuation">,</span>str1<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;str2: %p\n&quot;</span><span class="token punctuation">,</span>str2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;str3: %p\n&quot;</span><span class="token punctuation">,</span>str3<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;str4: %p\n&quot;</span><span class="token punctuation">,</span>str4<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;str5: %p\n&quot;</span><span class="token punctuation">,</span>str5<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;str6: %p\n&quot;</span><span class="token punctuation">,</span>str6<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;str7: %p\n&quot;</span><span class="token punctuation">,</span>str7<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;str8: %p\n&quot;</span><span class="token punctuation">,</span>str8<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">test02</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">char</span> p<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">&quot;hello world!&quot;</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;test02 p[] is %p\n&quot;</span><span class="token punctuation">,</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">char</span> <span class="token operator">*</span>p1<span class="token operator">=</span><span class="token string">&quot;hello world!&quot;</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;test02 *p is %p\n&quot;</span><span class="token punctuation">,</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">test01</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">test02</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//输出结果为:</span>
str1<span class="token operator">:</span> <span class="token number">0061F</span>EEB <span class="token comment">//栈 char str1[] = &quot;abcd&quot;;</span>
str2<span class="token operator">:</span> <span class="token number">0061F</span>EE6 <span class="token comment">//栈 char str2[] = &quot;abcd&quot;;</span>
str3<span class="token operator">:</span> <span class="token number">0061F</span>EE1 <span class="token comment">//栈 const char str3[] = &quot;abcd&quot;;</span>
str4<span class="token operator">:</span> <span class="token number">0061F</span>EDC <span class="token comment">//栈 const char str4[] = &quot;abcd&quot;;</span>
str5<span class="token operator">:</span> <span class="token number">00405094</span> <span class="token comment">//全局/静态区 const char str3[] = &quot;abcd&quot;;</span>
str6<span class="token operator">:</span> <span class="token number">00405094</span> <span class="token comment">//全局/静态区 const char *str6 = &quot;abcd&quot;;</span>
str7<span class="token operator">:</span> <span class="token number">00405094</span> <span class="token comment">//全局/静态区 char *str7 = &quot;abcd&quot;;</span>
str8<span class="token operator">:</span> <span class="token number">00405094</span> <span class="token comment">//全局/静态区 char *str8 = &quot;abcd&quot;;</span>
test02 p<span class="token punctuation">[</span><span class="token punctuation">]</span> is <span class="token number">0061F</span>EEF <span class="token comment">//栈 char p[]=&quot;hello world!&quot;;</span>
test02 <span class="token operator">*</span>p is <span class="token number">00405064</span> <span class="token comment">//全局/静态区 char *p1=&quot;hello world!&quot;;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><!---->字符串指针所表示的是字符串常量，并且全局常量和字符串常量都是位于全局/静态变量区，但是，局部常量位于栈区。演示代码如下所示：<div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token comment">//已初始化的全局变量 --全局区的.data区</span>
<span class="token keyword">int</span> g_a<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> g_b<span class="token operator">=</span><span class="token number">12</span><span class="token punctuation">;</span>

<span class="token comment">//已初始化的全局静态变量   --全局区的.data区 </span>
<span class="token keyword">static</span> <span class="token keyword">int</span> s_g_a<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> s_g_b<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>

<span class="token comment">//全局常量 全局区</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> g_c_a<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> g_c_b<span class="token operator">=</span><span class="token number">11</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">test01</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">//静态局部变量  全局区</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> s_a<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> s_b<span class="token operator">=</span><span class="token number">11</span><span class="token punctuation">;</span>

    <span class="token comment">//局部常量  位于栈区</span>
    <span class="token keyword">const</span> <span class="token keyword">int</span> l_g_c_a<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">int</span> l_g_c_b<span class="token operator">=</span><span class="token number">11</span><span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;全局变量g_a的地址是：%p\n&quot;</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>g_a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;全局变量g_b的地址是：%p\n&quot;</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>g_b<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;全局静态变量s_g_a的地址是：%p\n&quot;</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>s_g_a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;全局静态变量s_g_b的地址是：%p\n&quot;</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>s_g_b<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;静态局部变量s_a的地址是：%p\n&quot;</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>s_a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;静态局部变量s_b的地址是：%p\n&quot;</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>s_b<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;全局常量g_a的地址是：%p\n&quot;</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>g_c_a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;全局常量g_b的地址是：%p\n&quot;</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>g_c_b<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;局部常量g_a的地址是：%p\n&quot;</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>l_g_c_a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;局部常量g_b的地址是：%p\n&quot;</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>l_g_c_b<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">//字符串常量 全局区</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;字符串常量的地址是：%p\n&quot;</span><span class="token punctuation">,</span><span class="token operator">&amp;</span><span class="token string">&quot;Hello1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;字符串常量的地址是：%p\n&quot;</span><span class="token punctuation">,</span><span class="token operator">&amp;</span><span class="token string">&quot;Hello2&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">test01</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//测试结果为：</span>
全局变量g_a的地址是：<span class="token number">00404004</span>
全局变量g_b的地址是：<span class="token number">00404008</span>
全局静态变量s_g_a的地址是：<span class="token number">0040400</span>C
全局静态变量s_g_b的地址是：<span class="token number">00404010</span>
静态局部变量s_a的地址是：<span class="token number">00404014</span>
静态局部变量s_b的地址是：<span class="token number">00404018</span>
全局常量g_a的地址是：<span class="token number">00405064</span>
全局常量g_b的地址是：<span class="token number">00405068</span>
局部常量g_a的地址是：<span class="token number">0061FF</span>0C
局部常量g_b的地址是：<span class="token number">0061FF</span>08
字符串常量的地址是：<span class="token number">0040517</span>D
字符串常量的地址是：<span class="token number">0040519</span>C
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><!---->：程序只分text区、data区、bss区，当程序运行时才会增加堆区和栈区。（linux下查看代码二进制的elf格式)<p><strong>程序启动的过程</strong>： 1、操作系统首先创建相应的进程并分配私有的进程空间，然后操作系统的加载器负责把可执行文件的数据段和代码段映射到进程的虚拟内存空间中。 2、加载器读入可执行程序的导入符号表，根据这些符号表可以查找出该可执行程序的所有依赖的动态链接库。 3、加载器针对该程序的每一个动态链接库调用LoadLibrary （1）查找对应的动态库文件，加载器为该动态链接库确定一个合适的基地址。 （2）加载器读取该动态链接库的导入符号表和导出符号表，比较应用程序要求的导入符号是否匹配该库的导出符号。 （3）针对该库的导入符号表，查找对应的依赖的动态链接库，如有跳转，则跳到3 （4）调用该动态链接库的初始化函数 4、初始化应用程序的全局变量，对于全局对象自动调用构造函数。 5、进入应用程序入口点函数开始执行。 <strong>怎么判断数据分配在栈上还是堆上</strong>：首先局部变量分配在栈上；而通过malloc和new申请的空间是在堆上。</p><h3 id="_2-5-初始化为0的全局变量在bss还是data" tabindex="-1"><a class="header-anchor" href="#_2-5-初始化为0的全局变量在bss还是data" aria-hidden="true">#</a> 2.5 初始化为0的全局变量在bss还是data</h3><p>答：全局变量和静态变量，初始化了的存入data段，未初始化的存入bss段。</p><h3 id="_2-6-请简述一下atomoic内存顺序" tabindex="-1"><a class="header-anchor" href="#_2-6-请简述一下atomoic内存顺序" aria-hidden="true">#</a> 2.6 请简述一下atomoic内存顺序</h3><p>有六个内存顺序选项可应用于对原子类型的操作：</p><p>memory_order_relaxed：在原子类型上的操作以自由序列执行，没有任何同步关系，仅对此操作要求原子性。</p><p>memory_order_consume：memory_order_consume只会对其标识的对象保证该对象存储先行于那些需要加载该对象的操作。</p><p>memory_order_acquire：使用memory_order_acquire的原子操作，当前线程的读写操作都不能重排到此操作之前。</p><p>memory_order_release：使用memory_order_release的原子操作，当前线程的读写操作都不能重排到此操作之后。</p><p>memory_order_acq_rel：memory_order_acq_rel在此内存顺序的读-改-写操作既是获得加载又是释放操作。没有操作能够从此操作之后被重排到此操作之前，也没有操作能够从此操作之前被重排到此操作之后。</p><p>memory_order_seq_cst：memory_order_seq_cst比std::memory_order_acq_rel更为严格。memory_order_seq_cst不仅是一个&quot;获取释放&quot;内存顺序，它还会对所有拥有此标签的内存操作建立一个单独全序。</p><p>除非你为特定的操作指定一个顺序选项，否则内存顺序选项对于所有原子类型默认都是memory_order_seq_cst。</p><h2 id="_2-7-简述c-中内存对齐的使用场景" tabindex="-1"><a class="header-anchor" href="#_2-7-简述c-中内存对齐的使用场景" aria-hidden="true">#</a> 2.7 简述C++中内存对齐的使用场景</h2><p>内存对齐应用于三种数据类型中：struct/class/union</p><p>struct/class/union内存对齐原则有四个：</p><blockquote><ol><li>数据成员对齐规则：结构(struct)或联合(union)的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小或者成员的子成员大小的整数倍开始。</li></ol></blockquote><blockquote><ol start="2"><li>结构体作为成员:如果一个结构里有某些结构体成员,则结构体成员要从其内部&quot;最宽基本类型成员&quot;的整数倍地址开始存储。(struct a里存有struct b,b里有char,int ,double等元素,那b应该从8的整数倍开始存储)。</li></ol></blockquote><blockquote><ol start="3"><li>收尾工作:结构体的总大小，也就是sizeof的结果，必须是其内部最大成员的&quot;最宽基本类型成员&quot;的整数倍。不足的要补齐。(基本类型不包括struct/class/uinon)。</li></ol></blockquote><blockquote><ol start="4"><li>sizeof(union)，以结构里面size最大元素为union的size，因为在某一时刻，union只有一个成员真正存储于该地址。</li></ol></blockquote><p>补充说明：</p><ol><li><strong>什么是字节对齐</strong></li></ol><p>那么什么是字节对齐？在C语言中，结构体是一种复合数据类型，其构成元素既可以是基本数据类型（如int、long、float等）的变量，也可以是一些复合数据类型（如数组、结构体、联合体等）的数据单元。在结构体中，编译器为结构体的每个成员按其自然边界（alignment）分配空间。各个成员按照它们被声明的顺序在内存中顺序存储，第一个成员的地址和整个结构体的地址相同。</p><p>为了使CPU能够对变量进行快速的访问，变量的起始地址应该具有某些特性，即所谓的“对齐”，比如4字节的int型，其起始地址应该位于4字节的边界上，即起始地址能够被4整除，也即“对齐”跟数据在内存中的位置有关。如果一个变量的内存地址正好位于它长度的整数倍，他就被称做自然对齐。</p><p>比如在32位cpu下，假设一个整型变量的地址为0x00000004(为4的倍数)，那它就是自然对齐的，而如果其地址为0x00000002（非4的倍数）则是非对齐的。现代计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。</p><ol start="2"><li><strong>为什么要字节对齐</strong></li></ol><p>需要字节对齐的根本原因在于CPU访问数据的效率问题。假设上面整型变量的地址不是自然对齐，比如为0x00000002，则CPU如果取它的值的话需要访问两次内存，第一次取从0x00000002-0x00000003的一个short，第二次取从0x00000004-0x00000005的一个short然后组合得到所要的数据，如果变量在0x00000003地址上的话则要访问三次内存，第一次为char，第二次为short，第三次为char，然后组合得到整型数据。</p><p>而如果变量在自然对齐位置上，则只要一次就可以取出数据。一些系统对对齐要求非常严格，比如sparc系统，如果取未对齐的数据会发生错误，而在x86上就不会出现错误，只是效率下降。</p><p>各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。比如有些平台每次读都是从偶地址开始，如果一个int型（假设为32位系统）如果存放在偶地址开始的地方，那么一个读周期就可以读出这32bit，而如果存放在奇地址开始的地方，就需要2个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该32bit数据。显然在读取效率上下降很多。</p><ol start="3"><li><strong>字节对齐实例</strong>：</li></ol><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">union</span> example <span class="token punctuation">{</span>  
    <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  
    <span class="token keyword">char</span> b<span class="token punctuation">;</span>  
    <span class="token keyword">double</span> c<span class="token punctuation">;</span>  
<span class="token punctuation">}</span><span class="token punctuation">;</span>  
<span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>example<span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token comment">/*
联合体只取最长的，int a[5]，长度为20，字节对齐为24
*/</span>

<span class="token keyword">struct</span> <span class="token class-name">example</span> <span class="token punctuation">{</span>  
    <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  
    <span class="token keyword">char</span> b<span class="token punctuation">;</span>  
    <span class="token keyword">double</span> c<span class="token punctuation">;</span>  
<span class="token punctuation">}</span>test_struct<span class="token punctuation">;</span>
<span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>test_struct<span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token comment">/*
struct总和 int 20 分为 8 8 4 char 1 double 8 最大对齐8 char补充到int的4 所以为 8+8+8（4+1）+8（double），总计32
*/</span>

<span class="token keyword">struct</span> <span class="token class-name">example</span> <span class="token punctuation">{</span>  
    <span class="token keyword">char</span> b<span class="token punctuation">;</span>  
    <span class="token keyword">double</span> c<span class="token punctuation">;</span>  
    <span class="token keyword">int</span> a<span class="token punctuation">;</span>  
<span class="token punctuation">}</span>test_struct<span class="token punctuation">;</span>  
<span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>test_struct<span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token comment">/*
字节对齐除了内存起始地址要是数据类型的整数倍以外，还要满足一个条件，那就是占用的内存空间大小需要是结构体中占用最大内存空间的类型的整数倍，所以20不是double（8Byte）的整数倍，我们还要扩充四个字节，最后的结果是result=24
*/</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_3、c-面向对象" tabindex="-1"><a class="header-anchor" href="#_3、c-面向对象" aria-hidden="true">#</a> 3、C++面向对象</h2><h3 id="_3-1-简述一下什么是面向对象" tabindex="-1"><a class="header-anchor" href="#_3-1-简述一下什么是面向对象" aria-hidden="true">#</a> 3.1 简述一下什么是面向对象</h3><ol><li><p>面向对象是一种编程思想，把一切东西看成是一个个对象，比如人、耳机、鼠标、水杯等，他们各自都有属性，比如：耳机是白色的，鼠标是黑色的，水杯是圆柱形的等等，把这些对象拥有的属性变量和操作这些属性变量的函数打包成一个类来表示</p></li><li><p>面向过程和面向对象的区别</p></li></ol><p>面向过程：根据业务逻辑从上到下写代码</p><p>面向对象：将数据与函数绑定到一起，进行封装，这样能够更快速的开发程序，减少了重复代码的重写过程</p><h3 id="_3-2-简述一下面向对象的三大特征" tabindex="-1"><a class="header-anchor" href="#_3-2-简述一下面向对象的三大特征" aria-hidden="true">#</a> 3.2 简述一下面向对象的三大特征</h3><p>封装、继承、多态</p><ol><li><p>封装：将数据和操作数据的方法进行有机结合，隐藏对象的属性和实现细节，仅对外公开接口来和对象进行 交互。封装本质上是一种管理：我们如何管理兵马俑呢？比如如果什么都不管，兵马俑就被随意破坏了。那么我们首先建了一座房子把兵马俑给封装起来。但是我们目的全封装起来，不让别人看。所以我们开放了售票通道，可以买票突破封装在合理的监管机制下进去参观。类也是一样，不想给别人看到的，我们使用protected/private把成员封装起来。开放一些公有的成员函数对成员合理的访问。所以封装本质是一种管理。</p></li><li><p>继承：可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。 三种继承关系：</p></li></ol><table><thead><tr><th>继承方式</th><th>private继承</th><th>protected继承</th><th>public继承</th></tr></thead><tbody><tr><td>基类的private成员</td><td>不可见</td><td>不可见</td><td>不可见</td></tr><tr><td>基类的protected成员</td><td>变为private成员</td><td>仍为protected成员</td><td>仍为protected成员</td></tr><tr><td>基类的public成员</td><td>变为private成员</td><td>变为protected成员</td><td>仍为protected成员</td></tr></tbody></table><ol start="3"><li>多态：用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。实现多态，有二种方式，重写，重载。（虚函数/纯虚函数、函数重载）</li></ol><h3 id="_3-3-简述一下c-的重写与重载-以及他们之间的区别" tabindex="-1"><a class="header-anchor" href="#_3-3-简述一下c-的重写与重载-以及他们之间的区别" aria-hidden="true">#</a> 3.3 简述一下C++的重写与重载，以及他们之间的区别</h3><p>1、重写</p><p>是指派生类中存在重新定义的函数。其函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致。只有函数体不同（花括号内），派生类对象调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有virtual修饰。（虚函数/纯虚函数）</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;bits/stdC++.h&gt;</span></span>

<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">virtual</span>    <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;A&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token operator">:</span><span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">A</span></span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;B&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    A<span class="token operator">*</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    a<span class="token operator">-&gt;</span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//输出B，A类中的fun在B类中重写</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2、重载</p><p>我们在平时写代码中会用到几个函数但是他们的实现功能相同，但是有些细节却不同。例如：交换两个数的值其中包括（int, float,char,double)这些个类型。在C语言中我们是利用不同的函数名来加以区分。这样的代码不美观而且给程序猿也带来了很多的不便。于是在C++中人们提出了用一个函数名定义多个函数，也就是所谓的函数重载。函数重载是指同一可访问区内被声明的几个具有不同参数列（<strong>参数的类型，个数，顺序不同</strong>）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;bits/stdC++.h&gt;</span></span>

<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">fun1</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span><span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-4-c-如何实现重写与重载的-在c语言中怎么实现函数重载" tabindex="-1"><a class="header-anchor" href="#_3-4-c-如何实现重写与重载的-在c语言中怎么实现函数重载" aria-hidden="true">#</a> 3.4 C++如何实现重写与重载的？在C语言中怎么实现函数重载？</h3><p>答1：重写：在基类的函数前加上virual关键字，就可以在派生类中重写该函数，运行时将会根据对象的实际类型来调用对应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数。</p><blockquote><p>i. 用virtual关键字申明的函数叫做虚函数，虚函数肯定是类的成员函数 ii. 存在虚函数的类都有一个一维的虚函数表叫做虚表，类的对象有一个指向虚表开始的虚指针。虚表是和类对应的，虚表指针是和对象对应的 iii. 多态性是一个接口多种实现，是面向对象的核心，分为类的多态性和函数的多态性 iv. 重写用虚函数来实现，结合动态绑定 v. 纯虚函数是虚函数再加上 = 0 vi. 抽象类是指包括至少一个纯虚函数的类</p></blockquote><p>纯虚函数：virtual void fun()=0。即抽象类必须在子类实现这个函数，即先有名称，没有内容，在派生类实现内容。而虚函数可以再子类中不实现。还有，仅含有虚函数的类，并不是抽象类。</p><p>答2：重载：C++通过命名倾轧（name mangling）技术来改名函数名，区分参数不同的同名函数，命名倾轧是在编译阶段完成的。</p><p>题外话：C++在编译阶段通过函数名+形参列表的方式来区分函数，所以可以实现函数重载。而C语言在编译时是以函数名来区分函数的，所以C与C++混编的时候会出现错误。可以在++代码中使用extern{}关键字来保证正确编译。</p><p>答3：c语言中不允许有同名函数，因为编译时函数命名是一样的，不像C++会添加参数类型和返回类型作为函数编译后的名称，进而实现重载。如果要用c语言显现函数重载，可通过以下方式来实现：</p><blockquote><ol><li>使用函数指针来实现，重载的函数不能使用同名称，只是类似的实现了函数重载功能</li><li>重载函数使用可变参数，方式如打开文件open函数</li><li>gcc有内置函数，程序使用编译函数可以实现函数重载</li></ol></blockquote><p>一般方式1比较常用，示例代码：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword">void</span> <span class="token function">func_int</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span> a<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d\n&quot;</span><span class="token punctuation">,</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//输出int类型，注意 void * 转化为int</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">func_double</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span> b<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%.2f\n&quot;</span><span class="token punctuation">,</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token operator">*</span><span class="token punctuation">)</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//typedef申明一个函数指针</span>

<span class="token keyword">void</span> <span class="token function">c_func</span><span class="token punctuation">(</span>ptr p<span class="token punctuation">,</span><span class="token keyword">void</span> <span class="token operator">*</span>param<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
     <span class="token function">p</span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">//调用对应函数</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">23</span><span class="token punctuation">;</span>
    <span class="token keyword">double</span> b <span class="token operator">=</span> <span class="token number">23.23</span><span class="token punctuation">;</span>
    <span class="token function">c_func</span><span class="token punctuation">(</span>func_int<span class="token punctuation">,</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">c_func</span><span class="token punctuation">(</span>func_double<span class="token punctuation">,</span><span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>关于typedef和函数指针的恩怨纠葛，在补充代码如下：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">//形式1：返回类型(*函数名)(参数列表)</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token comment">//定义一个函数指针pFUN，它指向一个返回类型为char，有一个整型的参数的函数</span>
<span class="token keyword">char</span> <span class="token punctuation">(</span><span class="token operator">*</span>pFun<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//定义一个返回类型为char，参数为int的函数</span>
<span class="token comment">//从指针层面上理解该函数，即函数的函数名实际上是一个指针，</span>
<span class="token comment">//该指针指向函数在内存中的首地址</span>
<span class="token keyword">char</span> <span class="token function">glFun</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> a<span class="token punctuation">;</span>
    <span class="token comment">//return a;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token comment">//将函数glFun的地址赋值给变量pFun</span>
    pFun <span class="token operator">=</span> glFun<span class="token punctuation">;</span>
<span class="token comment">//*pFun”显然是取pFun所指向地址的内容，当然也就是取出了函数glFun()的内容，然后给定参数为2。</span>
    <span class="token punctuation">(</span><span class="token operator">*</span>pFun<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//形式2 typedef  返回类型(*新类型)(参数表)</span>
<span class="token comment">// typedef可以让函数指针更直观方便 ,typedef是新定义了一种类型</span>
<span class="token keyword">typedef</span> <span class="token keyword">char</span> <span class="token punctuation">(</span><span class="token operator">*</span>PTRFUN<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
PTRFUN pFun<span class="token punctuation">;</span> 
<span class="token keyword">char</span> <span class="token function">glFun</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span> 
<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
<span class="token punctuation">{</span> 
    pFun <span class="token operator">=</span> glFun<span class="token punctuation">;</span> 
    <span class="token punctuation">(</span><span class="token operator">*</span>pFun<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于typedef void(*T)(void *)，我们进行一层层的剖析</p><p>1、首先写成 void(*T)() 可以看出 T是一个指针，是一个指向返回值为void ，参数为空的类型的函数指针</p><p>2、在加上(void *) 为 void(*T)(void *) 就变成了一个指向 返回值为void，参数为void *类型的指针</p><p>3、在加上上typedef ，加上后，T就不再是一个函数指针了，它代表着一种类型，这种类型可以定义一个 指向 返回值为void，参数为void *类型的指针</p><p>4、<code>比如 T t;</code></p><p><code>void func(void \*)；</code></p><p><code>t=func </code></p><h3 id="_3-5-构造函数分为哪几种" tabindex="-1"><a class="header-anchor" href="#_3-5-构造函数分为哪几种" aria-hidden="true">#</a> 3.5 构造函数分为哪几种？</h3><p>默认无参构造函数、拷贝构造函数、有参构造函数（初始化列表或函数体内赋值）、<!----></p><p>需要注意：有参构造中，可细分为初始化列表he函数体内赋值。初始化列表就是在定义变量的同时就给值，函数体内赋值相当于先定义变量，再给值。当类中有成员变量为常量时，必须使用初始化列表。</p><p>下面以代码举例，说明拷贝构造函数和移动构造函数：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">//拷贝构造函数</span>
<span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">const</span> Test<span class="token operator">&amp;</span> t<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token operator">-&gt;</span>i <span class="token operator">=</span> t<span class="token punctuation">.</span>i<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token operator">-&gt;</span>p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span>t<span class="token punctuation">.</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
<span class="token comment">//移动构造函数</span>
<span class="token keyword">class</span> <span class="token class-name">Example</span><span class="token punctuation">{</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	string <span class="token operator">*</span>ptr<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	 <span class="token comment">//移动构造函数</span>
	 <span class="token function">Example</span> <span class="token punctuation">(</span>Example<span class="token operator">&amp;&amp;</span> x<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">ptr</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>ptr<span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        x<span class="token punctuation">.</span>ptr <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//拷贝构造函数 深拷贝  区别在于不会处理形参元素x</span>
    <span class="token function">Example</span> <span class="token punctuation">(</span>Example<span class="token operator">&amp;</span> x<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
    	<span class="token keyword">delete</span> ptr<span class="token punctuation">;</span>
    	ptr<span class="token operator">=</span><span class="token keyword">new</span> <span class="token function">string</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//有参构造函数</span>
    <span class="token function">Example</span> <span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> str<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">ptr</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">string</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token comment">//重载赋值运算符</span>
    Example<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span> <span class="token punctuation">(</span>Example6<span class="token operator">&amp;&amp;</span> x<span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token keyword">delete</span> ptr<span class="token punctuation">;</span> 
        ptr <span class="token operator">=</span> x<span class="token punctuation">.</span>ptr<span class="token punctuation">;</span>
        x<span class="token punctuation">.</span>ptr<span class="token operator">=</span><span class="token keyword">nullptr</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//打印字符串</span>
    <span class="token keyword">const</span> string<span class="token operator">&amp;</span> <span class="token function">content</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span><span class="token punctuation">}</span>
    <span class="token comment">//重载加号运算符：</span>
    Example <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token keyword">const</span> Example<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">Example</span><span class="token punctuation">(</span><span class="token function">content</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span>rhs<span class="token punctuation">.</span><span class="token function">content</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>；
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-6-只定义析构函数-会自动生成哪些构造函数" tabindex="-1"><a class="header-anchor" href="#_3-6-只定义析构函数-会自动生成哪些构造函数" aria-hidden="true">#</a> 3.6 只定义析构函数，会自动生成哪些构造函数</h3><p>只定义了析构函数，编译器将自动为我们生成拷贝构造函数和默认构造函数。</p><p>注意：有了有参的构造了，编译器就不提供默认的构造函数。</p><h3 id="_3-7-说说一个类-默认会生成哪些函数" tabindex="-1"><a class="header-anchor" href="#_3-7-说说一个类-默认会生成哪些函数" aria-hidden="true">#</a> 3.7 说说一个类，默认会生成哪些函数</h3><p>定义了一个空类，默认为生成以下几个函数： 1、无参构造函数 2、拷贝构造函数（默认的为浅拷贝） 3、重载赋值运算符 4、析构函数（非虚）</p><h3 id="_3-8-说说-c-类对象的初始化顺序-有多重继承情况下的顺序" tabindex="-1"><a class="header-anchor" href="#_3-8-说说-c-类对象的初始化顺序-有多重继承情况下的顺序" aria-hidden="true">#</a> 3.8 说说 C++ 类对象的初始化顺序，有多重继承情况下的顺序</h3><ol><li><p>创建派生类的对象，基类的构造函数优先被调用（也优先于派生类里的成员类）；</p></li><li><p>如果类里面有成员类，成员类的构造函数优先被调用；(也优先于该类本身的构造函数）</p></li><li><p>基类构造函数如果有多个基类，则<!---->而不是它们在成员初始化表中的顺序；；（即：class 类名：public 基类1，public 基类2）</p></li><li><p>成员类对象构造函数如果有多个成员类对象，则<!---->而不是它们出现在成员初始化表中的顺序；（即：类内变量：类名 变量1；类名 变量2）</p></li><li><p>派生类构造函数，作为一般规则派生类构造函数应该不能直接向一个基类数据成员赋值而是把值传递给适当的基类构造函数,否则两个类的实现变成紧耦合的（tightly coupled）将更加难于正确地修改或扩展基类的实现。（基类设计者的责任是提供一组适当的基类构造函数）</p></li></ol><p>综上可以得出，初始化顺序：</p><blockquote><p>父类构造函数–&gt;成员类对象构造函数–&gt;自身构造函数</p><p>其中成员变量的初始化与声明顺序有关，构造函数的调用顺序是类派生列表中的顺序。</p><p>析构顺序和构造顺序相反。</p></blockquote><p>代码示例：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Base1</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">Base1</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;construting Base1——&quot;</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">Base1</span><span class="token punctuation">(</span>Base1<span class="token operator">&amp;</span> b1<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Base1 Copy constructor&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token operator">~</span><span class="token function">Base1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;~Base1&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Base2</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">Base2</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;constructing Base2——&quot;</span> <span class="token operator">&lt;&lt;</span> j <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">Base2</span><span class="token punctuation">(</span>Base2<span class="token operator">&amp;</span> b2<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Base2 Copy constructor&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token operator">~</span><span class="token function">Base2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;~Base2&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span><span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base1</span><span class="token punctuation">,</span> <span class="token keyword">public</span> <span class="token class-name">Base2</span></span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token comment">//Derived(int a, int b, int c, int d) :Base1(b), member2(c), Base2(a), member1(d)</span>
	<span class="token function">Derived</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">,</span> <span class="token keyword">int</span> d<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">Base1</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">member2</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Base2</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">member1</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;constructing Derived&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">Derived</span><span class="token punctuation">(</span>Derived<span class="token operator">&amp;</span> d<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">Base1</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">member2</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Base2</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">member1</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Derived Copy constructor &quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token operator">~</span><span class="token function">Derived</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;~Derived&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	Base2 member2<span class="token punctuation">;</span> 
	Base1 member1<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">//在派生类中的，基类构造函数的调用顺序是，先看权限继承方式上的顺序：public Base1, public Base2；</span>
<span class="token comment">//再看成员变量定义的顺序：Base2 member2; Base1 member1;</span>
<span class="token keyword">int</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	Derived <span class="token function">d1</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	Derived <span class="token function">d2</span><span class="token punctuation">(</span>d1<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">system</span><span class="token punctuation">(</span><span class="token string">&quot;pause&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//输出结果为：</span>
construting Base1——<span class="token number">1</span>
constructing Base2——<span class="token number">3</span>
constructing Base2——<span class="token number">2</span>
construting Base1——<span class="token number">4</span>
constructing Derived
Base1 Copy constructor
Base2 Copy constructor
Base2 Copy constructor
Base1 Copy constructor
Derived Copy constructor
<span class="token operator">~</span>Derived
<span class="token operator">~</span>Base1
<span class="token operator">~</span>Base2
<span class="token operator">~</span>Base2
<span class="token operator">~</span>Base1
<span class="token operator">~</span>Derived
<span class="token operator">~</span>Base1
<span class="token operator">~</span>Base2
<span class="token operator">~</span>Base2
<span class="token operator">~</span>Base1
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-9-简述下向上转型和向下转型" tabindex="-1"><a class="header-anchor" href="#_3-9-简述下向上转型和向下转型" aria-hidden="true">#</a> 3.9 简述下向上转型和向下转型</h3><ol><li><p>子类转换为父类：向上转型，使用dynamic_cast(expression)，这种转换相对来说比较安全不会有数据的丢失；</p></li><li><p>父类转换为子类：向下转型，可以使用强制转换，这种转换时不安全的，会导致数据的丢失，原因是父类的指针或者引用的内存中可能不包含子类的成员的内存。</p></li></ol><h3 id="_3-10-简述下深拷贝和浅拷贝-如何实现深拷贝" tabindex="-1"><a class="header-anchor" href="#_3-10-简述下深拷贝和浅拷贝-如何实现深拷贝" aria-hidden="true">#</a> 3.10 简述下深拷贝和浅拷贝，如何实现深拷贝</h3><ol><li><p>浅拷贝：又称值拷贝，将源对象的值拷贝到目标对象中去，本质上来说源对象和目标对象共用一份实体，只是所引用的变量名不同，地址其实还是相同的。举个简单的例子，你的小名叫西西，大名叫冬冬，当别人叫你西西或者冬冬的时候你都会答应，这两个名字虽然不相同，但是都指的是你。</p></li><li><p>深拷贝，拷贝的时候先开辟出和源对象大小一样的空间，然后将源对象里的内容拷贝到目标对象中去，这样两个指针就指向了不同的内存位置。并且里面的内容是一样的，这样不但达到了我们想要的目的，还不会出现问题，两个指针先后去调用析构函数，分别释放自己所指向的位置。即为每次增加一个指针，便申请一块新的内存，并让这个指针指向新的内存，深拷贝情况下，不会出现重复释放同一块内存的错误。</p></li></ol><h3 id="_3-11-简述一下c-中的多态" tabindex="-1"><a class="header-anchor" href="#_3-11-简述一下c-中的多态" aria-hidden="true">#</a> 3.11 简述一下C++中的多态</h3><p>由于派生类重写基类方法，然后用基类引用指向派生类对象，调用方法时候会进行动态绑定，这就是多态。 多态分为静态多态和动态多态：</p><ol><li>静态多态：编译器在编译期间完成的，编译器会根据实参类型来推断该调用哪个函数，如果有对应的函数，就调用，没有则在编译时报错。例如：</li></ol><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>include<span class="token operator">&lt;</span>iostream<span class="token operator">&gt;</span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token comment">//1</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> a<span class="token operator">+</span>b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">char</span> <span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">char</span> a<span class="token punctuation">,</span><span class="token keyword">char</span> b<span class="token punctuation">)</span><span class="token comment">//2</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> a<span class="token operator">+</span>b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    cout<span class="token operator">&lt;&lt;</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">666</span><span class="token punctuation">,</span><span class="token number">888</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token comment">//1</span>
    cout<span class="token operator">&lt;&lt;</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token char">&#39;1&#39;</span><span class="token punctuation">,</span><span class="token char">&#39;2&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//2</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>静态多态，就是在编译阶段就实现的多态。 2. 动态多态：其实要实现动态多态，需要几个条件----即动态绑定条件：</p><blockquote><p>虚函数，基类必须含有虚函数，派生类必须重写虚函数； 通过基类指针或引用来调用虚函数</p></blockquote><h3 id="_3-12-为什么要虚析构-为什么不能虚构造" tabindex="-1"><a class="header-anchor" href="#_3-12-为什么要虚析构-为什么不能虚构造" aria-hidden="true">#</a> 3.12 为什么要虚析构，为什么不能虚构造？</h3><ol><li>为什么要虚析构：将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。如果基类的析构函数不是虚函数，在特定情况下会导致派生类无法被析构。</li></ol><blockquote><p>i. 用派生类类型指针绑定派生类实例，析构的时候，不管基类析构函数是不是虚函数，都会正常析构</p><p>ii. 用基类类型指针绑定派生类实例，析构的时候，如果基类析构函数不是虚函数，则只会析构基类，不会析构派生类对象，从而造成内存泄漏。为什么会出现这种现象呢，个人认为析构的时候如果没有虚函数的动态绑定功能，就只根据指针的类型来进行的，而不是根据指针绑定的对象来进行，所以只是调用了基类的析构函数；如果基类的析构函数是虚函数，则析构的时候就要根据指针绑定的对象来调用对应的析构函数了。</p></blockquote><p>C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。</p><ol start="2"><li>为什么不能虚构造？</li></ol><p>i. 从存储空间角度：虚函数对应一个vtable,这个表的地址是存储在对象的内存空间的。如果将构造函数设置为虚函数，就需要到vtable 中调用，可是对象还没有实例化，没有内存空间分配，如何调用。（悖论）</p><p>ii. 从使用角度：虚函数主要用于在信息不全的情况下，能使重载的函数得到对应的调用。构造函数本身就是要初始化实例，那使用虚函数也没有实际意义呀。所以构造函数没有必要是虚函数。虚函数的作用在于通过父类的指针或者引用来调用它的时候能够变成调用子类的那个成员函数。而构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数。</p><p>iii. 从实现上看，vtable 在构造函数调用后才建立，因而构造函数不可能成为虚函数。从实际含义上看，在调用构造函数时还不能确定对象的真实类型（因为子类会调父类的构造函数）；而且构造函数的作用是提供初始化，在对象生命期只执行一次，不是对象的动态行为，也没有太大的必要成为虚函数。</p><h3 id="_3-13-说说模板类是在什么时候实现的" tabindex="-1"><a class="header-anchor" href="#_3-13-说说模板类是在什么时候实现的" aria-hidden="true">#</a> 3.13 说说模板类是在什么时候实现的</h3><ol><li><p>模板实例化：模板的实例化分为显式实例化和隐式实例化，前者是研发人员明确的告诉模板应该使用什么样的类型去生成具体的类或函数，后者是在编译的过程中由编译器来决定使用什么类型来实例化一个模板。不管是显式实例化或隐式实例化，最终生成的类或函数完全是按照模板的定义来实现的</p></li><li><p>模板具体化：当模板使用某种类型实例化后生成的类或函数不能满足需要时，可以考虑对模板进行具体化。具体化时可以修改原模板的定义，当使用该类型时，按照具体化后的定义实现，具体化相当于对某种类型进行特殊处理。<!---->&gt;</p></li></ol><p>代码示例：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token comment">// #1 模板定义</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">TemplateStruct</span>
<span class="token punctuation">{</span>
    <span class="token function">TemplateStruct</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// #2 模板显示实例化</span>
<span class="token keyword">template</span> <span class="token keyword">struct</span> <span class="token class-name">TemplateStruct</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>

<span class="token comment">// #3 模板具体化</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span> <span class="token keyword">struct</span> <span class="token class-name">TemplateStruct</span><span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">&gt;</span>
<span class="token punctuation">{</span>
    <span class="token function">TemplateStruct</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;--8--&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    TemplateStruct<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> intStruct<span class="token punctuation">;</span>
    TemplateStruct<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">&gt;</span> doubleStruct<span class="token punctuation">;</span>

    <span class="token comment">// #4 模板隐式实例化</span>
    TemplateStruct<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">&gt;</span> llStruct<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//输出结果为：</span>
<span class="token number">4</span>
<span class="token operator">--</span><span class="token number">8</span><span class="token operator">--</span>
<span class="token number">1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-14-说说类继承时-派生类对不同关键字修饰的基类方法的访问权限" tabindex="-1"><a class="header-anchor" href="#_3-14-说说类继承时-派生类对不同关键字修饰的基类方法的访问权限" aria-hidden="true">#</a> 3.14 说说类继承时，派生类对不同关键字修饰的基类方法的访问权限</h3><p>类中的成员可以分为三种类型，分别为public成员、protected成员、public成员。类中可以直接访问自己类的public、protected、private成员，但类对象只能访问自己类的public成员。</p><ol><li><p>public继承：派生类可以访问基类的public、protected成员，不可以访问基类的private成员； 派生类对象可以访问基类的public成员，不可以访问基类的protected、private成员。</p></li><li><p>protected继承：派生类可以访问基类的public、protected成员，不可以访问基类的private成员； 派生类对象不可以访问基类的public、protected、private成员。</p></li><li><p>private继承：派生类可以访问基类的public、protected成员，不可以访问基类的private成员； 派生类对象不可以访问基类的public、protected、private成员。</p></li></ol><h3 id="_3-15-简述一下移动构造函数-什么库用到了这个函数" tabindex="-1"><a class="header-anchor" href="#_3-15-简述一下移动构造函数-什么库用到了这个函数" aria-hidden="true">#</a> 3.15 简述一下移动构造函数，什么库用到了这个函数？</h3><p>C++11中新增了移动构造函数。与拷贝类似，移动也使用一个对象的值设置另一个对象的值。但是，又与拷贝不同的是，移动实现的是对象值真实的转移（源对象到目的对象）：源对象将丢失其内容，其内容将被目的对象占有。移动操作的发生的时候，是当移动值的对象是未命名的对象的时候。这里未命名的对象就是那些临时变量，甚至都不会有名称。典型的未命名对象就是函数的返回值或者类型转换的对象。使用临时对象的值初始化另一个对象值，不会要求对对象的复制：因为临时对象不会有其它使用，因而，它的值可以被移动到目的对象。做到这些，就要使用移动构造函数和移动赋值：当使用一个临时变量对对象进行构造初始化的时候，调用移动构造函数。类似的，使用未命名的变量的值赋给一个对象时，调用移动赋值操作。</p><p>移动操作的概念对对象管理它们使用的存储空间很有用的，诸如对象使用new和delete分配内存的时候。在这类对象中，拷贝和移动是不同的操作：从A拷贝到B意味着，B分配了新内存，A的整个内容被拷贝到为B分配的新内存上。</p><p>而从A移动到B意味着分配给A的内存转移给了B，没有分配新的内存，它仅仅包含简单地拷贝指针。</p><p>看下面的例子：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// 移动构造函数和赋值</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Example6</span> <span class="token punctuation">{</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    string<span class="token operator">*</span> ptr<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Example6</span> <span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> str<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">ptr</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">string</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token operator">~</span><span class="token function">Example6</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">delete</span> ptr<span class="token punctuation">;</span><span class="token punctuation">}</span>
    <span class="token comment">// 移动构造函数，参数x不能是const Pointer&amp;&amp; x，</span>
    <span class="token comment">// 因为要改变x的成员数据的值；</span>
    <span class="token comment">// C++98不支持，C++0x（C++11）支持</span>
    <span class="token function">Example6</span> <span class="token punctuation">(</span>Example6<span class="token operator">&amp;&amp;</span> x<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">ptr</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>ptr<span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        x<span class="token punctuation">.</span>ptr <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// move assignment</span>
    Example6<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span> <span class="token punctuation">(</span>Example6<span class="token operator">&amp;&amp;</span> x<span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token keyword">delete</span> ptr<span class="token punctuation">;</span> 
        ptr <span class="token operator">=</span> x<span class="token punctuation">.</span>ptr<span class="token punctuation">;</span>
        x<span class="token punctuation">.</span>ptr<span class="token operator">=</span><span class="token keyword">nullptr</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// access content:</span>
    <span class="token keyword">const</span> string<span class="token operator">&amp;</span> <span class="token function">content</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span><span class="token punctuation">}</span>
    <span class="token comment">// addition:</span>
    Example6 <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token keyword">const</span> Example6<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">Example6</span><span class="token punctuation">(</span><span class="token function">content</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span>rhs<span class="token punctuation">.</span><span class="token function">content</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Example6 <span class="token function">foo</span><span class="token punctuation">(</span><span class="token string">&quot;Exam&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">// 构造函数</span>
    Example6 <span class="token function">bar</span><span class="token punctuation">(</span><span class="token function">move</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 移动构造函数</span>
                                <span class="token comment">// 调用move之后，foo变为一个右值引用变量，</span>
                                <span class="token comment">// 此时，foo所指向的字符串已经被&quot;掏空&quot;，</span>
                                <span class="token comment">// 所以此时不能再调用foo</span>
	Example6 bar2 <span class="token operator">=</span> <span class="token function">Example6</span><span class="token punctuation">(</span><span class="token string">&quot;ple&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 拷贝构造函数</span>
    bar <span class="token operator">=</span> bar<span class="token operator">+</span> bar2<span class="token punctuation">;</span>             <span class="token comment">// 移动赋值，在这儿&quot;=&quot;号右边的加法操作，</span>
                                <span class="token comment">// 产生一个临时值，即一个右值</span>
                                 <span class="token comment">// 所以此时调用移动赋值语句</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;bar&#39;s content: &quot;</span> <span class="token operator">&lt;&lt;</span> bar<span class="token punctuation">.</span><span class="token function">content</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token char">&#39;\n&#39;</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//说明：std::move()函数时C++11新增的，用于将一个左值引用转换为右值引用。</span>
<span class="token comment">//输出结果为：bar`s content: Example</span>
<span class="token comment">//附加说明：本例中，如何调用重载赋值运算符：Example6 str2=move(bar);此时，bar字符串被删除内存，str2=Example</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-16-请你回答一下-c-类内可以定义引用数据成员吗" tabindex="-1"><a class="header-anchor" href="#_3-16-请你回答一下-c-类内可以定义引用数据成员吗" aria-hidden="true">#</a> 3.16 请你回答一下 C++ 类内可以定义引用数据成员吗？</h3><p>C++类内可以定义引用成员变量，但要遵循以下三个规则：</p><ol><li><p>不能用默认构造函数初始化，必须提供构造函数，用初始化列表的方式来初始化引用成员变量。否则会造成引用未初始化错误。</p></li><li><p>构造函数的形参也必须是引用类型。</p></li><li><p>不能在构造函数里初始化，必须在初始化列表中进行初始化。</p></li></ol><h3 id="_3-17-简述一下什么是常函数-有什么作用" tabindex="-1"><a class="header-anchor" href="#_3-17-简述一下什么是常函数-有什么作用" aria-hidden="true">#</a> 3.17 简述一下什么是常函数，有什么作用</h3><p>类的成员函数后面加 const，表明这个函数不会对这个类对象的数据成员（准确地说是非静态数据成员）作任何改变。在设计类的时候，一个原则就是对于不改变数据成员的成员函数都要在后面加const，而对于改变数据成员的成员函数不能加 const。所以 const 关键字对成员函数的行为作了更明确的限定：有 const 修饰的成员函数（指 const 放在函数参数表的后面，而不是在函数前面或者参数表内），只能读取数据成员，不能改变数据成员；没有 const 修饰的成员函数，对数据成员则是可读可写的。除此之外，在类的成员函数后面加 const 还有什么好处呢？那就是<strong>常量（即 const）对象可以调用 const 成员函数，而不能调用非const修饰的函数</strong>。正如非const类型的数据可以给const类型的变量赋值一样，反之则不成立。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">CStu</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> a<span class="token punctuation">;</span>
    <span class="token function">CStu</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        a <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">void</span> <span class="token function">Show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
    <span class="token punctuation">{</span>
        <span class="token comment">//a = 13; //常函数不能修改数据成员</span>
        cout <span class="token operator">&lt;&lt;</span>a <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;I am show()&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    CStu st<span class="token punctuation">;</span>
    st<span class="token punctuation">.</span><span class="token function">Show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">system</span><span class="token punctuation">(</span><span class="token string">&quot;pause&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-18-说说什么是虚继承-解决什么问题-如何实现" tabindex="-1"><a class="header-anchor" href="#_3-18-说说什么是虚继承-解决什么问题-如何实现" aria-hidden="true">#</a> 3.18 说说什么是虚继承，解决什么问题，如何实现？</h3><p>虚继承是解决C++多重继承问题的一种手段，从不同途径继承来的同一基类，会在子类中存在多份拷贝。这将存在两个问题：其一，浪费存储空间；第二，存在二义性问题，通常可以将派生类对象的地址赋值给基类对象，实现的具体方式是，将基类指针指向继承类（继承类有基类的拷贝）中的基类对象的地址，但是多重继承可能存在一个基类的多份拷贝，这就出现了二义性。虚继承可以解决多种继承前面提到的两个问题（即菱形继承问题）</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> _a<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token operator">:</span><span class="token base-clause"><span class="token keyword">virtual</span> <span class="token keyword">public</span> <span class="token class-name">A</span></span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> _b<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token operator">:</span><span class="token base-clause"><span class="token keyword">virtual</span> <span class="token keyword">public</span> <span class="token class-name">A</span></span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> _c<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">D</span> <span class="token operator">:</span><span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">B</span><span class="token punctuation">,</span> <span class="token keyword">public</span> <span class="token class-name">C</span></span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> _d<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">//菱形继承和菱形虚继承的对象模型</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    D d<span class="token punctuation">;</span>
    d<span class="token punctuation">.</span>B<span class="token double-colon punctuation">::</span>_a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    d<span class="token punctuation">.</span>C<span class="token double-colon punctuation">::</span>_a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    d<span class="token punctuation">.</span>_b <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
    d<span class="token punctuation">.</span>_c <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
    d<span class="token punctuation">.</span>_d <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>D<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>分别从菱形继承和虚继承来分析：</p><blockquote><p>菱形继承中A在B,C,D,中各有一份，虚继承中，A共享。</p><p>上面的虚继承表实际上是一个指针数组。B、C实际上是虚基表指针，指向虚基表。</p><p>虚基表：存放相对偏移量，用来找虚基类</p></blockquote><h3 id="_3-19-简述一下虚函数和纯虚函数-以及实现原理" tabindex="-1"><a class="header-anchor" href="#_3-19-简述一下虚函数和纯虚函数-以及实现原理" aria-hidden="true">#</a> 3.19 简述一下虚函数和纯虚函数，以及实现原理</h3><ol><li>C++中的虚函数的作用主要是实现了多态的机制。关于多态，简而言之就是用父类型的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。这种技术可以让父类的指针有“多种形态”，这是一种泛型技术。<strong>如果调用非虚函数，则无论实际对象是什么类型，都执行基类类型所定义的函数</strong>。非虚函数总是在编译时根据调用该函数的对象，引用或指针的类型而确定。如果调用虚函数，则直到运行时才能确定调用哪个函数，运行的虚函数是引用所绑定或指针所指向的对象所属类型定义的版本。虚函数必须是基类的非静态成员函数。虚函数的作用是实现动态联编，也就是在程序的运行阶段动态地选择合适的成员函数，在定义了虚函数后，可以在基类的派生类中对虚函数重新定义，在派生类中重新定义的函数应与虚函数具有相同的形参个数和形参类型。以实现统一的接口，不同定义过程。如果在派生类中没有对虚函数重新定义，则它继承其基类的虚函数。</li></ol><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">{</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
        <span class="token comment">//虚函数</span>
        <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">GetName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            cout<span class="token operator">&lt;&lt;</span><span class="token string">&quot;PersonName:xiaosi&quot;</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token operator">:</span><span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Person</span></span><span class="token punctuation">{</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
        <span class="token keyword">void</span> <span class="token function">GetName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            cout<span class="token operator">&lt;&lt;</span><span class="token string">&quot;StudentName:xiaosi&quot;</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">//指针</span>
    Person <span class="token operator">*</span>person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//基类调用子类的函数</span>
    person<span class="token operator">-&gt;</span><span class="token function">GetName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//StudentName:xiaosi</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>虚函数（Virtual Function）是通过一张虚函数表（Virtual Table）来实现的。简称为V-Table。在这个表中，主是要一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，保证其真实反应实际的函数。这样，在有虚函数的类的实例中这个表被分配在了这个实例的内存中，所以，当我们用父类的指针来操作一个子类的时候，这张虚函数表就显得尤为重要了，它就像一个地图一样，指明了实际所应该调用的函数。</p><ol start="2"><li>纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加“=0” virtualvoid GetName() =0。在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。为了解决上述问题，将函数定义为纯虚函数，则编译器要求在派生类中必须予以重写以实现多态性。同时含有纯虚拟函数的类称为抽象类，它不能生成对象。这样就很好地解决了上述两个问题。将函数定义为纯虚函数能够说明，该函数为后代类型提供了可以覆盖的接口，但是这个类中的函数绝不会调用。声明了纯虚函数的类是一个抽象类。所以，用户不能创建类的实例，只能创建它的派生类的实例。必须在继承类中重新声明函数（不要后面的＝0）否则该派生类也不能实例化，而且它们在抽象类中往往没有定义。定义纯虚函数的目的在于，使派生类仅仅只是继承函数的接口。纯虚函数的意义，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但类无法为纯虚函数提供一个合理的缺省实现。所以类纯虚函数的声明就是在告诉子类的设计者，“你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它”。</li></ol><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">//抽象类</span>
<span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">{</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
        <span class="token comment">//纯虚函数</span>
        <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">GetName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token operator">:</span><span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Person</span></span><span class="token punctuation">{</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
        <span class="token function">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token keyword">void</span> <span class="token function">GetName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            cout<span class="token operator">&lt;&lt;</span><span class="token string">&quot;StudentName:xiaosi&quot;</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    Student student<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-20-说说纯虚函数能实例化吗-为什么-派生类要实现吗-为什么" tabindex="-1"><a class="header-anchor" href="#_3-20-说说纯虚函数能实例化吗-为什么-派生类要实现吗-为什么" aria-hidden="true">#</a> 3.20 说说纯虚函数能实例化吗，为什么？派生类要实现吗，为什么？</h3><ol><li>纯虚函数不可以实例化，但是可以用其派生类实例化，示例如下：</li></ol><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Base</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code> <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span>

 <span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

 <span class="token keyword">class</span> <span class="token class-name">Base</span>
 <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
     <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>

 <span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span><span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span>
 <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
     <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">override</span>
     <span class="token punctuation">{</span>
         cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;哈哈&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>

 <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     Base <span class="token operator">*</span>b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Derived</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     b<span class="token operator">-&gt;</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

     <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li><p>虚函数的原理采用 vtable。类中含有纯虚函数时，其vtable 不完全，有个空位。 即“纯虚函数在类的vtable表中对应的表项被赋值为0。也就是指向一个不存在的函数。由于编译器绝对不允许有调用一个不存在的函数的可能，所以该类不能生成对象。在它的派生类中，除非重写此函数，否则也不能生成对象。”</p><p>所以纯虚函数不能实例化。</p></li><li><p>纯虚函数是在基类中声明的虚函数，它要求任何派生类都要定义自己的实现方法，以实现多态性。</p></li><li><p>定义纯虚函数是为了实现一个接口，用来规范派生类的行为，也即规范继承这个类的程序员必须实现这个函数。派生类仅仅只是继承函数的接口。纯虚函数的意义在于，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但基类无法为纯虚函数提供一个合理的缺省实现。所以类纯虚函数的声明就是在告诉子类的设计者，“你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它”。</p></li></ol><h3 id="_3-21-说说c-中虚函数与纯虚函数的区别" tabindex="-1"><a class="header-anchor" href="#_3-21-说说c-中虚函数与纯虚函数的区别" aria-hidden="true">#</a> 3.21 说说C++中虚函数与纯虚函数的区别</h3><p>答：</p><ol><li><p>虚函数和纯虚函数可以定义在同一个类中，含有纯虚函数的类被称为抽象类，而只含有虚函数的类不能被称为抽象类。</p></li><li><p>虚函数可以被直接使用，也可以被子类重载以后，以多态的形式调用，而纯虚函数必须在子类中实现该函数才可以使用，因为纯虚函数在基类有声明而没有定义。</p></li><li><p>虚函数和纯虚函数都可以在子类中被重载，以多态的形式被调用。</p></li><li><p>虚函数和纯虚函数通常存在于抽象基类之中，被继承的子类重载，目的是提供一个统一的接口。</p></li><li><p>虚函数的定义形式：<code>virtual{}</code>;纯虚函数的定义形式：<code>virtual {} = 0</code>;在虚函数和纯虚函数的定义中不能有static标识符，原因很简单，被static修饰的函数在编译时要求前期绑定,然而虚函数却是动态绑定，而且被两者修饰的函数生命周期也不一样。</p></li></ol><p>举个虚函数的例子：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        cout<span class="token operator">&lt;&lt;</span><span class="token string">&quot;A::foo() is called&quot;</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">B</span><span class="token operator">:</span><span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">A</span></span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        cout<span class="token operator">&lt;&lt;</span><span class="token string">&quot;B::foo() is called&quot;</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    A <span class="token operator">*</span>a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    a<span class="token operator">-&gt;</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 在这里，a虽然是指向A的指针，但是被调用的函数(foo)却是B的!</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个例子是虚函数的一个典型应用，通过这个例子，也许你就对虚函数有了一些概念。它虚就虚在所谓“推迟联编”或者“动态联编”上，一个类函数的调用并不是在编译时刻被确定的，而是在运行时刻被确定的。由于编写代码的时候并不能确定被调用的是基类的函数还是哪个派生类的函数，所以被成为“虚”函数。</p><p>虚函数只能借助于指针或者引用来达到多态的效果。</p><ol start="2"><li>纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加“=0” 。形如<code>virtual void funtion1()=0</code></li></ol><p>为了方便使用多态特性，我们常常需要在基类中定义虚拟函数。</p><p>在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。</p><p>为了解决上述问题，引入了纯虚函数的概念，将函数定义为纯虚函数（方法：virtual ReturnType Function()= 0;），则编译器要求在派生类中必须予以重写以实现多态性。同时含有纯虚拟函数的类称为抽象类，它不能生成对象。这样就很好地解决了上述两个问题。 声明了纯虚函数的类是一个抽象类。所以，用户不能创建类的实例，只能创建它的派生类的实例。</p><p>纯虚函数最显著的特征是：它们必须在继承类中重新声明函数（不要后面的＝0，否则该派生类也不能实例化），而且它们在抽象类中往往没有定义。</p><p>定义纯虚函数的目的在于，使派生类仅仅只是继承函数的接口。</p><p>纯虚函数的意义，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但类无法为纯虚函数提供一个合理的缺省实现。所以类纯虚函数的声明就是在告诉子类的设计者，“你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它”。</p><h3 id="_3-22-说说-c-中什么是菱形继承问题-如何解决" tabindex="-1"><a class="header-anchor" href="#_3-22-说说-c-中什么是菱形继承问题-如何解决" aria-hidden="true">#</a> 3.22 说说 C++ 中什么是菱形继承问题，如何解决</h3><p>使用虚继承来解决该问题</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Tiger</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">virtual</span> <span class="token keyword">public</span> <span class="token class-name">Animal</span></span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Lion</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">virtual</span> <span class="token keyword">public</span> <span class="token class-name">Animal</span></span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-23-请问构造函数中的能不能调用虚方法" tabindex="-1"><a class="header-anchor" href="#_3-23-请问构造函数中的能不能调用虚方法" aria-hidden="true">#</a> 3.23 请问构造函数中的能不能调用虚方法</h3><p>不要在构造函数中调用虚方法，从语法上讲，调用完全没有问题，但是从效果上看，往往不能达到需要的目的。</p><p>派生类对象构造期间进入基类的构造函数时，对象类型变成了基类类型，而不是派生类类型。</p><p>同样，进入基类析构函数时，对象也是基类类型。</p><p>所以，虚函数始终仅仅调用基类的虚函数（如果是基类调用虚函数），不能达到多态的效果，所以放在构造函数中是没有意义的，而且往往不能达到本来想要的效果。</p><h3 id="_3-24-请问拷贝构造函数的参数是什么传递方式-为什么" tabindex="-1"><a class="header-anchor" href="#_3-24-请问拷贝构造函数的参数是什么传递方式-为什么" aria-hidden="true">#</a> 3.24 请问拷贝构造函数的参数是什么传递方式，为什么</h3><ol><li><p>拷贝构造函数的参数必须使用引用传递</p></li><li><p>如果拷贝构造函数中的参数不是一个引用，即形如CClass(const CClass c_class)，那么就相当于采用了传值的方式(pass-by-value)，而传值的方式会调用该类的拷贝构造函数，从而造成无穷递归地调用拷贝构造函数。因此拷贝构造函数的参数必须是一个引用。</p></li></ol><p>需要澄清的是，传指针其实也是传值，如果上面的拷贝构造函数写成CClass(const CClass* c_class)，也是不行的。事实上，只有传引用不是传值外，其他所有的传递方式都是传值。</p><h3 id="_3-25-如何理解抽象类" tabindex="-1"><a class="header-anchor" href="#_3-25-如何理解抽象类" aria-hidden="true">#</a> 3.25 如何理解抽象类？</h3><ol><li>抽象类的定义如下：</li></ol><p>纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加“=0”，有虚函数的类就叫做抽象类。</p><ol start="2"><li>抽象类有如下几个特点：</li></ol><p>1）抽象类只能用作其他类的基类，不能建立抽象类对象。</p><p>2）抽象类不能用作参数类型、函数返回类型或显式转换的类型。</p><p>3）可以定义指向抽象类的指针和引用，此指针可以指向它的派生类，进而实现多态性。</p><h3 id="_3-26-什么是多态-除了虚函数-还有什么方式能实现多态" tabindex="-1"><a class="header-anchor" href="#_3-26-什么是多态-除了虚函数-还有什么方式能实现多态" aria-hidden="true">#</a> 3.26 什么是多态？除了虚函数，还有什么方式能实现多态？</h3><ol><li><p>多态是面向对象的重要特性之一，它是一种行为的封装，就是不同对象对同一行为会有不同的状态。(举例 : 学生和成人都去买票时,学生会打折,成人不会)</p></li><li><p>多态是以封装和继承为基础的。在C++中多态分为静态多态（早绑定）和动态多态（晚绑定）两种，其中动态多态是通过虚函数实现，静态多态通过函数重载实现，代码如下：</p></li></ol><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>    
    <span class="token keyword">void</span> <span class="token keyword">do</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>    
    <span class="token keyword">void</span> <span class="token keyword">do</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-27-简述一下虚析构函数-什么作用" tabindex="-1"><a class="header-anchor" href="#_3-27-简述一下虚析构函数-什么作用" aria-hidden="true">#</a> 3.27 简述一下虚析构函数，什么作用</h3><ol><li>虚析构函数，是将基类的析构函数声明为virtual，举例如下：</li></ol><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">TimeKeeper</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>    
    <span class="token function">TimeKeeper</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        
    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">TimeKeeper</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>虚析构函数的主要作用是防止内存泄露。</li></ol><p>定义一个基类的指针p，在delete p时，如果基类的析构函数是虚函数，这时只会看p所赋值的对象，如果p赋值的对象是派生类的对象，就会调用派生类的析构函数（毫无疑问，在这之前也会先调用基类的构造函数，在调用派生类的构造函数，然后调用派生类的析构函数，基类的析构函数，所谓先构造的后释放）；如果p赋值的对象是基类的对象，就会调用基类的析构函数，这样就不会造成内存泄露。</p><p>如果基类的析构函数不是虚函数，在delete p时，调用析构函数时，只会看指针的数据类型，而不会去看赋值的对象，这样就会造成内存泄露。</p><p>说明： 我们创建一个TimeKeeper基类和一些及其它的派生类作为不同的计时方法：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">TimeKeeper</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">TimeKeeper</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token operator">~</span><span class="token function">TimeKeeper</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token comment">//非virtual的</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">//都继承与TimeKeeper</span>
<span class="token keyword">class</span> <span class="token class-name">AtomicClock</span> <span class="token operator">:</span><span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">TimeKeeper</span></span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">WaterClock</span> <span class="token operator">:</span><span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">TimeKeeper</span></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">WristWatch</span> <span class="token operator">:</span><span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">TimeKeeper</span></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果客户想要在程序中使用时间，不想操作时间如何计算等细节，这时候我们可以设计factory（工厂）函数，让函数返回指针指向一个计时对象。该函数返回一个基类指针，这个基类指针是指向于派生类对象的</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>TimeKeeper<span class="token operator">*</span> <span class="token function">getTimeKeeper</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">//返回一个指针，指向一个TimeKeeper派生类的动态分配对象</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因为函数返回的对象存在于堆中，因此为了在不使用时我们需要使用释放该对象（delete）</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>TimeKeeper<span class="token operator">*</span> ptk <span class="token operator">=</span> <span class="token function">getTimeKeeper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">delete</span> ptk<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>此处基类的析构函数是非virtual的，因此通过一个基类指针删除派生类对象是错误的</strong></p><!---->： 将基类的析构函数改为virtual就正确了<div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">TimeKeeper</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">TimeKeeper</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">TimeKeeper</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>声明为virtual之后，通过基类指针删除派生类对象就会释放整个对象（基类+派生类）</p><h3 id="_3-28-说说什么是虚基类-可否被实例化" tabindex="-1"><a class="header-anchor" href="#_3-28-说说什么是虚基类-可否被实例化" aria-hidden="true">#</a> 3.28 说说什么是虚基类，可否被实例化？</h3><ol><li>在被继承的类前面加上virtual关键字，这时被继承的类称为虚基类，代码如下：</li></ol><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token keyword">class</span> <span class="token class-name">B1</span><span class="token operator">:</span><span class="token base-clause"><span class="token keyword">public</span> <span class="token keyword">virtual</span> <span class="token class-name">A</span></span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">B2</span><span class="token operator">:</span><span class="token base-clause"><span class="token keyword">public</span> <span class="token keyword">virtual</span> <span class="token class-name">A</span></span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">D</span><span class="token operator">:</span><span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">B1</span><span class="token punctuation">,</span><span class="token keyword">public</span> <span class="token class-name">B2</span></span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>虚继承的类可以被实例化，举例如下：</li></ol><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span><span class="token comment">/* ... */</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Tiger</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">virtual</span> <span class="token keyword">public</span> <span class="token class-name">Animal</span></span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Lion</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">virtual</span> <span class="token keyword">public</span> <span class="token class-name">Animal</span></span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span> <span class="token punctuation">)</span>
<span class="token punctuation">{</span>
Liger lg <span class="token punctuation">;</span>
<span class="token comment">/*既然我们已经在Tiger和Lion类的定义中声明了&quot;virtual&quot;关键字，于是下面的代码编译OK */</span>
<span class="token keyword">int</span> weight <span class="token operator">=</span> lg<span class="token punctuation">.</span><span class="token function">getWeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-29-简述一下拷贝赋值和移动赋值" tabindex="-1"><a class="header-anchor" href="#_3-29-简述一下拷贝赋值和移动赋值" aria-hidden="true">#</a> 3.29 简述一下拷贝赋值和移动赋值？</h3><ol><li><p>拷贝赋值是通过拷贝构造函数来赋值，在创建对象时，使用同一类中之前创建的对象来初始化新创建的对象。</p></li><li><p>移动赋值是通过移动构造函数来赋值，二者的主要区别在于</p></li></ol><p>1）拷贝构造函数的形参是一个左值引用，而移动构造函数的形参是一个右值引用；</p><p>2）拷贝构造函数完成的是整个对象或变量的拷贝，而移动构造函数是生成一个指针指向源对象或变量的地址，接管源对象的内存，相对于大量数据的拷贝<strong>节省时间和内存空间</strong>。</p><h3 id="_3-30-仿函数了解吗-有什么作用" tabindex="-1"><a class="header-anchor" href="#_3-30-仿函数了解吗-有什么作用" aria-hidden="true">#</a> 3.30 仿函数了解吗？有什么作用</h3><ol><li>仿函数（functor）又称为函数对象（function object）<strong>是一个能行使函数功能的类</strong>。仿函数的语法几乎和我们普通的函数调用一样，不过作为仿函数的类，都<!---->，举个例子：</li></ol><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Func</span><span class="token punctuation">{</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
        <span class="token keyword">void</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> str<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>
            cout<span class="token operator">&lt;&lt;</span>str<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
Func myFunc<span class="token punctuation">;</span>
<span class="token function">myFunc</span><span class="token punctuation">(</span><span class="token string">&quot;helloworld!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//输出：</span>
helloworld<span class="token operator">!</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>仿函数既能想普通函数一样传入给定数量的参数，还能存储或者处理更多我们需要的有用信息。我们可以举个例子：</li></ol><p>假设有一个<code>vector&lt;string&gt;</code>，你的任务是统计长度小于5的string的个数，如果使用count_if函数的话，你的代码可能长成这样：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>  <span class="token keyword">bool</span> <span class="token function">LengthIsLessThanFive</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> str<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">return</span> str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token number">5</span><span class="token punctuation">;</span>   
  <span class="token punctuation">}</span>
<span class="token keyword">int</span> res<span class="token operator">=</span><span class="token function">count_if</span><span class="token punctuation">(</span>vec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> LengthIsLessThanFive<span class="token punctuation">)</span><span class="token punctuation">;</span>
其中count_if函数的第三个参数是一个函数指针，返回一个<span class="token keyword">bool</span>类型的值。一般的，如果需要将特定的阈值长度也传入的话，我们可能将函数写成这样：
```cpp
 <span class="token keyword">bool</span> <span class="token function">LenthIsLessThan</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> str<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;</span>len<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个函数看起来比前面一个版本更具有一般性，但是他不能满足count_if函数的参数要求：count_if要求的是unary function（仅带有一个参数）作为它的最后一个参数。如果我们使用仿函数，是不是就豁然开朗了呢：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>  <span class="token keyword">class</span> <span class="token class-name">ShorterThan</span> <span class="token punctuation">{</span>
      <span class="token keyword">public</span><span class="token operator">:</span>
          <span class="token keyword">explicit</span> <span class="token function">ShorterThan</span><span class="token punctuation">(</span><span class="token keyword">int</span> maxLength<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">length</span><span class="token punctuation">(</span>maxLength<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
          <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> str<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>
              <span class="token keyword">return</span> str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> length<span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
      <span class="token keyword">private</span><span class="token operator">:</span>
          <span class="token keyword">const</span> <span class="token keyword">int</span> length<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-31-c-中哪些函数不能被声明为虚函数" tabindex="-1"><a class="header-anchor" href="#_3-31-c-中哪些函数不能被声明为虚函数" aria-hidden="true">#</a> 3.31 C++ 中哪些函数不能被声明为虚函数？</h3><p>常见的不不能声明为虚函数的有：<strong>普通函数（非成员函数），静态成员函数，内联成员函数，构造函数，友元函数</strong>。</p><ol><li>为什么C++不支持普通函数为虚函数？</li></ol><p>普通函数（非成员函数）只能被overload(重载)，不能被override(重写)，声明为虚函数也没有什么意思，因此编译器会在编译时绑定函数。</p><ol start="2"><li>为什么C++不支持构造函数为虚函数？</li></ol><p>这个原因很简单，主要是从语义上考虑，所以不支持。因为构造函数本来就是为了明确初始化对象成员才产生的，然而virtual function主要是为了再不完全了解细节的情况下也能正确处理对象。另外，virtual函数是在不同类型的对象产生不同的动作，现在对象还没有产生，如何使用virtual函数来完成你想完成的动作。（这不就是典型的悖论）</p><p>构造函数用来创建一个新的对象,而虚函数的运行是建立在对象的基础上,在构造函数执行时,对象尚未形成,所以不能将构造函数定义为虚函数</p><ol start="3"><li>为什么C++不支持内联成员函数为虚函数？</li></ol><p>内联函数就是为了在代码中直接展开，减少函数调用花费的代价，而虚函数是为了在继承后对象能够准确的执行自己的动作，这是不可能统一的。（再说了，inline函数在编译时被展开，虚函数在运行时才能动态的绑定函数）</p><p>内联函数是在编译时期展开,而虚函数的特性是运行时才动态联编,所以两者矛盾,不能定义内联函数为虚函数</p><ol start="4"><li>为什么C++不支持静态成员函数为虚函数？</li></ol><p>这也很简单，静态成员函数对于每个类来说只有一份代码，所有的对象都共享这一份代码，他也没有要动态绑定的必要性。</p><p>静态成员函数属于一个类而非某一对象,没有this指针,它无法进行对象的判别</p><ol start="5"><li>为什么C++不支持友元函数为虚函数？</li></ol><p>因为C++不支持友元函数的继承，对于没有继承特性的函数没有虚函数的说法。</p><h3 id="_3-32-解释下-c-中类模板和模板类的区别" tabindex="-1"><a class="header-anchor" href="#_3-32-解释下-c-中类模板和模板类的区别" aria-hidden="true">#</a> 3.32 解释下 C++ 中类模板和模板类的区别</h3><ol><li><p>类模板是模板的定义，不是一个实实在在的类，定义中用到通用类型参数</p></li><li><p>模板类是实实在在的类定义，是类模板的实例化。类定义中参数被实际类型所代替。</p></li></ol><p>答案解析</p><ol><li><p>类模板的类型参数可以有一个或多个，每个类型前面都必须加class或typename，如template &lt;class T1,class T2&gt;class someclass{…};在定义对象时分别代入实际的类型名，如 someclass&lt;int,double&gt; obj;</p></li><li><p>和使用类一样，使用类模板时要注意其作用域，只能在其有效作用域内用它定义对象。</p></li><li><p>模板可以有层次，一个类模板可以作为基类，派生出派生模板类。</p></li></ol><h3 id="_3-33-虚函数表里存放的内容是什么时候写进去的" tabindex="-1"><a class="header-anchor" href="#_3-33-虚函数表里存放的内容是什么时候写进去的" aria-hidden="true">#</a> 3.33 虚函数表里存放的内容是什么时候写进去的？</h3><ol><li><p>虚函数表是一个存储虚函数地址的数组,以NULL结尾。虚表（vtable）在<strong>编译阶段生成</strong>，对象内存空间开辟以后，写入对象中的 v_ptr，然后调用构造函数。即：虚表在构造函数之前写入。</p></li><li><p>除了在构造函数之前写入之外，我们还需要考虑到虚表的二次写入机制，通过此机制让每个对象的虚表指针都能准确的指向到自己类的虚表，为实现动多态提供支持。</p></li></ol><h2 id="_4、标准模板库stl" tabindex="-1"><a class="header-anchor" href="#_4、标准模板库stl" aria-hidden="true">#</a> 4、标准模板库STL</h2><h2 id="_5、c-新特性" tabindex="-1"><a class="header-anchor" href="#_5、c-新特性" aria-hidden="true">#</a> 5、C++新特性</h2><h3 id="_5-1-c-新特性" tabindex="-1"><a class="header-anchor" href="#_5-1-c-新特性" aria-hidden="true">#</a> 5.1 C++新特性</h3><p>内容参考于<a href="https://blog.csdn.net/dnty00/article/details/126171485" target="_blank" rel="noopener noreferrer">csdn<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> 一、C++新特性 C++新特性主要包括包含语法改进和标准库扩充两个方面，主要包括以下11点 1、语法的改进 1）统一的初始化方法 在 C++11 中，可以直接在变量名后面跟上初始化列表，来进行对象的初始化 2）成员变量默认初始化 3）auto关键字用于定义变量，编译器可以自动判断的类型（前提：定义一个变量时对其进行初始化） 4）decltype 求表达式的类型 5）智能指针 shared_ptr</p><p>和 unique_ptr、weak_ptr 不同之处在于，多个 shared_ptr 智能指针可以共同使用同一块堆内存。并且，由于该类型智能指针在实现上采用的是引用计数机制，即便有一个 shared_ptr 指针放弃了堆内存的“使用权”（引用计数减 1），也不会影响其他指向同一堆内存的 shared_ptr 指针（只有引用计数为 0 时，堆内存才会被自动释放） 6）空指针 nullptr（原来NULL） 7）基于范围的for循环 8）右值引用和move语义</p><ul><li>右值引用</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">//左值引用</span>
<span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">&amp;</span>b <span class="token operator">=</span> num<span class="token punctuation">;</span>  <span class="token comment">//正确</span>
<span class="token keyword">int</span> <span class="token operator">&amp;</span>c <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>   <span class="token comment">//错误，在C++98/03标准中，无法为右值添加引用</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实际开发中可能需要对右值进行修改（实现移动语义时就需要），显然左值引用的方式是行不通的。为此，C++11 标准新引入了另一种引用方式，称为右值引用，用 “&amp;&amp;” 表示。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token comment">//int &amp;&amp; a = num;  //右值引用不能初始化为左值</span>
<span class="token keyword">int</span> <span class="token operator">&amp;&amp;</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>move语义</li></ul><p>在C++11中，标准库在中提供了一个有用的函数std::move，std::move()函数并不能移动任何东西，它唯一的功能是将一个左值引用强制转化为右值引用，继而可以通过右值引用使用该值，以用于移动语义。从实现上讲，std::move基本等同于一个类型转换：static_cast&lt;T&amp;&amp;&gt;(lvalue);</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token function">move</span><span class="token punctuation">(</span> arg <span class="token punctuation">)</span> <span class="token comment">//其中，arg 表示指定的左值对象。该函数会返回 arg 对象的右值形式。</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>2、标准模板库的扩充（往STL里面添加了一些模板类，比较好用） 9）无序容器（哈希表） 用法和功能同map一模一样，区别在于哈希表的效率更高 10）正则表达式 可以认为正则表达式实质上是一个字符串，该字符串描述了一种特定模式的字符串 11）Lambda表达式（匿名函数） lambda表达式是一个匿名函数，用于定义并创建匿名的函数对象，以简化编程工作。举个例子：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> vec<span class="token punctuation">;</span>
 <span class="token function">sort</span><span class="token punctuation">(</span>vec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cmp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 旧式</span>
 <span class="token function">sort</span><span class="token punctuation">(</span>vec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">bool</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> a <span class="token operator">&lt;</span> b<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// Lambda表达式</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>声明lambda表达式：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token punctuation">[</span>capture list<span class="token punctuation">]</span> <span class="token punctuation">(</span>params list<span class="token punctuation">)</span> <span class="token keyword">mutable</span> exception<span class="token operator">-&gt;</span> <span class="token keyword">return</span> type <span class="token punctuation">{</span> function body <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>capture list：捕获外部变量列表</li><li>params list：形参列表</li><li>mutable指示符：用来说用是否可以修改捕获的变量</li><li>exception：异常设定</li><li>return type：返回类型</li><li>function body：函数体</li></ul><p>详细说明：</p><ol><li>统一的初始化方法 C++98/03 可以使用初始化列表（initializer list）进行初始化：</li></ol><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> i_arr<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">long</span> l_arr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">A</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> x<span class="token punctuation">;</span>
    <span class="token keyword">int</span> y<span class="token punctuation">;</span>
<span class="token punctuation">}</span> a <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是这种初始化方式的适用性非常狭窄，只有上面提到的这两种数据类型可以使用初始化列表。在 C++11 中，初始化列表的适用性被大大增加了。它现在可以用于任何类型对象的初始化，实例如下：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Foo</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token keyword">const</span> Foo <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    Foo <span class="token function">a1</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Foo a2 <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>  <span class="token comment">//error: &#39;Foo::Foo(const Foo &amp;)&#39; is private</span>
    Foo a3 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">123</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    Foo a4 <span class="token punctuation">{</span> <span class="token number">123</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> a5 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> a6 <span class="token punctuation">{</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上例中，a3、a4 使用了新的初始化方式来初始化对象，效果如同 a1 的直接初始化。a5、a6 则是基本数据类型的列表初始化方式。可以看到，它们的形式都是统一的。这里需要注意的是，a3 虽然使用了等于号，但它仍然是列表初始化，因此，私有的拷贝构造并不会影响到它。a4 和 a6 的写法，是 C++98/03 所不具备的。在 C++11 中，可以直接在变量名后面跟上初始化列表，来进行对象的初始化。</p><ol start="2"><li>成员变量默认初始化 好处：构建一个类的对象不需要用构造函数初始化成员变量。</li></ol><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">//程序实例</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">B</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token number">1234</span><span class="token punctuation">;</span> <span class="token comment">//成员变量有一个初始值</span>
    <span class="token keyword">int</span> n<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    B b<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> b<span class="token punctuation">.</span>m <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li>auto关键字 用于定义变量，编译器可以自动判断的类型（前提：定义一个变量时对其进行初始化）。</li></ol><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">//程序实例</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    vector<span class="token operator">&lt;</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token operator">&gt;</span> v<span class="token punctuation">;</span>
    vector<span class="token operator">&lt;</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>iterator i <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看出来，定义迭代器 i 的时候，类型书写比较冗长，容易出错。然而有了 auto 类型推导，我们大可不必这样，只写一个 auto 即可。</p><ol start="4"><li>decltype 求表达式的类型</li></ol><p>decltype 是 C++11 新增的一个关键字，它和 auto 的功能一样，都用来在编译时期进行自动类型推导。</p><p>(1)为什么要有decltype</p><p>因为 auto 并不适用于所有的自动类型推导场景，在某些特殊情况下 auto 用起来非常不方便，甚至压根无法使用，所以 decltype 关键字也被引入到 C++11 中。</p><p>auto 和 decltype 关键字都可以自动推导出变量的类型，但它们的用法是有区别的：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">auto</span> varname <span class="token operator">=</span> value<span class="token punctuation">;</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span>exp<span class="token punctuation">)</span> varname <span class="token operator">=</span> value<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>其中，varname 表示变量名，value 表示赋给变量的值，exp 表示一个表达式。</p><p>auto 根据&quot;=&quot;右边的初始值 value 推导出变量的类型，而 decltype 根据 exp 表达式推导出变量的类型，跟&quot;=&quot;右边的 value 没有关系。</p><p>另外，auto 要求变量必须初始化，而 decltype 不要求。这很容易理解，auto 是根据变量的初始值来推导出变量类型的，如果不初始化，变量的类型也就无法推导了。decltype 可以写成下面的形式：</p><blockquote><p>decltype(exp) varname;</p></blockquote><p>(2)代码示例</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// decltype 用法举例</span>
nt a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">//b 被推导成了 int</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token number">10.8</span><span class="token punctuation">)</span> x <span class="token operator">=</span> <span class="token number">5.5</span><span class="token punctuation">;</span>  <span class="token comment">//x 被推导成了 double</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span>x <span class="token operator">+</span> <span class="token number">100</span><span class="token punctuation">)</span> y<span class="token punctuation">;</span>  <span class="token comment">//y 被推导成了 double</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="5"><li>智能指针 shared_ptr</li></ol><p>和 unique_ptr、weak_ptr 不同之处在于，多个 shared_ptr 智能指针可以共同使用同一块堆内存。并且，由于该类型智能指针在实现上采用的是引用计数机制，即便有一个 shared_ptr 指针放弃了堆内存的“使用权”（引用计数减 1），也不会影响其他指向同一堆内存的 shared_ptr 指针（只有引用计数为 0 时，堆内存才会被自动释放）。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">//构建 2 个智能指针</span>
    std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">p1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">p2</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//输出 p2 指向的数据</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p2 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    p1<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//引用计数减 1,p1为空指针</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>p1<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;p1 不为空&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;p1 为空&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//以上操作，并不会影响 p2</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p2 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token comment">//判断当前和 p2 同指向的智能指针有多少个</span>
    cout <span class="token operator">&lt;&lt;</span> p2<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/*    程序运行结果：        
            10
            p1 为空
            10
            1    
*/</span>   
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="6"><li>空指针 nullptr（原来NULL）</li></ol><p>nullptr 是 nullptr_t 类型的右值常量，专用于初始化空类型指针。nullptr_t 是 C++11 新增加的数据类型，可称为“指针空值类型”。也就是说，nullpter 仅是该类型的一个实例对象（已经定义好，可以直接使用），如果需要我们完全定义出多个同 nullptr 完全一样的实例对象。值得一提的是，nullptr 可以被隐式转换成任意的指针类型。例如：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token operator">*</span> a1 <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> <span class="token operator">*</span> a2 <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
<span class="token keyword">double</span> <span class="token operator">*</span> a3 <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>显然，不同类型的指针变量都可以使用 nullptr 来初始化，编译器分别将 nullptr 隐式转换成 int、char 以及 double* 指针类型。另外，通过将指针初始化为 nullptr，可以很好地解决 NULL 遗留的问题，比如：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">isnull</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>c<span class="token punctuation">)</span><span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;void*c&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">isnull</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;int n&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">isnull</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">isnull</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/*    程序运行结果：        
        int n
        void*c
*/</span>         
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="7"><li>基于范围的for循环 如果要用 for 循环语句遍历一个数组或者容器，只能套用如下结构：</li></ol><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">for</span><span class="token punctuation">(</span>表达式 <span class="token number">1</span><span class="token punctuation">;</span> 表达式 <span class="token number">2</span><span class="token punctuation">;</span> 表达式 <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">//循环体</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">//程序实例</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">char</span> arc<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&quot;www.123.com&quot;</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
    <span class="token comment">//for循环遍历普通数组</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">strlen</span><span class="token punctuation">(</span>arc<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> arc<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">&gt;</span><span class="token function">myvector</span><span class="token punctuation">(</span>arc<span class="token punctuation">,</span>arc<span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>iterator iter<span class="token punctuation">;</span>
    <span class="token comment">//for循环遍历 vector 容器</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>iter <span class="token operator">=</span> myvector<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> iter <span class="token operator">!=</span> myvector<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>iter<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>iter<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">/*    程序运行结果：        
        www.123.com
        www
*/</span>      
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="8"><li>右值引用和move语义 i. 右值引用</li></ol><p>C++98/03 标准中就有引用，使用 &quot;&amp;&quot; 表示。但此种引用方式有一个缺陷，即正常情况下只能操作 C++ 中的左值，无法对右值添加引用。举个例子：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">&amp;</span>b <span class="token operator">=</span> num<span class="token punctuation">;</span> <span class="token comment">//正确</span>
<span class="token keyword">int</span> <span class="token operator">&amp;</span>c <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">//错误</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如上所示，编译器允许我们为 num 左值建立一个引用，但不可以为 10 这个右值建立引用。因此，C++98/03 标准中的引用又称为左值引用。</p><p>注意，虽然 C++98/03 标准不支持为右值建立非常量左值引用，但允许使用常量左值引用操作右值。也就是说，常量左值引用既可以操作左值，也可以操作右值，例如：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>b <span class="token operator">=</span> num<span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>c <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们知道，右值往往是没有名称的，因此要使用它只能借助引用的方式。这就产生一个问题，实际开发中我们可能需要对右值进行修改（实现移动语义时就需要），显然左值引用的方式是行不通的。</p><p>为此，C++11 标准新引入了另一种引用方式，称为右值引用，用 &quot;&amp;&amp;&quot; 表示。</p><p>需要注意的，和声明左值引用一样，右值引用也必须立即进行初始化操作，且只能使用右值进行初始化，比如：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token comment">//int &amp;&amp; a = num;  //右值引用不能初始化为左值</span>
<span class="token keyword">int</span> <span class="token operator">&amp;&amp;</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
​ 和常量左值引用不同的是，右值引用还可以对右值进行修改。例如：

<span class="token keyword">int</span> <span class="token operator">&amp;&amp;</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token comment">/*    程序运行结果：        
        100    
*/</span>          
​ 另外值得一提的是，C<span class="token operator">++</span> 语法上是支持定义常量右值引用的，例如<span class="token operator">:</span>
<span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token comment">//编译器不会报错</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但这种定义出来的右值引用并无实际用处。一方面，右值引用主要用于移动语义和完美转发，其中前者需要有修改右值的权限；其次，常量右值引用的作用就是引用一个不可修改的右值，这项工作完全可以交给常量左值引用完成。</p><p>ii. move语义</p><p>move 本意为 &quot;移动&quot;，但该函数并不能移动任何数据，它的功能很简单，就是将某个左值强制转化为右值。基于 move() 函数特殊的功能，其常用于实现移动语义。move() 函数的用法也很简单，其语法格式如下：</p><blockquote><p>move( arg ) //其中，arg 表示指定的左值对象。该函数会返回 arg 对象的右值形式。</p></blockquote><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">//程序实例</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">first</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">first</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">num</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;construct!&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//移动构造函数</span>
    <span class="token function">first</span><span class="token punctuation">(</span>first <span class="token operator">&amp;&amp;</span>d<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">num</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span>num<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        d<span class="token punctuation">.</span>num <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;first move construct!&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment">//这里应该是 private，使用 public 是为了更方便说明问题</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>num<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">second</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">second</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">fir</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token comment">//用 first 类的移动构造函数初始化 fir</span>
    <span class="token function">second</span><span class="token punctuation">(</span>second <span class="token operator">&amp;&amp;</span> sec<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">fir</span><span class="token punctuation">(</span><span class="token function">move</span><span class="token punctuation">(</span>sec<span class="token punctuation">.</span>fir<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;second move construct&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment">//这里也应该是 private，使用 public 是为了更方便说明问题</span>
    first fir<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    second oth<span class="token punctuation">;</span>
    second oth2 <span class="token operator">=</span> <span class="token function">move</span><span class="token punctuation">(</span>oth<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//cout &lt;&lt; *oth.fir.num &lt;&lt; endl;   //程序报运行时错误</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/*    程序运行结果：
          construct!
        first move construct!
        second move construct
*/</span>            
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="9"><li>无序容器（哈希表）</li></ol><p>用法和功能同map一模一样，区别在于哈希表的效率更高。</p><p>(1) 无序容器具有以下 2 个特点：</p><p>a. 无序容器内部存储的键值对是无序的，各键值对的存储位置取决于该键值对中的键，</p><p>b. 和关联式容器相比，无序容器擅长通过指定键查找对应的值（平均时间复杂度为 O(1)）；但对于使用迭代器遍历容器中存储的元素，无序容器的执行效率则不如关联式容器。</p><p>(2) 和关联式容器一样，无序容器只是一类容器的统称，其包含有 4 个具体容器，分别为 unordered_map、unordered_multimap、unordered_set 以及 unordered_multiset。功能如下表：</p><table><thead><tr><th>无序容器</th><th>功能</th></tr></thead><tbody><tr><td>unordered_map</td><td>存储键值对 &lt;key, value&gt; 类型的元素，其中各个键值对键的值不允许重复，且该容器中存储的键值对是无序的。</td></tr><tr><td>unordered_multimap</td><td>和 unordered_map 唯一的区别在于，该容器允许存储多个键相同的键值对。</td></tr><tr><td>unordered_set</td><td>不再以键值对的形式存储数据，而是直接存储数据元素本身（当然也可以理解为，该容器存储的全部都是键 key 和值 value 相等的键值对，正因为它们相等，因此只存储 value 即可）。另外，该容器存储的元素不能重复，且容器内部存储的元素也是无序的。</td></tr><tr><td>unordered_multiset</td><td>和 unordered_set 唯一的区别在于，该容器允许存储值相同的元素。</td></tr></tbody></table><p>程序实例（以 unordered_map 容器为例）</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unordered_map&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">//创建并初始化一个 unordered_map 容器，其存储的 &lt;string,string&gt; 类型的键值对</span>
    std<span class="token double-colon punctuation">::</span>unordered_map<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&gt;</span> my_uMap<span class="token punctuation">{</span>
        <span class="token punctuation">{</span><span class="token string">&quot;教程1&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;www.123.com&quot;</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">{</span><span class="token string">&quot;教程2&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;www.234.com&quot;</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">{</span><span class="token string">&quot;教程3&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;www.345.com&quot;</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token comment">//查找指定键对应的值，效率比关联式容器高</span>
    string str <span class="token operator">=</span> my_uMap<span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span><span class="token string">&quot;C语言教程&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;str = &quot;</span> <span class="token operator">&lt;&lt;</span> str <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token comment">//使用迭代器遍历哈希容器，效率不如关联式容器</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> iter <span class="token operator">=</span> my_uMap<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> iter <span class="token operator">!=</span> my_uMap<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>iter<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment">//pair 类型键值对分为 2 部分</span>
        cout <span class="token operator">&lt;&lt;</span> iter<span class="token operator">-&gt;</span>first <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span> <span class="token operator">&lt;&lt;</span> iter<span class="token operator">-&gt;</span>second <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/*    程序运行结果：
          教程1 www.123.com
          教程2 www.234.com
          教程3 www.345.com
*/</span>  
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="10"><li>正则表达式</li></ol><p>可以认为正则表达式实质上是一个字符串，该字符串描述了一种特定模式的字符串。常用符号的意义如下：</p><ol start="11"><li>Lambda匿名函数 所谓匿名函数，简单地理解就是没有名称的函数，又常被称为 lambda 函数或者 lambda 表达式。</li></ol><p>（1）定义</p><p>lambda 匿名函数很简单，可以套用如下的语法格式：</p><p>[外部变量访问方式说明符] (参数) mutable noexcept/throw() -&gt; 返回值类型 ​ { ​ 函数体; ​ };</p><p>其中各部分的含义分别为：</p><p>a. [外部变量方位方式说明符]</p><blockquote><p>[ ] 方括号用于向编译器表明当前是一个 lambda 表达式，其不能被省略。在方括号内部，可以注明当前 lambda 函数的函数体中可以使用哪些“外部变量”。</p></blockquote><p>所谓外部变量，指的是和当前 lambda 表达式位于同一作用域内的所有局部变量。 b. (参数)</p><blockquote><p>和普通函数的定义一样，lambda 匿名函数也可以接收外部传递的多个参数。和普通函数不同的是，如果不需要传递参数，可以连同 () 小括号一起省略；</p></blockquote><p>c. mutable</p><blockquote><p>此关键字可以省略，如果使用则之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，对于以值传递方式引入的外部变量，不允许在 lambda 表达式内部修改它们的值（可以理解为这部分变量都是 const 常量）。而如果想修改它们，就必须使用 mutable 关键字。</p></blockquote><p>注意:对于以值传递方式引入的外部变量，lambda 表达式修改的是拷贝的那一份，并不会修改真正的外部变量；</p><p>d. noexcept/throw()</p><blockquote><p>可以省略，如果使用，在之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，lambda 函数的函数体中可以抛出任何类型的异常。而标注 noexcept 关键字，则表示函数体内不会抛出任何异常；使用 throw() 可以指定 lambda 函数内部可以抛出的异常类型。</p></blockquote><p>e. -&gt; 返回值类型</p><blockquote><p>指明 lambda 匿名函数的返回值类型。值得一提的是，如果 lambda 函数体内只有一个 return 语句，或者该函数返回 void，则编译器可以自行推断出返回值类型，此情况下可以直接省略&quot;-&gt; 返回值类型&quot;。</p></blockquote><p>f. 函数体</p><blockquote><p>和普通函数一样，lambda 匿名函数包含的内部代码都放置在函数体中。该函数体内除了可以使用指定传递进来的参数之外，还可以使用指定的外部变量以及全局范围内的所有全局变量。</p></blockquote><p>（2）程序实例</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> num<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token comment">//对 a 数组中的元素进行排序</span>
    <span class="token function">sort</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> num<span class="token operator">+</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">bool</span><span class="token punctuation">{</span> <span class="token keyword">return</span> x <span class="token operator">&lt;</span> y<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> n <span class="token operator">:</span> num<span class="token punctuation">)</span><span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> n <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/*    程序运行结果：
          1 2 3 4
*/</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_5-2-说说-c-中智能指针和指针的区别是什么" tabindex="-1"><a class="header-anchor" href="#_5-2-说说-c-中智能指针和指针的区别是什么" aria-hidden="true">#</a> 5.2 说说 C++ 中智能指针和指针的区别是什么？</h3><ol><li>智能指针</li></ol><p>如果在程序中使用new从堆（自由存储区）分配内存，等到不需要时，应使用delete将其释放。C++引用了智能指针auto_ptr，以帮助自动完成这个过程。随后的编程体验（尤其是使用STL）表明，需要有更精致的机制。基于程序员的编程体验和BOOST库提供的解决方案，C++11摒弃了auto_ptr，并新增了三种智能指针：unique_ptr、shared_ptr和weak_ptr。所有新增的智能指针都能与STL容器和移动语义协同工作。</p><ol start="2"><li>指针</li></ol><p>C 语言规定所有变量在使用前必须先定义，指定其类型，并按此分配内存单元。指针变量不同于整型变量和其他类型的变量，它是专门用来存放地址的，所以必须将它定义为“指针类型”。</p><p>智能指针和普通指针的区别</p><p>智能指针和普通指针的区别在于智能指针实际上是对普通指针加了一层封装机制，区别是它负责自动释放所指的对象，这样的一层封装机制的目的是为了使得智能指针可以方便的管理一个对象的生命期。</p><h3 id="_5-3" tabindex="-1"><a class="header-anchor" href="#_5-3" aria-hidden="true">#</a> 5.3</h3><h2 id="_6、c-操作系统-linux相关" tabindex="-1"><a class="header-anchor" href="#_6、c-操作系统-linux相关" aria-hidden="true">#</a> 6、C++操作系统（Linux相关）</h2><h2 id="_7、计算机网络" tabindex="-1"><a class="header-anchor" href="#_7、计算机网络" aria-hidden="true">#</a> 7、计算机网络</h2><h2 id="_8、设计模式-摘选" tabindex="-1"><a class="header-anchor" href="#_8、设计模式-摘选" aria-hidden="true">#</a> 8、设计模式（摘选）</h2><h2 id="_9、常见编程大题" tabindex="-1"><a class="header-anchor" href="#_9、常见编程大题" aria-hidden="true">#</a> 9、常见编程大题</h2></div><!----><footer class="page-meta"><div class="meta-item edit-link"><a href="https://github.com/XiaoYuer2022/XiaoYuer2022.github.io/edit/main/src/docs/1编程语言基础/ALL_c++全面总结.md" rel="noopener noreferrer" target="_blank" aria-label="在 GitHub 上编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="edit icon"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->在 GitHub 上编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item git-info"><div class="update-time"><span class="label">上次编辑于: </span><!----></div><div class="contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: 508506630@qq.com">HaoY</span><!--]--><!--]--></div></div></footer><nav class="page-nav"><!----><a href="/docs/1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/c__%E9%83%A8%E5%88%86%E5%86%85%E5%AE%B9(%E6%9D%A5%E6%BA%90%E4%BA%8E%E7%89%9B%E5%AE%A2%EF%BC%8C%E8%87%AA%E5%B7%B1%E5%A2%9E%E5%8A%A0).html" class="nav-link next" aria-label="C++部分内容(来源于牛客，自己增加)"><div class="hint">下一页<span class="arrow end"></span></div><div class="link">C++部分内容(来源于牛客，自己增加)<span class="font-icon icon iconfont icon-write" style=""></span></div></a></nav><!----><!----><!--]--></main><!--]--><footer class="footer-wrapper"><div class="footer"><a href="https://beian.miit.gov.cn/#/Integrated/index">渝ICP备2023001651号</a></div><div class="copyright">Copyright © 2023 Mr.HaoXX</div></footer></div><!--]--><!----><!--]--></div>
    <script type="module" src="/assets/app-cd86945f.js" defer></script>
  </body>
</html>
