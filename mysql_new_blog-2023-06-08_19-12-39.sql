-- MySQL dump 10.13  Distrib 8.0.27, for Linux (x86_64)
--
-- Host: localhost    Database: blog
-- ------------------------------------------------------
-- Server version	8.0.27

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!50503 SET NAMES utf8mb4 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Current Database: `blog`
--

CREATE DATABASE /*!32312 IF NOT EXISTS*/ `blog` /*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci */ /*!80016 DEFAULT ENCRYPTION='N' */;

USE `blog`;

--
-- Table structure for table `t_album`
--

DROP TABLE IF EXISTS `t_album`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `t_album` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '相册id',
  `album_name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '相册名',
  `album_cover` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '相册封面',
  `album_desc` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '相册描述',
  `status` tinyint(1) NOT NULL DEFAULT '1' COMMENT '状态 (1公开 2私密)',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_album`
--

LOCK TABLES `t_album` WRITE;
/*!40000 ALTER TABLE `t_album` DISABLE KEYS */;
INSERT INTO `t_album` VALUES (1,'精选壁纸','https://upload.haoxx.site/article/27c7f38a329c07159a80315712680ea5.jpg','壁纸',1,'2023-01-02 16:24:56','2023-01-06 10:18:56');
INSERT INTO `t_album` VALUES (2,'文章内置图片册','https://upload.haoxx.site/photo/24319fa48171a24c8adf1eb0c6680f17.jpg','存放了文章中的部分图片',1,'2023-01-10 18:41:41','2023-06-07 19:14:26');
/*!40000 ALTER TABLE `t_album` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `t_article`
--

DROP TABLE IF EXISTS `t_article`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `t_article` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '文章id',
  `user_id` int NOT NULL COMMENT '作者id',
  `category_id` int NOT NULL COMMENT '分类id',
  `article_cover` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '缩略图',
  `article_title` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '文章标题',
  `article_content` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '文章内容',
  `article_type` tinyint(1) NOT NULL DEFAULT '1' COMMENT '类型 (1原创 2转载 3翻译)',
  `is_top` tinyint(1) NOT NULL DEFAULT '0' COMMENT '是否置顶 (0否 1是）',
  `is_delete` tinyint(1) NOT NULL DEFAULT '0' COMMENT '是否删除 (0否 1是)',
  `is_recommend` tinyint(1) NOT NULL DEFAULT '0' COMMENT '是否推荐 (0否 1是)',
  `status` tinyint(1) NOT NULL DEFAULT '1' COMMENT '状态 (1公开 2私密 3评论可见)',
  `create_time` datetime NOT NULL COMMENT '发表时间',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=107 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_article`
--

LOCK TABLES `t_article` WRITE;
/*!40000 ALTER TABLE `t_article` DISABLE KEYS */;
INSERT INTO `t_article` VALUES (71,1,51,'https://upload.haoxx.site/article/b6877ebd88b9d69396333c5769e07c05.jpg','全面内容综述','\n第一部分是C++基础，第二部分是C/C++内存问题，第三部分是C++面向对象，第四部分是C++标准模板库STL，第五部分是C++新特性，第六部分是C++操作系统内容，第七部分是C++计算机网络，第八部分提到了部分常用的设计模式，第九部分举了一些常见的编程题。\n\n内容参考自[牛客](https://www.nowcoder.com/issue/tutorial?zhuanlanId=Gj56lM&uuid=0d542159b96c424f8b35bd6f9a278609)\n\n## 1、C++基础\n\n\n\n### 1.1 简述C++语言的特点\n\n1. C++在C语言基础上引入了**面向对象**的机制，同时也**兼容C语言**。\n2. C++有三大特性：封装、继承、多态\n3. C++语言编写出的程序结构清晰、易于扩充，程序可读性好\n4. C++生成的代码质量高，运行效率高，仅比汇编语言慢10%～20%\n5. C++更加安全，增加了const常量、引用、四类cast转换（static_cast、dynamic_cast、const_cast、reinterpret_cast）、智能指针、try—catch等等\n6. C++可复用性高，C++引入了模板的概念，后面在此基础上，实现了方便开发的标准模板库STL（Standard Template Library）\n7. 同时，C++是**不断在发展**的语言。C++后续版本更是发展了不少新特性，如C++11中引入了nullptr、auto变量、Lambda匿名函数、右值引用、智能指针。\n\n### 1.2 说说C语言与C++语言的区别\n\n1. C语言是C++的子集，C++可以很好兼容C语言。但是C++又有很多**新特性**，如引用、智能指针、auto变量等。\n2. C++是**面对对象**的编程语言；C语言是面对过程的编程语言\n3. C语言有一些不安全的语言特性，如指针使用的潜在危险、强制转换的不确定性、内存泄露等。而C++对此增加了不少新特性来**改善安全性**，如const常量、引用、cast转换、智能指针、try—catch等等\n4. C++**可复用性高**，C++引入了**模板**的概念，后面在此基础上，实现了方便开发的标准模板库STL。C++的STL库相对于C语言的函数库**更灵活、更通用**\n\n### 1.3 说说C++中struct和class的区别\n\n1. struct一般用于描述一个数据结构集合，而class是对一个对象数据的封装；\n2. struct的默认访问权限是public，而class默认权限是private；\n\n```cpp\nstruct A{\n	int iNum;  //默认访问控制权限是public\n};\nclass B{\n	int iNum;  //默认访问控制权限是private\n};\n```\n\n3. 在继承关系上，struct是public继承，而class是private继承；\n4. class关键字可以用于定义模板参数，就像typename，而struct不能用于定义模板参数。\n\n### 1.4 说说C中结构体和C++中结构体的区别\n\n1. C的结构体内不允许有函数存在，C++允许有内部成员函数，且允许该函数是虚函数\n2. C的结构体对内部成员变量的访问权限只能是public，而C++允许public,protected,private三种\n3. C语言的结构体是不可以继承的，C++的结构体是可以从其他的结构体或者类继承过来的\n4. C 中使用结构体需要加上 struct 关键字，或者对结构体使用 typedef 取别名，而 C++ 中可以省略 struct 关键字直接使用\n\n小总结一波：①C与C++在声明时的区别在于：\n\n|          |           C            |           C++            |\n| :------: | :--------------------: | :----------------------: |\n| 成员函数 |         不能有         |           可以           |\n| 静态成员 |         不能有         |           可以           |\n| 访问控制 |  默认public，不可修改  | public/private/protected |\n| 继承关系 |       不可以继承       |  可从类或其他结构体继承  |\n|  初始化  | 不能直接初始化数据成员 |           可以           |\n\n②使用时的区别：\n\nC 中使用结构体需要加上 struct 关键字，或者对结构体使用 typedef 取别名，而 C++ 中可以省略 struct 关键字直接使用，例如：\n\n```cpp\nstruct Student{\n	int iAge;\n	string strName;\n};\ntypedef struct Student Student2; //C中给结构体取别名\n\nstuct Student stu1;   //C中正常使用\nStudent2 stu2;      //C中通过取别名来使用\nStudent stu3;      // C++中使用结构体可以省略关键字struct\n```\n\n### 1.5 说说include头文件的顺序以及双引号“”和尖括号<>的区别\n\n1. 区别\n   （1）尖括号的头文件是系统文件，双引号的文件是自定义文件；\n   （2）编译器预处理阶段查找头文件的路径不一样\n2. 查找路径\n   （1）使用尖括号<>的头文件的查找路径：编译器设置的头文件路径-->系统变量\n   （2）使用双引号“”的头文件的查找路径：当前头文件目录-->编译器设置的头文件路径-->系统变量\n\n### 1.6 导入C函数的关键字是什么，C++编译的时候与C有什么区别\n\n1. **关键字**：在C++中，导入C函数的关键字是extern，表达形式为extern “C”， extern \"C\"的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern \"C\"后，会指示编译器这部分代码按C语言的进行编译，而不是C++的。\n2. **编译区别**：由于C++支持函数重载，因此编译器编译函数的过程中会将函数的**参数类型**也加到编译后的代码中，而不仅仅是**函数名**；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括**函数名**。\n   程序示例：\n\n```cpp\n//extern示例\n//在C++程序里边声明该函数，会指示编译器这部分代码按C语言的进行编译\nextern \"C\" int strcmp(const char *s1, const char *s2);\n\n//在C++程序里边声明该函数\nextern \"C\"{\n    #include <string.h>//string.h里边包含了要调用的C函数的声明\n}\n\n//两种不同的语言，有着不同的编译规则，比如一个函数fun，可能C语言编译的时候为_fun，而C++则是__fun__\n```\n\n### 1.7 简述C++从代码到可执行二进制文件的过程\n\nC++和C语言类似，一个C++程序从源码到执行文件，有四个过程，**预处理、编译、汇编、链接**。\n\n1. 预处理：这个过程主要的处理操作如下：\n   （1） 将所有的#define删除，并且展开所有的宏定义\n   （2） 处理所有的条件预编译指令，如#if、#ifdef\n   （3） 处理#include预编译指令，将被包含的文件插入到该预编译指令的位置。\n   （4） 过滤所有的注释\n   （5） 添加行号和文件名标识。\n2. 编译：这个过程主要的处理操作如下：\n   （1） 词法分析：将源代码的字符序列分割成一系列的记号。\n   （2） 语法分析：对记号进行语法分析，产生语法树。\n   （3） 语义分析：判断表达式是否有意义。\n   （4） 代码优化：\n   （5） 目标代码生成：生成汇编代码。\n   （6） 目标代码优化：\n3. 汇编：这个过程主要是将汇编代码转变成机器可以执行的指令。\n4. 链接：将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。\n\n链接分为静态链接和动态链接。\n\n静态链接，是在链接的时候就已经把要调用的函数或者过程链接到了生成的可执行文件中，就算你在去把静态库删除也不会影响可执行程序的执行；生成的静态链接库，Windows下以.lib为后缀，Linux下以.a为后缀。\n\n而动态链接，是在链接的时候没有把调用的函数代码链接进去，而是在执行的过程中，再去找要链接的函数，生成的可执行文件中没有函数代码，只包含函数的重定位信息，所以当你删除动态库时，可执行程序就不能运行。生成的动态链接库，Windows下以.dll为后缀，Linux下以.so为后缀。\n\n### 1.8 说说 static关键字的作用\n\n**static关键字的作用**：一方面她延长了函数和变量的作用时间；另一方面，它也限制了函数和变量的作用范围。\n\n1. **定义全局静态变量和局部静态变量**：在变量前面加上static关键字。初始化的静态变量会在数据段（.data）分配内存，未初始化的静态变量会在BSS段（.bss）分配内存。直到程序结束，静态变量始终会维持前值。只不过全局静态变量和局部静态变量的作用域不一样；\n2. **定义静态函数**：在函数返回类型前加上static关键字，函数即被定义为静态函数。静态函数只能在本源文件中使用；\n3. 在变量类型前加上static关键字，变量即被定义为静态变量。静态变量只能在本源文件中使用；\n4. 在C++中，static关键字可以用于定义类中的静态成员变量：使用静态数据成员，它既可以被当成全局变量那样去存储，但又被隐藏在类的内部。类中的static静态数据成员拥有一块单独的存储区，而不管创建了多少个该类的对象。所有这些对象的静态数据成员都共享这一块静态存储空间；\n5. 在C++中，static关键字可以用于定义类中的静态成员函数：与静态成员变量类似，类里面同样可以定义静态成员函数。只需要在函数前加上关键字static即可。如静态成员函数也是类的一部分，而不是对象的一部分。所有这些对象的静态数据成员都共享这一块静态存储空间。\n\n**关于第五点的补充说明**：当调用一个对象的非静态成员函数时，系统会把该对象的起始地址赋给成员函数的this指针。而静态成员函数不属于任何一个对象，因此C++规定静态成员函数没有this指针（划重点，面试题常考）。既然它没有指向某一对象，也就无法对一个对象中的非静态成员进行访问。\n\n### 1.9 说说数组和指针的区别\n\n1、概念：\n    （1）数组：数组是用于储存多个相同类型数据的集合。数组名是首元素的地址\n    （2）指针：指针相当于一个变量，但是它和不同变量不一样，它存放的是其它变量在**内存中的地址**。指针名指向了内存的首地址\n\n2. 区别：\n   （1）**赋值**：同类型指针变量可以相互赋值；数组不行，只能一个一个元素的赋值或拷贝\n   （2）**存储方式**：\n\n数组：数组在内存中是连续存放的，开辟一块连续的内存空间。数组是根据数组的下标进行访问的，数组的存储空间，不是在静态区就是在栈上。\n\n指针：指针很灵活，它可以指向任意类型的数据。指针的类型说明了它所指向地址空间的内存。由于指针本身就是一个变量，再加上它所存放的也是变量，所以指针的存储空间不能确定。\n（3）**求sizeof**：\n\n数组所占存储空间的内存大小是sizeof(数组)，计算数组中元素个数：sizeof（数组名）/sizeof（数据类型）\n\n在32位平台下，无论指针的类型是什么，sizeof（指针名）都是4，在64位平台下，无论指针的类型是什么，sizeof（指针名）都是8。\n（4）**初始化**：\n\n```cpp\n// 数组\nint a[5] = { 0 };\nchar b[] = \"Hello\";    // 按字符串初始化，大小为6\nchar c[] = { \'H\',\'e\',\'l\',\'l\',\'o\',\'\\0\' };    // 按字符初始化\nint* arr = new int[10];    // 动态创建一维数组\n\n// 指针\n// 指向对象的指针\nint* p = new int(0);\ndelete p;\n// 指向数组的指针\nint* p1 = new int[10];\ndelete[] p1;\n// 指向类的指针：\nstring* p2 = new string;\ndelete p2;\n// 指向指针的指针（二级指针）\nint** pp = &p;\n**pp = 10;\n```\n\n（5）**指针操作**：\n\n数组名的指针操作：\n\n`int (*p)[4]`定义了一个数组指针，该指针指向一个包含4个元素的数组。\n\n```cpp\nint a[3][4];  \nint (*p)[4];  //该语句是定义一个数组指针，指向含4个元素的一维数组\np = a;        //将该二维数组的首地址赋给p，也就是a[0]或&a[0][0]\np++;          //该语句执行过后，也就是p=p+1；p跨过行a[0][]指向了行a[1][]\n              //所以数组指针也称指向一维数组的指针，亦称行指针。\n//访问数组中第i行j列的一个元素，有几种操作方式：\n//*(p[i]+j)、*(*(p+i)+j)、(*(p+i))[j]、p[i][j]。其中，优先级：()>[]>*。\n//这几种操作方式都是合法的。\n```\n\n指针变量的数据操作：\n\n```cpp\nchar *str = \"hello,douya!\";\nstr[2] = \'a\';\n*(str+2) = \'b\';\n//这两种操作方式都是合法的。\n```\n\n补充：int \\*p[4]和int (*p)[4]的区别和区分：因为[]的优先级要比\\*高，所以前者是p先和[ ]结合，表示一个数组，然后再与*结合，表示int指针类型的数组。（本质上是数组，不过是int指针类型的数组）这数组里每个元素都是int类型的指针，储存的是int类型变量的地址。\n\n而int(\\*p)[4]，p先和\\*结合，表示p是一个指针，int ［4］就是他的类型，表示这是一个数组类型的指针，即p是一个指向一个长度为4数组的指针，它的本质是一个指针，这个指针的类型是int类型长度为4的数组。表示，这个指针存的是int类型长度为4的数组的地址。（不是其中某个元素的地址）\n\n### 1.10 说说什么是函数指针，如何定义函数指针，有什么使用场景\n\n1. **概念**：函数指针就是指向函数的指针变量。每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址\n2. **定义**形式如下：\n\n```cpp\nint func(int a);  \nint (*f)(int a);  \nf = &func;  \n```\n\n3. 函数指针的**应用场景**：**回调**(callback)。我们调用别人提供的 API函数(Application Programming Interface,应用程序编程接口)，称为Call；如果别人的库里面调用我们的函数，就叫回调Callback。\n\n  我们用系统的API叫调用，系统用我们的API叫回调。\n\n  程序示例：\n\n```cpp\n//以库函数qsort排序函数为例，它的原型如下：\nvoid qsort(void *base,//void*类型，代表原始数组\n           size_t nmemb, //第二个是size_t类型，代表数据数量\n           size_t size, //第三个是size_t类型，代表单个数据占用空间大小\n           int(*compar)(const void *,const void *)//第四个参数是函数指针\n          );\n//第四个参数告诉qsort，应该使用哪个函数来比较元素，即只要我们告诉qsort比较大小的规则，它就可以帮我们对任意数据类型的数组进行排序。在库函数qsort调用我们自定义的比较函数，这就是回调的应用。\n\n//示例\nint num[100];\nint cmp_int(const void* _a , const void* _b){//参数格式固定\n    int* a = (int*)_a;    //强制类型转换\n    int* b = (int*)_b;\n    return *a - *b;　　\n}\nqsort(num,100,sizeof(num[0]),cmp_int); //回调\n```\n\n### 1.11 说说静态变量什么时候初始化\n\n<font color=\'red\'>对于C语言的全局和静态变量，初始化发生在任何代码执行之前，属于编译期初始化。</font>\n\n<font color=\'red\'>而C++标准规定：全局或静态对象当且仅当对象首次用到时才进行构造。</font>\n\n1. **作用域**：C++里作用域可分为6种：全局，局部，类，语句，命名空间和文件作用域\n\n  全局变量：全局作用域+文件作用域，可以通过extern作用于其他非定义的源文件。\n  静态全局变量 ：全局作用域，所以无法在其他文件中使用。\n  静态局部变量 ：局部作用域，只被初始化一次，直到程序结束。\n  类静态成员变量：类作用域。\n\n2. **所在空间**：都在静态存储区。因为静态变量都在静态存储区，所以下次调用函数的时候还是能取到原来的值\n\n3. **生命周期**：静态全局变量、静态局部变量都在静态存储区，直到程序结束才会回收内存。类静态成员变量在静态存储区，当超出类作用域时回收内存\n\n### 1.12 nullptr可以调用成员函数吗，为什么？\n\n答案：能。\n原因：因为在编译时对象就绑定了函数地址，和指针空不空没关系。\n\n因为在编译时对象就绑定了函数地址，和指针空不空没关系。pAn->breathe();编译的时候，函数的地址就和指针pAn绑定了；调用breath(\\*this), this就等于pAn。由于函数中没有需要解引用this的地方，所以函数运行不会出错，但是若用到this，因为this=nullptr，运行出错。\n\n```cpp\n//给出实例\nclass animal{\npublic:\n    void sleep(){ cout << \"animal sleep\" << endl; }\n    void breathe(){ cout << \"animal breathe haha\" << endl; }\n};\nclass fish :public animal{\npublic:\n    void breathe(){ cout << \"fish bubble\" << endl; }\n};\nint main(){\n    animal *pAn=nullptr;\n    pAn->breathe();   // 输出：animal breathe haha\n    fish *pFish = nullptr;\n    pFish->breathe(); // 输出：fish bubble\n    return 0;\n}  \n```\n\n### 1.13 什么是野指针，怎么产生的，如何避免？\n\n1. **概念**：野指针就是指针指向的位置是不可知的（随机的、不正确的、没有明确限制的）\n2. **产生原因**：释放内存后指针不及时置空（野指针），依然指向了该内存，那么可能出现非法访问的错误。这些我们都要注意避免，如：\n\n```cpp\nchar *p = (char *)malloc(sizeof(char)*100);  \nstrcpy(p, \"Douya\");  \nfree(p);//p所指向的内存被释放，但是p所指的地址仍然不变  \n...  \nif (p != NULL){//没有起到防错作用  \n    strcpy(p, \"hello, Douya!\");//出错  \n}  \n```\n\n3. 避免办法：\n   （1）初始化置为NULL\n   （2）申请内存后判空\n   （3）指针释放后置NULL\n   （4）使用智能指针\n\n```cpp\nint *p = NULL; //初始化置NULL\np = (int *)malloc(sizeof(int)*n); //申请n个int内存空间  \nassert(p != NULL); //判空，防错设计\n//C 库函数 void *realloc(void *ptr, size_t size) 尝试重新调整之前调用 malloc 或 calloc 所分配的 ptr 所指向的内存块的大小。\n//注意：如果大小为 0，且 ptr 指向一个已存在的内存块，则 ptr 所指向的内存块会被释放，并返回一个空指针。\np = (int *) realloc(p, 25);//重新分配内存, p 所指向的内存块会被释放并分配一个新的内存地址\nfree(p);  \np = NULL; //释放后置空\n\nint *p1 = NULL; //初始化置NULL\ncalloc默认设置分配的内存数据为0\np1 = (int *)calloc(n, sizeof(int)); //申请n个int内存空间同时初始化为0 \nassert(p1 != NULL); //判空，防错设计\nfree(p1);  \np1 = NULL; //释放后置空\n\nint *p2 = NULL; //初始化置NULL\np2 = new int[n]; //申请n个int内存空间  \nassert(p2 != NULL); //判空，防错设计\ndelete []p2;  \np2 = nullptr; //释放后置空  \n```\n\n### 1.14 说说静态局部变量，全局变量，局部变量的特点，以及使用场景\n\n1. **首先从作用域考虑**：C++里作用域可分为6种：全局，局部，类，语句，命名空间和文件作用域。\n   全局变量：全局作用域+文件作用域，可以通过extern作用于其他非定义的源文件。\n   静态全局变量 ：全局作用域，所以无法在其他文件中使用。\n   局部变量：局部作用域，比如函数的参数，函数内的局部变量等等。\n   静态局部变量 ：局部作用域，只被初始化一次，直到程序结束。\n2. **从所在空间考虑**：除了局部变量在栈上外，其他都在静态存储区。因为静态变量都在静态存储区，所以下次调用函数的时候还是能取到原来的值。\n3. **生命周期**： 局部变量在栈上，出了作用域就回收内存；而全局变量、静态全局变量、静态局部变量都在静态存储区，直到程序结束才会回收内存。\n4. **使用场景**：从它们各自特点就可以看出各自的应用场景，不再赘述。\n\n### 1.15 说说内联函数和宏函数的区别\n\n区别：\n\n1. **宏定义不是函数**，但是使用起来像函数。预处理器用复制宏代码的方式代替函数的调用，省去了函数压栈退栈过程，提高了效率；而**内联函数本质上是一个函数**，内联函数一般用于函数体的代码比较简单的函数，不能包含复杂的控制语句，while、switch，并且内联函数本身不能直接调用自身(内联函数不能用于迭代)。\n\n2. **宏定义**是在预编译的时候把所有的宏名用宏体来替换，简单的说就是字符串替换 ；而**内联函数**则是在编译的时候进行代码插入，编译器会在每处调用内联函数的地方直接把内联函数的内容展开，这样可以省去函数的调用的开销，提高效率\n\n3. **宏定义**是没有类型检查的，无论对还是错都是直接替换；而**内联函数**在编译的时候会进行类型的检查，内联函数满足函数的性质，比如有返回值、参数列表等\n\n  **说人话**：相同点是，宏定义和内联函数，相比于函数体内代码较短，逻辑简单的普通函数而言，避免了出栈入栈的开销，提高了运行效率。不同的在于，宏定义本质不是函数。只是简单的字符替换，而且不会进行检查；内联函数本质是函数，是进行代码插入，有检错（宏定义不会对传入的参数进行检查），有形参，有返回值。\n\n  代码示例如下：\n\n```cpp\n//宏定义示例\n#define MAX(a，b) ((a)>(b)?(a):(b))\nMAX(a,\"Hello\")； //错误地比较int和字符串，没有参数类型检查\n\n//内联函数示例\n#include <stdio.h>\ninline int add(int a, int b){\n    return (a + b);\n}\nint main(void){\n    int a;\n    a = add(1, 2);\n    printf(\"a+b=%d\\n\", a);\n    return 0;\n}\n//以上a = add(1, 2);处在编译时将被展开为：a = (a + b);\n```\n\n1、使用时的一些注意事项：\n\n+ 使用宏定义一定要注意错误情况的出现，比如宏定义函数没有类型检查，可能传进来任意类型，从而带来错误，如举例。还有就是括号的使用，宏在定义时要小心处理宏参数，一般用括号括起来，否则容易出现二义性\n\n+ inline函数一般用于比较小的，频繁调用的函数，这样可以减少函数调用带来的开销。只需要在函数返回类型前加上关键字inline，即可将函数指定为inline函数。\n\n+ 同其它函数不同的是，最好将inline函数定义在头文件，而不仅仅是声明，因为编译器在处理inline函数时，需要在调用点内联展开该函数，所以仅需要函数声明是不够的。\n\n2、内联函数使用的条件：\n\n+ 内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。以下情况不宜使用内联：\n\n+ （1）如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。\n+ （2）如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。\n+ 内联不是什么时候都能展开的，一个好的编译器将会根据函数的定义体，自动地取消不符合要求的内联。\n\n### 1.16 说说运算符i++和++i的区别\n\n先看代码示例：\n\n```cpp\n#include <stdio.h>\nint main(){\n    int i = 2;\n    int j = 2;\n    j += i++; //先赋值后加\n    printf(\"i= %d, j= %d\\n\",i, j); //i= 3, j= 4\n    i = 2;\n    j = 2;\n    j += ++i; //先加后赋值\n    printf(\"i= %d, j= %d\",i, j); //i= 3, j= 5\n}\n```\n\n区别：\n\n1. 赋值顺序不同：++ i 是先加后赋值；i ++ 是先赋值后加；++i和i++都是分两步完成的。\n2. 效率不同：<font color=\'red\'>后置++执行速度比前置的慢</font>。\n3. i++ 不能作为左值，而++i 可以：\n\n```cpp\nint i = 0;\nint *p1 = &（++i）；//正确\nint *p2 = &（i++）；//错误\n++i = 1；//正确\ni++ = 1；//错误\n```\n\n4. 两者都不是原子操作\n\n### 1.17 说说new和malloc的区别，各自底层实现原理\n\n1. new是操作符，而malloc是函数。\n2. new在调用的时候先分配内存，在调用构造函数，释放的时候调用析构函数；而malloc没有构造函数和析构函数。\n3. malloc需要给定申请内存的大小，返回的指针需要强转；new会调用构造函数，不用指定内存的大小，返回指针不用强转。\n4. new可以被重载；malloc不行\n5. new分配内存更直接和安全。\n6. new发生错误抛出异常，malloc返回null\n\n答案解析：\n\n**malloc底层实现**：当开辟的空间小于 128K 时，调用 brk（）函数；当开辟的空间大于 128K 时，调用mmap（）。malloc采用的是内存池的管理方式，以减少内存碎片。先申请大块内存作为堆区，然后将堆区分为多个内存块。当用户申请内存时，直接从堆区分配一块合适的空闲快。采用隐式链表将所有空闲块，每一个空闲块记录了一个未分配的、连续的内存地址。\n\n**new底层实现**：关键字new在调用构造函数的时候实际上进行了如下的几个步骤：\n\n1. 创建一个新的对象\n2. 将构造函数的作用域赋值给这个新的对象（因此this指向了这个新的对象）\n3. 执行构造函数中的代码（为这个新对象添加属性）\n4. 返回新对象\n\n### 1.18 说说const和define的区别\n\nconst用于定义常量；而define用于定义宏，而宏也可以用于定义常量。都用于常量定义时，它们的\n区别有：\n\n1. const生效于编译的阶段；define生效于预处理阶段。\n2. const定义的常量，在C语言中是存储在内存中、需要额外的内存空间的；define定义的常量，运行时是直接的操作数，并不会存放在内存中。\n3. const定义的常量是带类型的；define定义的常量不带类型。因此define定义的常量不利于类型检查。\n\n### 1.19 说说C++中函数指针和指针函数的区别\n\n1. 定义不同\n   指针函数本质是一个函数，其返回值为指针。\n   函数指针本质是一个指针，其指向一个函数。\n\n2. 写法不同\n\n>指针函数：int \\*fun(int x,int y);\n>	   函数指针：int (\\*fun)(int x,int y);\n\n3. 用法不同\n\n用法参考以下代码示例：\n\n```cpp\n//指针函数示例\ntypedef struct _Data{\n    int a;\n    int b;\n}Data;\n//指针函数\nData* f(int a,int b){\n    Data * data = new Data;\n    //...\n    return data;\n}\nint main(){\n    //调用指针函数\n    Data * myData = f(4,5);\n    //Data * myData = static_cast<Data*>(f(4,5));\n   //...\n}\n\n//函数指针示例\nint add(int x,int y){\n    return x+y;\n}\n//函数指针\nint (*fun)(int x,int y);\n//赋值\nfun = add;\n//调用\ncout << \"(*fun)(1,2) = \" << (*fun)(1,2) ;\n//输出结果\n//(*fun)(1,2) =  3\n```\n\n### 1.20 说说const int *a, int const *a, const int a, int *const a, const int *const a分别是什么，有什么特点。\n\n参考答案：\n\n```cpp\n1. const int a;     //指的是a是一个常量，不允许修改。\n2. const int *a;    //a指针所指向的内存里的值不变，即（*a）不变\n3. int const *a;    //同const int *a;\n4. int *const a;    //a指针所指向的内存地址不变，即a不变\n5. const int *const a;   //都不变，即（*a）不变，a也不变\n```\n\n### 1.21 说说使用指针需要注意什么？\n\n1. 定义指针时，先初始化为NULL。\n2. 用malloc或new申请内存之后，应该立即检查指针值是否为NULL。防止使用指针值为NULL的内存。\n3. 不要忘记为数组和动态内存赋初值。防止将未被初始化的内存作为右值使用。\n4. 避免数字或指针的下标越界，特别要当心发生“多1”或者“少1”操作\n5. 动态内存的申请与释放必须配对，防止内存泄漏\n6. 用free或delete释放了内存之后，立即将指针设置为NULL，防止“野指针”\n\n示例代码：\n\n```cpp\n//（1）初始化置NULL\n//（2）申请内存后判空\n//（3）指针释放后置NULL\nint *p = NULL; //初始化置NULL\np = (int *)malloc(sizeof(int)*n); //申请n个int内存空间  \nassert(p != NULL); //判空，防错设计\np = (int *) realloc(p, 25);//重新分配内存, p 所指向的内存块会被释放并分配一个新的内存地址\nfree(p);  \np = NULL; //释放后置空\n\nint *p1 = NULL; //初始化置NULL\np1 = (int *)calloc(n, sizeof(int)); //申请n个int内存空间同时初始化为0 \nassert(p1 != NULL); //判空，防错设计\nfree(p1);  \np1 = NULL; //释放后置空\n\nint *p2 = NULL; //初始化置NULL\np2 = new int[n]; //申请n个int内存空间  \nassert(p2 != NULL); //判空，防错设计\ndelete []p2;  \np2 = nullptr; //释放后置空  \n```\n\n### 1.22 说说内联函数和函数的区别，内联函数的作用\n\n1. 内联函数比普通函数多了关键字inline\n2. 内联函数避免了函数调用的开销；普通函数有调用的开销\n3. 普通函数在被调用的时候，需要寻址（函数入口地址）；内联函数不需要寻址。\n4. 内联函数有一定的限制，内联函数体要求代码简单，不能包含复杂的结构控制语句；普通函数没有这个要求。\n\n**内联函数的作用**：内联函数在调用时，是将调用表达式用内联函数体来替换。避免函数调用的开销。\n\n在使用内联函数时，应注意如下几点：　\n\n1. 在内联函数内不允许用循环语句和开关语句。　\n\n如果内联函数有这些语句，则编译将该函数视同普通函数那样产生函数调用代码,递归函数是不能被用来做内联函数的。内联函数只适合于只有1～5行的小函数。对一个含有许多语句的大函数，函数调用和返回的开销相对来说微不足道，所以也没有必要用内联函数实现。　\n\n2. 内联函数的定义必须出现在内联函数第一次被调用之前。\n\n### 1.23 简述C++有几种传值方式，之间的区别是什么？\n\n传参方式有这三种：**值传递**、**引用传递**、**指针传递**\n\n1. 值传递：形参即使在函数体内值发生变化，也不会影响实参的值；\n2. 引用传递：形参在函数体内值发生变化，会影响实参的值；\n3. 指针传递：在指针指向没有发生改变的前提下，形参在函数体内值发生变化，会影响实参的值；\n\n值传递用于对象时，整个对象会拷贝一个副本，这样效率低；而引用传递用于对象时，不发生拷贝行为，只是绑定对象，更高效；指针传递同理，但不如引用传递安全。\n\n```cpp\n//代码示例\n#include <iostream>\nusing namespace std;\n\nvoid testfunc(int a, int *b, int &c){//形参a值发生了改变，但是没有影响实参i的值；但形参*b、c的值发生了改变，影响到了实参*j、k的值\n    a += 1;\n    (*b) += 1;\n    c += 1;\n    printf(\"a= %d, b= %d, c= %d\\n\",a,*b,c);//a= 2, b= 2, c= 2\n}\nint main(){\n       int i = 1;\n    int a = 1;\n    int *j = &a;\n    int k = 1;\n    testfunc(i, j, k);\n    printf(\"i= %d, j= %d, k= %d\\n\",i,*j,k);//i= 1, j= 2, k= 2\n    return 0;\n}\n```\n\n### 1.24 简述const（星号）和（星号）const的区别\n\n代码示例：\n\n```cpp\n//const* 是常量指针，*const 是指针常量\n\nint const *a;    //a指针所指向的内存里的值不变，即（*a）不变\nint *const a;    //a指针所指向的内存地址不变，即a不变\n```\n\n\n\n\n\n\n## 2、C/C++内存问题\n\n### 2.1 简述一下堆和栈的区别\n\n1. **堆栈空间分配不同**。栈由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等；堆一般由程序员分配释放。\n2. **堆栈缓存方式不同**。栈使用的是一级缓存， 它们通常都是被调用时处于存储空间中，调用完毕立即释放；堆则是存放在二级缓存中，速度要慢些。\n3. **堆栈数据结构不同**。堆类似数组结构；栈类似栈结构，先进后出。\n\n### 2.2 简述C++的内存管理\n\n1. 内存分配方式\n   在C++中，内存分成5个区，他们分别是堆、栈、自由存储区、全局/静态存储区和常量存储区。\n\n><font color=\'red\'>栈</font>，在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。\n>\n><font color=\'red\'>堆</font>，就是那些由malloc/realloc/calloc分配的内存块，一般一个malloc就要对应一个free。\n>\n><font color=\'red\'>自由存储区</font>，就是那些由new分配的内存块，和堆是十分相似的，不过是用delete来结束自己的生命。 【补充说明】\n>\n><font color=\'red\'>全局/静态存储区</font>，全局变量和静态变量被分配到同一块内存中\n>\n><font color=\'red\'>常量存储区</font>，这是一块比较特殊的存储区，里面存放的是常量，不允许修改。\n\n【**补充说明**】：\n\n如果我接着问你自由存储区与堆有什么区别，你或许这样回答：“malloc在堆上分配的内存块，使用free释放内存，而new所申请的内存则是在自由存储区上，使用delete来释放。”\n\n这样听起来似乎也没错，但如果我接着问：\n\n自由存储区与堆是两块不同的内存区域吗？它们有可能相同吗？\n\n你可能就懵了。\n\n**尽管C++标准没有要求，但很多编译器的new/delete都是以malloc/free为基础来实现的。那么请问：借以malloc实现的new，所申请的内存是在堆上还是在自由存储区上？ 明显，此时的堆与自由存储区所代表的空间是相同的。**\n\n如果，你重载了new运算符，使其不在堆上开辟空间，那么对于自动存储区的概念就完全不相同了。\n\n从技术上来说，堆（heap）是C语言和操作系统的术语。堆是操作系统所维护的一块特殊内存，它提供了动态分配的功能，当运行程序调用malloc()时就会从中分配，稍后调用free可把内存交还。而自由存储是C++中通过new和delete动态分配和释放对象的抽象概念，通过new来申请的内存区域可称为自由存储区。基本上，所有的C++编译器默认使用堆来实现自由存储，也即是缺省的全局运算符new和delete也许会按照malloc和free的方式来被实现，这时藉由new运算符分配的对象，说它在堆上也对，说它在自由存储区上也正确。但程序员也可以通过重载操作符，改用其他内存来实现自由存储，例如全局变量做的对象池，这时自由存储区就区别于堆了。我们所需要记住的就是：\n\n><font color=\'red\'>堆是操作系统维护的一块内存，而自由存储是C++中通过new与delete动态分配和释放对象的抽象概念。堆与自由存储区并不等价。</font>\n\n【**补充说明结束**】\n\n2. 常见的内存错误和对策\n\n（1）内存分配未成功，却使用了它。\n\n（2）内存分配虽然成功，但是尚未初始化就引用它。\n\n（3）内存分配成功并且已经初始化，但操作越过了内存的边界。\n\n（4）忘记了释放内存，造成内存泄露。\n\n（5）释放了内存却继续使用它。\n\n对策：\n\n（1）定义指针时，先初始化为NULL。\n\n（2）用malloc或new申请内存之后，应该立即检查指针值是否为NULL。防止使用指针值为NULL的内存。\n\n（3）不要忘记为数组和动态内存赋初值。防止将未被初始化的内存作为右值使用。\n\n（4）避免数字或指针的下标越界，特别要当心发生“多1”或者“少1”操作\n\n（5）动态内存的申请与释放必须配对，防止内存泄漏\n\n（6）用free或delete释放了内存之后，立即将指针设置为NULL，防止“野指针”\n\n（7）使用智能指针。\n\n3. 内存泄漏及解决办法\n\n**什么是内存泄露？**\n\n简单地说就是申请了一块内存空间，使用完毕后没有释放掉。（1）new和malloc申请资源使用后，没有用delete和free释放；（2）子类继承父类时，父类析构函数不是虚函数。（3）Windows句柄资源使用后没有释放。\n\n**怎么检测？**\n\n第一：良好的编码习惯，使用了内存分配的函数，一旦使用完毕,要记得使用其相应的函数释放掉。\n\n第二：将分配的内存的指针以链表的形式自行管理，使用完毕之后从链表中删除，程序结束时可检查改链表。\n\n第三：使用智能指针。\n\n第四：一些常见的工具插件，如ccmalloc、Dmalloc、Leaky、Valgrind等等。\n\n### 2.3 malloc和局部变量分配在堆还是栈？\n\n malloc是在堆上分配内存，需要程序员自己回收内存；局部变量是在栈中分配内存，超过作用域就自动回收。\n\n### 2.4 程序有哪些section，分别的作用？程序启动的过程？怎么判断数据分配在栈上还是堆上？\n\n![图1](https://s3.bmp.ovh/imgs/2022/08/29/91e07f9f6bdac247.png)\n\n**一个程序有哪些section**：\n\n如上图，从低地址到高地址，一个程序由**代码段、数据段、 BSS 段**组成。\n\n【1】、**数据段**：存放程序中已初始化的全局变量和静态变量的一块内存区域。\n\n【2】、**代码段**：存放程序执行代码的一块内存区域。只读，代码段的头部还会包含一些<font color=\'blue\'>只读的**常数变量**</font>。(全局常量和字符串常量位于全局区/静态区还是代码区，还有待商榷)\n\n【3】、**BSS 段**：存放程序中未初始化的全局变量和静态变量的一块内存区域。\n\n【4】、可执行程序在运行时又会多出两个区域：堆区和栈区。\n\n**堆区**：动态申请内存用。堆从低地址向高地址增长。\n\n**栈区**：存储局部变量、函数参数值。栈从高地址向低地址增长。是一块连续的空间。\n\n【5】、最后还有一个**文件映射区**，位于堆和栈之间。\n\n<font color=\'red\'>【警告】：在网上查阅的资料显示，字符串常量存放在全局/静态区，而不是代码区。普通常量也是位于全局/静态区。</font>根据观察和代码验证，字符串数组是变量，存放在栈区；字符串指针是常量，存放在全局/静态区。还有一点，全局/静态区是低地址，栈是高地址。\n\n```cpp\n#include <stdio.h>\n\nvoid test01()\n{\nchar str1[] = \"abcd\";\nchar str2[] = \"abcd\";\n \nconst char str3[] = \"abcd\";\nconst char str4[] = \"abcd\";\n \nconst char *str5 = \"abcd\";\nconst char *str6 = \"abcd\";\n \nchar *str7 = \"abcd\";\nchar *str8 = \"abcd\";\n\nprintf(\"str1: %p\\n\",str1);\nprintf(\"str2: %p\\n\",str2);\nprintf(\"str3: %p\\n\",str3);\nprintf(\"str4: %p\\n\",str4);\n\nprintf(\"str5: %p\\n\",str5);\nprintf(\"str6: %p\\n\",str6);\nprintf(\"str7: %p\\n\",str7);\nprintf(\"str8: %p\\n\",str8);\n}\n\nvoid test02()\n{\n    char p[]=\"hello world!\";\n    printf(\"test02 p[] is %p\\n\",p);\n\n    char *p1=\"hello world!\";\n    printf(\"test02 *p is %p\\n\",p1);\n}\n\nint main()\n{\n    test01();\n    test02();\n    return 0;\n}\n//输出结果为:\nstr1: 0061FEEB //栈 char str1[] = \"abcd\";\nstr2: 0061FEE6 //栈 char str2[] = \"abcd\";\nstr3: 0061FEE1 //栈 const char str3[] = \"abcd\";\nstr4: 0061FEDC //栈 const char str4[] = \"abcd\";\nstr5: 00405094 //全局/静态区 const char str3[] = \"abcd\";\nstr6: 00405094 //全局/静态区 const char *str6 = \"abcd\";\nstr7: 00405094 //全局/静态区 char *str7 = \"abcd\";\nstr8: 00405094 //全局/静态区 char *str8 = \"abcd\";\ntest02 p[] is 0061FEEF //栈 char p[]=\"hello world!\";\ntest02 *p is 00405064 //全局/静态区 char *p1=\"hello world!\";\n```\n\n<font color=\'red\'>注意！</font>字符串指针所表示的是字符串常量，并且全局常量和字符串常量都是位于全局/静态变量区，但是，局部常量位于栈区。演示代码如下所示：\n\n```cpp\n#include <stdio.h>\n\n//已初始化的全局变量 --全局区的.data区\nint g_a=10;\nint g_b=12;\n\n//已初始化的全局静态变量   --全局区的.data区 \nstatic int s_g_a=10;\nstatic int s_g_b=10;\n\n//全局常量 全局区\nconst int g_c_a=10;\nconst int g_c_b=11;\n\nvoid test01()\n{\n    //静态局部变量  全局区\n    static int s_a=10;\n    static int s_b=11;\n\n    //局部常量  位于栈区\n    const int l_g_c_a=10;\n    const int l_g_c_b=11;\n\n    printf(\"全局变量g_a的地址是：%p\\n\",&g_a);\n    printf(\"全局变量g_b的地址是：%p\\n\",&g_b);\n\n    printf(\"全局静态变量s_g_a的地址是：%p\\n\",&s_g_a);\n    printf(\"全局静态变量s_g_b的地址是：%p\\n\",&s_g_b);\n\n    printf(\"静态局部变量s_a的地址是：%p\\n\",&s_a);\n    printf(\"静态局部变量s_b的地址是：%p\\n\",&s_b);\n\n    printf(\"全局常量g_a的地址是：%p\\n\",&g_c_a);\n    printf(\"全局常量g_b的地址是：%p\\n\",&g_c_b);\n\n    printf(\"局部常量g_a的地址是：%p\\n\",&l_g_c_a);\n    printf(\"局部常量g_b的地址是：%p\\n\",&l_g_c_b);\n\n    //字符串常量 全局区\n    printf(\"字符串常量的地址是：%p\\n\",&\"Hello1\");\n    printf(\"字符串常量的地址是：%p\\n\",&\"Hello2\");\n}\n\nint main()\n{\n    test01();\n    return 0;\n}\n//测试结果为：\n全局变量g_a的地址是：00404004\n全局变量g_b的地址是：00404008\n全局静态变量s_g_a的地址是：0040400C\n全局静态变量s_g_b的地址是：00404010\n静态局部变量s_a的地址是：00404014\n静态局部变量s_b的地址是：00404018\n全局常量g_a的地址是：00405064\n全局常量g_b的地址是：00405068\n局部常量g_a的地址是：0061FF0C\n局部常量g_b的地址是：0061FF08\n字符串常量的地址是：0040517D\n字符串常量的地址是：0040519C\n```\n\n<font color=\'red\'>有一种说法</font>：程序只分text区、data区、bss区，当程序运行时才会增加堆区和栈区。（linux下查看代码二进制的elf格式)\n**程序启动的过程**：\n1、操作系统首先创建相应的进程并分配私有的进程空间，然后操作系统的加载器负责把可执行文件的数据段和代码段映射到进程的虚拟内存空间中。\n2、加载器读入可执行程序的导入符号表，根据这些符号表可以查找出该可执行程序的所有依赖的动态链接库。\n3、加载器针对该程序的每一个动态链接库调用LoadLibrary\n	（1）查找对应的动态库文件，加载器为该动态链接库确定一个合适的基地址。\n	（2）加载器读取该动态链接库的导入符号表和导出符号表，比较应用程序要求的导入符号是否匹配该库的导出符号。\n	（3）针对该库的导入符号表，查找对应的依赖的动态链接库，如有跳转，则跳到3\n	（4）调用该动态链接库的初始化函数\n4、初始化应用程序的全局变量，对于全局对象自动调用构造函数。\n5、进入应用程序入口点函数开始执行。\n**怎么判断数据分配在栈上还是堆上**：首先局部变量分配在栈上；而通过malloc和new申请的空间是在堆上。\n\n### 2.5 初始化为0的全局变量在bss还是data\n\n答：全局变量和静态变量，初始化了的存入data段，未初始化的存入bss段。\n\n### 2.6 请简述一下atomoic内存顺序\n\n有六个内存顺序选项可应用于对原子类型的操作：\n\nmemory_order_relaxed：在原子类型上的操作以自由序列执行，没有任何同步关系，仅对此操作要求原子性。\n\nmemory_order_consume：memory_order_consume只会对其标识的对象保证该对象存储先行于那些需要加载该对象的操作。\n\nmemory_order_acquire：使用memory_order_acquire的原子操作，当前线程的读写操作都不能重排到此操作之前。\n\nmemory_order_release：使用memory_order_release的原子操作，当前线程的读写操作都不能重排到此操作之后。\n\nmemory_order_acq_rel：memory_order_acq_rel在此内存顺序的读-改-写操作既是获得加载又是释放操作。没有操作能够从此操作之后被重排到此操作之前，也没有操作能够从此操作之前被重排到此操作之后。\n\nmemory_order_seq_cst：memory_order_seq_cst比std::memory_order_acq_rel更为严格。memory_order_seq_cst不仅是一个\"获取释放\"内存顺序，它还会对所有拥有此标签的内存操作建立一个单独全序。\n\n除非你为特定的操作指定一个顺序选项，否则内存顺序选项对于所有原子类型默认都是memory_order_seq_cst。\n\n## 2.7 简述C++中内存对齐的使用场景\n\n内存对齐应用于三种数据类型中：struct/class/union\n\nstruct/class/union内存对齐原则有四个：\n\n>1. 数据成员对齐规则：结构(struct)或联合(union)的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小或者成员的子成员大小的整数倍开始。\n\n>2. 结构体作为成员:如果一个结构里有某些结构体成员,则结构体成员要从其内部\"最宽基本类型成员\"的整数倍地址开始存储。(struct a里存有struct b,b里有char,int ,double等元素,那b应该从8的整数倍开始存储)。\n\n>3. 收尾工作:结构体的总大小，也就是sizeof的结果，必须是其内部最大成员的\"最宽基本类型成员\"的整数倍。不足的要补齐。(基本类型不包括struct/class/uinon)。\n\n>4. sizeof(union)，以结构里面size最大元素为union的size，因为在某一时刻，union只有一个成员真正存储于该地址。\n\n补充说明：\n\n1. **什么是字节对齐**\n\n那么什么是字节对齐？在C语言中，结构体是一种复合数据类型，其构成元素既可以是基本数据类型（如int、long、float等）的变量，也可以是一些复合数据类型（如数组、结构体、联合体等）的数据单元。在结构体中，编译器为结构体的每个成员按其自然边界（alignment）分配空间。各个成员按照它们被声明的顺序在内存中顺序存储，第一个成员的地址和整个结构体的地址相同。\n\n为了使CPU能够对变量进行快速的访问，变量的起始地址应该具有某些特性，即所谓的“对齐”，比如4字节的int型，其起始地址应该位于4字节的边界上，即起始地址能够被4整除，也即“对齐”跟数据在内存中的位置有关。如果一个变量的内存地址正好位于它长度的整数倍，他就被称做自然对齐。\n\n比如在32位cpu下，假设一个整型变量的地址为0x00000004(为4的倍数)，那它就是自然对齐的，而如果其地址为0x00000002（非4的倍数）则是非对齐的。现代计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。\n\n2. **为什么要字节对齐**\n\n需要字节对齐的根本原因在于CPU访问数据的效率问题。假设上面整型变量的地址不是自然对齐，比如为0x00000002，则CPU如果取它的值的话需要访问两次内存，第一次取从0x00000002-0x00000003的一个short，第二次取从0x00000004-0x00000005的一个short然后组合得到所要的数据，如果变量在0x00000003地址上的话则要访问三次内存，第一次为char，第二次为short，第三次为char，然后组合得到整型数据。\n\n而如果变量在自然对齐位置上，则只要一次就可以取出数据。一些系统对对齐要求非常严格，比如sparc系统，如果取未对齐的数据会发生错误，而在x86上就不会出现错误，只是效率下降。\n\n各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。比如有些平台每次读都是从偶地址开始，如果一个int型（假设为32位系统）如果存放在偶地址开始的地方，那么一个读周期就可以读出这32bit，而如果存放在奇地址开始的地方，就需要2个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该32bit数据。显然在读取效率上下降很多。\n\n3. **字节对齐实例**：\n\n```cpp\nunion example {  \n    int a[5];  \n    char b;  \n    double c;  \n};  \nint result = sizeof(example);  \n/*\n联合体只取最长的，int a[5]，长度为20，字节对齐为24\n*/\n\nstruct example {  \n    int a[5];  \n    char b;  \n    double c;  \n}test_struct;\nint result = sizeof(test_struct);  \n/*\nstruct总和 int 20 分为 8 8 4 char 1 double 8 最大对齐8 char补充到int的4 所以为 8+8+8（4+1）+8（double），总计32\n*/\n\nstruct example {  \n    char b;  \n    double c;  \n    int a;  \n}test_struct;  \nint result = sizeof(test_struct);  \n/*\n字节对齐除了内存起始地址要是数据类型的整数倍以外，还要满足一个条件，那就是占用的内存空间大小需要是结构体中占用最大内存空间的类型的整数倍，所以20不是double（8Byte）的整数倍，我们还要扩充四个字节，最后的结果是result=24\n*/\n```\n\n## 3、C++面向对象\n\n### 3.1 简述一下什么是面向对象\n\n1. 面向对象是一种编程思想，把一切东西看成是一个个对象，比如人、耳机、鼠标、水杯等，他们各自都有属性，比如：耳机是白色的，鼠标是黑色的，水杯是圆柱形的等等，把这些对象拥有的属性变量和操作这些属性变量的函数打包成一个类来表示\n\n2. 面向过程和面向对象的区别\n\n面向过程：根据业务逻辑从上到下写代码\n\n面向对象：将数据与函数绑定到一起，进行封装，这样能够更快速的开发程序，减少了重复代码的重写过程\n\n### 3.2 简述一下面向对象的三大特征\n\n封装、继承、多态\n\n1. 封装：将数据和操作数据的方法进行有机结合，隐藏对象的属性和实现细节，仅对外公开接口来和对象进行 交互。封装本质上是一种管理：我们如何管理兵马俑呢？比如如果什么都不管，兵马俑就被随意破坏了。那么我们首先建了一座房子把兵马俑给封装起来。但是我们目的全封装起来，不让别人看。所以我们开放了售票通道，可以买票突破封装在合理的监管机制下进去参观。类也是一样，不想给别人看到的，我们使用protected/private把成员封装起来。开放一些公有的成员函数对成员合理的访问。所以封装本质是一种管理。\n\n2. 继承：可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。\n   三种继承关系：\n\n| 继承方式            | private继承     | protected继承     | public继承        |\n| ------------------- | --------------- | ----------------- | ----------------- |\n| 基类的private成员   | 不可见          | 不可见            | 不可见            |\n| 基类的protected成员 | 变为private成员 | 仍为protected成员 | 仍为protected成员 |\n| 基类的public成员    | 变为private成员 | 变为protected成员 | 仍为protected成员 |\n\n3. 多态：用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。实现多态，有二种方式，重写，重载。（虚函数/纯虚函数、函数重载）\n\n### 3.3 简述一下C++的重写与重载，以及他们之间的区别\n\n1、重写\n\n是指派生类中存在重新定义的函数。其函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致。只有函数体不同（花括号内），派生类对象调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有virtual修饰。（虚函数/纯虚函数）\n\n```cpp\n#include<bits/stdC++.h>\n\nusing namespace std;\n\nclass A\n{\npublic:\n    virtual    void fun()\n    {\n        cout << \"A\";\n    }\n};\nclass B :public A\n{\npublic:\n    virtual void fun()\n    {\n        cout << \"B\";\n    }\n};\nint main(void)\n{\n    A* a = new B();\n    a->fun();//输出B，A类中的fun在B类中重写\n}\n```\n\n2、重载\n\n我们在平时写代码中会用到几个函数但是他们的实现功能相同，但是有些细节却不同。例如：交换两个数的值其中包括（int, float,char,double)这些个类型。在C语言中我们是利用不同的函数名来加以区分。这样的代码不美观而且给程序猿也带来了很多的不便。于是在C++中人们提出了用一个函数名定义多个函数，也就是所谓的函数重载。函数重载是指同一可访问区内被声明的几个具有不同参数列（**参数的类型，个数，顺序不同**）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型。\n\n```cpp\n#include<bits/stdC++.h>\n\nusing namespace std;\n\nclass A\n{\n    void fun() {};\n    void fun(int i) {};\n    void fun(int i, int j) {};\n    void fun1(int i,int j){};\n};\n```\n\n### 3.4 C++如何实现重写与重载的？在C语言中怎么实现函数重载？\n\n答1：重写：在基类的函数前加上virual关键字，就可以在派生类中重写该函数，运行时将会根据对象的实际类型来调用对应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数。\n\n>i. 用virtual关键字申明的函数叫做虚函数，虚函数肯定是类的成员函数\n>ii. 存在虚函数的类都有一个一维的虚函数表叫做虚表，类的对象有一个指向虚表开始的虚指针。虚表是和类对应的，虚表指针是和对象对应的\n>iii. 多态性是一个接口多种实现，是面向对象的核心，分为类的多态性和函数的多态性\n>iv. 重写用虚函数来实现，结合动态绑定\n>v. 纯虚函数是虚函数再加上 = 0\n>vi. 抽象类是指包括至少一个纯虚函数的类\n\n纯虚函数：virtual void fun()=0。即抽象类必须在子类实现这个函数，即先有名称，没有内容，在派生类实现内容。而虚函数可以再子类中不实现。还有，仅含有虚函数的类，并不是抽象类。\n\n答2：重载：C++通过命名倾轧（name mangling）技术来改名函数名，区分参数不同的同名函数，命名倾轧是在编译阶段完成的。\n\n题外话：C++在编译阶段通过函数名+形参列表的方式来区分函数，所以可以实现函数重载。而C语言在编译时是以函数名来区分函数的，所以C与C++混编的时候会出现错误。可以在++代码中使用extern{}关键字来保证正确编译。\n\n答3：c语言中不允许有同名函数，因为编译时函数命名是一样的，不像C++会添加参数类型和返回类型作为函数编译后的名称，进而实现重载。如果要用c语言显现函数重载，可通过以下方式来实现：\n\n>1. 使用函数指针来实现，重载的函数不能使用同名称，只是类似的实现了函数重载功能\n>2. 重载函数使用可变参数，方式如打开文件open函数\n>3. gcc有内置函数，程序使用编译函数可以实现函数重载\n\n一般方式1比较常用，示例代码：\n\n```cpp\n#include<stdio.h>\n\nvoid func_int(void * a)\n{\n    printf(\"%d\\n\",*(int*)a);  //输出int类型，注意 void * 转化为int\n}\n\nvoid func_double(void * b)\n{\n    printf(\"%.2f\\n\",*(double*)b);\n}\n\ntypedef void (*ptr)(void *);  //typedef申明一个函数指针\n\nvoid c_func(ptr p,void *param)\n{\n     p(param);                //调用对应函数\n}\n\nint main()\n{\n    int a = 23;\n    double b = 23.23;\n    c_func(func_int,&a);\n    c_func(func_double,&b);\n    return 0;\n}\n```\n\n关于typedef和函数指针的恩怨纠葛，在补充代码如下：\n\n```cpp\n//形式1：返回类型(*函数名)(参数列表)\n#include <iostream>\nusing namespace std;\n//定义一个函数指针pFUN，它指向一个返回类型为char，有一个整型的参数的函数\nchar (*pFun)(int);\n//定义一个返回类型为char，参数为int的函数\n//从指针层面上理解该函数，即函数的函数名实际上是一个指针，\n//该指针指向函数在内存中的首地址\nchar glFun(int a)\n{\n    cout << a;\n    //return a;\n}\nint main()\n{\n//将函数glFun的地址赋值给变量pFun\n    pFun = glFun;\n//*pFun”显然是取pFun所指向地址的内容，当然也就是取出了函数glFun()的内容，然后给定参数为2。\n    (*pFun)(2);\n    return 0;\n}\n\n//形式2 typedef  返回类型(*新类型)(参数表)\n// typedef可以让函数指针更直观方便 ,typedef是新定义了一种类型\ntypedef char (*PTRFUN)(int); \nPTRFUN pFun; \nchar glFun(int a){ return;} \nvoid main() \n{ \n    pFun = glFun; \n    (*pFun)(2); \n}\n```\n\n对于typedef void(\\*T)(void \\*)，我们进行一层层的剖析\n\n1、首先写成 void(\\*T)() 可以看出 T是一个指针，是一个指向返回值为void ，参数为空的类型的函数指针\n\n2、在加上(void \\*)  为 void(\\*T)(void \\*)  就变成了一个指向 返回值为void，参数为void \\*类型的指针\n\n3、在加上上typedef ，加上后，T就不再是一个函数指针了，它代表着一种类型，这种类型可以定义一个 指向 返回值为void，参数为void \\*类型的指针 \n\n4、``比如 T t;``\n\n``void func(void \\*)；``\n\n``t=func ``\n\n### 3.5 构造函数分为哪几种？\n\n默认无参构造函数、拷贝构造函数、有参构造函数（初始化列表或函数体内赋值）、<font color=\'red\'>移动构造函数</font>\n\n需要注意：有参构造中，可细分为初始化列表he函数体内赋值。初始化列表就是在定义变量的同时就给值，函数体内赋值相当于先定义变量，再给值。当类中有成员变量为常量时，必须使用初始化列表。\n\n下面以代码举例，说明拷贝构造函数和移动构造函数：\n\n```cpp\n//拷贝构造函数\nTest(const Test& t)\n    {\n        this->i = t.i;\n        this->p = new int(*t.p);\n    }\n    \n//移动构造函数\nclass Example{\nprivate:\n	string *ptr;\npublic:\n	 //移动构造函数\n	 Example (Example&& x) : ptr(x.ptr) \n    {\n        x.ptr = nullptr;\n    }\n    //拷贝构造函数 深拷贝  区别在于不会处理形参元素x\n    Example (Example& x)\n    {\n    	delete ptr;\n    	ptr=new string(x.ptr);\n    }\n    //有参构造函数\n    Example (const string& str) : ptr(new string(str)) {}\n    //重载赋值运算符\n    Example& operator= (Example6&& x) \n    {\n        delete ptr; \n        ptr = x.ptr;\n        x.ptr=nullptr;\n        return *this;\n    }\n    //打印字符串\n    const string& content() const {return *ptr;}\n    //重载加号运算符：\n    Example operator+(const Example& rhs) \n    {\n        return Example(content()+rhs.content());\n    }\n}；\n```\n\n### 3.6 只定义析构函数，会自动生成哪些构造函数\n\n只定义了析构函数，编译器将自动为我们生成拷贝构造函数和默认构造函数。\n\n注意：有了有参的构造了，编译器就不提供默认的构造函数。\n\n### 3.7 说说一个类，默认会生成哪些函数\n\n定义了一个空类，默认为生成以下几个函数：\n1、无参构造函数\n2、拷贝构造函数（默认的为浅拷贝）\n3、重载赋值运算符\n4、析构函数（非虚）\n\n### 3.8 说说 C++ 类对象的初始化顺序，有多重继承情况下的顺序\n\n1. 创建派生类的对象，基类的构造函数优先被调用（也优先于派生类里的成员类）；\n\n2. 如果类里面有成员类，成员类的构造函数优先被调用；(也优先于该类本身的构造函数）\n\n3. 基类构造函数如果有多个基类，则<font color=\'red\'>构造函数的调用顺序是某类在类派生表中出现的顺序</font>而不是它们在成员初始化表中的顺序；；（即：class 类名：public 基类1，public 基类2）\n\n4. 成员类对象构造函数如果有多个成员类对象，则<font color=\'red\'>构造函数的调用顺序是对象在类中被声明的顺序</font>而不是它们出现在成员初始化表中的顺序；（即：类内变量：类名 变量1；类名 变量2）\n\n5. 派生类构造函数，作为一般规则派生类构造函数应该不能直接向一个基类数据成员赋值而是把值传递给适当的基类构造函数,否则两个类的实现变成紧耦合的（tightly coupled）将更加难于正确地修改或扩展基类的实现。（基类设计者的责任是提供一组适当的基类构造函数）\n\n综上可以得出，初始化顺序：\n\n> 父类构造函数–>成员类对象构造函数–>自身构造函数\n>\n> 其中成员变量的初始化与声明顺序有关，构造函数的调用顺序是类派生列表中的顺序。\n>\n> 析构顺序和构造顺序相反。\n\n代码示例：\n\n```cpp\n#include <iostream>\nusing namespace std;\nclass Base1 {\npublic:\n	Base1(int i)\n	{\n		cout << \"construting Base1——\" << i << endl;\n	}\n	Base1(Base1& b1)\n	{\n		cout << \"Base1 Copy constructor\" << endl;\n	}\n	~Base1()\n	{\n		cout << \"~Base1\" << endl;\n	}\n};\nclass Base2\n{\npublic:\n	Base2(int j)\n	{\n		cout << \"constructing Base2——\" << j << endl;\n	}\n	Base2(Base2& b2)\n	{\n		cout << \"Base2 Copy constructor\" << endl;\n	}\n	~Base2()\n	{\n		cout << \"~Base2\" << endl;\n	}\n};\nclass Derived :public Base1, public Base2\n{\npublic:\n	//Derived(int a, int b, int c, int d) :Base1(b), member2(c), Base2(a), member1(d)\n	Derived(int a, int b, int c, int d) :Base1(a), member2(b), Base2(c), member1(d)\n	{\n		cout << \"constructing Derived\" << endl;\n	}\n	Derived(Derived& d) :Base1(d), member2(d), Base2(d), member1(d)\n	{\n		cout << \"Derived Copy constructor \" << endl;\n	}\n	~Derived()\n	{\n		cout << \"~Derived\" << endl;\n	}\nprivate:\n	Base2 member2; \n	Base1 member1;\n};\n//在派生类中的，基类构造函数的调用顺序是，先看权限继承方式上的顺序：public Base1, public Base2；\n//再看成员变量定义的顺序：Base2 member2; Base1 member1;\nint test()\n{\n	Derived d1(1, 2, 3, 4);\n	Derived d2(d1);\n	return 0;\n}\nint main()\n{\n	test();\n	system(\"pause\");\n	return 0;\n}\n//输出结果为：\nconstruting Base1——1\nconstructing Base2——3\nconstructing Base2——2\nconstruting Base1——4\nconstructing Derived\nBase1 Copy constructor\nBase2 Copy constructor\nBase2 Copy constructor\nBase1 Copy constructor\nDerived Copy constructor\n~Derived\n~Base1\n~Base2\n~Base2\n~Base1\n~Derived\n~Base1\n~Base2\n~Base2\n~Base1\n```\n\n### 3.9 简述下向上转型和向下转型\n\n1. 子类转换为父类：向上转型，使用dynamic_cast(expression)，这种转换相对来说比较安全不会有数据的丢失；\n\n2. 父类转换为子类：向下转型，可以使用强制转换，这种转换时不安全的，会导致数据的丢失，原因是父类的指针或者引用的内存中可能不包含子类的成员的内存。\n\n### 3.10 简述下深拷贝和浅拷贝，如何实现深拷贝\n\n1. 浅拷贝：又称值拷贝，将源对象的值拷贝到目标对象中去，本质上来说源对象和目标对象共用一份实体，只是所引用的变量名不同，地址其实还是相同的。举个简单的例子，你的小名叫西西，大名叫冬冬，当别人叫你西西或者冬冬的时候你都会答应，这两个名字虽然不相同，但是都指的是你。\n\n2. 深拷贝，拷贝的时候先开辟出和源对象大小一样的空间，然后将源对象里的内容拷贝到目标对象中去，这样两个指针就指向了不同的内存位置。并且里面的内容是一样的，这样不但达到了我们想要的目的，还不会出现问题，两个指针先后去调用析构函数，分别释放自己所指向的位置。即为每次增加一个指针，便申请一块新的内存，并让这个指针指向新的内存，深拷贝情况下，不会出现重复释放同一块内存的错误。\n\n### 3.11 简述一下C++中的多态\n\n由于派生类重写基类方法，然后用基类引用指向派生类对象，调用方法时候会进行动态绑定，这就是多态。 多态分为静态多态和动态多态：\n\n1. 静态多态：编译器在编译期间完成的，编译器会根据实参类型来推断该调用哪个函数，如果有对应的函数，就调用，没有则在编译时报错。例如：\n\n```cpp\ninclude<iostream>\nusing namespace std;\n\nint Add(int a,int b)//1\n{\n    return a+b;\n}\n\nchar Add(char a,char b)//2\n{\n    return a+b;\n}\n\nint main()\n{\n    cout<<Add(666,888)<<endl;//1\n    cout<<Add(\'1\',\'2\');//2\n    return 0;\n}\n```\n\n静态多态，就是在编译阶段就实现的多态。\n\n2. 动态多态：其实要实现动态多态，需要几个条件----即动态绑定条件：\n\n> 虚函数，基类必须含有虚函数，派生类必须重写虚函数；\n> 通过基类指针或引用来调用虚函数\n\n### 3.12 为什么要虚析构，为什么不能虚构造？\n\n1. 为什么要虚析构：将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。如果基类的析构函数不是虚函数，在特定情况下会导致派生类无法被析构。\n\n> i. 用派生类类型指针绑定派生类实例，析构的时候，不管基类析构函数是不是虚函数，都会正常析构\n>\n> ii. 用基类类型指针绑定派生类实例，析构的时候，如果基类析构函数不是虚函数，则只会析构基类，不会析构派生类对象，从而造成内存泄漏。为什么会出现这种现象呢，个人认为析构的时候如果没有虚函数的动态绑定功能，就只根据指针的类型来进行的，而不是根据指针绑定的对象来进行，所以只是调用了基类的析构函数；如果基类的析构函数是虚函数，则析构的时候就要根据指针绑定的对象来调用对应的析构函数了。\n\nC++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。\n\n2. 为什么不能虚构造？\n\ni. 从存储空间角度：虚函数对应一个vtable,这个表的地址是存储在对象的内存空间的。如果将构造函数设置为虚函数，就需要到vtable 中调用，可是对象还没有实例化，没有内存空间分配，如何调用。（悖论）\n\nii. 从使用角度：虚函数主要用于在信息不全的情况下，能使重载的函数得到对应的调用。构造函数本身就是要初始化实例，那使用虚函数也没有实际意义呀。所以构造函数没有必要是虚函数。虚函数的作用在于通过父类的指针或者引用来调用它的时候能够变成调用子类的那个成员函数。而构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数。\n\niii. 从实现上看，vtable 在构造函数调用后才建立，因而构造函数不可能成为虚函数。从实际含义上看，在调用构造函数时还不能确定对象的真实类型（因为子类会调父类的构造函数）；而且构造函数的作用是提供初始化，在对象生命期只执行一次，不是对象的动态行为，也没有太大的必要成为虚函数。\n\n### 3.13 说说模板类是在什么时候实现的\n\n1. 模板实例化：模板的实例化分为显式实例化和隐式实例化，前者是研发人员明确的告诉模板应该使用什么样的类型去生成具体的类或函数，后者是在编译的过程中由编译器来决定使用什么类型来实例化一个模板。不管是显式实例化或隐式实例化，最终生成的类或函数完全是按照模板的定义来实现的\n\n2. 模板具体化：当模板使用某种类型实例化后生成的类或函数不能满足需要时，可以考虑对模板进行具体化。具体化时可以修改原模板的定义，当使用该类型时，按照具体化后的定义实现，具体化相当于对某种类型进行特殊处理。<font color=\'blue\'>模板的具体化，就是重写模板</font>>\n\n代码示例：\n\n```cpp\n#include <iostream>\nusing namespace std;\n\n// #1 模板定义\ntemplate<class T>\nstruct TemplateStruct\n{\n    TemplateStruct()\n    {\n        cout << sizeof(T) << endl;\n    }\n};\n\n// #2 模板显示实例化\ntemplate struct TemplateStruct<int>;\n\n// #3 模板具体化\ntemplate<> struct TemplateStruct<double>\n{\n    TemplateStruct() {\n        cout << \"--8--\" << endl;\n    }\n};\n\nint main()\n{\n    TemplateStruct<int> intStruct;\n    TemplateStruct<double> doubleStruct;\n\n    // #4 模板隐式实例化\n    TemplateStruct<char> llStruct;\n}\n//输出结果为：\n4\n--8--\n1\n```\n\n### 3.14 说说类继承时，派生类对不同关键字修饰的基类方法的访问权限\n\n类中的成员可以分为三种类型，分别为public成员、protected成员、public成员。类中可以直接访问自己类的public、protected、private成员，但类对象只能访问自己类的public成员。\n\n1. public继承：派生类可以访问基类的public、protected成员，不可以访问基类的private成员；\n   派生类对象可以访问基类的public成员，不可以访问基类的protected、private成员。\n\n2. protected继承：派生类可以访问基类的public、protected成员，不可以访问基类的private成员；\n   派生类对象不可以访问基类的public、protected、private成员。\n\n3. private继承：派生类可以访问基类的public、protected成员，不可以访问基类的private成员；\n   派生类对象不可以访问基类的public、protected、private成员。\n\n### 3.15 简述一下移动构造函数，什么库用到了这个函数？\n\nC++11中新增了移动构造函数。与拷贝类似，移动也使用一个对象的值设置另一个对象的值。但是，又与拷贝不同的是，移动实现的是对象值真实的转移（源对象到目的对象）：源对象将丢失其内容，其内容将被目的对象占有。移动操作的发生的时候，是当移动值的对象是未命名的对象的时候。这里未命名的对象就是那些临时变量，甚至都不会有名称。典型的未命名对象就是函数的返回值或者类型转换的对象。使用临时对象的值初始化另一个对象值，不会要求对对象的复制：因为临时对象不会有其它使用，因而，它的值可以被移动到目的对象。做到这些，就要使用移动构造函数和移动赋值：当使用一个临时变量对对象进行构造初始化的时候，调用移动构造函数。类似的，使用未命名的变量的值赋给一个对象时，调用移动赋值操作。\n\n移动操作的概念对对象管理它们使用的存储空间很有用的，诸如对象使用new和delete分配内存的时候。在这类对象中，拷贝和移动是不同的操作：从A拷贝到B意味着，B分配了新内存，A的整个内容被拷贝到为B分配的新内存上。\n\n而从A移动到B意味着分配给A的内存转移给了B，没有分配新的内存，它仅仅包含简单地拷贝指针。\n\n看下面的例子：\n\n```cpp\n// 移动构造函数和赋值\n#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Example6 {\nprivate:\n    string* ptr;\npublic:\n    Example6 (const string& str) : ptr(new string(str)) {}\n    ~Example6 () {delete ptr;}\n    // 移动构造函数，参数x不能是const Pointer&& x，\n    // 因为要改变x的成员数据的值；\n    // C++98不支持，C++0x（C++11）支持\n    Example6 (Example6&& x) : ptr(x.ptr) \n    {\n        x.ptr = nullptr;\n    }\n    // move assignment\n    Example6& operator= (Example6&& x) \n    {\n        delete ptr; \n        ptr = x.ptr;\n        x.ptr=nullptr;\n        return *this;\n    }\n    // access content:\n    const string& content() const {return *ptr;}\n    // addition:\n    Example6 operator+(const Example6& rhs) \n    {\n        return Example6(content()+rhs.content());\n    }\n};\nint main () {\n    Example6 foo(\"Exam\");           // 构造函数\n    Example6 bar(move(foo));     // 移动构造函数\n                                // 调用move之后，foo变为一个右值引用变量，\n                                // 此时，foo所指向的字符串已经被\"掏空\"，\n                                // 所以此时不能再调用foo\n	Example6 bar2 = Example6(\"ple\"); // 拷贝构造函数\n    bar = bar+ bar2;             // 移动赋值，在这儿\"=\"号右边的加法操作，\n                                // 产生一个临时值，即一个右值\n                                 // 所以此时调用移动赋值语句\n    cout << \"bar\'s content: \" << bar.content() << \'\\n\';\n    return 0;\n}\n//说明：std::move()函数时C++11新增的，用于将一个左值引用转换为右值引用。\n//输出结果为：bar`s content: Example\n//附加说明：本例中，如何调用重载赋值运算符：Example6 str2=move(bar);此时，bar字符串被删除内存，str2=Example\n```\n\n### 3.16 请你回答一下 C++ 类内可以定义引用数据成员吗？\n\nC++类内可以定义引用成员变量，但要遵循以下三个规则：\n\n1. 不能用默认构造函数初始化，必须提供构造函数，用初始化列表的方式来初始化引用成员变量。否则会造成引用未初始化错误。\n\n2. 构造函数的形参也必须是引用类型。\n\n3. 不能在构造函数里初始化，必须在初始化列表中进行初始化。\n\n### 3.17 简述一下什么是常函数，有什么作用\n\n类的成员函数后面加 const，表明这个函数不会对这个类对象的数据成员（准确地说是非静态数据成员）作任何改变。在设计类的时候，一个原则就是对于不改变数据成员的成员函数都要在后面加const，而对于改变数据成员的成员函数不能加 const。所以 const 关键字对成员函数的行为作了更明确的限定：有 const 修饰的成员函数（指 const 放在函数参数表的后面，而不是在函数前面或者参数表内），只能读取数据成员，不能改变数据成员；没有 const 修饰的成员函数，对数据成员则是可读可写的。除此之外，在类的成员函数后面加 const 还有什么好处呢？那就是**常量（即 const）对象可以调用 const 成员函数，而不能调用非const修饰的函数**。正如非const类型的数据可以给const类型的变量赋值一样，反之则不成立。\n\n```cpp\n#include<iostream>\nusing namespace std;\n\nclass CStu\n{\npublic:\n    int a;\n    CStu()\n    {\n        a = 12;\n    }\n\n    void Show() const\n    {\n        //a = 13; //常函数不能修改数据成员\n        cout <<a << \"I am show()\" << endl;\n    }\n};\n\nint main()\n{\n    CStu st;\n    st.Show();\n    system(\"pause\");\n    return 0;\n}\n```\n\n### 3.18 说说什么是虚继承，解决什么问题，如何实现？\n\n虚继承是解决C++多重继承问题的一种手段，从不同途径继承来的同一基类，会在子类中存在多份拷贝。这将存在两个问题：其一，浪费存储空间；第二，存在二义性问题，通常可以将派生类对象的地址赋值给基类对象，实现的具体方式是，将基类指针指向继承类（继承类有基类的拷贝）中的基类对象的地址，但是多重继承可能存在一个基类的多份拷贝，这就出现了二义性。虚继承可以解决多种继承前面提到的两个问题（即菱形继承问题）\n\n```cpp\n#include<iostream>\nusing namespace std;\nclass A{\npublic:\n    int _a;\n};\nclass B :virtual public A\n{\npublic:\n    int _b;\n};\nclass C :virtual public A\n{\npublic:\n    int _c;\n};\nclass D :public B, public C\n{\npublic:\n    int _d;\n};\n//菱形继承和菱形虚继承的对象模型\nint main()\n{\n    D d;\n    d.B::_a = 1;\n    d.C::_a = 2;\n    d._b = 3;\n    d._c = 4;\n    d._d = 5;\n    cout << sizeof(D) << endl;\n    return 0;\n}\n```\n\n分别从菱形继承和虚继承来分析：\n\n>菱形继承中A在B,C,D,中各有一份，虚继承中，A共享。\n>\n>上面的虚继承表实际上是一个指针数组。B、C实际上是虚基表指针，指向虚基表。\n>\n>虚基表：存放相对偏移量，用来找虚基类\n\n### 3.19 简述一下虚函数和纯虚函数，以及实现原理\n\n1. C++中的虚函数的作用主要是实现了多态的机制。关于多态，简而言之就是用父类型的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。这种技术可以让父类的指针有“多种形态”，这是一种泛型技术。**如果调用非虚函数，则无论实际对象是什么类型，都执行基类类型所定义的函数**。非虚函数总是在编译时根据调用该函数的对象，引用或指针的类型而确定。如果调用虚函数，则直到运行时才能确定调用哪个函数，运行的虚函数是引用所绑定或指针所指向的对象所属类型定义的版本。虚函数必须是基类的非静态成员函数。虚函数的作用是实现动态联编，也就是在程序的运行阶段动态地选择合适的成员函数，在定义了虚函数后，可以在基类的派生类中对虚函数重新定义，在派生类中重新定义的函数应与虚函数具有相同的形参个数和形参类型。以实现统一的接口，不同定义过程。如果在派生类中没有对虚函数重新定义，则它继承其基类的虚函数。\n\n\n```cpp\nclass Person{\n    public:\n        //虚函数\n        virtual void GetName(){\n            cout<<\"PersonName:xiaosi\"<<endl;\n        };\n};\nclass Student:public Person{\n    public:\n        void GetName(){\n            cout<<\"StudentName:xiaosi\"<<endl;\n        };\n};\nint main(){\n    //指针\n    Person *person = new Student();\n    //基类调用子类的函数\n    person->GetName();//StudentName:xiaosi\n}\n```\n\n虚函数（Virtual Function）是通过一张虚函数表（Virtual Table）来实现的。简称为V-Table。在这个表中，主是要一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，保证其真实反应实际的函数。这样，在有虚函数的类的实例中这个表被分配在了这个实例的内存中，所以，当我们用父类的指针来操作一个子类的时候，这张虚函数表就显得尤为重要了，它就像一个地图一样，指明了实际所应该调用的函数。\n\n\n2. 纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加“=0” virtualvoid GetName() =0。在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。为了解决上述问题，将函数定义为纯虚函数，则编译器要求在派生类中必须予以重写以实现多态性。同时含有纯虚拟函数的类称为抽象类，它不能生成对象。这样就很好地解决了上述两个问题。将函数定义为纯虚函数能够说明，该函数为后代类型提供了可以覆盖的接口，但是这个类中的函数绝不会调用。声明了纯虚函数的类是一个抽象类。所以，用户不能创建类的实例，只能创建它的派生类的实例。必须在继承类中重新声明函数（不要后面的＝0）否则该派生类也不能实例化，而且它们在抽象类中往往没有定义。定义纯虚函数的目的在于，使派生类仅仅只是继承函数的接口。纯虚函数的意义，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但类无法为纯虚函数提供一个合理的缺省实现。所以类纯虚函数的声明就是在告诉子类的设计者，“你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它”。\n\n```cpp\n//抽象类\nclass Person{\n    public:\n        //纯虚函数\n        virtual void GetName()=0;\n};\nclass Student:public Person{\n    public:\n        Student(){\n        };\n        void GetName(){\n            cout<<\"StudentName:xiaosi\"<<endl;\n        };\n};\nint main(){\n    Student student;\n}\n```\n\n### 3.20 说说纯虚函数能实例化吗，为什么？派生类要实现吗，为什么？\n\n1. 纯虚函数不可以实例化，但是可以用其派生类实例化，示例如下：\n\n```cpp\nclass Base\n{\npublic:\n    virtual void func() = 0;\n};\n```\n\n```cpp\n #include<iostream>\n\n using namespace std;\n\n class Base\n {\n public:\n     virtual void func() = 0;\n };\n\n class Derived :public Base\n {\n public:\n     void func() override\n     {\n         cout << \"哈哈\" << endl;\n     }\n };\n\n int main()\n {\n     Base *b = new Derived();\n     b->func();\n\n     return 0;\n }\n\n```\n\n2. 虚函数的原理采用 vtable。类中含有纯虚函数时，其vtable 不完全，有个空位。\n   即“纯虚函数在类的vtable表中对应的表项被赋值为0。也就是指向一个不存在的函数。由于编译器绝对不允许有调用一个不存在的函数的可能，所以该类不能生成对象。在它的派生类中，除非重写此函数，否则也不能生成对象。”\n\n   所以纯虚函数不能实例化。\n\n3. 纯虚函数是在基类中声明的虚函数，它要求任何派生类都要定义自己的实现方法，以实现多态性。\n\n4. 定义纯虚函数是为了实现一个接口，用来规范派生类的行为，也即规范继承这个类的程序员必须实现这个函数。派生类仅仅只是继承函数的接口。纯虚函数的意义在于，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但基类无法为纯虚函数提供一个合理的缺省实现。所以类纯虚函数的声明就是在告诉子类的设计者，“你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它”。\n\n### 3.21 说说C++中虚函数与纯虚函数的区别\n\n答：\n\n1. 虚函数和纯虚函数可以定义在同一个类中，含有纯虚函数的类被称为抽象类，而只含有虚函数的类不能被称为抽象类。\n\n2. 虚函数可以被直接使用，也可以被子类重载以后，以多态的形式调用，而纯虚函数必须在子类中实现该函数才可以使用，因为纯虚函数在基类有声明而没有定义。\n\n3. 虚函数和纯虚函数都可以在子类中被重载，以多态的形式被调用。\n\n4. 虚函数和纯虚函数通常存在于抽象基类之中，被继承的子类重载，目的是提供一个统一的接口。\n\n5. 虚函数的定义形式：`virtual{}`;纯虚函数的定义形式：`virtual {} = 0`;在虚函数和纯虚函数的定义中不能有static标识符，原因很简单，被static修饰的函数在编译时要求前期绑定,然而虚函数却是动态绑定，而且被两者修饰的函数生命周期也不一样。\n\n举个虚函数的例子：\n\n```cpp\nclass A\n{\npublic:\n    virtual void foo()\n    {\n        cout<<\"A::foo() is called\"<<endl;\n    }\n};\nclass B:public A\n{\npublic:\n    void foo()\n    {\n        cout<<\"B::foo() is called\"<<endl;\n    }\n};\nint main(void)\n{\n    A *a = new B();\n    a->foo();   // 在这里，a虽然是指向A的指针，但是被调用的函数(foo)却是B的!\n    return 0;\n}\n```\n\n这个例子是虚函数的一个典型应用，通过这个例子，也许你就对虚函数有了一些概念。它虚就虚在所谓“推迟联编”或者“动态联编”上，一个类函数的调用并不是在编译时刻被确定的，而是在运行时刻被确定的。由于编写代码的时候并不能确定被调用的是基类的函数还是哪个派生类的函数，所以被成为“虚”函数。\n\n虚函数只能借助于指针或者引用来达到多态的效果。\n\n\n2. 纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加“=0” 。形如`virtual void funtion1()=0`\n\n为了方便使用多态特性，我们常常需要在基类中定义虚拟函数。\n\n在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。\n\n为了解决上述问题，引入了纯虚函数的概念，将函数定义为纯虚函数（方法：virtual ReturnType Function()= 0;），则编译器要求在派生类中必须予以重写以实现多态性。同时含有纯虚拟函数的类称为抽象类，它不能生成对象。这样就很好地解决了上述两个问题。\n声明了纯虚函数的类是一个抽象类。所以，用户不能创建类的实例，只能创建它的派生类的实例。\n\n纯虚函数最显著的特征是：它们必须在继承类中重新声明函数（不要后面的＝0，否则该派生类也不能实例化），而且它们在抽象类中往往没有定义。\n\n定义纯虚函数的目的在于，使派生类仅仅只是继承函数的接口。\n\n纯虚函数的意义，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但类无法为纯虚函数提供一个合理的缺省实现。所以类纯虚函数的声明就是在告诉子类的设计者，“你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它”。\n\n### 3.22 说说 C++ 中什么是菱形继承问题，如何解决\n\n使用虚继承来解决该问题\n\n```cpp\nclass Tiger : virtual public Animal { /* ... */ };\nclass Lion : virtual public Animal { /* ... */ }\n```\n\n### 3.23 请问构造函数中的能不能调用虚方法\n\n不要在构造函数中调用虚方法，从语法上讲，调用完全没有问题，但是从效果上看，往往不能达到需要的目的。\n\n派生类对象构造期间进入基类的构造函数时，对象类型变成了基类类型，而不是派生类类型。\n\n同样，进入基类析构函数时，对象也是基类类型。\n\n所以，虚函数始终仅仅调用基类的虚函数（如果是基类调用虚函数），不能达到多态的效果，所以放在构造函数中是没有意义的，而且往往不能达到本来想要的效果。\n\n### 3.24 请问拷贝构造函数的参数是什么传递方式，为什么\n\n1. 拷贝构造函数的参数必须使用引用传递\n\n2. 如果拷贝构造函数中的参数不是一个引用，即形如CClass(const CClass c_class)，那么就相当于采用了传值的方式(pass-by-value)，而传值的方式会调用该类的拷贝构造函数，从而造成无穷递归地调用拷贝构造函数。因此拷贝构造函数的参数必须是一个引用。\n\n需要澄清的是，传指针其实也是传值，如果上面的拷贝构造函数写成CClass(const CClass\\* c_class)，也是不行的。事实上，只有传引用不是传值外，其他所有的传递方式都是传值。\n\n### 3.25 如何理解抽象类？\n\n1. 抽象类的定义如下：\n\n纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加“=0”，有虚函数的类就叫做抽象类。\n\n2. 抽象类有如下几个特点：\n\n1）抽象类只能用作其他类的基类，不能建立抽象类对象。\n\n2）抽象类不能用作参数类型、函数返回类型或显式转换的类型。\n\n3）可以定义指向抽象类的指针和引用，此指针可以指向它的派生类，进而实现多态性。\n\n### 3.26 什么是多态？除了虚函数，还有什么方式能实现多态？\n\n1. 多态是面向对象的重要特性之一，它是一种行为的封装，就是不同对象对同一行为会有不同的状态。(举例 : 学生和成人都去买票时,学生会打折,成人不会)\n\n2. 多态是以封装和继承为基础的。在C++中多态分为静态多态（早绑定）和动态多态（晚绑定）两种，其中动态多态是通过虚函数实现，静态多态通过函数重载实现，代码如下：\n\n```cpp\nclass A\n{\npublic:    \n    void do(int a);    \n    void do(int a, int b);\n};\n```\n\n### 3.27 简述一下虚析构函数，什么作用\n\n1. 虚析构函数，是将基类的析构函数声明为virtual，举例如下：\n\n```cpp\nclass TimeKeeper\n{\npublic:    \n    TimeKeeper() {}        \n    virtual ~TimeKeeper() {}    \n};\n```\n\n2. 虚析构函数的主要作用是防止内存泄露。\n\n定义一个基类的指针p，在delete p时，如果基类的析构函数是虚函数，这时只会看p所赋值的对象，如果p赋值的对象是派生类的对象，就会调用派生类的析构函数（毫无疑问，在这之前也会先调用基类的构造函数，在调用派生类的构造函数，然后调用派生类的析构函数，基类的析构函数，所谓先构造的后释放）；如果p赋值的对象是基类的对象，就会调用基类的析构函数，这样就不会造成内存泄露。\n\n如果基类的析构函数不是虚函数，在delete p时，调用析构函数时，只会看指针的数据类型，而不会去看赋值的对象，这样就会造成内存泄露。\n\n说明：\n我们创建一个TimeKeeper基类和一些及其它的派生类作为不同的计时方法：\n\n```cpp\nclass TimeKeeper\n{\npublic:\n    TimeKeeper() {}\n    ~TimeKeeper() {}  //非virtual的\n};\n\n//都继承与TimeKeeper\nclass AtomicClock :public TimeKeeper{};\nclass WaterClock :public TimeKeeper {};\nclass WristWatch :public TimeKeeper {};\n```\n\n如果客户想要在程序中使用时间，不想操作时间如何计算等细节，这时候我们可以设计factory（工厂）函数，让函数返回指针指向一个计时对象。该函数返回一个基类指针，这个基类指针是指向于派生类对象的\n\n```cpp\nTimeKeeper* getTimeKeeper()\n{\n    //返回一个指针，指向一个TimeKeeper派生类的动态分配对象\n}\n```\n\n因为函数返回的对象存在于堆中，因此为了在不使用时我们需要使用释放该对象（delete）\n\n```cpp\nTimeKeeper* ptk = getTimeKeeper();\ndelete ptk;\n```\n\n**此处基类的析构函数是非virtual的，因此通过一个基类指针删除派生类对象是错误的**\n\n<font color=\'red\'>解决办法</font>： 将基类的析构函数改为virtual就正确了\n\n```cpp\nclass TimeKeeper\n{\npublic:\n    TimeKeeper() {}\n    virtual ~TimeKeeper() {}\n};\n```\n\n声明为virtual之后，通过基类指针删除派生类对象就会释放整个对象（基类+派生类）\n\n### 3.28 说说什么是虚基类，可否被实例化？\n\n1. 在被继承的类前面加上virtual关键字，这时被继承的类称为虚基类，代码如下：\n\n```cpp\nclass A\nclass B1:public virtual A;\nclass B2:public virtual A;\nclass D:public B1,public B2;\n```\n\n2. 虚继承的类可以被实例化，举例如下：\n\n```cpp\nclass Animal {/* ... */ };\nclass Tiger : virtual public Animal { /* ... */ };\nclass Lion : virtual public Animal { /* ... */ }\n```\n\n```cpp\nint main( )\n{\nLiger lg ;\n/*既然我们已经在Tiger和Lion类的定义中声明了\"virtual\"关键字，于是下面的代码编译OK */\nint weight = lg.getWeight();\n}\n```\n\n### 3.29  简述一下拷贝赋值和移动赋值？\n\n1. 拷贝赋值是通过拷贝构造函数来赋值，在创建对象时，使用同一类中之前创建的对象来初始化新创建的对象。\n\n2. 移动赋值是通过移动构造函数来赋值，二者的主要区别在于\n\n1）拷贝构造函数的形参是一个左值引用，而移动构造函数的形参是一个右值引用；\n\n2）拷贝构造函数完成的是整个对象或变量的拷贝，而移动构造函数是生成一个指针指向源对象或变量的地址，接管源对象的内存，相对于大量数据的拷贝**节省时间和内存空间**。\n\n### 3.30 仿函数了解吗？有什么作用\n\n1. 仿函数（functor）又称为函数对象（function object）**是一个能行使函数功能的类**。仿函数的语法几乎和我们普通的函数调用一样，不过作为仿函数的类，都<font color=\'red\'>必须重载operator()运算符</font>，举个例子：\n\n ```cpp\n class Func{\n     public:\n         void operator() (const string& str) const {\n             cout<<str<<endl;\n         }\n };\n Func myFunc;\n myFunc(\"helloworld!\");\n//输出：\nhelloworld!\n ```\n\n2. 仿函数既能想普通函数一样传入给定数量的参数，还能存储或者处理更多我们需要的有用信息。我们可以举个例子：\n\n假设有一个`vector<string>`，你的任务是统计长度小于5的string的个数，如果使用count_if函数的话，你的代码可能长成这样：\n\n```cpp\n  bool LengthIsLessThanFive(const string& str) {\n       return str.length()<5;   \n  }\nint res=count_if(vec.begin(), vec.end(), LengthIsLessThanFive);\n其中count_if函数的第三个参数是一个函数指针，返回一个bool类型的值。一般的，如果需要将特定的阈值长度也传入的话，我们可能将函数写成这样：\n```cpp\n bool LenthIsLessThan(const string& str, int len) {\n      return str.length()<len;\n  }\n```\n\n这个函数看起来比前面一个版本更具有一般性，但是他不能满足count_if函数的参数要求：count_if要求的是unary function（仅带有一个参数）作为它的最后一个参数。如果我们使用仿函数，是不是就豁然开朗了呢：\n\n```cpp\n  class ShorterThan {\n      public:\n          explicit ShorterThan(int maxLength) : length(maxLength) {}\n          bool operator() (const string& str) const {\n              return str.length() < length;\n          }\n      private:\n          const int length;\n  };\n```\n\n### 3.31 C++ 中哪些函数不能被声明为虚函数？\n\n常见的不不能声明为虚函数的有：**普通函数（非成员函数），静态成员函数，内联成员函数，构造函数，友元函数**。\n\n1. 为什么C++不支持普通函数为虚函数？\n\n普通函数（非成员函数）只能被overload(重载)，不能被override(重写)，声明为虚函数也没有什么意思，因此编译器会在编译时绑定函数。\n\n2. 为什么C++不支持构造函数为虚函数？\n\n这个原因很简单，主要是从语义上考虑，所以不支持。因为构造函数本来就是为了明确初始化对象成员才产生的，然而virtual function主要是为了再不完全了解细节的情况下也能正确处理对象。另外，virtual函数是在不同类型的对象产生不同的动作，现在对象还没有产生，如何使用virtual函数来完成你想完成的动作。（这不就是典型的悖论）\n\n构造函数用来创建一个新的对象,而虚函数的运行是建立在对象的基础上,在构造函数执行时,对象尚未形成,所以不能将构造函数定义为虚函数\n\n3. 为什么C++不支持内联成员函数为虚函数？\n\n内联函数就是为了在代码中直接展开，减少函数调用花费的代价，而虚函数是为了在继承后对象能够准确的执行自己的动作，这是不可能统一的。（再说了，inline函数在编译时被展开，虚函数在运行时才能动态的绑定函数）\n\n内联函数是在编译时期展开,而虚函数的特性是运行时才动态联编,所以两者矛盾,不能定义内联函数为虚函数\n\n4. 为什么C++不支持静态成员函数为虚函数？\n\n这也很简单，静态成员函数对于每个类来说只有一份代码，所有的对象都共享这一份代码，他也没有要动态绑定的必要性。\n\n静态成员函数属于一个类而非某一对象,没有this指针,它无法进行对象的判别\n\n5. 为什么C++不支持友元函数为虚函数？\n\n因为C++不支持友元函数的继承，对于没有继承特性的函数没有虚函数的说法。\n\n### 3.32 解释下 C++ 中类模板和模板类的区别\n\n1. 类模板是模板的定义，不是一个实实在在的类，定义中用到通用类型参数\n\n2. 模板类是实实在在的类定义，是类模板的实例化。类定义中参数被实际类型所代替。\n\n答案解析\n\n1. 类模板的类型参数可以有一个或多个，每个类型前面都必须加class或typename，如template <class T1,class T2>class someclass{…};在定义对象时分别代入实际的类型名，如 someclass<int,double> obj;\n\n2. 和使用类一样，使用类模板时要注意其作用域，只能在其有效作用域内用它定义对象。\n\n3. 模板可以有层次，一个类模板可以作为基类，派生出派生模板类。\n\n### 3.33 虚函数表里存放的内容是什么时候写进去的？\n\n1. 虚函数表是一个存储虚函数地址的数组,以NULL结尾。虚表（vtable）在**编译阶段生成**，对象内存空间开辟以后，写入对象中的 v_ptr，然后调用构造函数。即：虚表在构造函数之前写入。\n\n2. 除了在构造函数之前写入之外，我们还需要考虑到虚表的二次写入机制，通过此机制让每个对象的虚表指针都能准确的指向到自己类的虚表，为实现动多态提供支持。\n\n## 4、标准模板库STL\n\n\n\n\n## 5、C++新特性\n\n### 5.1 C++新特性\n\n内容参考于[csdn](https://blog.csdn.net/dnty00/article/details/126171485)\n一、C++新特性\nC++新特性主要包括包含语法改进和标准库扩充两个方面，主要包括以下11点\n1、语法的改进\n1）统一的初始化方法\n在 C++11 中，可以直接在变量名后面跟上初始化列表，来进行对象的初始化\n2）成员变量默认初始化\n3）auto关键字用于定义变量，编译器可以自动判断的类型（前提：定义一个变量时对其进行初始化）\n4）decltype 求表达式的类型\n5）智能指针 shared_ptr\n\n和 unique_ptr、weak_ptr 不同之处在于，多个 shared_ptr 智能指针可以共同使用同一块堆内存。并且，由于该类型智能指针在实现上采用的是引用计数机制，即便有一个 shared_ptr 指针放弃了堆内存的“使用权”（引用计数减 1），也不会影响其他指向同一堆内存的 shared_ptr 指针（只有引用计数为 0 时，堆内存才会被自动释放）\n6）空指针 nullptr（原来NULL）\n7）基于范围的for循环\n8）右值引用和move语义\n\n+ 右值引用\n\n```cpp\n//左值引用\nint num = 10;\nint &b = num;  //正确\nint &c = 10;   //错误，在C++98/03标准中，无法为右值添加引用\n```\n\n实际开发中可能需要对右值进行修改（实现移动语义时就需要），显然左值引用的方式是行不通的。为此，C++11 标准新引入了另一种引用方式，称为右值引用，用 “&&” 表示。\n\n```cpp\nint num = 10;\n//int && a = num;  //右值引用不能初始化为左值\nint && a = 10;\n```\n\n+ move语义\n\n在C++11中，标准库在中提供了一个有用的函数std::move，std::move()函数并不能移动任何东西，它唯一的功能是将一个左值引用强制转化为右值引用，继而可以通过右值引用使用该值，以用于移动语义。从实现上讲，std::move基本等同于一个类型转换：static_cast<T&&>(lvalue);\n\n```cpp\nmove( arg ) //其中，arg 表示指定的左值对象。该函数会返回 arg 对象的右值形式。\n```\n\n2、标准模板库的扩充（往STL里面添加了一些模板类，比较好用）\n9）无序容器（哈希表）\n用法和功能同map一模一样，区别在于哈希表的效率更高\n10）正则表达式\n可以认为正则表达式实质上是一个字符串，该字符串描述了一种特定模式的字符串\n11）Lambda表达式（匿名函数）\nlambda表达式是一个匿名函数，用于定义并创建匿名的函数对象，以简化编程工作。举个例子：\n\n```cpp\n vector<int> vec;\n sort(vec.begin(), vec.end(), cmp); // 旧式\n sort(vec.begin(), vec.end(), [](int a, int b) -> bool { return a < b; });   // Lambda表达式\n```\n\n声明lambda表达式：\n\n```cpp\n[capture list] (params list) mutable exception-> return type { function body }\n```\n\n+ capture list：捕获外部变量列表\n+ params list：形参列表\n+ mutable指示符：用来说用是否可以修改捕获的变量\n+ exception：异常设定\n+ return type：返回类型\n+ function body：函数体\n\n详细说明：\n\n1. 统一的初始化方法\n   C++98/03 可以使用初始化列表（initializer list）进行初始化：\n\n```cpp\nint i_arr[3] = { 1, 2, 3 };\nlong l_arr[] = { 1, 3, 2, 4 };\nstruct A\n{\n    int x;\n    int y;\n} a = { 1, 2 };\n```\n\n但是这种初始化方式的适用性非常狭窄，只有上面提到的这两种数据类型可以使用初始化列表。在 C++11 中，初始化列表的适用性被大大增加了。它现在可以用于任何类型对象的初始化，实例如下：\n\n```cpp\nclass Foo\n{\npublic:\n    Foo(int) {}\nprivate:\n    Foo(const Foo &);\n};\nint main(void)\n{\n    Foo a1(123);\n    Foo a2 = 123;  //error: \'Foo::Foo(const Foo &)\' is private\n    Foo a3 = { 123 };\n    Foo a4 { 123 };\n    int a5 = { 3 };\n    int a6 { 3 };\n    return 0;\n}\n```\n\n在上例中，a3、a4 使用了新的初始化方式来初始化对象，效果如同 a1 的直接初始化。a5、a6 则是基本数据类型的列表初始化方式。可以看到，它们的形式都是统一的。这里需要注意的是，a3 虽然使用了等于号，但它仍然是列表初始化，因此，私有的拷贝构造并不会影响到它。a4 和 a6 的写法，是 C++98/03 所不具备的。在 C++11 中，可以直接在变量名后面跟上初始化列表，来进行对象的初始化。\n\n2. 成员变量默认初始化\n   好处：构建一个类的对象不需要用构造函数初始化成员变量。\n\n```cpp\n//程序实例\n#include<iostream>\nusing namespace std;\nclass B\n{\npublic:\n    int m = 1234; //成员变量有一个初始值\n    int n;\n};\nint main()\n{\n    B b;\n    cout << b.m << endl;\n    return 0;\n}\n```\n\n3. auto关键字\n   用于定义变量，编译器可以自动判断的类型（前提：定义一个变量时对其进行初始化）。\n\n```cpp\n//程序实例\n#include <vector>\nusing namespace std;\nint main(){\n    vector< vector<int> > v;\n    vector< vector<int> >::iterator i = v.begin();\n    return 0;\n}\n```\n\n可以看出来，定义迭代器 i 的时候，类型书写比较冗长，容易出错。然而有了 auto 类型推导，我们大可不必这样，只写一个 auto 即可。\n\n4. decltype 求表达式的类型\n\ndecltype 是 C++11 新增的一个关键字，它和 auto 的功能一样，都用来在编译时期进行自动类型推导。\n\n(1)为什么要有decltype\n\n因为 auto 并不适用于所有的自动类型推导场景，在某些特殊情况下 auto 用起来非常不方便，甚至压根无法使用，所以 decltype 关键字也被引入到 C++11 中。\n\nauto 和 decltype 关键字都可以自动推导出变量的类型，但它们的用法是有区别的：\n\n```cpp\nauto varname = value;\ndecltype(exp) varname = value;\n```\n\n其中，varname 表示变量名，value 表示赋给变量的值，exp 表示一个表达式。\n\nauto 根据\"=\"右边的初始值 value 推导出变量的类型，而 decltype 根据 exp 表达式推导出变量的类型，跟\"=\"右边的 value 没有关系。\n\n另外，auto 要求变量必须初始化，而 decltype 不要求。这很容易理解，auto 是根据变量的初始值来推导出变量类型的，如果不初始化，变量的类型也就无法推导了。decltype 可以写成下面的形式：\n\n>decltype(exp) varname;\n\n(2)代码示例\n\n```cpp\n// decltype 用法举例\nnt a = 0;\ndecltype(a) b = 1;  //b 被推导成了 int\ndecltype(10.8) x = 5.5;  //x 被推导成了 double\ndecltype(x + 100) y;  //y 被推导成了 double\n```\n\n5. 智能指针 shared_ptr\n\n和 unique_ptr、weak_ptr 不同之处在于，多个 shared_ptr 智能指针可以共同使用同一块堆内存。并且，由于该类型智能指针在实现上采用的是引用计数机制，即便有一个 shared_ptr 指针放弃了堆内存的“使用权”（引用计数减 1），也不会影响其他指向同一堆内存的 shared_ptr 指针（只有引用计数为 0 时，堆内存才会被自动释放）。\n\n```cpp\n#include <iostream>\n#include <memory>\nusing namespace std;\nint main()\n{\n    //构建 2 个智能指针\n    std::shared_ptr<int> p1(new int(10));\n    std::shared_ptr<int> p2(p1);\n    //输出 p2 指向的数据\n    cout << *p2 << endl;\n    p1.reset();//引用计数减 1,p1为空指针\n    if (p1) {\n        cout << \"p1 不为空\" << endl;\n    }\n    else {\n        cout << \"p1 为空\" << endl;\n    }\n    //以上操作，并不会影响 p2\n    cout << *p2 << endl;\n    //判断当前和 p2 同指向的智能指针有多少个\n    cout << p2.use_count() << endl;\n    return 0;\n}\n\n/*    程序运行结果：        \n            10\n            p1 为空\n            10\n            1    \n*/   \n```\n\n6. 空指针 nullptr（原来NULL）\n\n nullptr 是 nullptr_t 类型的右值常量，专用于初始化空类型指针。nullptr_t 是 C++11 新增加的数据类型，可称为“指针空值类型”。也就是说，nullpter 仅是该类型的一个实例对象（已经定义好，可以直接使用），如果需要我们完全定义出多个同 nullptr 完全一样的实例对象。值得一提的是，nullptr 可以被隐式转换成任意的指针类型。例如：\n\n```cpp\nint * a1 = nullptr;\nchar * a2 = nullptr;\ndouble * a3 = nullptr;\n```\n\n 显然，不同类型的指针变量都可以使用 nullptr 来初始化，编译器分别将 nullptr 隐式转换成 int、char 以及 double\\* 指针类型。另外，通过将指针初始化为 nullptr，可以很好地解决 NULL 遗留的问题，比如：\n\n```cpp\n#include <iostream>\nusing namespace std;\nvoid isnull(void *c){\n    cout << \"void*c\" << endl;\n}\nvoid isnull(int n){\n    cout << \"int n\" << endl;\n}\nint main() {\n    isnull(NULL);\n    isnull(nullptr);\n    return 0;\n}\n\n/*    程序运行结果：        \n        int n\n        void*c\n*/         \n```\n\n7. 基于范围的for循环\n   如果要用 for 循环语句遍历一个数组或者容器，只能套用如下结构：\n\n```cpp\nfor(表达式 1; 表达式 2; 表达式 3){\n    //循环体\n}\n```\n\n```cpp\n//程序实例\n#include <iostream>\n#include <vector>\n#include <string.h>\nusing namespace std;\nint main() {\n    char arc[] = \"www.123.com\";\n    int i;\n    //for循环遍历普通数组\n    for (i = 0; i < strlen(arc); i++) {\n        cout << arc[i];\n    }\n    cout << endl;\n    vector<char>myvector(arc,arc+3);\n    vector<char>::iterator iter;\n    //for循环遍历 vector 容器\n    for (iter = myvector.begin(); iter != myvector.end(); ++iter) {\n        cout << *iter;\n    }\n    return 0;\n}\n/*    程序运行结果：        \n        www.123.com\n        www\n*/      \n```\n\n8. 右值引用和move语义\n   i. 右值引用\n\n C++98/03 标准中就有引用，使用 \"&\" 表示。但此种引用方式有一个缺陷，即正常情况下只能操作 C++ 中的左值，无法对右值添加引用。举个例子：\n\n```cpp\nint num = 10;\nint &b = num; //正确\nint &c = 10; //错误\n```\n\n 如上所示，编译器允许我们为 num 左值建立一个引用，但不可以为 10 这个右值建立引用。因此，C++98/03 标准中的引用又称为左值引用。\n\n注意，虽然 C++98/03 标准不支持为右值建立非常量左值引用，但允许使用常量左值引用操作右值。也就是说，常量左值引用既可以操作左值，也可以操作右值，例如：\n\n```cpp\nint num = 10;\nconst int &b = num;\nconst int &c = 10;\n```\n\n我们知道，右值往往是没有名称的，因此要使用它只能借助引用的方式。这就产生一个问题，实际开发中我们可能需要对右值进行修改（实现移动语义时就需要），显然左值引用的方式是行不通的。\n\n 为此，C++11 标准新引入了另一种引用方式，称为右值引用，用 \"&&\" 表示。\n\n 需要注意的，和声明左值引用一样，右值引用也必须立即进行初始化操作，且只能使用右值进行初始化，比如：\n\n```cpp\nint num = 10;\n//int && a = num;  //右值引用不能初始化为左值\nint && a = 10;\n​ 和常量左值引用不同的是，右值引用还可以对右值进行修改。例如：\n\nint && a = 10;\na = 100;\ncout << a << endl;\n/*    程序运行结果：        \n        100    \n*/          \n​ 另外值得一提的是，C++ 语法上是支持定义常量右值引用的，例如:\nconst int&& a = 10;//编译器不会报错\n```\n\n 但这种定义出来的右值引用并无实际用处。一方面，右值引用主要用于移动语义和完美转发，其中前者需要有修改右值的权限；其次，常量右值引用的作用就是引用一个不可修改的右值，这项工作完全可以交给常量左值引用完成。\n\nii. move语义\n\n move 本意为 \"移动\"，但该函数并不能移动任何数据，它的功能很简单，就是将某个左值强制转化为右值。基于 move() 函数特殊的功能，其常用于实现移动语义。move() 函数的用法也很简单，其语法格式如下：\n\n> move( arg ) //其中，arg 表示指定的左值对象。该函数会返回 arg 对象的右值形式。\n\n```cpp\n//程序实例\n#include <iostream>\nusing namespace std;\nclass first {\npublic:\n    first() :num(new int(0)) {\n        cout << \"construct!\" << endl;\n    }\n    //移动构造函数\n    first(first &&d) :num(d.num) {\n        d.num = NULL;\n        cout << \"first move construct!\" << endl;\n    }\npublic:    //这里应该是 private，使用 public 是为了更方便说明问题\n    int *num;\n};\nclass second {\npublic:\n    second() :fir() {}\n    //用 first 类的移动构造函数初始化 fir\n    second(second && sec) :fir(move(sec.fir)) {\n        cout << \"second move construct\" << endl;\n    }\npublic:    //这里也应该是 private，使用 public 是为了更方便说明问题\n    first fir;\n};\nint main() {\n    second oth;\n    second oth2 = move(oth);\n    //cout << *oth.fir.num << endl;   //程序报运行时错误\n    return 0;\n}\n\n/*    程序运行结果：\n          construct!\n        first move construct!\n        second move construct\n*/            \n```\n\n9. 无序容器（哈希表）\n\n用法和功能同map一模一样，区别在于哈希表的效率更高。\n\n(1) 无序容器具有以下 2 个特点：\n\n a. 无序容器内部存储的键值对是无序的，各键值对的存储位置取决于该键值对中的键，\n\n b. 和关联式容器相比，无序容器擅长通过指定键查找对应的值（平均时间复杂度为 O(1)）；但对于使用迭代器遍历容器中存储的元素，无序容器的执行效率则不如关联式容器。\n\n(2) 和关联式容器一样，无序容器只是一类容器的统称，其包含有 4 个具体容器，分别为 unordered_map、unordered_multimap、unordered_set 以及 unordered_multiset。功能如下表：\n\n| 无序容器           | 功能                                                         |\n| ------------------ | ------------------------------------------------------------ |\n| unordered_map      | 存储键值对 <key, value> 类型的元素，其中各个键值对键的值不允许重复，且该容器中存储的键值对是无序的。 |\n| unordered_multimap | 和 unordered_map 唯一的区别在于，该容器允许存储多个键相同的键值对。 |\n| unordered_set      | 不再以键值对的形式存储数据，而是直接存储数据元素本身（当然也可以理解为，该容器存储的全部都是键 key 和值 value 相等的键值对，正因为它们相等，因此只存储 value 即可）。另外，该容器存储的元素不能重复，且容器内部存储的元素也是无序的。 |\n| unordered_multiset | 和 unordered_set 唯一的区别在于，该容器允许存储值相同的元素。 |\n\n 程序实例（以 unordered_map 容器为例）\n\n```cpp\n#include <iostream>\n#include <string>\n#include <unordered_map>\nusing namespace std;\nint main()\n{\n    //创建并初始化一个 unordered_map 容器，其存储的 <string,string> 类型的键值对\n    std::unordered_map<std::string, std::string> my_uMap{\n        {\"教程1\",\"www.123.com\"},\n        {\"教程2\",\"www.234.com\"},\n        {\"教程3\",\"www.345.com\"} };\n    //查找指定键对应的值，效率比关联式容器高\n    string str = my_uMap.at(\"C语言教程\");\n    cout << \"str = \" << str << endl;\n    //使用迭代器遍历哈希容器，效率不如关联式容器\n    for (auto iter = my_uMap.begin(); iter != my_uMap.end(); ++iter)\n    {\n        //pair 类型键值对分为 2 部分\n        cout << iter->first << \" \" << iter->second << endl;\n    }\n    return 0;\n}\n\n/*    程序运行结果：\n          教程1 www.123.com\n          教程2 www.234.com\n          教程3 www.345.com\n*/  \n```\n\n10. 正则表达式\n\n可以认为正则表达式实质上是一个字符串，该字符串描述了一种特定模式的字符串。常用符号的意义如下：\n\n11. Lambda匿名函数\n    所谓匿名函数，简单地理解就是没有名称的函数，又常被称为 lambda 函数或者 lambda 表达式。\n\n（1）定义\n\n lambda 匿名函数很简单，可以套用如下的语法格式：\n\n [外部变量访问方式说明符] (参数) mutable noexcept/throw() -> 返回值类型\n​ {\n​ 函数体;\n​ };\n\n其中各部分的含义分别为：\n\na. [外部变量方位方式说明符]\n\n> [ ] 方括号用于向编译器表明当前是一个 lambda 表达式，其不能被省略。在方括号内部，可以注明当前 lambda 函数的函数体中可以使用哪些“外部变量”。\n\n所谓外部变量，指的是和当前 lambda 表达式位于同一作用域内的所有局部变量。\nb. (参数)\n\n>和普通函数的定义一样，lambda 匿名函数也可以接收外部传递的多个参数。和普通函数不同的是，如果不需要传递参数，可以连同 () 小括号一起省略；\n\nc. mutable\n\n>此关键字可以省略，如果使用则之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，对于以值传递方式引入的外部变量，不允许在 lambda 表达式内部修改它们的值（可以理解为这部分变量都是 const 常量）。而如果想修改它们，就必须使用 mutable 关键字。\n\n 注意:对于以值传递方式引入的外部变量，lambda 表达式修改的是拷贝的那一份，并不会修改真正的外部变量；\n\nd. noexcept/throw()\n\n>可以省略，如果使用，在之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，lambda 函数的函数体中可以抛出任何类型的异常。而标注 noexcept 关键字，则表示函数体内不会抛出任何异常；使用 throw() 可以指定 lambda 函数内部可以抛出的异常类型。\n\ne. -> 返回值类型\n\n>指明 lambda 匿名函数的返回值类型。值得一提的是，如果 lambda 函数体内只有一个 return 语句，或者该函数返回 void，则编译器可以自行推断出返回值类型，此情况下可以直接省略\"-> 返回值类型\"。\n\nf. 函数体\n\n>和普通函数一样，lambda 匿名函数包含的内部代码都放置在函数体中。该函数体内除了可以使用指定传递进来的参数之外，还可以使用指定的外部变量以及全局范围内的所有全局变量。\n\n（2）程序实例\n\n```cpp\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main()\n{\n    int num[4] = {4, 2, 3, 1};\n    //对 a 数组中的元素进行排序\n    sort(num, num+4, [=](int x, int y) -> bool{ return x < y; } );\n    for(int n : num){\n        cout << n << \" \";\n    }\n    return 0;\n}\n\n/*    程序运行结果：\n          1 2 3 4\n*/ \n```\n\n### 5.2 说说 C++ 中智能指针和指针的区别是什么？\n\n1. 智能指针\n\n 如果在程序中使用new从堆（自由存储区）分配内存，等到不需要时，应使用delete将其释放。C++引用了智能指针auto_ptr，以帮助自动完成这个过程。随后的编程体验（尤其是使用STL）表明，需要有更精致的机制。基于程序员的编程体验和BOOST库提供的解决方案，C++11摒弃了auto_ptr，并新增了三种智能指针：unique_ptr、shared_ptr和weak_ptr。所有新增的智能指针都能与STL容器和移动语义协同工作。\n\n2. 指针\n\n C 语言规定所有变量在使用前必须先定义，指定其类型，并按此分配内存单元。指针变量不同于整型变量和其他类型的变量，它是专门用来存放地址的，所以必须将它定义为“指针类型”。\n\n智能指针和普通指针的区别\n\n 智能指针和普通指针的区别在于智能指针实际上是对普通指针加了一层封装机制，区别是它负责自动释放所指的对象，这样的一层封装机制的目的是为了使得智能指针可以方便的管理一个对象的生命期。\n\n### 5.3 \n\n\n## 6、C++操作系统（Linux相关）\n\n\n\n\n## 7、计算机网络\n\n\n\n\n\n## 8、设计模式（摘选）\n\n\n\n\n\n## 9、常见编程大题\n\n\n\n',1,0,0,0,1,'2023-06-07 16:32:56','2023-06-07 19:54:56');
INSERT INTO `t_article` VALUES (72,1,51,'https://upload.haoxx.site/article/a48f6cb59c54e3e6f6397ee22eed38b2.jpg','C++方面的部分内容','\n## C++基础\n\n\n\n### 1. 虚函数\n\n### 2. 指针的理解\n\n### 3. malloc和new的基本概念以及区别\n\n[csdn资料](https://blog.csdn.net/weixin_43899008/article/details/123261412)\n一、属性方面，malloc是库函数，需要头文件支持，new是运算符，需要编译器支持。\n二、参数方面，new无需指定内存大小，编译器会自行计算；malloc需要指定内存大小。而且new会调用构造函数。\n三、处理数组方面，new使用new[]，并使用delete[]进行释放，malloc需要手动定义数组大小，并用free释放内存。\n四、返回类型，malloc返回值是void\\*指针，使用前需要显式地指定为需要的指针类型。new分配成功返回的是对象类型指针，与对象严格匹配，无类型转换，所以new是符合类型安全性操作符。\n五、内存分配方面，new内存分配失败时，抛出bad_alloc异常，malloc分配内存失败时返回NULL。\n六、自定义类型方面，new会先调用operator new函数，申请足够的内存，然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete就是反着来，先调用析构函数，然后operator delete函数释放内存。malloc是库函数，只能动态地申请和释放内存，无法强制要求其做自定义类型对象构造和析构函数。\n七、new可以重载，malloc不可以\n八、new在自由储存区分配内存，malloc在堆上分配内存。\n九、内存泄漏方面，内存泄漏对于new和malloc都能检测出来，new可以明确指出是哪个文件的哪一行，但是malloc不可以明确指出是哪个文件的哪一行。\n十、效率方面，new是关键字，malloc是库函数，new效率更高。\n\n![图1](https://s3.bmp.ovh/imgs/2022/08/28/6c46c39176ca9029.png)\n\n### 4. 智能指针，弱指针作用\n\n### 5. \\*p++的间隔\n\n### 6. 指针为NULL，访问会怎样\n\n简单说一下，c的NULL是宏定义，为void\\*，而cpp的NULL宏定义为0。cpp常用nullptr来给指针赋初值。nullptr的值为void\\*。\n\n可以给指针赋初始值为NULL，但是不可以访问。内存地址为0的区域是用户应用程序访问的禁区，一旦访问就会段错误。\n\n### 7. const int \\*p和int \\* const p的区别\n\n常量指针和指针常量。前者本质为指针，只是指针指向内存区域里存放的数据为常量，所以常量指针：指向的区域可以更改，指向的内容不可以更改；后者本质为常量，只是常量里装的是指针，所以指针指向不能改，指向的内容可以更改。\n\n### 8. C++ join detach\n\npthread_join()是在父线程中调用，等子线程运行完后通知子线程，然后父线程回收子线程资源。pthread_detach()是在子线程中调用，是子线程脱离父线程，子线程运行完后由系统回收资源。\n\n### 9. <font color=\'red\'>C++ 11新特性</font>\n\n内容参考于[csdn](https://blog.csdn.net/dnty00/article/details/126171485)\n一、cpp新特性\ncpp新特性主要包括包含语法改进和标准库扩充两个方面，主要包括以下11点\n1、语法的改进\n1）统一的初始化方法\n在 cpp11 中，可以直接在变量名后面跟上初始化列表，来进行对象的初始化\n2）成员变量默认初始化\n3）auto关键字用于定义变量，编译器可以自动判断的类型（前提：定义一个变量时对其进行初始化）\n4）decltype 求表达式的类型\n5）智能指针 shared_ptr\n\n和 unique_ptr、weak_ptr 不同之处在于，多个 shared_ptr 智能指针可以共同使用同一块堆内存。并且，由于该类型智能指针在实现上采用的是引用计数机制，即便有一个 shared_ptr 指针放弃了堆内存的“使用权”（引用计数减 1），也不会影响其他指向同一堆内存的 shared_ptr 指针（只有引用计数为 0 时，堆内存才会被自动释放）\n6）空指针 nullptr（原来NULL）\n7）基于范围的for循环\n8）右值引用和move语义\n\n+ 右值引用\n\n```cpp\n//左值引用\nint num = 10;\nint &b = num;  //正确\nint &c = 10;   //错误，在cpp98/03标准中，无法为右值添加引用\n```\n\n实际开发中可能需要对右值进行修改（实现移动语义时就需要），显然左值引用的方式是行不通的。为此，cpp11 标准新引入了另一种引用方式，称为右值引用，用 “&&” 表示。\n\n```cpp\nint num = 10;\n//int && a = num;  //右值引用不能初始化为左值\nint && a = 10;\n```\n\n+ move语义\n\n在cpp11中，标准库在中提供了一个有用的函数std::move，std::move()函数并不能移动任何东西，它唯一的功能是将一个左值引用强制转化为右值引用，继而可以通过右值引用使用该值，以用于移动语义。从实现上讲，std::move基本等同于一个类型转换：static_cast<T&&>(lvalue);\n\n```cpp\nmove( arg ) //其中，arg 表示指定的左值对象。该函数会返回 arg 对象的右值形式。\n```\n\n2、标准模板库的扩充（往STL里面添加了一些模板类，比较好用）\n9）无序容器（哈希表）\n用法和功能同map一模一样，区别在于哈希表的效率更高\n10）正则表达式\n可以认为正则表达式实质上是一个字符串，该字符串描述了一种特定模式的字符串\n11）Lambda表达式（匿名函数）\nlambda表达式是一个匿名函数，用于定义并创建匿名的函数对象，以简化编程工作。举个例子：\n\n```cpp\n vector<int> vec;\n sort(vec.begin(), vec.end(), cmp); // 旧式\n sort(vec.begin(), vec.end(), [](int a, int b) -> bool { return a < b; });   // Lambda表达式\n```\n\n声明lambda表达式：\n\n```cpp\n[capture list] (params list) mutable exception-> return type { function body }\n```\n\n+ capture list：捕获外部变量列表\n+ params list：形参列表\n+ mutable指示符：用来说用是否可以修改捕获的变量\n+ exception：异常设定\n+ return type：返回类型\n+ function body：函数体\n\n二、智能指针\n\n**为什么要使用智能指针**：\n\n智能指针的作用是管理一个指针，因为存在申请的空间在函数结束时忘记释放，造成内存泄漏的情况。使用智能指针可以很大程度上避免这个问题，因为智能指针就是一个类，当超出了类的作用域时，类会自动调用析构函数，自动释放资源。所以**智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间**。\n智能指针的作用：处理内存泄漏问题和空悬指针问题。\n\ncpp中的智能指针有4种，分别为：shared_ptr、unique_ptr、weak_ptr、auto_ptr，其中auto_ptr被cpp11弃用。\n\n+ 对于shared_ptr，可解决资源忘记释放的内存泄漏问题，及悬空指针问题。\n  *shared_ptr实现共享式拥有的概念，多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。从名字share就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。\n\n+ 对于unique_ptr，对象对其有唯一所有权。\n  unique_ptr实现独占式拥有的概念，同一时间只能有一个智能指针可以指向该对象，它对于避免资源泄露，因为无法进行拷贝构造和拷贝赋值，但是可以进行移动构造和移动赋值。\n\n+ 对于weak_ptr，和 shared_ptr 搭配，不会增加引用计数，用于避免循环引用（比如 a 对象持有 b 对象，b 对象持有 a 对象），这样必然会导致内存泄露。\n  解决shared_ptr相互引用时，两个指针的引用计数永远不会下降为0，从而导致死锁问题。而weak_ptr是对对象的一种弱引用，可以绑定到shared_ptr，但不会增加对象的引用计数\n\n+ 对于auto_ptr，实现独占式拥有的概念，同一时间只能有一个智能指针可以指向该对象；但auto_ptr在cpp11中被摒弃，其主要问题在于：\n  1）对象所有权的转移，比如在函数传参过程中，对象所有权不会返还，从而存在潜在的内存崩溃问题；\n  2）不能指向数组，也不能作为STL容器的成员\n\n### 10. 匿名函数\n\n匿名函数lambada表达式，就是没有名字的函数。最常见的匿名函数是`[](){}`。它没有参数也没有返回值。在匿名函数中，[]里面用来捕获函数外部的变量，而()里面就是匿名函数的参数，{}里面就是函数的执行代码。\n\n概念：cpp11提供了类似与Python的lambda表达式的方式，称为匿名函数，其好处是：使用匿名函数，可以免去函数的声明和定义。这样匿名函数仅在调用函数的时候才会创建函数对象，而调用结束后立即释放，所以匿名函数比非匿名函数更节省空间。\n\nLambda在STL中使用，书写上带来极大的方便。\n捕获capture： //类似于函数名，是匿名函数的触发条件\n\n>[] //未定义变量.试图在Lambda内使用任何外部变量都是错误的.\n>[x, &y] //x 按值捕获, y 按引用捕获.\n>[&] //用到的任何外部变量都隐式按引用捕获\n>[=] //用到的任何外部变量都隐式按值捕获\n>[&, x] //x显式地按值捕获. 其它变量按引用捕获\n>[=, &z] //z按引用捕获. 其它变量按值捕获\n\nparameters: //参数\nreturn-type: //返回值\nbody: //函数体\n例子：\n\n```cpp\n[](int x, int y) { return x + y; } // 隐式返回类型\n[](int& x) { ++x; }   // 没有return语句 -> lambda 函数的返回类型是\'void\'\n[]() { ++global_x; }  // 没有参数,仅访问某个全局变量\n[]{ ++global_x; }     // 与上一个相同,省略了()\n```\n\n### 11. 类内默认的函数\n\n6种：<font color=\'red\'>无参构造函数，析构函数，拷贝构造函数（浅拷贝的）、赋值运算符重载函数</font>、const成员、取地址及const取地址操作符重载。\n\n![](https://s3.bmp.ovh/imgs/2022/08/28/a9b8047f51af8e86.png)\n\n### 12. 什么时候重载拷贝构造函数\n\n\n### 13. 深浅拷贝\n\n浅拷贝就是直接用等号连接的赋值操作，一般类中不涉及内存开辟的话，浅拷贝可以使用。深拷贝需要重写拷贝构造函数。浅拷贝就是创建一个新的指针来指向对应的内容。深拷贝是新开辟一块区域，然后向指定的内容存入这块区域，然后用一个新的指针指向这块区域。\n\n浅拷贝只是对指针的拷贝，浅拷贝后两个指针指向同一个内存空间；深拷贝不仅对指针进行拷贝，而且对指针指向的内容进行拷贝，经深拷贝后的指针是指向两个不同地址的指针。\n\n当拷贝一个基类指针到派生类时，如果调用系统默认的拷贝构造函数，这时只是对指针进行拷贝，两个指针指向同一个地址，这就会导致指针被分配了一次内存，但内存被释放了两次（两次调用析构函数），造成程序崩溃。\n\n对于类中开辟了内存空间的情况，必须重写拷贝构造函数以实现深拷贝，否则会出现一块内存区域被重复释放多次的错误。\n\n### 14. stl容器底层实现\n\n\n### 15. unordered_map和map区别\n\n### 16. 锁的作用\n\n\n### 17. lock_guard的用法\n\n\n\n## 操作系统\n\n### 1. 进程和线程区别\n\n### 2. 一个线程崩溃了对其他线程有什么影响\n\n## 数据结构\n\n### 1. 红黑树基础概念，特性，根节点是什么颜色，可以有连续两个红节点吗\n\n## 算法题\n\n### 1. 获取链表倒数第三个节点（双指针）\n\n\n\n# C++中的智能指针\n\n内容参考自[csdn1](https://blog.csdn.net/m0_67623521/article/details/125695620)和[csdn2](https://blog.csdn.net/K346K346/article/details/81478223?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165743267316781432922953%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=165743267316781432922953&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-81478223-null-null.142%5Ev32%5Eexperiment_2_v1,185%5Ev2%5Econtrol&utm_term=c%2B%2B%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88&spm=1018.2226.3001.4187)\n\n## 前言\n\nC++ STL（Standard Template Library）一共提供了四种指针：auto_ptr、unique_ptr、shared_ptr 和 weak_ptr，其中auto_ptr是cpp98提供的，cpp11 已将其摒弃，并提出了 unique_ptr 替代 auto_ptr。\n\n虽然 auto_ptr 已被摒弃，但在实际项目中仍可使用，但建议使用更加安全的 unique_ptr。cpp98中只有一种智能指针auto_ptr，这个智能指针实际上是一个封装好的类，方便管理指针，使用构造函数来生成指针，使用析构函数来释放指针，避免内存泄漏。但是auto_ptr有漏洞，基于此，提出了三种新指针，unique_ptr限制了指针的所有权，只有一个对象所持有；shared_ptr在指针管理类中新增一个计数值，来记录指针所引用对象的个数，当计数值为0时就释放指针；weak_ptr智能指针没有没有重载 operator* 和 operator->，他常作为shared_ptr的辅助指针，用于监测shared_ptr的引用计数值。\n\n## 1、unique_ptr\n\n它持有对对象的独有权——两个unique_ptr 不能指向一个对象，即 unique_ptr 不共享它所管理的对象。它无法复制到其他 unique_ptr，无法通过值传递到函数，也无法用于需要副本的任何标准模板库 （STL）算法。只能移动 unique_ptr，即对资源管理权限可以实现转移。这意味着，内存资源所有权可以转移到另一个 unique_ptr，并且原始 unique_ptr 不再拥有此资源。\n\nunique_ptr 与原始指针一样有效，并可用于 STL 容器。将 unique_ptr 实例添加到 STL 容器运行效率很高，因为通过 unique_ptr 的移动构造函数，不再需要进行复制操作。\n\n独占的指针，只可以自己使用，它指向的对象只可以他一个人使用，可以使用move将使用权转移，如：\n\n```cpp\n#include <iostream>\n#include <memory>\nusing namespace std;\nint main(){\n    auto ptr1=make_unique<string> (\"12345\");\n    cout<<*ptr1<<endl;\n    auto ptr2=std::move(ptr1);\n    // cout<<*ptr1<<endl;\n    cout<<*ptr2<<endl;\n    return 0;\n}\n//输出结果：\n//12345\n//12345\n```\n\n创建智能指针的方法：通过构造函数指定、通过 reset 方法重新指定、通过 release 方法释放所有权、通过移动语义转移所有权（move），unique_ptr 还可能没有对象，这种情况被称为 empty。\n\n```cpp\n#include <iostream>\n#include <memory>\nusing namespace std;\nint main(){\n    unique_ptr<int> p1;\n    p1.reset(new int(123));\n    cout<<*p1<<endl;\n    unique_ptr<int> p2(new int(1234));\n    cout<<*p2<<endl;\n    int *p3=p1.release();\n    cout<<*p3<<endl;\n    unique_ptr<int> p4=move(p2);\n    cout<<*p4<<endl;\n \n    return 0;\n}\n// 123\n// 1234\n// 123\n// 1234\n```\n\n## 2、auto_ptr\n\n引入问题：\n\n```cpp\nauto_ptr< string> p1(new string (\"string1\");\nauto_ptr<string> p2;\np2=p1;\n```\n\n如果上面的指针是普通的指针，那么就会面临一个问题，就是delete的时候会删除有两次，解决方案有多种：\n\n1、重载复制运算符，将其定义为深复制，这样他们俩就会指向不同的地方，缺点是会浪费空间。\n\n2、建立所有全概念。将指针定义为只可以有一个对象拥有，赋值运算符直接将所有权转移。这就是用于 auto_ptr 和 unique_ptr 的策略，但 unique_ptr 的策略更严格。\n\n3、创建智能更高的指针，跟踪引用特定对象的智能指针数。这称为引用计数。例如，赋值时，计数将加 1，而指针过期时，计数将减 1,。当减为 0 时才调用 delete。这是 shared_ptr 采用的策略。\n\n## 3、shared_ptr\n\nshared_ptr 是一个标准的共享所有权的智能指针，**允许多个指针指向同一个对象**，定义在 memory 文件中，命名空间为 std。shared_ptr 利用引用计数的方式实现了对所管理的对象的所有权的分享，即允许多个 shared_ptr 共同管理同一个对象。像 shared_ptr 这种智能指针，《Effective cpp》称之为“引用计数型智能指针”（reference-counting smart pointer，RCSP）。\n\nshared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性（auto_ptr 是独占的），在使用引用计数的机制上提供了可以共享所有权的智能指针，当然这需要额外的开销：\n（1）shared_ptr 对象除了包括一个所拥有对象的指针外，还必须包括一个引用计数代理对象的指针；\n（2）时间上的开销主要在初始化和拷贝操作上， * 和 -> 操作符重载的开销跟 auto_ptr 是一样；\n（3）开销并不是我们不使用 shared_ptr 的理由,，永远不要进行不成熟的优化，直到性能分析器告诉你这一点。\n\n\n\n可以使用辅助类来实现该智能指针，它的具体做法如下：\n（a）当创建智能指针类的新对象时，初始化指针，并将引用计数设置为1；\n（b）当能智能指针类对象作为另一个对象的副本时，拷贝构造函数复制副本的指向辅助类对象的指针，并增加辅助类对象对基础类对象的引用计数（加1）；\n（c）使用赋值操作符对一个智能指针类对象进行赋值时，处理复杂一点：先使左操作数的引用计数减 1（为何减 1：因为指针已经指向别的地方），如果减1后引用计数为 0，则释放指针所指对象内存。然后增加右操作数所指对象的引用计数（为何增加：因为此时做操作数指向对象即右操作数指向对象）；\n（d）完成析构函数：调用析构函数时，析构函数先使引用计数减 1，如果减至 0 则 delete 对象。\n接口：\n\n```cpp\nclass Point {\nprivate:\n    int x, y;\npublic:\n    Point(int xVal = 0, int yVal = 0) :x(xVal), y(yVal) {}\n    int getX() const { return x; }\n    int getY() const { return y; }\n    void setX(int xVal) { x = xVal; }\n    void setY(int yVal) { y = yVal; }\n};\n```\n\n实现：\n\n```cpp\nclass SmartPtr {\npublic:\n	//构造函数\n	SmartPtr() { rp = nullptr; }\n	SmartPtr(Point *ptr):rp(new RefPtr(ptr)) {}\n	SmartPtr(const SmartPtr &sp):rp(sp.rp) { \n		++rp->count;\n		cout << \"in copy constructor\" <<endl;\n	}\n	\n	// 重载赋值运算符\n	SmartPtr& operator=(const SmartPtr& rhs) {\n		++rhs.rp->count;\n		if (rp != nullptr && --rp->count == 0) {\n			delete rp;\n		}\n		rp = rhs.rp;\n		cout << \"in assignment operator\" << endl;\n		return *this;\n	}\n	\n	// 重载->操作符\n	Point* operator->() {\n		return rp->p;\n	}\n	\n	// 重载*操作符\n	Point& operator*() {\n		return *(rp->p);\n	}\n \n	~SmartPtr() {\n		if (--rp->count == 0) delete rp;\n		else cout << \"还有\" << rp->count << \"个指针指向基础对象\" << endl;\n	}\n \nprivate:\n	RefPtr* rp;\n};\n```\n\n## 4、weak_ptr\n\nweak_ptr 被设计为与 shared_ptr 共同工作，可以从一个 shared_ptr 或者另一个 weak_ptr 对象构造而来。weak_ptr 是为了配合 shared_ptr 而引入的一种智能指针，它更像是 shared_ptr 的一个助手而不是智能指针，因为它不具有普通指针的行为，没有重载 operator* 和 operator-> ，因此取名为 weak，表明其是功能较弱的智能指针。***它的最大作用在于协助 shared_ptr 工作，可获得资源的观测权，像旁观者那样观测资源的使用情况。观察者意味着 weak_ptr 只对 shared_ptr 进行引用，而不改变其引用计数，当被观察的 shared_ptr 失效后，相应的 weak_ptr 也相应失效。**\n\n解决循环引用的问题，用法：\n\n```cpp\nweak_ptr<T> w;	 	//创建空 weak_ptr，可以指向类型为 T 的对象\nweak_ptr<T> w(sp);	//与 shared_ptr 指向相同的对象，shared_ptr 引用计数不变。T必须能转换为 sp 指向的类型\nw=p;				//p 可以是 shared_ptr 或 weak_ptr，赋值后 w 与 p 共享对象\nw.reset();			//将 w 置空\nw.use_count();		//返回与 w 共享对象的 shared_ptr 的数量\nw.expired();		//若 w.use_count() 为 0，返回 true，否则返回 false\nw.lock();			//如果 expired() 为 true，返回一个空 shared_ptr，否则返回非空 shared_ptr\n```\n\nweak_ptr 对象引用资源时不会增加引用计数，但是它能够通过 lock() 方法来判断它所管理的资源是否被释放。\n\n### weak_ptr指针的作用\n\n现在要说的问题是，weak_ptr 到底有什么作用呢？从上面那个例子看来，似乎没有任何作用。其实 weak_ptr 可用于打破循环引用。引用计数是一种便利的内存管理机制，但它有一个很大的缺点，那就是不能管理循环引用的对象。一个简单的例子如下：\n\n```cpp\n#include <iostream>\n#include <memory>\n  \nclass Woman;  \nclass Man {\nprivate:  \n    //std::weak_ptr<Woman> _wife;  \n    std::shared_ptr<Woman> _wife;  \npublic:  \n    void setWife(std::shared_ptr<Woman> woman) {  \n        _wife = woman;  \n    }  \n  \n    void doSomthing() {  \n        if(_wife.lock()){}  \n    }  \n  \n    ~Man() {\n        std::cout << \"kill man\\n\";  \n    }  \n};  \n  \nclass Woman {  \nprivate:  \n    //std::weak_ptr<Man> _husband;  \n    std::shared_ptr<Man> _husband;  \npublic:  \n    void setHusband(std::shared_ptr<Man> man) {  \n        _husband = man;  \n    }  \n    ~Woman() {  \n        std::cout <<\"kill woman\\n\";  \n    }  \n};\n\nint main(int argc, char** argv) {  \n    std::shared_ptr<Man> m(new Man());  \n    std::shared_ptr<Woman> w(new Woman());  \n    if(m && w) {  \n        m->setWife(w);  \n        w->setHusband(m);  \n    }  \n    return 0;  \n}\n```\n\n在 Man 类内部会引用一个 Woman，Woman 类内部也引用一个 Man。当一个 man 和一个 woman 是夫妻的时候，他们直接就存在了相互引用问题。man 内部有个用于管理wife生命期的 shared_ptr 变量，也就是说 wife 必定是在 husband 去世之后才能去世。同样的，woman 内部也有一个管理 husband 生命期的 shared_ptr 变量，也就是说 husband 必须在 wife 去世之后才能去世。这就是循环引用存在的问题：husband 的生命期由 wife 的生命期决定，wife 的生命期由 husband 的生命期决定，最后两人都死不掉，违反了自然规律，导致了内存泄漏。\n\n一般来讲，解除这种循环引用有下面三种可行的方法：\n（1）当只剩下最后一个引用的时候需要手动打破循环引用释放对象。\n（2）当 parent 的生存期超过 children 的生存期的时候，children 改为使用一个普通指针指向 parent。\n（3）使用弱引用的智能指针打破这种循环引用。\n虽然这三种方法都可行，但方法 1 和方法 2 都需要程序员手动控制，麻烦且容易出错。这里主要介绍一下第三种方法，使用弱引用的智能指针std:weak_ptr 来打破循环引用。\n\nweak_ptr 对象引用资源时不会增加引用计数，但是它能够通过 lock() 方法来判断它所管理的资源是否被释放。**做法就是上面的代码注释的地方取消注释，取消 Woman 类或者 Man 类的任意一个即可，也可同时取消注释，全部换成弱引用 weak_ptr**。\n\n另外很自然地一个问题是：既然 weak_ptr 不增加资源的引用计数，那么在使用 weak_ptr 对象的时候，资源被突然释放了怎么办呢？不用担心，因为不能直接通过 weak_ptr 来访问资源。那么如何通过 weak_ptr 来间接访问资源呢？答案是在需要访问资源的时候 weak_ptr 为你生成一个shared_ptr，shared_ptr 能够保证在 shared_ptr 没有被释放之前，其所管理的资源是不会被释放的。创建 shared_ptr 的方法就是 lock() 成员函数。\n\n注意： shared_ptr 实现了 operator bool() const 方法来判断被管理的资源是否已被释放。\n\n## 5、如何选择智能指针\n\n上文简单地介绍了 cpp STL 的四种智能指针。当然，除了 STL 的智能指针，cpp 准标准库 Boost 的智能指针，比如 boost::scoped_ptr、boost::shared_array、boost::intrusive_ptr 也可在实践中使用，但这里不做进一步介绍，有兴趣的读者可以参考：[cpp 智能指针详解](https://blog.csdn.net/xt_xiaotian/article/details/5714477)。\n\n在了解 STL 的四种智能指针后，大家可能会想另一个问题：在实际应用中，应使用哪种智能指针呢？\n\n下面给出几个使用指南。\n（1）如果程序要使用多个指向同一个对象的指针，应选择 shared_ptr。这样的情况包括：\n\n将指针作为参数或者函数的返回值进行传递的话，应该使用 shared_ptr；\n两个对象都包含指向第三个对象的指针，此时应该使用 shared_ptr 来管理第三个对象；\nSTL 容器包含指针。很多 STL 算法都支持复制和赋值操作，这些操作可用于 shared_ptr，但不能用于 unique_ptr（编译器发出 warning）和 auto_ptr（行为不确定）。如果你的编译器没有提供 shared_ptr，可使用 Boost 库提供的 shared_ptr。\n（2）如果程序不需要多个指向同一个对象的指针，则可使用 unique_ptr。如果函数使用 new 分配内存，并返还指向该内存的指针，将其返回类型声明为 unique_ptr 是不错的选择。这样，所有权转让给接受返回值的 unique_ptr，而该智能指针将负责调用 delete。可将 unique_ptr 存储到 STL 容器中，只要对容器元素不使用拷贝操作的算法即可（如 sort()）。例如，可在程序中使用类似于下面的代码段。\n\n```cpp\nunique_ptr<int> make_int(int n) {\n    return unique_ptr<int>(new int(n));\n}\n\nvoid show(unique_ptr<int>& p1) {\n    cout << *p1 << \' \';\n}\n\nint main() {\n	//...\n    vector<unique_ptr<int>> vp(size);\n    for(int i = 0; i < vp.size(); i++) {\n		vp[i] = make_int(rand() % 1000);       // copy temporary unique_ptr\n	}\n    vp.push_back(make_int(rand() % 1000));     // ok because arg is temporary\n    for_each(vp.begin(), vp.end(), show);      // use for_each()\n	//...\n}\n```\n\n其中 push_back 调用没有问题，因为它返回一个临时 unique_ptr，该 unique_ptr 被赋给 vp 中的一个 unique_ptr。另外，如果按值而不是按引用给 show() 传递对象，for_each() 将非法，因为这将导致使用一个来自 vp 的非临时 unique_ptr 初始化 pi，而这是不允许的。前面说过，编译器将发现错误使用 unique_ptr 的企图。\n\n在 unique_ptr 为右值时，可将其赋给 shared_ptr，这与将一个 unique_ptr 赋给另一个 unique_ptr 需要满足的条件相同，即 unique_ptr 必须是一个临时对象。与前面一样，在下面的代码中，`make_int() `的返回类型为 `unique_ptr<int>`：\n\n```cpp\nunique_ptr<int> pup(make_int(rand() % 1000));		// ok\nshared_ptr<int> spp(pup);										// not allowed, pup as lvalue\nshared_ptr<int> spr(make_int(rand() % 1000));    	// ok\n```\n\n模板 shared_ptr 包含一个显式构造函数，可用于将右值 unique_ptr 转换为 shared_ptr。shared_ptr 将接管原来归 unique_ptr 所有的对象。\n\n在满足 unique_ptr 要求的条件时，也可使用 auto_ptr，但 unique_ptr 是更好的选择。如果你的编译器没有unique_ptr，可考虑使用 Boost 库提供的 scoped_ptr，它与 unique_ptr 类似。\n（3）虽然说在满足 unique_ptr 要求的条件时，使用 auto_ptr 也可以完成对内存资源的管理，但是因为 auto_ ptr 不够安全，不提倡使用，即任何情况下都不应该使用 auto_ptr。\n（4）为了解决 shared_ptr 的循环引用问题，我们可以祭出 weak_ptr。\n（5）在局部作用域（例如函数内部或类内部），且不需要将指针作为参数或返回值进行传递的情况下，如果对性能要求严格，使用 scoped_ptr 的开销较 shared_ptr 会小一些。scoped_ptr正如其名，是一个局部指针。\n\n## 6、auto_ptr存在的问题\n\n尽可能不要把auto_ptr设置为全局指针；除非自己知道后果，否则不要把auto_ptr赋值给同类型的另一个智能指针。\n\n在某些应用场景下，拷贝构造函数的意义不明确，同理赋值语句也是这个道理，意义同样不明确，因为C11标准之前并不存在移动赋值和移动构造的概念，还有就是之前谈到的一个对象和一组对象的问题，对于自定义类型而言，auto_ptr的析构函数仅能够析构一个对象，不能够处理一组对象的情况，这些都是尚未解决的问题。\n\nauto_ptr指针当使用赋值语句将ptr1赋值给ptr2时，程序并未报错，但实际上存在隐患。问题1：auto_ptr并不共享管理权，当使用赋值语句将指针赋值后，ptr1将失去对内存的管理权。问题2：程序结束时，内存释放时会被释放两次，引发程序崩溃。',1,0,0,0,1,'2023-06-07 16:34:52','2023-06-07 19:55:18');
INSERT INTO `t_article` VALUES (73,1,51,'https://upload.haoxx.site/article/8a9d452db38f480ff6fc43806fe4f0df.jpg','C++复习总攻略','\n\nC++：基本数据类型/扩展数据类型、复合数据类型、函数、循环和分支、类、模板、内存模型/命令空间/堆的使用、异常。\n\n数据类型：基本数据类型分为整型和浮点型。整型有bool、char、short int、int、long int、long long；浮点型有float、double还有long double。扩展类型则是unsigned XXX。\n\n复合数据类型有数组、结构体、共用体、枚举、字符串、String类、指针、(vector容器和array)。注意，数组的两种替代品：vector使用new实现的类模板，可变长，方便且安全。array和数组一样定长，但是方便且安全。可以用方法begin和end来确定头尾，避免越界，用at方法来取元素时会自动检查越界问题，要比数组用方括号安全一些。\n\n函数：\n\n循环：for、while、do_while。分支：if/else、switch/case、三元运算符?:\n\n类：类的申明与定义、类的继承（注意权限问题）、（构造函数、拷贝构造函数深拷贝浅拷贝、析构函数），还有static和const修饰的方法和属性的一些使用注意事项，最后还有一个问题就是友元（全局函数友元和类友元）\n\n重载：函数重载和运算符重载。注意cpp三要素：封装、继承、多态。\n\n模板：函数模板、类模板\n\n\n异常：try throw catch\n\n文件IO\n\n## 1、char与signed char和signed char\n\n一般char就是signed char （VC编译器、X86上的GCC），不过arm-linux-gcc却把char定义为 unsigned char。在存储介质中的表现形式是一样的，占1字节8bit。区别在于看第一位是不是符号位。\n\nint默认就是signed int。\n\n在补充一点，32位和64位系统中，数据类型的不同之处：\n\n在32位机器和64机器中int类型都占用4个字节。编译器可以根据自身硬件来选择合适的大小，但是需要满足约束：short和int型至少为16位，long型至少为32位，并且short型长度不能超过int型，而int型不能超过long型。这即是说各个类型的变量长度是由编译器来决定的，而当前主流的编译器中一般是32位机器和64位机器中int型都是4个字节（例如，GCC）。下面列举在GCC编译器下32位机器和64位机器各个类型变量所占字节数：\n![图1](https://s3.bmp.ovh/imgs/2022/08/10/e2def3a84e510cd9.png)\n需要关注的是，一般而言，32位机器和64位最大的不同就是long和指针。一般32位的long是4字节，64位是8字节；32位的指针是4字节，64位的指针是8字节。',1,0,0,0,1,'2023-06-07 16:35:31','2023-06-07 19:55:40');
INSERT INTO `t_article` VALUES (74,1,51,'https://upload.haoxx.site/article/04e39dc69be59749653fec847b165ae6.jpg','C++关键字说明','\n[参考资料](https://zhuanlan.zhihu.com/p/467001575)\n\n![cpp关键字图示](https://s3.bmp.ovh/imgs/2022/07/14/d1b5fade281cfa4b.jpg)\n\n## 1）auto\n\ncpp11的 auto 表示变量的自动类型推断。即在声明变量的时候，根据变量初始值的类型自动为此变量选择匹配的类型。\n\n```cpp\nauto x = 3; // x 为 int 类型\ncout << typeid(x).name() << endl;auto \n```\n\n变量必须在定义时初始化，这类似于const关键字。\n\n## 2）bool、true、false\n\nbool 类型是cpp 中的基本数据结构。bool 类型只有两个取值，true 和 false。true 表示“真”，false 表示“假”。\nbool 类型常用于条件判断、开关变量的值或函数返回值。\n\n## 3）char、wchar_t\n\nchar 类型表示单个字符。char 类型的数据需要用单引号括起来：\nchar letter =\'A\';\nwchar_t 是宽字符类型，每个 wchar_t 类型占2个字节，16位宽。汉字的表示就需要用到 wchar_t。\n<font color=\'skyblue\'>字符与整数密切相关，它们在内部其实是被存储为整数</font>。每个可打印的字符以及许多不可打印的字符都被分配一个唯一的数字。用于编码字符的最常见方法是 ASCII（美国信息交换标准代码的首字母简写）。\n**备注**：UTF-8编码方式，中文占3个字符，中文标点也占3个字符。*UTF-8存储中文时占2-4个字节。utf-8是变长的、不定长的，ucs-4范围是1~6字节。 决定一个utf8字长度得看它首个字符，根据左侧位1的个数来决定占用了几个字节。*\n\n## 4）int、short、long\n\n略\n\n## 5）float、double、long double\n\n略\n\n## 6）signed和unsigned\n\n区别在于二进制数据时，第一位是否为符号位\n\n## 7）enum枚举类型\n\nenum 表示枚举类型，可以给出一系列固定值，实质上是 int 类型\n\n```cpp\nenum color {\n    RED = 0,\n    GREEN = 1,\n    BLUE = 2 \n};\n```\n\n## 8）union联合体类型\n\nunion 是联合体类型，通过共享内存，一个union可以有多个数据成员。但在任意时刻，联合中只能有一个数据成员可以有值。例如\n\n```cpp\nunion price {\n    char x\n    int y;\n    double z; \n};\n```\n\n## 9）struct和class     \n\nclass是一般的类类型，struct在cpp中是特殊的类类型，声明中默认的访问权限与class不同，struct是public，class是private。\n\n结构体是一种特殊形态的类,它和类一样,可以有自己的数据成员和函数成员,可以有自己的构造函数和析构函数,可以控制访问权限，可以继承,支持包含多态等,二者定义的语法形式也几乎一样。结构体和类的唯一区别在于，结构体和类具有不同的默认访问控制属性：在类中,对于未指定访问控制属性的成员，其访问控制属性为私有类型(private) ;在结构体中,对于未指定任何访问控制属性的成员,其访问控制属性为公有类型。\n\n结构体可以有函数成员(包含构造函数和析构函数)，但实质上是函数指针。C语言没有权限控制的说法，C语言的结构体自然不能对成员进行权限控制。\n\n```cpp\n#include <stdio.h>\ntypedef struct CStructure\n{\nint (*memberFunction)(); //结构体里的函数成员，实质上是函数指针\n}CStructure;\nint globalFunction()\n{\nprintf(\"Member function of a struct in C\\n\");\nreturn 0;\n}\nint main()\n{\nCStructure obj; //创建结构体对象\nobj.memberFunction=globalFunction;//为函数指针赋值\nobj.memberFunction();//使用函数指针\nreturn 0;\n}\n```\n\n## 10）sizeof运算符用于获取数据类型占用的字节数\n\nsizeof 运算法用于获取数据类型占用的字节数。\n\ncpp中有5种不能重载的运算符：两个是类的成员引用符号（.和->)，一个是类空间引用符号(::)，一个是唯一的三元运算符(?:)，还有一个就是sizeof运算符\n\n## 11）typeid运算符可以输出变量的类型\n\ntypeid运算符可以输出变量的类型。\n![程序示例1](https://s3.bmp.ovh/imgs/2022/07/14/8a88a709070fd5a4.jpg)\n![程序示例2](https://s3.bmp.ovh/imgs/2022/07/14/a1eb9b5310ce14da.png)\n\n## 12）typedef \n\ntypedef 可以为现有数据类型创建一个别名，便于程序的阅读和编写。\n**补充**：\n\ntypedef和define都是替一个对象取一个别名，以此增强程序的可读性，区别如下：\n**（1）原理不同**\n\n#define是C语言中定义的语法，是预处理指令，在预处理时进行简单而机械的字符串替换，不作正确性检查，只有在编译已被展开的源程序时才会发现可能的错误并报错。\n\ntypedef是关键字，在编译时处理，有类型检查功能。它在自己的作用域内给一个已经存在的类型一个别名，但不能在一个函数定义里面使用typedef。用typedef定义数组、指针、结构等类型会带来很大的方便，不仅使程序书写简单，也使意义明确，增强可读性。\n\n**（2）功能不同**\n\ntypedef用来定义类型的别名，一是起到类型易于记忆的功能。另一个是定义机器无关的类型。如定义一个REAL的浮点类型，在目标机器上它可以获得最高的精度：typedef long double REAL， 在不支持long double的机器上，看起来是这样的，typedef double REAL，在不支持double的机器上，是这样的，typedef float REAL\n\n#define不只是可以为类型取别名，还可以定义常量、变量、编译开关等。\n\n**（3）作用域不同**\n\n#define没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用，而typedef有自己的作用域\n\n**（4）对指针的操作不同**\n\n```C\n例1：\n#define INTPTR1 int*     //新的别名放在中间，注意：#define N 5,别名N在中间\ntypedef int* INTPTR2; //新的别名在后面\nINTPTR1 p1, p2;\nINTPTR2 p3, p4;\n含义分别为，\n声明一个指针变量p1和一个整型变量p2 //因为#define知识简单的字符替换\n声明两个指针变量p3、p4\n例2：\n#define INTPTR1 int*\ntypedef int* INTPTR2;\nint a = 1;\nint b = 2;\nint c = 3;\nconst INTPTR1 p1 = &a;//等同于const int* p1,p1是常量指针\nconst INTPTR2 p2 = &b;//等同于const int* p2,p2是常量指针\nINTPTR2 const p3 = &c;//等同于int* const p3，p3是指针常量\n````\n\n```cpp\n//一、关于“指针常量“和“常量指针”的一些思考：\n主要是看这个表述最后的那个名词：是常量还是指针。那么它的本质就是对应的常量还是指针。\n//1、指针常量：本质是常量，但是常量里面装的是指针。\n表达式为（先*后const）：int* const p;\n所以，指针指向的地址不能变，但是地址中存储的值可以变化。\nint a=1,b=2;\nint* const p=&a;\ncout<<*p<<endl; //值为1\n*p=7; //正确，指针常量允许修改值。\n*p=&b; //错误！指针常量不允许修改指向的地址\n\n//2、常量指针：本质是指针，但是指针指向常量\n表达式为（先const后*）：const int* q;或者 int const* q; \n注意： const* int q;会报错。\n所以，指针指向的地址可以变，但是指针所指向的值不允许变化。\nint c=1,d=2;\nint const *q=&c;  // 或者 const int* q=&c;\ncout<<*q<<endl; //值为1\n*q=7; //错误！常量指针不允许修改值。\nq=&d; //正确，常量指针允许修改指向的地址\n```\n\n因为<font color=\'red\'>*引用* 是指针常量</font>嘛，所以引用本身是一个常量，但是里面装的是指针。即：引用的指针不能变，但是指向的内容可以变化。在定义**引用**的同时，必须初始化。\n\n+ 引用除了给变量赋予新的名称，还可以用于函数形参（常见于类的拷贝构造）。\n+ 引用可以用作函数返回值。注意，不要返回局部变量。还有**函数调用作左值**的使用。\n+ 常量引用，形如：`const int& v;`\n\n**小技巧**：\n\n+ 指针常量/常量指针，就看这个词的最后两个字是什么，它的本质就是什么。\n+ 指针常量：是一个常量，常量里面装的是指针，所以指针的指向内存不能改变；\n+ 常量指针：是一个指针，指针指向内存中存放的数据是称量，所以指针的指向内存可以变，但是存放的数据可以变。\n\n## 13）static \n\n用于声明静态变量或类的静态函数。静态变量作用范围在一个文件内，程序开始时分配空间，结束时释放空间，默认初始化为 0，使用时可改变其值。\ncpp 类的成员变量被声明为 static（称为静态成员变量），意味着它被该类的所有实例所共享，也就是说当某个类的实例修改了该静态成员变量，其修改值为该类的其它所有实例所见；而类的静态成员函数也只能访问静态成员（变量或函数）。\n**static和extern**\n\n对于全局变量和函数而言，两者功能相反，extern想让程序使用其他文件的函数或全局变量；static是将函数和全局变量限制在本文件当中。\n\n对于局部变量，static是将变量的创建空间从栈区更改到了静态数据区。\n**class类中的static成员函数/变量 和 const成员函数/变量**\n\n0、前言\n\n为什么cpp中会出现/保留static关键字和const关键字呢？\n参考链接：https://zhuanlan.zhihu.com/p/141113043\n\nstatic有两个功能，对于全局变量和函数，是限制其作用域；对于局部变量，是将其创建空间从栈区更改到静态存储区，以保证在函数调用结束时，变量值不会被释放。\n\n在cpp类的多个对象中，如果我们想要一个变量值，可以让所有对象共享，常规的做法是使用全局变量。但是全局变量的使用破坏了类的封装性，而类的静态变量，既可以让类内对象共享，也可以对类外对象隐藏。\n\n**cpp中为什么会引入const**\n\ncpp有一个类型严格的编译系统，这使得cpp程序的错误在编译阶段即可发现许多，从而使得出错率大为减少，因此，也成为了cpp与c相比，有着突出优点的一个方面。\n\nc中很常用的预处理命令`#define 变量名 变量值`，可以很方便地进行值替代。这种值代替至少有三个优势：\n\n> 一是避免了意义模糊的数字出现，使得程序语义流畅清晰，如下例：\n> 　　#define user_num_max 107 这样就避免了直接使用107带来的困惑。\n> 　　二是可以很方便地进行参数的调整与修改，如上例，当人数由107变为201时，进改动此处即可，\n> 　　三是提高了程序的执行效率，由于使用了预编译器进行值替代，并不需要为这些常量分配存储空间，所以执行的效率较高。\n\n预处理语句虽然有以上的许多优点，但它有个比较致命的缺点，即，预处理语句仅仅只是简单值替代，缺乏类型的检测机制。这样预处理语句就不能享受cpp严格类型检查的好处，从而可能成为引发一系列错误的隐患。\n\n结论：\n\n> const 推出的初始目的，正是为了取代预编译指令，消除它的缺点，同时继承它的优点。\n\n现在它的形式变为：`const typename 变量名=变量值`，**为什么const能很好的替代预定义命令？**\n\n> 1． 首先，以const 修饰的常量值，具有不可变性，这是它能取代预定义语句的基础。\n> 2． 第二，很明显，它也同样可以避免意义模糊的数字出现，同样可以很方便地进行参数的调整和修改。\n> 3． 第三，<font color=\'red\'>cpp的编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高</font>，同时，这也是它取代预定义语句的重要基础。这里，我要提一下，为什么说这一点是也是它能取代预定义语句的基础，这是因为，编译器不会去读存储的内容，如果编译器为const分配了存储空间，它就不能够成为一个编译期间的常量了。\n> 4． 最后，const定义也像一个普通的变量定义一样，它会由编译器对它进行类型的检测，消除了预定义语句的隐患。\n\n**const 使用场景分析**\n\n1. const用于修饰指针的两种情况\n\n```c\nint const *a; 　//a可变，*a不可变 [常量指针，本质为指针，指针指向的内存空间存放的是常量。所以，值不能变，指针能变。即*a不能变，a能变]\nint *const a; 　//a不可变，*a可变 [指针常量，本质为常量，常量里存放的是指针。所以指针指向不能变，值能变，例如cpp的引用。即a不能变，*a能变]\n```\n\n*分析*：const 是一个左结合的类型修饰符，它与其左侧的类型修饰符和为一个类型修饰符，所以，int const 限定\\*a,不限定a。int \\*const 限定a,不限定\\*a。\n\n2. const 限定函数的传递值参数\n   *分析*：上述写法限定参数在函数体中不可被改变。由值传递的特点可知，var在函数体中的改变不会影响到函数外部。所以，此限定与函数的使用者无关，仅与函数的编写者有关。\n3. const限定函数的返回值\n\n```C\nconst int fun1(); \nconst myclass fun2();\n```\n\n*分析*：上述写法限定函数的返回值不可被更新，当函数返回内部的类型时（如fun1），已经是一个数值，当然不可被赋值更新，所以，此时const无意义，最好去掉，以免困惑。当函数返回自定义的类型时（如fun2），这个类型仍然包含可以被赋值的变量成员，所以，此时有意义。\n\n一般而言，当返回值类型是指针或者class类，或者struct结构体时，返回值用const限制才比较合适。当返回值是基本数据类型时，用const并无意义。\n\n4. 传递与返回指针\n\n此种情况最为常见，由地址变量的特点可知，适当使用const，意义昭然。\n\n5. const限定类的成员函数\n\n```cpp\nclass classname {\n　public:\n　　int fun() const; //常成员函数\n　.....\n}\n```\n\n　　注意：采用此种const 后置的形式是一种规定，亦为了不引起混淆。在此函数的声明中和定义中均要使用const,因为const已经成为类型信息的一部分。\n\n> 获得能力：可以操作常量对象。\n>       失去能力：不能修改类的数据成员，不能在函数中调用其他不是const的函数。\n\n**const使用总结**\n\n> 1. 函数返回值为const时，返回的东西赋给一个类型相同的标示后其不能为左值；\n> 2. 用const定义的int可用来开辟数组，但const定义的常量数组中的元素，不能用来定义数组。\n> 3. const int *i; int const *i; int * const i; 前两个功能相同，说明i所指向的值不变；最后一个说明指针指向的地址不变，但值可以变。\n> 4. 类中的const成员函数,定义为在原型后加const。常量函数不能修改类中的任何属性。但有两种方法可以修改。\n>\n> > 1) {(yourclass *)this->member = values;}\n> > 2) 将一个成员定义成mutable即可被常量函数修改。\n>\n> 5. 类中的常量const 类型的，不能在类中被用来定义数组。而enum {ONE=100; TWO=2};定义的ONE、TWO 却可以。通常的enum定义的值分配问题：enum A{ L=9, Z};此时Z的值为10。\n\n一、静态数据成员的特点\n\n+ 静态成员不属于某一个对象，而是属于整个类（定义在数据段）\n+ 静态成员供所有对象共享，每个对象可以调用且修改。一个对象修改，其他对象也跟着变化\n+ 可以直接通过类名直接访问\n+ *注意!* 静态数据成员，类内定义，类外初始化\n\n二、类的静态成员函数\n\n+ 类的静态成员函数不属于某一个对象，属于整个类，所以不存在this指针\n+ 因为没有this指针，所以不能调用普通成员函数和变量\n+ 静态成员函数不能用const修饰\n+ 静态成员函数只能访问类的静态成员，不能访问普通成员。因为类的静态成员是属于整个类的，在类定义好的时候就已经在内存开辟了空间，而普通成员是在对象生成的时候才在内存开辟空间，如果使用静态成员函数去访问普通的类会出错\n+ 普通成员函数可以调用静态成员或者非静态成员\n\n三、类的常量成员const\n常量数据成员特点：\n\n+ 必须在构造函数那里进行列表初始化，不可以在构造函数内部初始化\n+ 初始化以后不可以再修改\n\n四、常量成员函数const\n\n+ 常量成员函数内不允许对类的成员变量进行修改，也不允许对函数的const参数进行修改（防止对成员变量误操作）\n\n五、比较compare：静态和常量\n\n+ 静态成员变量类内定义，类外初始化。常量成员必须在构造函数的初始化列表中初始化，不能在函数体中初始化；\n+ 普通对象能调用静态成员函数，能调用常量成员函数。静态对象只能调用静态成员函数，不能访问普通成员变量和函数*(因为类的静态成员是属于整个类的，在类定义好时就已经在内存中开辟了空间，而普通成员是在对象生成的时候才在内存中开辟空间，如果使用静态成员函数访问普通成员变量/函数就会出错)*。常对象只能访问常成员函数。常成员函数只能调用常成员变量(防止这个函数修改普通变量的值)，不过普通变量可用mutable关键字修饰，这样，常成员函数就可以了调用和修改它了。\n+ <font color=\'red\'>需要注意的是</font>,其实静态成员函数可以访问为非静态成员变量，只是十分复杂，故不建议采用。之前说到，静态成员函数不能访问普通成员变量，是因为没有this指针，那么如果静态函数的形参就包含该类，那就可以访问该类的普通成员变量了。`如类A中有static void f(A a); static int a,int b，void A::f(A a) {cout<<a;//正确，cout<<b;//错误；cout<<a.b/正确}`。\n+ 建议规范调用静态成员函数和变量，即使用类名而非对象名来调用静态对象。如A::a和A::func(),而不是A obj;obj.a和obj.func()。\n+ \n\n## 14）public、protected、private \n\n权限修饰符。\n\n## 15）virtual\n\n用于声明虚基类、虚函数。虚函数=0时，则为纯虚函数，纯虚函数所在的类称为抽象类。\n\n## 16）override、final\n\noverride 用于表示当前函数重写了基类的虚函数。\nfinal 用于禁止类继承、禁止重载虚函数。\n\n## 17）operator\n\n用于重载操作符。如下重载类Person的 == 运算法：\n![程序示例](https://s3.bmp.ovh/imgs/2022/07/14/12e8450b6ab81b3a.jpg)\n\n## 18）const、constexpr\n\nconst 表示所修饰的对象或变量不能被改变。\nconstexpr 用于生成常量表达式，常量表达式主要是允许一些计算发生在编译时，而不是运行的时候。\n\n## 19）using\n\n用于在当前文件引入命名空间，例如：using namespace std；\n在子类中，使用 using 声明引入基类成员名称。\n\n## 20）namespace\n\ncpp标准程序库中的所有标识符都被定义于一个名为 std 的namespace中。\n命名空间除了系统定义的名字空间之外，还可以自己定义，定义命名空间用关键字 namespace，使用命名空间时用符号 :: 指定。\n\n## 21）inline\n\n声明为内联函数，即在编译时将所调用的函数代码直接嵌入到主调函数中。\n作用是提高效率，但是程序应尽量短小\n\n## 22）new、delete  <font color=\'red\'>补充</font>\n\nnew 用于向内存申请一段新的空间，delete 用于释放申请空间。\n用new创建一个int型的空间，并附初始值：`int *p=new int(2);`。 `delete p`\n用new创建一个数组的空间，并附初始值：`int *p=new int [5](0);` `delete[] p`\n\n## 23）this\n\n每个类成员函数都隐含了一个this指针，用来指向类本身。\nthis指针一般可以省略，但在赋值运算符重载的时候要显示使用。静态成员函数没有this指针。\n\n## 24）nullptr\n\ncpp11新引入的，用来声明一个 空指针，代替NULL。\nint* p = nullptr;\n\n## 25）void\n\n特殊的\"空\"类型，指定函数无返回值或无参数。\n\n## 26）friend\n\n用于声明友元关系。\n友元可以访问与其有 friend 关系的类中的 private/protected 成员，通过友元直接访问类中的 private/protected 成员的主要目的是提高效率。\n友元包括友元函数和友元类。全局函数/成员函数做友元，类做友元。\n\n#### 4.4.1 全局函数做友元\n\n```cpp\nclass Building\n{\n	//告诉编译器 goodGay全局函数 是 Building类的好朋友，可以访问类中的私有内容\n	friend void goodGay(Building * building);\n\npublic:\n\n	Building()\n	{\n		this->m_SittingRoom = \"客厅\";\n		this->m_BedRoom = \"卧室\";\n	}\n\n\npublic:\n	string m_SittingRoom; //客厅\n\nprivate:\n	string m_BedRoom; //卧室\n};\n\n\nvoid goodGay(Building * building)\n{\n	cout << \"好基友正在访问： \" << building->m_SittingRoom << endl;\n	cout << \"好基友正在访问： \" << building->m_BedRoom << endl;\n}\n\n\nvoid test01()\n{\n	Building b;\n	goodGay(&b);\n}\n\nint main(){\n\n	test01();\n\n	system(\"pause\");\n	return 0;\n}\n```\n\n\n\n#### 4.4.2 类做友元\n\n```cpp\nclass Building;\nclass goodGay\n{\npublic:\n	goodGay();\n	void visit();\nprivate:\n	Building *building;\n};\nclass Building\n{\n	//告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类中私有内容\n	friend class goodGay;\npublic:\n	Building();\npublic:\n	string m_SittingRoom; //客厅\nprivate:\n	string m_BedRoom;//卧室\n};\nBuilding::Building()\n{\n	this->m_SittingRoom = \"客厅\";\n	this->m_BedRoom = \"卧室\";\n}\ngoodGay::goodGay()\n{\n	building = new Building;\n}\nvoid goodGay::visit()\n{\n	cout << \"好基友正在访问\" << building->m_SittingRoom << endl;\n	cout << \"好基友正在访问\" << building->m_BedRoom << endl;\n}\nvoid test01()\n{\n	goodGay gg;\n	gg.visit();\n\n}\nint main(){\n\n	test01();\n\n	system(\"pause\");\n	return 0;\n}\n```\n\n#### 4.4.3 成员函数做友元\n\n```cpp\nclass Building;\nclass goodGay\n{\npublic:\n\n	goodGay();\n	void visit(); //只让visit函数作为Building的好朋友，可以发访问Building中私有内容\n	void visit2(); \n\nprivate:\n	Building *building;\n};\n\n\nclass Building\n{\n	//告诉编译器  goodGay类中的visit成员函数 是Building好朋友，可以访问私有内容\n	friend void goodGay::visit();\n\npublic:\n	Building();\n\npublic:\n	string m_SittingRoom; //客厅\nprivate:\n	string m_BedRoom;//卧室\n};\n\nBuilding::Building()\n{\n	this->m_SittingRoom = \"客厅\";\n	this->m_BedRoom = \"卧室\";\n}\n\ngoodGay::goodGay()\n{\n	building = new Building;\n}\n\nvoid goodGay::visit()\n{\n	cout << \"好基友正在访问\" << building->m_SittingRoom << endl;\n	cout << \"好基友正在访问\" << building->m_BedRoom << endl;\n}\n\nvoid goodGay::visit2()\n{\n	cout << \"好基友正在访问\" << building->m_SittingRoom << endl;\n	//cout << \"好基友正在访问\" << building->m_BedRoom << endl;\n}\n\nvoid test01()\n{\n	goodGay  gg;\n	gg.visit();\n\n}\n\nint main(){\n    \n	test01();\n\n	system(\"pause\");\n	return 0;\n}\n```\n\n\n\n## 27）template \n\n模板，cpp中泛型机制的实现。模板就是实现代码重用机制的一种工具，它可以实现类型参数化，即把类型定义为参数， 从而实现了真正的代码可重用性。模版可以分为两类，一个是函数模版，另外一个是类模版。\n\n## 28）if、else\n\n用于条件语句。\n\n## 29）for、while、do\n\n用于循环语句。\n\n## 30）switch、case、default\n\n用于分支语句。switch 表示分支语句的起始，根据 switch 条件跳转到 case 标记或 defalut 标记的分支上。\n\n## 31）break、continue、goto\n\nbreak用于跳出for、while循环或switch语句。\ncontinue用于跳到一个循环的起始位置。\ngoto用于无条件跳转到函数内的标记处，一般情况不建议使用goto。\n\n## 32）and、or、xor、not、bitand、bitor\n\nand 表示逻辑与 &&；\nor 表示逻辑或 ||；\nxor 表示逻辑异或 ^；\nnot 表示逻辑非 !；\nbitand 表示按位与 &；\nbitor 表示按位或 |。\n\n## 33）return\n\nreturn表示从被调函数返回到主调函数继续执行，返回时可带一个返回值。\n\n## 34）try、catch、throw\n\n用于异常处理。try 指定 try 块的起始，try 块后的 catch 可以捕获异常，异常由 throw 抛出。\n\n## 35）noexcept\n\ncpp11中，用于声明一个函数不可以抛出任何异常。\n\n## 36）static_cast、const_cast、dynamic_cast、reinterpret_cast\n\ncpp类型风格来性转换：\nstatic_cast用于静态转换；\nconst_cast删除const变量的属性，方便赋值；\ndynamic_cast用于将一个父类对象的指针转换为子类对象的指针或引用；\nreinterpret_cast将一种类型转换为另一种不同的类型。\n参考链接：https://www.cnblogs.com/wangchaoguo-li/p/14210679.html\n\n|       方式       |                           使用场景                           |\n| :--------------: | :----------------------------------------------------------: |\n|   static_cast    | 基本数据类型之间的转换使用，例如float转int，int转char等；子类对象指针转换成父类对象指针也可以使用static_cast；在有类型指针和void\\*之间转换使用，不能使用static_cast在有类型指针之间进行类型转换。 |\n|   dynamic_cast   | 用于将父类的指针或引用转换为子类的指针或引用，此场景下父类必须要有虚函数（只要拥有虚函数就行） |\n|    const_cast    |       用于常量指针或引用与非常量指针或引用之间的转换。       |\n| reinterpret_cast | 类似C语言中的强制类型转换，什么都可以转，尽量不要使用此方式。 |\n\n**static_cast**\n\n基本数据类型之间的转换使用，例如float转int，int转char等，在有类型指针和void\\*之间转换使用，子类对象指针转换成父类对象指针也可以使用static_cast（<font color=\'red\'>不能使用static_cast在有类型指针之间进行类型转换</font>）。\n\n```c\n#include <iostream>\n\nusing namespace std;\n\nstruct Base {\n    virtual void Func() { cout << \"Base Func \\n\"; }\n};\n\nstruct Derive : public Base {\n    void Func() override { cout << \"Derive Func \\n\"; }\n};\n\nint main()\n{\n    float f = 1.23;\n    cout << \"f \" << f << endl;\n    int i = static_cast<int>(f);\n    cout << \"i \" << i << endl;\n\n    void *p;\n    int *i_p = static_cast<int *>(p);\n    void *pi = static_cast<void *>(&f);\n    int *pi = static_cast<int *>(&f);  //error invalid static_cast from type ‘float*’ to type ‘int*’\n\n    Derive d;\n    d.Func();\n    Base *b = static_cast<Base *>(&d);\n    b->Func();\n    return 0;\n}\n```\n\n**dynamic_cast**\n\n用于将父类的指针或引用转换为子类的指针或引用，此场景下父类必须要有虚函数（只要拥有虚函数就行），因为dynamic_cast是运行时检查，检查需要运行时信息RTTI。\n\n```cpp\n#include <iostream>\n\nusing namespace std;\n\nstruct Base {\n    virtual void Func() { cout << \"Base Func \\n\"; }\n};\n\nstruct Derive : public Base {\n    void Func() override { cout << \"Derive Func \\n\"; }\n};\n\nint main() {\n    Derive d;\n    d.Func();\n    Base *b = dynamic_cast<Base *>(&d);\n    b->Func();\n    Derive *dd = dynamic_cast<Derive *>(b);\n    dd->Func();\n    return 0;\n}\n```\n\n**const_cast**\n\n用于常量指针或引用与非常量指针或引用之间的转换，只有const_cast才可以对常量进行操作，一般都是用它来去除常量性（去除常量性是危险操作，还是要谨慎操作）。\n\n```cpp\nint main() {\n    int data = 10;\n    const int *cpi = &data;\n\n    int *pi = const_cast<int *>(cpi);\n\n    const int *cpii = const_cast<const int *>(pi);\n    return 0;\n}\n```\n\n**reinterpret_cast**\n\n类似C语言中的强制类型转换，什么都可以转，万不得已不要使用，一般前三种转换方式不能解决问题了使用这种强制类型转换方式。\n\n```cpp\nint main() {\n    int data = 10;\n    int *pi = &data;\n\n    float *fpi = reinterpret_cast<float *>(pi);\n\n    return 0;\n}\n```\n\n## 37）register\n\n提示编译器尽可能把变量存入到CPU内部寄存器中。\n\n## 38）explicit\n\nexplicit 的作用是禁止单参数构造函数被用于自动类型转换，比较典型的是容器类型。\n\n再次注意，是单参数，形如`explicit Fraction(int numerator:m_numerator(numerator){}`，还有一种情况是多参数，但是后面几个参数都有默认值，只有第一个参数没有默认值：`explicit Fraction(int numerator, int denominator = 1): m_numerator(numerator), m_denominator(denominator){}`\n\n注意：当类的声明和定义分别在两个文件中时，explicit只能写在在声明.h中，不能写在定义.c中。\n参考链接：[CSDN](https://blog.csdn.net/l2563898960/article/details/97769569)\nexplicit意为清晰地，明确的意思，顾名思义，它的作用就是阻止隐式转换的发生。\n**例如**: cpp中只带有一个参数的构造函数,或者或者除了第一个参数外其余参数都有缺省值的多参构造函数,承担了两个角色:\n1.用于构建单参数的类对象.\n2.隐含的类型转换操作符.\n\n>例如:一个类A的构造函数A(int i)就是，既可以用来作为构造器，又可以实现隐式转换A a=1；因为1可以通过构造函数A(int i)转换为一个类A的对象。(隐含的类型转换操作符)\n\n但有时候，我们并不想让他进行隐式转换，这是cpp的explicit关键字就起作用了。\nexplicit的三种使用情况：**类型转换（operator())**、**单操作数构造函数**、**同时出现类型转换和有参构造函数**\n再说下面的内容前，需要提及：类型类型转换函数的一般形式：\n\n```cpp\noperator 数据类型() const\n{\n	//函数实现\n}\n```\n\n> 1.转换函数必须是类的成员函数\n> 2.转换函数不能声明返回类型\n> 3.形参列表必须为空\n> 4.类型转换函数通常应该是const\n\n### 使用情况1：类型转换\n\n```cpp\n#include<iostream>\nusing namespace std;\nclass Fraction{\npublic:\n	Fraction(int numerator, int denominator = 1): m_numerator(numerator), m_denominator(denominator){}\n	operator double() const   //类型转换函数\n	{\n		return (double)m_numerator/m_denominator;\n	}\nprivate:\n	int m_numerator;\n	int m_denominator;\n};\n\nint main(void)\n{\n	Fraction f(3, 5);\n	double d = 3.5 + f;\n	cout << d << endl;\n	return 0;\n}\n```\n\n我们设计了一个Fraction类(分数类), 在主函数中定义了一个分数对象<font color=red>f</font>,然后将<font color=red>3.5 + f</font>赋值给double类型变量<font color=red>d</font>, 但是我们发现f并不是一个double类型的变量,因此编译器会从Fraction类中寻找<font color=red>operator double()</font>函数,隐式调用该函数将Fraction类型转换成一个double类型. <font color=red>operator double()</font>就是我们所说的类型转换函数(type conversion function).\n\n注意，此代码中含有隐式类型转换。在计算3.5+f时，类的对象f回调用类型转换函数operator double()来将f转换成double。\n\n使用explicit关键字来避免隐式类型转换，在进行类型转换时，必须显示声明：用`static_cast<double>f`\n\n```cpp\n#include<iostream>\nusing namespace std;\nclass Fraction{\npublic:\n	Fraction(int numerator, int denominator = 1): m_numerator(numerator), m_denominator(denominator){}\n	explicit operator double() const    //不能隐式类型转换了\n	{\n		return (double)m_numerator/m_denominator;\n	}\nprivate:\n	int m_numerator;\n	int m_denominator;\n}；\n\nint main(void)\n{\n	Fraction f(3, 5);\n	double d = 3.5 + static_cast<double>(f);//必须显式类型转换\n	cout << d << endl;\n	return 0;\n}\n```\n\n### 使用情况2：有参构造函数\n\n对于3.5+f，上面的例子是使用类型转换来实现的。其实，也可以使用重载运算符+的方法来实现，不过，需要写成f+3.5的形式。\n\n```cpp\n//code 1\n#include<iostream>\nusing namespace std;\nclass Fraction\n{\npublic:\n    Fraction(int numerator, int denominator = 1) : m_numerator(numerator), m_denominator(denominator) {}\n    double operator+(double a)\n    {\n        return (double)this->m_numerator /this->m_denominator+a;\n    }\nprivate:\n    int m_numerator;\n    int m_denominator;\n};\n\nint main(void)\n{\n    Fraction f(3, 5);\n    double d = f+3.5;\n    cout << d << endl;\n    system(\"pause\");\n    return 0;\n}\n////////////////operator+中隐藏的类型转换//////////////////////////////\n//code 2\n#include<iostream>\nusing namespace std;\nclass Fraction\n{\n public:\n 	Fraction(int numerator, int denominator = 1): m_numerator(numerator), m_denominator(denominator){}\n 	double operator+(const Fraction& a)\n 	{\n 		return (a.m_numerator + this->m_numerator)/(a.m_denominator + this->m_denominator);\n 	}\n private:\n 	int m_numerator;\n	int m_denominator;\n }\n \n int main(void)\n{\n	Fraction f(3, 5);\n	double d = f + 3;\n	cout << d << endl;\n	return 0;\n}\n```\n\n在double d = f + 3 这句话中构造函数就是前面所提到的第二种角色隐含的类型转换操作符.,因为执行到这句话首先会调用+的重载函数,该函数的调用对象默认为左操作数,右操作数为Fraction类型,因此会调用有参构造函数将3转换成Fraction类型,然后将得到的返回值double类型赋值给变量d.\n\n同理如果不想让构造函数进行隐式类型转换,可以在构造函数前面加上explicit关键字,防止进行隐式转换.使用方法如下:\n\n```cpp\n#include<iostream>\nusing namespace std;\nclass Fraction\n{\n public:\n 	explicit Fraction(int numerator, int denominator = 1): m_numerator(numerator), m_denominator(denominator){}\n 	double operator+(const Fraction& a)\n 	{\n 		return (a.m_numerator + this->m_numerator)/(a.m_denominator + this->m_denominator);\n 	}\n private:\n 	int m_numerator;\n	int m_denominator;\n };\n \n int main(void)\n{\n	Fraction f(3, 5);\n	double d = f + 3;//注意，此处代码会报错\n	cout << d << endl;\n	system(\"pause\");\n	return 0;\n	//想要代码运行，需要将3类型准换为Fraction类，即使用类的有参构造函数。但是有参构造函数使用explicit修饰，不能隐式类型转换。\n}\n```\n\n### 使用情形3：有参构造和类型转换函数同时出现\n\n```cpp\n#include<iostream>\nusing namespace std；\nclass Fraction\n{\n public:\n 	Fraction(int numerator, int denominator = 1): m_numerator(numerator), m_denominator(denominator){}\n 	operator int()  //强制类型转换\n 	{\n 		return m_numerator/denominator;\n 	}\n 	int operator+(const Fraction& a)//重载运算符+，以及隐式使用了有参构造函数\n 	{\n 		return (a.m_numerator + this->m_numerator)/(a.m_denominator + this->m_denominator);\n 	}\n private:\n 	int m_numerator;\n	int m_denominator;\n }\n\n int main(void)\n{\n	Fraction f(3, 5);\n	int d = f + 3;//上面两种方法都有效，使用哪个？有歧义\n	cout << d << endl;\n	return 0;\n}\n```\n\n这时你会发现会产生一个二义性问题,在执行int d = f + 3的时候到底是该选择类型转换函数,将f转换成int类型再继续运算呢?还是应该将3作为构造函数的参数进行隐式转换,然后再调用+运算符重载函数呢?\n解决这个问题的办法就是使用explicit关键字限制,具体方法有两种：\n1.在构造函数前面加上explicit关键字, 防止int类型隐式转换成为Fraction类型.\n2.在类型转换函数前面加上explicit关键字,这样只有显示调用类型转换`static_cast<int>(f)`时,才会调用该函数.\n**总结**：\n\n1. cpp中，一个参数的构造函数(或者除了第一个参数外其余参数都有缺省值的多参构造函数)，承担了两个角色。\n\n+ 用于构建单参数的类对象\n+ 隐含的类型转换操作符\n\n2. explicit关键字只对有一个参数的类构造函数有效, 如果类构造函数参数大于或等于两个时, 是不会产生隐式转换的, 所以explicit关键字也就无效了\n3. 声明为explicit的构造函数不能在隐式转换中使用，只能显示调用，去构造一个类对象。\n\n```cpp\nBase base(‘a’) //显示调用,OK\nBase base = ‘a’ //隐式调用,err 调用了单参数的有参构造函数，或多参数，但后面几个参数有缺省值的\n```\n\n4. 尽量避免有二义性的类型转换，如果类中包含一个或多个隐式类型转换，则必需使用explicit关键字确保在类类型和目标类型之间只存在唯一一种隐式转换方式，否则将出现二义性。\n5. 但是将拷贝构造函数声明成explicit并不是良好的设计，一般只将有单个参数的constructor声明为explicit，而copy constructor不要声明为explicit.\n\n## 39）extern\n\n1、\n\n当出现extern “C”时，表示 extern “C”之后的代码按照C语言的规则去编译；\n\n当extern修饰变量或函数时，表示其具有外部链接属性，即其既可以在本模块中使用也可以在其他模块中使用。\n\n为什么会出现 extern “C\" ?因为C不支持函数重载，而cpp支持函数重载，所以两类编程语言在汇编时对函数的处理方式不一样。c语言是用函数名来匹配，cpp使用函数名+形参列表来匹配。对于函数`Func(int i,int j)`,c语言的汇编结果为Func，cpp汇编结果为`_Z8Funcii`，这样如果c和cpp混编的话就会出现链接时找不到函数定义的情况。\n**注意**：除了函数重载外，extern “C”不影响cpp的其他特性\n\n```cpp\n//一般情况，extern \"C\"是和函数声明放在一起，即位于h头文件中\n//情况1：在cpp中调用c代码的函数\nc文件中有一个函数： void Transfer(int a,char b);\ncpp文件必须用extern \"C\"声明该函数如下才可以实现调用：\nextern \"C\" void Transfer(int a,char b);\n\n//情况2：c调用cpp代码的函数\nc文件若要调用，就必须在cpp文件中用extern \"C\"来声明该函数，否则cpp在编译过程中就会对其进行名字改编，c文件就找不到该函数的原型\ncpp文件中有一函数：\n        void Transfer(int a; char b);\n但必须用extern \"C\"来声明后，如下：\n        extern “C” void Transfer(int a; char b);\nc文件才可以调用void Transfer(int a; char b)函数。\n\n//附加说明1\n在.cpp文件中引用c的头文件：\n　// cpp code\n　　extern “C” {\n　　#include “my-header1.h”\n　　#include “my-header2.h”\n　　}\n//附加说明2\nc的头文件如果想被cpp文件使用的话：\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n ...   // 按照C语言的规则去编译，C语言的头文件声明放在此处\n#ifdef __cplusplus\n}\n#endif\n使用附加说明1，cpp代码能正确使用c的头文件。使用附加说明2，该c头文件可被c和cpp正确使用。两种情况，仍选其一即可。\n```\n\n2、extern关键字的常规使用\nextern是用来声明全局变量或者全局函数的，需要注意，是声明，不是定义\n`extern  int  i; //声明变量i，但没分配存储空间，还不能使用`，还有`int  i; //定义了变量i，并分配了空间，可以使用`。注意：在程序中一个变量可以声明多次，但只能定义一次。如果声明时有初始化式，也会被当做定义，例如：\n`extern  int  i = 5； //定义了变量5 ，说明：这样做不规范，会被报警告`\n后面的程序中若再出现extern  int  i = 5；或者int  i;的语句，就会出错，因为变量只能定义一次。\n\n**关于extern的进一步说明**：对于普通定义的变量，常规定义正常使用；在其他文件中要使用此变量时，需要先加extern做声明，编辑器才会在当前文件以外的文件中去寻找该变量或函数的定义，例如：\n\n```cpp\nfile1:\n	int i=10;\nfile2:\n	extern int i;\n	i=2;\n```\n\n**特别地**：对于被const修饰的变量或函数而言，这个变量/函数默认为“局部的”。即使在其他文件中使用extern修饰了也无法使用。如果想在其他文件中使用这个变量，必须在定义该const变量时，显式地指出它将用于外部文件：\n\n```cpp\nfile1:\nextern const int i=10;\nfile2:\nextern const int i;\n```\n\n**说明**：extern与static的功能是相对的。extern用于在程序中使用其他文件中定义的变量或函数，1）static修饰函数，用于将函数的使用限制在当前文件内。2）static修饰全局变量也是同样的道理，限制变量的使用区域。3）static修饰局部变量，那变量的创建空间就从栈区变更到了静态数据区，可用于多次调用某个函数时，函数内计数值的递增。\n\n## 40）mutable\n\nmutable就是为了突破成员函数 const的限制，可以在const函数里面来修改被mutable修饰的成员变量。',1,0,0,0,1,'2023-06-07 16:36:15','2023-06-07 19:55:52');
INSERT INTO `t_article` VALUES (75,1,51,'https://upload.haoxx.site/article/2ec42f646cb85e6554ab21b4e9bc6c19.jpg','C++指针与常量知识点说明','---\ntitle: C++指针与常量知识点说明\ndate: 2022-10-30\ncategory:\n - 1编程语言基础\n\nfooter: <a href=\"https://beian.miit.gov.cn/#/Integrated/index\">渝ICP备2023001651号</a>\n\n---\n\n:::tip\nC++指针与常量知识点说明\n:::\n\n<!-- more -->\n\n\n[参考资料](https://www.cnblogs.com/zpcdbky/p/4902688.html)\n\n网上常见的说法似乎有误：\n\n```cpp\nconst int* p  //常量指针\nint* const p  //指针常量\n```\n\n在外文书籍中很少有这种说法。一种简洁易懂的说法是：\n\n> 指向常量的指针----`const int* p`     【常量指针】\n>\n> 本身是常量的指针----`int* const p`  【本身是常量的指针】，也是cpp中的引用\n\n判断方法：\n	**先找到\\*，然后看\\*的两边，右边是对指针p本身的限定，左边是对p所指向的东西的限定。**\n\n说明：(顺带一提：\\*号优先级排第二，从右往左结合)\n\n1.const int\\* p：\n\n就是所谓的“指向常量的指针”。这里注意，<font color=\"blue\">所谓“指向常量”只是这个指针的“一厢情愿”，只是一种效果上的等价。</font>事实上，const int \\*p=&a;a既可以是常量(const int a=10;)又可以是变量(int a=10;)，但p一厢情愿地认为它所指的就是一个常量，所以它不允许通过自己来修改所指，这就造成一种效果上的等价——从p的角度看，它所指的“的确”是常量。所以，<font color=\"red\">对“指向常量的指针”的最佳理解应为：我们不能通过该指针修改它所指向的东西（常量或者变量）。</font>\n\n 注意，const int \\*p=&a;只是说不能通过p来修改a，如果a本身不是const的，通过其它方式修改a自然是可以的（例如直接++a）。\n\n另外一点，由于p本身只是一个普通的指针，所以允许在声明时不初始化。但需要注意的是，我们只是说可以，但并不提倡这样做。在任何时候都不应该让指针无所指，如果在声明一个指针时还不知道让它指向谁，就先将其初始化为nullptr或NULL（nullptr是cpp11新特性，用它比用NULL更安全些，这里不详细介绍）。\n\n2.int\\* const p：\n\n就是所谓的“本身是常量的指针”。关于“p本身不能修改但可以通过p修改其所指”这一点，我们在讲判断方法时已经说过，这里主要再说一下p的初始化。\n\n由于p本身是const的，所以在编译的时候必须知道p的值（即p所指向的东西的地址），所以在声明p的同时必须初始化p。但要注意，对于 int\\* const p=&a，我们只要求a的地址是确定的，但a的值可以不确定。\n\n3.const int\\* cosnt p：\n\n就是所谓的“所指和本身都是常量的指针”。它的语法特性就是前两者的结合，这里不再赘述。\n\n4.补充说明：\n\n引用生命是必须初始化，且必须左值初始化。这一点与“本身是敞亮的指针”(int\\* const p)的特性一样。事实上，我们完全可以借用“本身是常量的指针”来理解甚至定义引用：\n\n**引用是一个指向不可变的、被编译器自动解引用的指针，即，引用是一个被编译器自动解引用的“本身是常量的指针”。**\n-',1,0,0,0,1,'2023-06-07 16:36:49','2023-06-07 19:56:15');
INSERT INTO `t_article` VALUES (76,1,51,'https://upload.haoxx.site/article/e16db2f6b4c568f36a1baa140b2e3b86.jpg','C/C++的比较','---\ntitle: C/C++的比较\ndate: 2022-04-01\ncategory:\n - 1编程语言基础\n\nfooter: <a href=\"https://beian.miit.gov.cn/#/Integrated/index\">渝ICP备2023001651号</a>\n\n---\n\n:::tip\nC/C++的比较\n:::\n\n<!-- more -->\n\n\n## 1、第一部分 C++高級編程\n\n以下部分内容来源于[知乎：C++高级编程学习笔记](https://zhuanlan.zhihu.com/p/414375745)\n1.头文件添加注释(文件名, 作者, 函数简介, 日期). （建议而非必要）\n2.当头文件数目较多时, 应将头文件放在include目录下, 源文件放在source目录下.\n3.const常量有数据类型, 宏常量#define没有数据类型.\n4.对于重载赋值运算符`operator =`, 应该用\"引用传递\"方式。形如：\n\n```cpp\nA operator=(B &b)\n{\n	A a;\n    a.Data=b.Data;\n    return a;\n}\n//或\n#include <iostream>\nusing namespace std;\n\nclass Distance\n{\nprivate:\n    int feet;\n    int inches;\npublic:\n    Distance(){\n        feet=0;\n        inches=0;\n    }\n    Distance(int f,int i){\n        feet=f;\n        inches=i;\n    }\n    void operator=(const Distance &D) //赋值运算符重载\n    {\n		feet=D.feet;\n        inches=D.inches;\n    }\n    void displayDistance()\n    {\n		cout<<\"F: \"<<feet<<\"I: \"<<inches<<endl;\n    }\n};\nint main()\n{\n	Distance D1(11,10),D2(5,11);\n	\n	cout<<\"First Distance : \";\n	D1.displayDistance();\n	cout<<\"Second Distance : \";\n	D2.displayDistance();\n	\n	//使用赋值运算符\n	D1=D2;\n	cout<<\"then,the new First Distance :\";\n	D1.displayDistance();\n	return 0;\n}\n```\n\n5.函数入口处用assert检查\n6.内存分配方式有三种, 从静态存储区域分配, 从栈上分配, 从堆上分配, 静态存储区包括全局变量, static变量等.\n7.C++/C语言，没有办法知道指针所指的内存容量.\n8.指针消亡了, 不表示所指的内存会被自动释放。内存被释放了, 不表示指针会消亡或者成了NULL指针.\n9.指针被free或delete之后, 别忘记设置为NULL.\n\n关于8和9的思考：先用指针开辟一个空间，然后在令指针为NULL。这时，指针消亡了，但是内存空间还在，只是不能使用了（内存泄漏）。对开启了空间的指针free或者delete，内存空间会被释放，但是指针还能使用（只是使用前需要重新在赋指针值）。\n10.malloc不调用构造函数, new自动调用构造函数, free和delete类似.\nmalloc是c语言的底层函数，new是C++的类方法。\n11.为什么要用重载? (1) 便于记忆。(2) 不得不, 比如说类的多个构造函数\n12.不能编译头文件\n全局变量定义时, (直接赋值), extern无作用\n全局变量声明时, extern告诉编译器, 定义部分在其它模块中\n全局变量默认extern\n13.重载: 同一个类中, 或都是全局函数.\n覆盖: 分别位于派生类与基类中, 函数名与参数都相同，有virtual关键字，用于多态.\n隐藏: 分别位于派生类与基类中, 只要同名, 且非覆盖, 均为隐藏.\n14.函数参数的缺省值，只能出现在函数的<font color=\"red\">声明</font>中. \n15.操作符重载。调用时, 普通函数参数出现在圆括号内, 对于运算符, 参数出现在其左右两侧。定义时，可定义为全局函数和类的成员函数，后者比前者少了一个参数。\n16.类的构造次序，先构造基类，再构造构造函数的参数，再构造成员，再构造自己。析构完全相反。\n17.String a(\"hello\"); String b=a; 其实是调用了b的拷贝构造函数，最好写成String b(a).\n18.对于一个类，编译器默认生成4个函数，无参构造函数，拷贝构造函数，析构函数，赋值函数(重载=运算符)\n19.类的析构函数，应为虚函数, 多态\n20.对于非内部数据类型的输入参数，应该将“值传递”的方式，改为“const 引用传递”，目的是提高效率。例如，将void Func(A a)，改为 void Func(const A &a)。其实实参在向形参传递值时，是用实参的值在栈上重新开辟了一块临时空间，再来装实参的值。如果使用引用的方法，就是单纯地指针传递，没有开辟空间这个步骤，节约时间，节约栈内存。\n21.引用被创建的同时，必须被初始化，一旦引用被初始化，就不能改变引用的关系。引用的实质是<font color=\"red\">指针常量</font>。即：<font color=\"red\">指针常量：本质为常量，常量里面装的是指针。所以，指针的指向不能变，指向的内存空间中，存放的值可以变</font>。\n22.对比于C语言的函数，cpp增加了重载，内联，const和virtual四种新机制，重载和内联机制，既可以用于全局函数，也可用于类的成员函数，const与virtual机制，仅用于类的成员函数\n23.赋值符号的重载，不能为友元，只能是类的成员函数\n\n## 2、第二部分 cpp和C的区别\n\n紧接上文，还是参考[知乎专栏](https://zhuanlan.zhihu.com/p/414375745)\n1、概述\n\n+ C++三要素：封装、继承、多态。封装是class，继承是class的继承，多态是函数重载和运算符重载\n+ 面向对象：\n  对象：存在即合理，抽象性：物以类聚，封装：事物的封闭性，继承：事物的相似性，多态：事物的多样性。\n+ 面向对象的方法：\n  ![图1](https://s3.bmp.ovh/imgs/2022/07/25/b6c212804ba23100.jpg)\n+ cpp是什么？\n  cpp是c语言的超集；是面向对象编程；可移植性，不牺牲性能和底层功能。可以用cpp compiler将cpp代码翻译成c代码\n+ cpp适合？\n  算法、应用开发、C/cpp服务器\n+ cpp设计原则\n  =1、cpp设计成使用静态型别机制、与C同样高效，可移植的，多用途程序设计语言。\n  =2、cpp设计成直接的和广泛的，支持多种程序设计风格（程序化程序设计、数据抽象化、面向对象程序设计、泛型程序设计）。\n  =3、cpp设计成给程序设计者，更多的选择，即使可能导致程序设计者选择错误。\n  =4、cpp设计成尽可能与C兼容，提供一个从C到cpp的平滑过渡。\n  =5、cpp避免平台限定，或没有普遍用途的特性。\n  =6、cpp不使用会带来额外开销的特性。\n  =7、cpp设计成无需复杂的程序设计环境。\n\n2、流的概念\ncpp的I/O是以字节流的形式实现的，流(stream)实际上就是一个字节序列。\n输入流: 在输入操作中，字节从输入设备(如键盘、磁盘、网络连接等)流向内存；输出流: 在输出操作中，字节从内存流向输出设备(如显示器、打印机、磁盘、网络连接等);这里“流”，试图说明字符，随着时间顺序生成或消耗的。输人/输出系统的任务，实际上就是以一种稳定、可靠的方式，在设备与内存之间传输数据。cpp并没有直接定义，进行输入输出的任何语句，这些功能是由标准IO库完成。\n\n3、命名空间\n实际上就是，一个由程序设计者命名的内存区域，程序设计者，可以根据需要指定一些有名字的空间域，把一些全局实体，分别放在各个命名空间中，从而与其它全局实体分隔开来。\n\n命名空间是ANSIcpp引入的，可以由用户命名的作用域，用来处理程序中常见的同名冲突。\n4、cpp程序的执行过程\n预处理、汇编、编译、连接\n5、C/cpp的字符串比较\n\n① C语言字符串练习 char st[100];\n① cpp语言字符串练习 string str;\n\n② 检测字符串长度 int len = strlen(st);\n② 检测字符串长度 int len = str.length();\n\n③ 字符串比较 strcmp(st1, st2);\n③ 字符串比较 str1.compare(str2);\n\n④ 在已有字符串后，追加新串 strcat(st1, st2); strncat(st1,st2,n);\n④ 在已有字符串后，追加新串 str1 += str2; str1.append(str2);\n\n⑤ 字符串拷贝 strcpy(st1,st2); strncpy(st1,st2, n);\n⑤ 字符串拷贝 str2 = str1; str2 = str1.substr();\n\n⑥ 字符串查找 where = strchr(st, ch)\n⑥ 字符串查找 where = str1.find(str2);\n\n6、c/cpp的数据类型和变量\n数据类型：\n![图3](https://s3.bmp.ovh/imgs/2022/07/25/9a78f1d9dd477a24.jpg)\n程序运行过程中，值能否发生改变，分为**常量和变量**\n从变量作用域的大小考虑：全局变量，局部变量\n全局变量：定义在所有的函数体之外，在程序开始运行时，分配存储空间，在程序结束时，释放存储空间\n函数中定义的变量，称为局部变量（Local Variable）\n从变量的生命周期考虑: 静态生存周期和动态生存周期\n动态存储变量：变量仅在需要的时候，分配和占用内存\n静态存储变量：变量在程序运行过程中，占用固定的内存\n从变量的在内存中位置考虑：普通变量与指针变量\n\nC语言中没有引用，cpp中才有引用，引用的主要用途，就是在函数传参和返回值上。如果既要利用引用提高使用效率，又要保护传递给函数的数据，不在函数中被改变，就应当使用常引用。\n\n如果输入参数，以值传递的方式传递对象，宜改用“&”引用方式来传递，这样可以省去临时对象的构造和析构过程，提高效率。特别是函数形参为类对象时，最好使用引用传递，而非值传递。\n\n如果函数的返回值是一个对象，有些场合，用“引用传递”替换“值传递”，可以提高效率，有些场合不可以。\n\n常引用\n\n声明一个引用，不是新定义一个变量，只是该引用名是目标变量的一个别名，本身不是一种数据类型，引用不占存储单元。对引用取地址，就是对目标变量取地址。\n\n还需注意，所谓常引用，这个“常”只对引用有效，对原数据是无效的。例如`int a=10;const int &b=a;a=20；//该语句有效，b=20;//该语句无效！`\n\n警告：主函数不允许操作栈指针！（如何区分指针和引用？）\n\n```cpp\n#include<iostream>\nusing namespace std;\nint &getlnt(const int v) //int&返回引用，int* getlnt(*)是返回指针\n{\nint *p = new int(v);\nreturn *p;\n}\nint main()\n{\nint &n = getlnt(123456789);\n//出错！栈指针在函数退出时会立即释放，操作野指针是非法的！\ncout << n << endl;\nint *pp = &n;\ndelete pp; //删除失败\nreturn 0;\n}\n```\n\n7、c/cpp函数说明\n函数实现的三结构：函数申明、函数（体）实现、函数调用\n函数体的构成：返回值类型、函数名、形参表、函数体\n函数与指针：指针函数和函数指针\n指针函数：本身是函数，返回值是指针。形如：`int* func_sum(int n)`，再次提醒：操作栈指针是非法的，对于返回值是指针的函数，这个指针①应当是指向静态变量static，或者该指针②全局变量指针。反正这个指针不能指向栈空间。\n函数指针：本质是一个指针，他指向了函数。形如`ret (*p)(参数列表)`，其中p称为函数指针。\n\n```cpp\nint max(int a,int b)\n{\n	return a>b?a:b;\n}\nint min(int a,int b)\n{\n	return a<b?a:b;\n}\nint main()\n{\n    int (*p)(int,int); //或者int (*p)(int a,int b)\n    p=max; //给函数指针赋值\n    int ret1=p(10,20);\n    p=min;\n    int ret2=p(2,10);\n    return 0;\n}\n```\n\n**为什么要使用函数指针**\n\n那么，有不少人就觉得，本来很简单的函数调用，搞那么复杂干什么？其实在这样比较简单的代码实现中不容易看出来，当项目比较大，代码变得复杂了以后，函数指针就体现出了其优越性。\n\n举个例子，如果我们要实现数组的排序，我们知道，常用的数组排序方法有很多种，比如快排，插入排序，冒泡排序，选择排序等，如果不管内部实现，你会发现，除了函数名不一样之外，返回值，包括函数入参都是相同的，这时候如果要调用不同的排序方法，就可以使用指针函数来实现，我们只需要修改函数指针初始化的地方，而不需要去修改每个调用的地方（特别是当调用特别频繁的时候）。\n\n**函数指针的典型应用：回调函数**\n函数指针的一个典型应用就是**回调函数**。回调函数就是一个通过函数指针来调用其他函数的函数。其将函数指针作为一个参数，传递给另一个函数。\n\n```cpp\n#include<stdio.h>\n#include<stdlib.h>\n\n//函数功能：实现累加求和\nint func_sum(int n)\n{\n        int sum = 0;\n        if (n < 0)\n        {\n                printf(\"n must be > 0\\n\");\n                exit(-1);\n        }\n        for (int i = 0; i < n; i++)\n        {\n                sum += i;\n        }\n        return sum;\n}\n\n//这个函数是回调函数，其中第二个参数为一个函数指针，通过该函数指针来调用求和函数，并把结果返回给主调函数\nint callback(int n, int (*p)(int))\n{\n	return p(n);\n}\n\nint main(void)\n{\n    int n = 0;\n    printf(\"please input number:\");\n    scanf(\"%d\", &n);\n    printf(\"the sum from 0 to %d is %d\\n\", n, callback(n, func_sum));       //此处直接调用回调函数，而不是直接调用func_sum函数\n    return 0;\n}\n```\n\n上面这个简单的demo就是一个比较典型的回调函数的例子。在这个程序中，回调函数callback无需关心func_sum是怎么实现的，只需要去调用即可。\n\n这样的好处就是，如果以后对求和函数有优化，比如新写了个func_sum2函数的实现，我们只需要在调用回调函数的地方将函数指针指向func_sum2即可，而无需去修改callback函数内部。\n\n回调函数广泛用于开发场景中，比如信号函数、线程函数等，都使用到了回调函数的知识。\n\n内存五区（按地址从低到高排序）：代码区、文字常量区（字符串常量）、全局区（静态区）、堆区、栈区。（来源百度）\n内存四区：代码区（存放代码）、全局区（存放全局变量、静态变量和常量）、栈区、堆区。（黑马）\n\nc/cpp增强了函数类型：\n基础函数：内联函数（cpp新增，c语言在c99后也引入了）、函数重载、模板函数（泛型编程）\n成员函数：构造/析构函数、常成员函数、静态成员函数、虚函数\n\n内联函数inline：主要解决程序的运行效率问题。针对那种函数体代码量较小，但是又会频繁调用的函数，在编译阶段，编译器会将函数名直接替换成函数体，以节省函数调用出栈入栈的开销。\n\n以代码量增加为代价，提高程序运行效率。\n\n内联函数的定义，必须出现在该函数第一次被调用前;内联函数不能有复杂的控制语句，如switch，goto和while。递归函数不能是内联函数，（递归函数）自己调用自己的函数如果用于内联的话，反而会影响效率。\n递归：自己调用自己；迭代：A调用B来获取新值。递归中一定含有迭代，迭代中不一定有递归。数据类型：树的打印函数使用了递归的方法。\n\n```cpp\n//迭代\nvoid print_shu(int i)\n{\n	...\n}\nint main()\n{\n	for(int i=0;i<n;i++)\n	{\n		print_shu(i);          //迭代\n	}\n	return 0;\n	\n}\n//递归\n```\n\n![图4](https://s3.bmp.ovh/imgs/2022/07/25/054dd7c396abe92b.png)\n函数重载：形参个数不同、形参顺序不同或形参类型不同。（返回值类型不能作为重载依据）\n函数形参默认值（缺省值）：如果同时存在函数声明和函数定义，默认值应在声明中给定，而不允许在定义中给定。默认值按从右到左的顺序。\n形参的默认值，可以是全局常量、全局变量、表达式、函数调用，但不能为局部变量。例如，\n\n```cpp\nvoid funcl(）\n{\nint k；\nvoid g(int x=k)；//k为局部变量\n}\n```\n\n## 3、第三部分 C++新特性\n\n参考链接[南邮武三郎的文章](https://www.zhihu.com/people/wujitao/posts?page=4)',1,0,0,0,1,'2023-06-07 16:37:08','2023-06-07 19:56:37');
INSERT INTO `t_article` VALUES (77,1,51,'https://upload.haoxx.site/article/015acc505d3ef69b0d459b85d2b4f990.jpg','C/C++学习思路','---\ntitle: C/C++学习思路\ndate: 2022-10-30\ncategory:\n - 1编程语言基础\n\nfooter: <a href=\"https://beian.miit.gov.cn/#/Integrated/index\">渝ICP备2023001651号</a>\n\n---\n\n:::tip\nC/C++学习思路\n:::\n\n<!-- more -->\n\n\n学完编程语言是基础，但仅仅掌握基础还不顾，离上手干活还有很大的鸿沟。鸿沟在于**编程基础四大件和应用实践编程**\n\n编程四大件：数据结构和算法、计算机网络、操作系统和设计模式\n\n应用编程实践：这部分会涉及到一些工具、编程环境、和具体编程实践，应该说这一部分学完，自己应该能做点东西出来、或者说能看懂一些实际项目的代码。包括但不限于：Linux操作系统的学习和使用（包含常用系统配置和shell脚本的使用）、编译/调试工具的使用、Linux环境编程（Linux系统编程、多线程编程和网络编程）\n\n-----------------------------------------\n\nC/cpp与Java的比较\n\nC/cpp与Java还是有很大的区别的。C是一种面向过程的更偏向于底层的编程语言，cpp是一种面向对象的编程语言。C和cpp，尤其是cpp，语言粒度细、机制多，性能虽然高，但语言本身的包袱也确实重，我们更愿意称它为“造轮子”的语言！也正因为C和cpp性能好，粒度细，所以什么都能做。而Java本身就是一种服务于互联网软件开发（后端开发+客户端开发）的语言，它是一个明显的“生态圈”的概念，所以应用领域非常清晰。更一般地来说，Java是纯应用层的，而C/cpp程序员既需要对底层知识有所了解，也需要知道应用层的知识。\n\n------------------------------------------\n\n岗位分析\n\n一般来说，C/cpp更适合做后台开发。包括：通信公司的后台开发、互联网公司的后台开发、游戏公司的后台开发。。。\n\n后台开发的职责细分，有：有做数据处理和分析的、有做基础协议和通信的、有做基础协议和通信的、甚至有做后台系统驱动和内核的。。。\n\n-------------------------------------------\n\n编程语言本身的学习\n\n**C语言**：\n\n+ 除了最基本的变量、条件、循环、字符串、数组、函数、结构体外\n+ C语言最最最重要的就是<font color=\"red\">指针</font>和<font color=\"red\">内存管理</font>。以后在工作中多半靠这两个东西吃饭，而且也是检验C语言掌握情况的两大标准\n\n> **推荐书籍**：《C Primer Plus》、《C和指针》、《C专家编程》\n\n**cpp**：\n\n+ cpp和C语言确实是不同的语言，但是cpp确实是对C语言的延伸，可以理解为在C语言里加入了面向对象的特性。因为只有面向对象特性的加持，代码才能更好的**复用**、**扩展**和**工程化**，这是大型项目的必备要素\n+ 除了C语言所有的底子之外，还需要学习cpp的面向对象（封装、继承与多态）特性、**泛型**、**模板**、**STL**等等\n\n> 推荐书籍（有先后顺序）：《cpp Primer》、《Effective cpp》、《cpp 标准程序库》、《STL源码剖析》《深度探索cpp对象模型》\n\n**最后一个小建议是**：语言部分的学习建议不要拖太久，一定要规划好时间，一鼓作气，高强度给它压下来，否则容易把自己拖泄气。\n\n-----------------------------------------\n\n编程基础“四大件”\n\n四大件是指：数据结构和算法、计算机网络、操作系统、设计模式\n\n1、数据结构和算法\n\n可以说这个直接决定了面试的成败！几种基础数据结构类型得烂熟于心，比如：<font color=\"red\">字符串、链表、二叉树、堆、栈、队列、哈希</font>等；基本的几大算法也要了如指掌，比如<font color=\"red\">查找、排序、动态规划、分治</font>等等。\n\n> 参考资料： 《大话数据结构》、《算法》、《剑指offer》《LeetCode刷题》 ，建议多在LeetCode上刷题\n\n2、计算机网络\n\n此处的计算机网络指的就是TCP/IP协议栈，可以说它是当下互联网通信的基石，无论如何一定要对TCP/IP的协议栈了如指掌，主要就是学习和掌握原理，包括：**ARP协议、IP协议、ICMP协议、TCP和UDP协议、DNS协议、HTTP协议、HTTPS协议**。\n\n> 推荐书籍： 《TCP/IP详解》\n\n3、操作系统\n\n该部分重点包括：进程和线程的相关原理（原子性、并发、锁）、内存相关原理（内存分布、内存调度）\n\n> 推荐书籍：《深入理解计算机系统》\n\n4、设计模式\n\n倒不需要23种设计模式全部记住，常见的几个如：**单例模式、工厂模式、代理模式、策略模式、模板方法模式**建议熟练于心。\n\n> 推荐书籍：《大话设计模式》、《设计模式之禅》\n\n------------------------------------------\n\n应用编程实践\n\n这部分会涉及到一些工具、编程环境、和具体编程实践，应该说这一部分学完，自己应该能做点东西出来、或者说能看懂一些实际项目的代码。\n\n1、Linux操作系统的使用\n\n包括：常见的Linux系统命令和基本的Shell编程\n\n> 推荐书籍：《鸟哥的私房菜》\n\n2、编译/调试工具\n\n我想大家最熟悉的一定是GCC了，与该命令配套的还有make/makefile脚本也必须掌握。作为make升级版的扩平台编译脚本Cmake和CmakeLists.txt也需要掌握。在gcc编译时，进场要指定头文件和库文件路径，这时常用的pkg-config命令就配上用场了。\n\n进阶一点的，除了GCC还有其他的编译工具，比如Clang。还有其他的跨平台的交叉编译工具链等等也需要学习。\n\n在程序调试中，GDB也需要掌握。\n\n3、Linux环境编程\n\n（1）Linux系统编程\n\n调用Linux系统的API来进行程序编写和功能实现。\n\n（2）多线程编写\n\n这一点与编程四大件之一的《操作系统》有很大的联系，进行多进程、多线程的程序编写，还有考虑进程间/线程间的通信：共享内存，还有考虑多进程间/多线程间的变量读写问题：互斥量、信号量、互斥锁、读写锁。一般在这部分，还会涉及到内存的开辟和释放问题。\n\n此处指的是多线程编程实践相关的东西，一般包括：线程、资源、信号、同步、互斥、锁等等一些具体的编程方法。\n\n（3）网络编程\n\n此处的网络编程主要指的是具体Linux系统上的网络编程 API和 IO函数的编程实践。一般是TCP和UDP相关的程序，涉及到点对点通信、广播通信、客户端-服务器-客户端通信等等。',1,0,0,0,1,'2023-06-07 16:37:36','2023-06-07 20:02:36');
INSERT INTO `t_article` VALUES (78,1,51,'https://upload.haoxx.site/article/ef2a97cea70aa44f3e7e7e4ac7c0a1ce.jpg','C/C++字符串处理函数大汇总','---\ntitle: C/C++字符串处理函数大汇总\ndate: 2023-04-01\ncategory:\n - 1编程语言基础\n\nfooter: <a href=\"https://beian.miit.gov.cn/#/Integrated/index\">渝ICP备2023001651号</a>\n\n---\n\n:::tip\nC/C++字符串处理函数大汇总\n:::\n\n<!-- more -->\n\n\n\n参考资料：[cnblogs](https://www.cnblogs.com/kongweisi/p/14676259.html)\n1、strlen(str*)  计算字符串长度（不含\'\\0\'） sizeof是计算所占内存大小，包含‘\\0’ \n\n2、strcpy(目标字符串，源字符串）或strncpy(目的字符串，源字符串，长度) 不会复制\\0\n注意：内存复制：，emcpy(目的地址，源地址，sizeof()长度) 恢复至\\0，注意目的地址要分配足够的空间，不然会段错误\n\n3、字符串追加函数strcat(目标字符串，源字符串) 或strncat(目的字符串。源字符串，长度)\n\n4、比较字符串strcmp(s1,s2)  strncmp(s1,s2,strlen()长度)\n\n5、字符串格式转换函数sprintf()  sscanf()\nsprintf使用的较多，使用场景比如，1.获取时间戳，格式化时间格式；2.日志文件系统写入格式化；\n\n6、strstr字符串中查找指定字符串     **推荐使用cpp的string的find函数**\n`char* strstr(源字符串s1，\"匹配字符串s2\")`。\n\n7、strchr字符串中查找指定字符      **推荐使用cpp的string的find函数**\n`char* strchar(源字符串s1，\'字符c\')`。参数1是字符串，参数2是字符。查找该字符在字符串中最后一次出现的位置。换个思路向：或者，是从右侧开始找，寻找字符在字符串中最后一次出现的位置。这个函数可以用来处理路径字符串，来获取文件名。对于s1=\"a/b/c/d.jpg\"，字符c=\'/\'，对于函数`char* p=strchr(s1,\'/\')`,函数返回值p=“/d.jpg\"。一般使用时是p+1，即”d.jpg\"。\n\n8、字符串分割函数strtok()      **推荐使用cpp封装的split方法，其中要用到cpp的流和getline函数**\n参考博客：[参考博客](http://c.biancheng.net/view/1345.html)\n格式：strtok（目标字符串，“目标字符串中所包含的字符”）\n\n9、atoi()转整形/atof()转双精度/atol()转long整型\n注意：①跳过前面的空格字符，直到遇到数字或正负号才开始做转换，而遇到非数字或字符串结束符(\'\\0\')才结束转换\n\n10、strpbrk\n`char* strpbrk(s1,s2)`，s1中寻找第一次出现s2中任意字符是的字符串指针。比如，s1=\"Hi,Linux\" ,s2=\"Linux\"，那么函数返回字符串指针所指向的字符串内容为i,Linux\n\n11、strcasecmp\n忽略大小写，比较字符串大小。第一个参数为s1，第二个参数为s2，s1小时返回负数。\n\n12、strspn\n`char* strspn(字符串s1，字符串s2)`，strspn()返回的数值为n，则代表字符串s 开头连续有n 个字符都是属于字符串accept内的字符。',1,0,0,0,1,'2023-06-07 16:39:04','2023-06-07 20:02:16');
INSERT INTO `t_article` VALUES (79,1,51,'https://upload.haoxx.site/article/79db75241acafdd2e58deb66960c3e25.jpg','Python学习思路','---\ntitle: Python学习思路\ndate: 2022-10-30\ncategory:\n - 1编程语言基础\n\nfooter: <a href=\"https://beian.miit.gov.cn/#/Integrated/index\">渝ICP备2023001651号</a>\n\n---\n\n:::tip\nPython学习思路\n:::\n\n<!-- more -->\n\n\n## 第一部分 入门：字面量/注释/数据类型/标识符和运算符\n\n### 1、字面量\n\n字面量是指“代码中，被卸下来的固定的值，被称之为字面量”，常见的有数字（整数、浮点数、布尔）、字符串、列表、元组、集合和字典。\n\nPython中定义变量不需要写上变量类型名，直接用“变量名=值”的方式定义和初始化变量。布尔变量的取值只能是True和Flase。字符串可由任意数量的字符组成。\n\n列表List，是有序的可变序列。它是python中使用最频繁的数据类型，可有序记录一堆数据。\n\n元组Tuple，有序的不可变序列。可以有序记录一堆不可变的python数据集合。\n\n集合Set，无需不重复集合，可无序记录一堆不重复的python数据集合。\n\n字典Dictionary，无序的键值对，可无序记录一堆键值对的python数据集合。\n\n### 2、注释\n\n注释有单行：#  ;多行： \"\"\"\n\n### 3、print格式化打印\n\n基础：print(内容1，内容2，内容3，。。。)，示例：`print(\"变量a的结果是：\",a,\"\\n\")`\n进阶版：使用%来进行格式化打印。\n①整数输出\n\n```python\n%o   ----   oct八进制\n%d   ----   dec十进制\n%x   ----   hex十六进制\n示例：\n>>> print(\'%o\' % 20)    ,输出 24\n>>> print(\'%d\' % 20)    ,输出 20\n>>> print(\'%x\' % 20)    ,输出 14\n```\n\n②浮点数输出\n\n```python\n%.nf   ----   保留小数点后n位小数\n%.ne   ----   保留小数点后n为小数，以指数形式输出打印\n%.ng   ----   保留n位有效数字\n示例：（注意：计算有效位时，小数点也算一个）\n>>> print(\'%f\' % 1.11)    ,输出 1.110000\n>>> print(\'%.1f\' % 1.11)    ,输出 1.1\n>>> print(\'%e\' % 1.11)    ,输出 1.110000e+00\n>>> print(\'%e\' % 1.11)    ,输出 1.110000e+00\n>>> print(\'%.1e\' % 1.11)    ,输出 1.1e+00\n>>> print(\'%g\' % 221.1111)    ,输出 221.111  ，默认g是6位有效数字\n>>> print(\'%.2g\' % 221.1111)    ,输出 2.2e+03 ，自动转换为科学计数法\n```\n\n③整数输出\n\n```python\n%0nd   ----   输出指定位数的十进制，如有效数字位数不够，前方补零\n>>> print(\'%05n\' % 123)   ,输出00123\n```\n\n④字符串输出\n\n```python\n%ns   ----   右对齐，占位符10位\n%-ns   ----  左对齐，占位符10位\n%.ns   ----  左对齐，占位符10位\n%n.ms   ---- n位占位符，截取m位字符串\n示例：\n>>> print(\'%s\' % \'hello world\')      ,输出 hello world\n>>> print(\'%20s\' % \'hello world\')    ,输出           hello word (右对齐，字符串为10，所以前面要补10个空格)\n>>> print(\'%-20s\' % \'hello world\')    ,输出 hello world         (左对齐，后面补10个空格)\n>>> print(\'%.2s\' % \'hello world\')    ,输出 he\n>>> print(\'%10.2s\' % \'hello world\')    ,输出         he (默认右对齐，总长度为10，取两个字符，所以前面有8个空格)\n>>> print(\'%-10.2\' % \'hello world\')    ,输出 he        (左对齐，输出一个he加上8个空格)\n```\n\n```python\n# 用print打印字符串输出\n方法1：\nprint(\"the a is %d\" % a)\n方法2：\nprint(f\"the a is {a}\")\n方法3：\nprint(\"current path length: {}, It costs {} s\".format(pathLen, time.time() - start_time))\n方法1的例子2：\nprint(\"current path length: %f, It costs %f s\" % (pathLen, time.time() - start_time))\n```\n\n### 4、数据类型与数据类型的转换\n\n使用print和type来获取变量的<font color=\'red\'>数据</font>类型。 `type(被查看类型的数据)`\n注意，变量没有类型，有类型的是数据。\n\n数据类型转换： int()   str()    float()\n\n### 5、标识符\n\n了解并掌握常用的关键字（区分大小写）：False True  None ,其余关键字均为小写\n\n标识符：变量、函数的命名(只允许字母、数字和下划线，甚至包含中文做变量名)。但是中文做变量名支持不完善，不建议用。\n\n标识符命名规则：\n\n+ 内容限定\n+ 大小写敏感\n+ 不可使用关键字\n\n### 6、基本运算符、以及布尔类型与比较运算符\n\n常见的有：加减乘除，还有<font color=\'blue\'>取整除符号</font>： `//`，比如：`5//2==2`，还有<font color=\'blue\'>取余符号</font>，比如：`5%2==1`，还有<font color=\'blue\'>指数符号</font>，`5**2==25`。\n\n另外，上述符号还可以与等号相结合，构成符合运算符。\n\n比较运算符：\n大于，小于，大于等于，小于等于，等于，不等于\n\n### 7、字符串的三种定义方式与字符串的拼接、格式化\n\n单引号、双引号、三引号。python中的字符串不区分单字符和字符串，所以单引号和双引号功能是一样的。三引号中的字符串可以跨行。\n\n使用+号对多个字符串进行拼接。\n\n方式①：使用三类常见的占位符与%相结合来进行字符串的格式化输出：\n常见的占位符：\n\n+ 字符串  %s\n+ 整数     %d\n+ 浮点数  %f\n\n```python\nname=\"测试姓名\"\nyear_num=1999\nstock_price=19.9\nmessage=\"我是：%s,我成立于：%d，我今天的估价是：%f\" % (name,year_num,stock_price)\nprint(message)\n```\n\n方式②：格式化的精度控制\n使用辅助符号m.n来进行精度控制：\n\n+ m，控制宽度，要求是数字（<font color=\'red\'>很少使用，设置的宽度小于数字自身，不生效</font>）\n+ .n，控制小数点精度，要求是数字，<font color=\'red\'>会进行小数位的四舍五入</font>。\n+ 一半在m前面没有任何东西，默认表示右对齐，当m大于数字的最大有效位时，在前面补空格。如果m前面有个`-`号，表示左对齐，当m大于数字的有效位数时，不需要在前面不空格，在数字的后面补空格。\n  方式③：掌握快速进行字符串格式化的方式：\n  通过语法：`f\"内容{变量}\"`的格式来进行快速格式化。例如：\n\n```python\nname=\"测试姓名\"，stock=19.9,year=1999\nprint(f\"我是：{name},我成立于：{year}，我今天的估价是：{stock}\")\n```\n\n这样做的特点是：\n\n+ 这种写法不做精度控制\n+ 也不理会类型\n+ 适用于快速格式化字符串\n\n方式④：技巧：对表达式的格式化\n上述三种方法，都是对变量进行格式化处理，那如果不需要使用变量存储，可不可以直接对表达式进行格式化处理呢？\n\n表达式：是一个具有明确执行结果的代码语句，比如：1+1, 2\\*4，他们就是表达式，因为他们有明确的结果，就是一个数值。又比如，常见的变量定义：`name=\"张三\"`也是一种表达式，因为他也有结果，就是把一个字符串常量付给了一个变量存储。\n\n下面。使用上述三种对变量的格式化方法，来处理表达式：\n\n```python\nprint(\"1 * 1 的结果是： %d\" % (1*1))\nprint(f\"1 * 1 的结果是：{1 * 1}\")\nprint(\"字符串在python中的类型是…%s\" % type(\'字符串\'))\n```\n\n### 8、数据的输入：input\n\n1、基础版：\n\n```python\nname=input()\nprint(\"your name is %s\" % name)\n```\n\n2、进阶版\n\n```python\nname=input(\"请输入你的名字：\")\nprint(\"your name is %s\" % name)\n```\n\n需要注意，input()接收并存入变量里的数据，均是字符串类型。就算你输入的是整数，也是转换成了字符串类型在存储的。用int()来得到整型值。10.16.63.184\n\n## 第二部分 代码结构：逻辑结构与函数\n\n### 9、if-else的条件语句、while/for循环语句、switch/case条件分支以及continue/break\n\n①if-elif-else代码块示例：\n代码示例：\n\n```python\nif 条件1：\n	满足条件1后该做的动作\nelif 条件2:\n	满足条件2后该做的动作\nelse:\n	所有条件都不满足后的动作\n```\n\nif-else的多层嵌套：秘诀：空格缩进，python根据缩进来判断代码块的归属和层次关系。\n\n②while代码块示例：\n\n```python\nwhile 条件：\n	满足条件后的动作\n```\n\n③for循环代码块示例：\n\n```python\nfor 临时变量 in 待处理的数据集\n	临时变量满足条件时，执行的语句\n#例如：\nname=\"test\"\nfor x in name\n	print(x)  # 输出t e s t\n```\n\n上述待处理的数据集，严格来讲，称之为：<font color=\'red\'>可迭代类型</font>。可迭代类型是指，其内容可以一个个一次取出的一种类型，包括：\n\n+ 字符串\n+ 列表     如：name_list=[\'Lisa\',\"Micheal\",\'LiHua\']\n+ 元组\n+ etc等等\n\n通过学习range语句，获得一个简单的数学序列（可迭代类型的一种）：\n语法1：`range(num)`，获取一个从0开始，到num结束的数字序列（不含num本身）。如range(5)就是获得一个从0 ~ ~ 4的序列：[0,1,2,3,4]。\n语法2：`range(num1,num2)`,获取一个从num1开始到num2结束的数字序列（包含num1但是不包含num2）。如range(1,5)就是输出序列[1,2,3,4]。\n语法3：`range(num1,num2,step)`,获取一个从num1开始到num2结束，包含num1但是不包含num2的数字序列，并且步长为step。如range(1,8,2)就是输出序列：[1,3,5,7]。\n\n### 10、函数\n\n#### 10.1 函数基础\n\n注意：函数体内为局部变量，函数体外为全局变量。但是，可以在函数体内，使用关键字`global`来将函数内部的变量声明为全局变量，如：\n\n```python\ndef testA()：\n	global num\n	num = 20\n	print(\"testA中的num为：\",num)\n\ndef testB()：\n	print(\"testB中的num为：\"，num)\n	\ntestA()\ntestB()\nprint(f\"全局变量num为{num}\")\n```\n\n#### 10.2 函数进阶\n\n##### 1、函数的多个返回值\n\n```python\ndef  xxx()：\n	return 1,2    //return语句后接多个变量，每个变量用逗号隔开\n//并且。return支持多种不同数据类型的数据return\n```\n\n##### 2、函数传参\n\n2.1 位置参数\n<font color=\'red\'>位置参数</font>：调用函数时根据函数定义的参数位置来传递参数\n<font color=\'blue\'>注意</font>：传递的参数和定义的参数的顺序及个数必须一致\n\n```python\ndef user_info(name,hei,gner)：\n	print(f\"{name}的{hei}是{gner}\\n\")\n	\n#函数调用\nuser(\"李华\",\"身高\",175)\n```\n\n2.2 关键字参数\n<font color=\'red\'>关键字参数</font>：函数调用时通过“键=值”形式传递参数.\n<font color=\'red\'>作用</font>: 可以让函数更加清晰、容易使用，同时也清除了参数的顺序需求.\n<font color=\'blue\'>注意</font>：函数调用时，如果有位置参数时，位置参数必须在关键字参数的前面，但关键字参数之间不存在先后顺序\n\n```python\ndef user_info(name,hei,gner)：\n	print(f\"{name}的{hei}是{gner}\\n\")\n	\n#函数调用\nuser(hei=\"身高\",name=\"李华\",gner=175)\n//或者：位置参数和关键字参数混用：注意位置参数必须放在最前面\nuser(175,hei=\"身高\",name=\"李华\")\n```\n\n2.3 缺省参数\n<font color=\'red\'>缺省参数</font>：缺省参数也叫默认参数，用于定义函数，为参数提供默认值，调用函数时可不传该默认参数的值（注意：所有位置参数必须出现在默认参数前，包括函数定义和调用）.\n<font color=\'red\'>作用</font>: 当调用函数时没有传递参数, 就会使用默认是用缺省参数对应的值\n<font color=\'blue\'>注意</font>：函数调用时，如果为缺省参数传值则修改默认参数值, 否则使用这个默认值\n\n```python\ndef user_info(name,hei,gner=175)：\n	print(f\"{name}的{hei}是{gner}\\n\")\n	\n#函数调用\nuser(hei=\"身高\",name=\"李华\")\n//或者：位置参数和关键字参数混用：注意位置参数必须放在最前面\nuser(180,hei=\"身高\",name=\"李华\")\n```\n\n2.4 不定长参数\n<font color=\'red\'>不定长参数</font>：不定长参数也叫可变参数. 用于不确定调用的时候会传递多少个参数(不传参也可以)的场景.\n<font color=\'red\'>作用</font>: 当调用函数时不确定参数个数时, 可以使用不定长参数\n不定长参数的类型：\n\n+ 1、位置传递\n+ 2、关键字传递\n\n1、位置传递：\n\n传进的<font color=\'red\'>所有参数</font>都会被<font color=\'red\'>args变量收集</font>，它会根据传进参数的位置合并为一个元组(tuple)，<font color=\'red\'>args是元组类型</font>，这就是<font color=\'red\'>位置传递</font>\n\n```python\ndef user_info(*args)：\n	print(args)\n	\n#函数调用\nuser_info(\'TOM\')\nuser_info(\'TOM\',18)\n```\n\n2、关键字传递\n\n参数是<font color=\'red\'>“键=值”</font>形式的形式的情况下, 所有的“键=值”都会被<font color=\'red\'>kwargs接受</font>, 同时会根据“键=值”组成<font color=\'red\'>字典</font>。\n\n```python\ndef user_info(**kwargs)：\n	print(kwargs)\n	\n#函数调用\nuser_info(name=\'TOM\',age=18)\n```\n\n\n位置不定长传递以\\*号标记一个形式参数，以元组的形式接受参数，形式参数一般命名为args\n\n关键字不定长传递以\\*\\*号标记一个形式参数，以字典的形式接受参数，形式参数一般命名为kwargs\n\n##### 3、匿名函数\n\n1、函数作为参数传递\n\n函数本身是可以作为参数，传入另一个函数中进行使用的。\n\n将函数传入的作用在于：传入计算逻辑，而非传入数据。示例如下：\n\n```python\ndef test_func(a,b,func)：\n	result=func(a,b)\n	print(result)\n\ndef func1(x,y)：\n	return x+y\ndef func2(x,y)：\n	return x*y\n	\n# 函数调用测试\ntest_func(1,2,func1) # 打印结果为3\ntest_func(1,2,func2) # 打印结果为2\n```\n\n2、lambda匿名函数\n\ndef定义的函数都是有名称的，并且可以基于名称多次使用该函数。而lambda函数可以定义没有函数名的<font color=\'red\'>匿名</font>函数，且匿名函数仅能使用一次。\n\n注意：\n\n+ 匿名函数用于临时构建一个函数，只用一次的场景\n+ 匿名函数的定义中，函数体只能写一行代码，如果函数体要写多行代码，不可使用匿名函数。\n\n匿名函数定义的语法：\n`lambda 传入参数：函数体`  # 注意：函数体仅允许只有一行代码\n\n+ lambda 是关键字，表示定义匿名函数\n+ 传入参数表示匿名函数的形式参数，如：x, y 表示接收2个形式参数\n+ 函数体，就是函数的执行逻辑，要注意：只能写一行，无法写多行代码\n  示例：\n\n```python\ndef test_func(a,b,func)：\n	result=func(a,b)\n	print(result)\n\n# 函数调用\ntest_func(1,2,lambda x,y: x+y)  # 打印输出3\n```\n\n\n\n\n\n## 第三部分 数据容器\n\n### 11.1、五类数据容器入门\n\n数据容器根据特点的不同，如：\n\n+ 是否支持重复元素\n+ 是否可以修改\n+ 是否有序\n\n列表(List)、元组(tuple)、字符串(str)、集合(set)、字典(dict)\n\n>列表List，是有序的可变序列。它是python中使用最频繁的数据类型，可有序记录一堆数据。\n>\n>元组Tuple，有序的不可变序列。可以有序记录一堆不可变的python数据集合。\n>\n>字符串String\n>\n>集合Set，无需不重复集合，可无序记录一堆不重复的python数据集合。\n>\n>字典Dictionary，无序的键值对，可无序记录一堆键值对的python数据集合。\n\n序列：序列是指内容连续、有序，可使用下标索引的一类数据容器。<font color=\'red\'>列表、元组和字符串</font>，均可以视为序列。序列不是一种新的数据容器，而是多种数据容器的一种共通属性。\n\n**序列的切片**：\n\n格式为：<font color=\'red\'>[起始下标:结束下标:步长]</font>\n\n注意：\n\n+ 1、步长为负数，表示反向取（注意，起始下标和结束下标也要反向标记）\n+ 2、注意，此操作<font color=\'blue\'>不会影响序列本身，而是会得到一个新的序列（列表、元组、字符串）</font>\n\n正向切片：\n![](https://s3.bmp.ovh/imgs/2022/10/14/e76148b450adaad2.png)\n\n反向切片：\n![](https://s3.bmp.ovh/imgs/2022/10/14/eed814e7ce28fd0e.png)\n举例如下：\n\n```python\n说明：列表方括号，元组圆括号，字符串使用双引号，集合大括号，字典也是大括号\n---------------------\n一、列表\n列表：name_list=[\'王力宏\',\'周杰伦\',\'林俊杰\',\'白洁\']\n列表2：name_list=[\'王力宏\',\'周杰伦\',24，True,12.31]\n---------------------\n二、元组\n元组：t1=(1,\'王力宏\',True,11.44)    # 元组内的元素在定义后就不可以更改了\n元组2：t2=(\'hello\',)        # 元组内只有一个元素的话，这个数据后要添加逗号\n---------------------\n三、字符串\n字符串：str1=\"iccaa\"\n---------------------\n四、集合\nnames={\'王力宏\',\'周杰伦\',\'林俊杰\',12,\'王力宏\'}  # 集合去重且无序，因为无序，所以不支持下标访问\nprint(names)     # 输出为 \'王力宏\',\'周杰伦\',\'林俊杰\',12\n---------------------\n五、字典\n字典：my_dict={\'网络\':99,\'所示\':23,\'啊啊\':82} # 1、字典的key和value可以是任意类型的数据，但key不可为字典。2、key不可重复，重复会对原有数据覆盖。和集合一样，无序，不可使用下标访问。3、value可以为字典，从而构成嵌套字典\n字典2：stu_score={\n	\"王力宏\"：{\"语文\":42,\"数学\":42,\"英语\":32}\n	\"周杰伦\": {\"语文\":31,\"数学\":92,\"英语\":25}\n	\"李 白\": {\"语文\":13,\"数学\":62,\"英语\":52}\n}\n嵌套字典的使用：\nprint(stu_score[\"王力宏\"])   # 输出为 {\"语文\":42,\"数学\":42,\"英语\":32}\nprint(stu_score[\"王力宏\"][\"语文\"]) # 输出为 42\n```\n\n<font color=\'red\'>列表</font>的特点：\n\n+ 可以容纳多个数据，上限为2^63^-1=9,223,372,036,854,775,807个\n+ 可以容纳不同类型的数据（混装）\n+ 数据是有序存储的（有下标序号）\n+ 允许重复数据存在\n+ 可以修改（增加或删除元素等）\n\n<font color=\'red\'>元组</font>的特点：      多数特性与列表一致，最大的不同在于不可修改性\n\n+ 可以容纳多个数据\n+ 可以容纳不同类型的数据（混装）\n+ 数据是有序存储的（下标索引）\n+ 允许重复数据存在\n+ <font color=\'blue\'>不可以修改</font>（增加或删除元素等）\n+ 支持for循环\n\n<font color=\'red\'>字符串</font>的特点：\n\n+ <font color=\'blue\'>只可以存储字符串</font>\n+ 长度任意（取决于内存大小）\n+ 支持下标索引\n+ 允许重复字符串存在\n+ <font color=\'blue\'>不可以修改</font>（增加或删除元素等）\n+ 支持for循环\n\n字符串的特点基本有列表、元组相同。与列表、元组不同的在于：字符串容器要求可以容纳的类型式单一的，只能是字符串类型。与列表不同与元组相同的在于：字符串不可更改。\n\n<font color=\'red\'>集合</font>的特点：\n\n+ 可以容纳多个数据\n+ 可以容纳不同类型的数据（混装）\n+ <font color=\'blue\'>数据是无序存储的</font>（不支持下标索引）\n+ <font color=\'blue\'>不允许重复数据存在</font>\n+ 可以修改（增加或删除元素等）\n+ 支持for循环\n\n<font color=\'red\'>字典</font>的特点：\n\n+ 可以容纳多个数据\n+ 可以容纳不同类型的数据（混装）\n+ <font color=\'blue\'>每一份数据是KeyValue键值对</font>（不支持下标索引）\n+ <font color=\'blue\'>可以通过Key获取到Value，Key不可重复(重复会覆盖)</font>\n+ 不支持下标索引\n+ 可以修改（增加或删除元素等）\n+ 支持for循环，不支持wehile循环\n\n### 11.2 列表\n\n#### 11.2.1 列表的定义方式\n\n```python\n变量名称 = [元素1,元素2,元素3,...]\n定义空列表：变量名=list() 或 变量名=[]\n支持嵌套：my_list=[[1,2,3],[4,5,6]]\n```\n\n#### 11.2.2 列表的下标索引\n\n正向索引：下标从0开始，0,1,2,3...\n反向索引：下标从-1开始，-1，-2，-3...\n嵌套列表也是支持下标索引的。\n\n#### 11.2.3 列表的常用操作（方法）\n\n如果将函数定义为类中成员，那么他就称为方法。函数与方法定义是一致的，只是使用格式不同。\n\n下面将介绍列表的常用操作：增删改查和统计/清空操作。其实这些都是数据容器的基本操作，不过对于元组和字符串来将，增删改+清空操作是不存在的。\n\n```python\nmy_list= [\'ass\',\'ss\',\'wwas\']\n-----------------------------\n1、查询1、根据下标，查询元素值：\nprint(my_list[2])\n查询2、根据元素值查询对应的坐标：\nprint(my_list.index(\"ss\"))\n----------------------------\n2、插入\n2.1 在指定位置插入：insert\nmy_list.insert(1,\"haha\")\nprint(my_list)  # 输出为： \'ass\',\"haha\"，\'ss\',\'wwas\'\n2.2 在结尾追加append\nmy_list.append(\"yuhao\")\nprint(my_list)  # 输出为： \'ass\'，\'ss\',\'wwas\',\"yuhao\"\n2.3 先从其他容器中取出数据，在依次追加到列表尾部\nmy_list.extend([4,1,6])\nprint(my_list)  # 输出为： \'ass\'，\'ss\',\'wwas\',4,1,6\n------------------------------\n3、删除\n3.1 用del关键字删除\ndel my_list[0] # 删除单个  或者  del my_list # 删除全部\ndel my_list[1:3]  # 删除链表的下标为1到下标为2的元素，用冒号来指定子区间，包含前者而不包含后者\n3.2 使用列表方法pop删除\nmy_list.pop([index=-1])  # 默认是出栈最后一个元素\nmy_list.pop()  # 出栈最后一个元素\nmy_list.pop(2)  # 出栈下标为2的元素，注意下标号从0开始\n3.3 使用列表方法clear来清空列表\nmy_list.clear()  \n3.4 根据元素值而非下标位置来删除元素\n#使用remove删除与元素值相匹配的第一个元素\nmy_list.remove(\'ass\')\n## 注意，del和pop都可以按照坐标来删除元素，但是del是关键字，pop是方法。del可以删除区间，del可以删除全部，而pop不能。还有del删除后不会将删除元素返回，但是pop会将删除的元素返回。\n-------------------------------\n4、更改\n# 直接用下标来对元素值进行更改\nmy_list[1]=\'hehhe\'\n--------------------------------\n5、查找\n通过下标号获取元素值；或者通过元素值反向查找下标号.index(\'ass\')\n查找列表最小值的方法1：.sort()，然后list[0];方法2;min(list)\n---------------------------------\n6、统计\n6.1 通过某元素在列表中的个数\nmy_list.count(\"ass\")\n6.2 统计列表的长度\nlen(my_list)\n```\n\n![](https://s3.bmp.ovh/imgs/2022/10/14/1134525ff952347e.png)\n\n#### 11.2.4 列表的遍历\n\n1、使用while遍历\n\n```python\nindex = 0\nwhile index < len(列表)：\n	元素=列表[index]\n	index++\n```\n\n2、使用for循环遍历\n\n```python\nfor i in my_list\n	print(i)\n```\n\n3、while和for循环的区别与联系\n\n+ 在循环控制上：\n+ + while循环<font color=\'blue\'>可以自定循环条件</font>，并自行控制\n+ + for循环<font color=\'blue\'>不可以自定循环条件</font>，只可以一个个从容器内取出数据\n+ 在无限循环上：\n+ + while循环<font color=\'blue\'>可以</font>通过条件控制做到无限循环\n+ + for循环理论上<font color=\'blue\'>不可以</font>，因为被遍历的容器容量不是无限的\n+ 在使用场景上：\n+ + while循环适用于任何想要循环的场景\n+ + for循环适用于，遍历数据容器的场景或简单的<font color=\'blue\'>固定次数</font>的循环场景\n\n### 11.3 元组tuple\n\n#### 11.3.1 元组的定义方式\n\nmy_tuple=(\'as\',\'sas\',\'asa\')\n定义空元组：my_tupe=tuple() 或my_tuple=()\n定义嵌套元组：my_tuple=((1,2,1),(2,1,6),(2,1))\n定义单个元素的元组：mt_tuple=(1,)  或(\'hello\',)\n\n#### 11.3.2 元组的常用操作（方法）\n\n```python\nmy_tuple=(\'wqw\',\'dsd\',\'sd\')\n1、查找\n1.1 根据下标查找\ntest=my_tuple[2]\n1.2 根据元素值查找下标值\nnum=my_tuple.index(\'wqw\')\n2、统计\n2.1 统计某元素在元组中出现的次数\nprint(my_tuple.count(\'wqw\'))\n2.2 统计元组长度\nprint(len(my_tuple))\n```\n\n#### 11.3.1 元组的遍历\n\n1、while遍历\n\n```python\nindex=0\nwhile index < len(my_tuple):\n	print(my_tuple[index])\n	index++\n```\n\n2、for循环遍历\n\n```python\nfor i in my_puple\n	print(i)\n```\n\n### 11.4 字符串\n\n#### 11.4.1 字符串的索引\n\n下标索引，正向从0开始，反向从-1开始\n\n#### 11.4.2 字符串的操作（方法）\n\n字符串与元组类似，内部元素不允许改动。所以，可使用的操作很少。\n\n```python\n1、查找\n通过下标或者index方法\n---------------------------------\n2、替换replace  # 注意，不是替换字符串本身，而是新生成了一个字符串\nname=\"iteima itcast\"\nnew_name = name.replace(\"it\",\"黑马\")\nprint(new_name)       # 输出为 黑马eima 黑马cast\n---------------------------------\n3、字符串分割 （是重新得到一个对象）\n将源字符串按照指定的分割方式，分割成几个子字符串，并存入列表\nname=\"传智播客  传智教育  差遵化  送达\"\nnew_name = name.split(\" \")\nprint(type(new_name))   # 输出为 <class \'list\'>\nprint(new_name) # 输出为 [\'传智播客\',\'传智教育\',\'差遵化\',\'送达\']\n---------------------------------\n4、字符串规整\n4.1 去掉前后空格\nmy_str=\"  itrima and itcast  \"\nprint(my_str.strip()) #输出为 \"itrima and itcast\"\n4.2 去前后指定字符串\nmy_str=\"12itrima and itcast21\"\nprint(my_str.strip(\"12\")) #输出为 \"itrima and itcast\"\n#注意，传入的是\"12\"，其实是按照单个字符来的，\"1\"和\"2\"都会被移除\n---------------------------------\n5、统计\n统计某字符串的出现次数：print(my_str.count(\"it\"))\n统计字符串长度：print(len(my_str))\n---------------------------------\n6、检查字符串的子串\n# find()函数的作用是检查一个字符串是否是另一个字符串的子串，并返回子串所在的起始位置索引\n语法：string_object.find(sub, start, end)\n参数含义：\nsub：必选参数。指定要检索的字符串，可以直接使用字符串具体的值或字符串变量；\nstart：可选参数。检查搜索开始的索引，默认为0；\nend：可选参数。检查搜索停止的索引，默认为字符串string_object的长度。\n注意，find()函数在执行检查搜索时，start处的字符将会被检查，而end是停止检索的索引，所以end索引处的字符不会参与检查搜索。\n方法返回值：\n如果字符串string_object中包含sub，则返回sub在string_object中起始的位置索引，否则返回-1。\n示例：\nstr1 = \"该网站的名称是：翔宇亭IT乐园\"\nstr2 = \"翔宇亭\"\nprint(str1.find(str2)) #结果为：8\n# 在字符串中，一个中文算一个字符。\n```\n\n![](https://s3.bmp.ovh/imgs/2022/10/14/d034ba3b4152f0e2.png)\n\n#### 11.4.3 字符串的遍历\n\n1、while遍历\n\n```python\nindex=0\nwhile index < len(my_str):\n	print(my_str[index])\n	index++\n```\n\n2、for循环遍历\n\n```python\nfor i in my_str\n	print(i)\n```\n\n\n\n\n接下来将学习“集合”和“字典”，这两种方式都是无序的，所以不可以使用下标访问。集合会组合相同项，字典可以使用键名来获取键值。\n\n### 11.5 集合\n\n#### 11.5.1 集合简介及集合的常见操作（方法）\n\n集合，最重要的一个特点就是可以去重。使用一个大括号来定义一个集合。\nmt_set={\"11a\",\"as\",\"das\"}\n定义空集合： my_set=set()\n提醒：my_dict={}是定义了一个空字典，而不是空集合\n\n集合的常见操作（方法）\n\n```python\n--------------------\n   操作集合时，一定要在心中谨记，集合内部是无序的，你看到在代码中集合的第一个元素是\"hello\"，但其实在内存中第一个元素有可能不是\"hello\"。因为集合需要对元素进行判断和删除重复元素的操作，就有可能会打乱内部元素的排序。\n--------------------\n1、添加新元素add   (其他几种数据容器的添加方法是insert或append)\nmy_set={\"hello\",\"world\"}\nmy_set.add(\"inte\")\nprint(my_set)   # 输出为 {\"hello\",\"world\",\"inte\"}\n2、移除元素remove\nmy_set={\"hello\",\"sdsdsd\",\"sdaa\",\"world\"}\nmy_set.remove(\"asaa\")\nprint(my_set)   # 输出为 {\"hello\",\"sdsdsd\",\"world\"}\n3、从集合中随即取出一个元素\nelement=my_set.pop()\n4、清空集合\nmy_set.clear()\n---------------------\n5、集合之间的操作\n5.1 取出了两个子集的差集\n6.功能：判断两个集合的差集，取出1中有的而2中没有的，并存入新的集合\nset1={1,2,3}\nset2={2,3,4}\nset_dif=set1.different(set2)\nprint(set_dif)  # 输出结果为 {1}，且集合1和集合2不变\n5.2 消除两个子集的差集\n功能：对比集合1和集合2，在集合1中，删除和集合2中相同的元素\n结果：集合1被改变，集合2不变化\nset1={1,2,3}\nset2={2,3,4}\nset1.different_update(set2)\nprint(set1)  # 输出{1}\n5.3 两集合合并\n功能：将集合1和集合2合并为一个集合\n结果：出现一个新集合，且集合1和集合2都不改变\nset3=set1.union(set2)\nprint(set3)  # 输出为 {1,2,3,4}\n\n---------------------\n6、统计集合中元素的数量\nprint(len(my_set))\n集合没有count方法，因为所有元素均唯一。\n```\n\n![](https://s3.bmp.ovh/imgs/2022/10/14/daa03b0bad2855b3.png)\n\n#### 11.5.2 集合的遍历\n\n因为集合内部无序，所以不能使用下标访问。因此，不能使用while循环，但是for循环不受影响。\n\n```python\nset={1,2,3}\nfor i in set\n	print(i)\n```\n\n字典也是同样的道理\n\n\n### 11.6 字典\n\n#### 11.6.1 字典的常见操作（方法）\n\n```python\n1、新增元素\nstu_score={\n	\"网\"=11\n	\"里\"=22\n	\"bai1\"=33\n}\nstu_score[\"张\"]=89\n2、更新元素值\n注意，字典的键名不可以重复，对已存在的键名进行操作就是在更新键值。\nstu_score[\"张\"]=21\n3、删除元素\n语法：字典.pop(键名)  # 获取指定键名的键值，并从字典中删除该元素\n4、清空元素\n语法：字典.clear()\n5、获取全部的key键名\nget_all_keys=stu_score.keys()\nprint(get_all_keys)  # 输出为 dict_keys([\'网\',\'里\',\'bail\'])，类型为<class \'dict_keys\'>\n5.2 获取全部的键值\nprint(stu_score.values())\n6、遍历字典（只能使用for）\nfor i in my_dict:\n	print(f\"字典中，键名为{i}的键值为{my_dict[i]}\")\n或：\nfor i in my_dict.keys():\n    print(f\"字典中，键名为{i}的键值为{my_dict[i]}\")\n7、获取字典中所有键值对的数量\nprint(len(my_dict))\n8、根据指定的键名获取键值\nprint(my_dict.get(\'网\'))  或  print(my_dict.get(\'网\',\'里\')) \n9、通过gets方法，根据键名获取键值\n# 语法： get(key, \"输出的信息\")\n# get方法根据第一个参数在键名中查找，找到了对应的键，打印其键值；没找到对应的键，就输出第二个参数对应的内容。如果第二个参数为空，就输出None。\n10、items方法，查找字典中所有的键值对，并返回一个可迭代对象，且对象是元组类型的。\ndict1 = {\'name\': \'Rose\', \'age\': 30, \'sex\': \'女\'}\nprint(dict1.items())\n#输出结果为：dict_items([(\'name\', \'Rose\'), (\'age\', 30), (\'sex\', \'女\')])\n# 输出结果的类型是：<class \'dict_items\'>\n```\n\n![](https://s3.bmp.ovh/imgs/2022/10/14/434f88294d37e333.png)\n\n### 11.7 几种数据容器的总结\n\n1、数据容器的分类\n\n+ 是否支持下标索引\n+ + 支持：列表、元组、字符串 - 序列类型\n+ + 不支持：集合、字典 - 非序列类型\n+ 是否支持重复元素\n+ + 支持：列表、元组、字符串 - 序列类型\n+ + 不支持：集合、字典 - 非序列类型\n+ 是否可以修改\n+ + 支持：列表、集合、字典\n+ + 不支持：元组、字符串\n\n![](https://s3.bmp.ovh/imgs/2022/10/14/75c25d928730e470.png)\n\n![](https://s3.bmp.ovh/imgs/2022/10/14/1bb99fb466c009c1.png)\n\n### 11.8 数据容器的通用操作\n\n1、都支持for循环遍历。但是，只有能读取下标的数据容器才支持while循环。即只有列表、元组和字符串才支持while循环，集合和字典仅支持for循环。\n\n2、通用的\"统计\"方法：\n列表、元组和字符串都支持以下三种方法：求长度、求最大元素和求最小元素：\n![](https://s3.bmp.ovh/imgs/2022/10/15/3b575f44ccd40b62.png)\n\n3、通用的转换功能（除了不能转成字典）\n![](https://s3.bmp.ovh/imgs/2022/10/15/bc6b7d83e5de3542.png)\n\n4、通用的排序功能\n\nsorted的参数reverse=True代表降序排序\n![](https://s3.bmp.ovh/imgs/2022/10/15/2055118e74bd42c4.png)\n\n\n\n## 第四部分 文件IO\n\n### 12、文件IO\n\n文件编/解码：就是将内容翻译成二进制的一种方式，常用的有UTF-8、GBK、big5等。\n\n文件的操作，常见的主要有文件的的打开、关闭、读、写等操作。文件打开用open函数，写用write函数，读用read、readline()或readlines函数，文件关闭用close函数。一般文件写write还伴随有flush缓存刷新。\n\n1、文件打开的操作：\n语法格式为：`open(name,mode,encoding)`\nname：是要打开的目标文件名的字符串(可以包含文件所在的具体路径)。\nmode：设置打开文件的模式(访问模式)：只读、写入、追加等。\nencoding:编码格式（推荐使用UTF-8）\n\n|    mode    |                             描述                             |\n| :--------: | :----------------------------------------------------------: |\n|     r      | 以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。 |\n|     w      | 打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，<font color=\'red\'>原有内容会被删除</font>。如果该文件<font color=\'red\'>不存在，创建新文件</font>。 |\n|     a      | 打开一个文件用于追加。如果该文件已存在，<font color=\'red\'>新的内容将会被写入到已有内容之后</font>。如果该文件<font color=\'red\'>不存在，创建新文件进行写入</font>。 |\n| 示例代码： |                                                              |\n\n```python\nf=open(\"python.txt\",\'r\',encoding=UTF-8)\n# 注意：此时的`f`是`open`函数的文件对象，对象是Python中一种特殊的数据类型，拥有属性和方法，可以使用对象.属性或对象.方法对其进行访问，后续面向对象课程会给大家进行详细的介绍。\n\n```\n\n2、读操作\n\n**read()方法**：\n\n`文件对象.read(num)`\nnum表示要从文件中读取的数据长度（单位为字节）。如果不设置num，默认为读取文件中所有数据。\n\n**readline()和readlines()方法**：\nreadline()方法是只读取一行内容，\nreadlines可以按照行的方式把整个文件中的内容进行一次性读取，并且返回的是一个<font color=\'blue\'>列表</font>，其中每一行的数据为一个元素。\n\n这个readlines方法经常与for循环搭配使用。\n\n```python\nfor line in open(\"python.txt\",\"r\"):\n	print(line)\n```\n\n3、文件的关闭\n\n```python\nf=open(\"python.txt\",\"r\")\nf.close()\n```\n\n4、with open语法\n\n```python\nwith open(\"python.txt\",\"r\") as f:\n	f.readlines()\n\n# 通过在with open的语句块中对文件进行操作,\n# 可以在操作完成后自动关闭close文件，避免遗忘掉close方法\n```\n\n5、文件的写入、文件的追加写入\n\n```python\n#（1）普通写入：文件不存在会创建，文件存在会先清空在写入\nf=open(\'python.txt\',\'w\')\nf.write(\"hello,world\")\nf.flush()\n#（2）追加写入，在原内容上追加写入内容\nf=open(\'python.txt\',\'a\')\nf.write(\"hello,world\")\nf.flush()\n```\n\n注意：\n\n> 直接调用write，内容并未真正写入文件，而是会积攒在程序的内存中，称之为缓冲区\n>\n> 当调用flush的时候，内容会真正写入文件\n>\n> 这样做是避免频繁的操作硬盘，导致效率下降（攒一堆，一次性写磁盘）\n\n\n## 第五部分  扩展\n\n### 13、异常\n\n代码示例：\n\n```python\ntry:\n	f=open(\'test.txt\',\'r\')\nexcept Exception as e:\n	f=open(\'test.txt\',\'w\')\nelse:\n	print(\"没有异常，真开心\")\nfinally:\n	f.close()\n	# 一般try下方只放一行尝试执行的代码\n```\n\n1、try后跟的可能会出现BUG的代码，如果该代码出现了错误，就跳转到except后的语句进行执行。如果没有出错，就跳转到else后的语句进行执行。不论try后的代码是否出现错误，最终都会执行finally后的代码。\n\n2、当捕获多个异常时，可以把要捕获的异常类型的名字，放到except 后，并使用元组的方式进行书写：`xcept(NameError,ZeroDivisionError)`\n\n3、捕获异常并输出信息：\n\n```python\nNameError, ZeroDivisionError) as e:\n    print(e)\n```\n\n4、使用`except`或`except Exception`来捕获所有类型的异常。\n![](https://s3.bmp.ovh/imgs/2022/10/15/25f7c38edf8d70a9.png)\n\n5、异常的传递性\n\n假设main函数调用func1()，func1()调用func2()。如果func2()出现了异常，并且没处理，异常会传递到func1()；如果fun1()也没处理，异常会传递到main()；如果main()也没处理，程序就会报错。这就是异常的传递性。基于此原理，我们可以在main函数中设置异常处理函数，这样就能确保所有异常都能被捕捉到。\n\n注意：当所有函数都没有处理异常时，程序就会报错。\n![](https://s3.bmp.ovh/imgs/2022/10/15/5c506fda7a3a2468.png)\n\n### 14、模块的导入、包的导入\n\npython模块Module：是一个python文件，以.py结尾。模块能定义函数、类和变量，模块中也能饱含可执行的代码。（类似于c语言的.h和配套的.c文件糅合在一起的那种）\n\n模块的作用:  python中有很多各种不同的模块, 每一个模块都可以帮助我们快速的实现一些<font color=\'red\'>功能</font>, 比如实现和时间相关的功能就可以使用time模块我们可以认为<font color=\'red\'>一个模块</font>就是<font color=\'red\'>一个工具包</font>, 每一个工具包中都有各种不同的工具供我们使用进而实现各种不同的功能。\n\n什么是Python包？包就像个文件夹，里面装了若干个模块。\n\n> <font color=\'red\'>从物理上看</font>，包就是一个文件夹，在该文件夹下包含了一个 <font color=\'red\'>__init__.py 文件</font>，该文件夹可用于包含多个<font color=\'red\'>模块文件</font>\n>\n> <font color=\'red\'>从逻辑上看</font>，包的本质依然是模块\n\n#### 14.1 模块的导入\n\n包的作用：当我们的模块文件越来越多时,包可以帮助我们管理这些模块, 包的作用就是包含多个模块，但包的本质依然是模块\n\n刚刚说过，模块类似于c语言中的.h和.c文件，那么一定有类似于#include的操作咯，示例如下：\n\n```python\n语法：[from 模块名] import [模块 | 类 | 变量 | 函数 | * ][as 别名]\n常见用法示例：\nimport 模块名\nimport 模块名1,,模块名2\nfrom 模块名 import 类、变量、方法等\nfrom 模块名 import *\nimport 模块名 as 别名\nfrom 模块名 import 功能名 as 别名\n```\n\n注意：只使用import时，需要用`模块名.方法()`的方式调用对应的方法；如果是使用import的话，直接用方法：`方法()`。而as只是起一个别名，当模块名比较长或者不好记时，用别名也是一种不错的方法。\n\n#### 14.2 自定义模块\n\n其实就是新建一个python文件，里面写上对应的类或函数。然后和你的主程序放在一个目录下，用`import 文件名`的方式来引用。模块的名字就是文件的名字（不要带.py）。也就是说自定义模块名必须要符合标识符命名规则\n\n1、模块的测试\n\n当模块写好后，开发人员可以在模块后写上测试代码，来验证模块函数的可行性。可是，这样的话，不论是模块还是调用模块的代码中都会执行这部分测试代码，这显然不是我们想要的。使用`if __name__==\'__main__\'`来解决这个问题：\n\n```python\ndef test(a,b)\n	print(a+b)\n\n# 只在当前文件中调用该函数，其他导入的文件内不符合该条件，则不执行test函数调用\nif __name__==\'__main\':\n	test(1,2)\n```\n\n2、注意事项\n\n```python\n#模块1代码module1.py\ndef my_test(a,b)\n	print(a+b)\n#模块2代码module2.py\ndef my_test(a,b)\n	print(a*b)\n# 导入模块和调用功能代码\nimport module1  # 或 from module1 import my_test\nimport module2  # 或 from module2 import my_test\n#方法测试\nmy_test(1,2)  # 输出结果为2,同名方法就调用最新的那个\n\n## 可行的解决办法之一\nfrom module1 import my_test as my_test1\nfrom module2 import my_test as my_test2\n```\n\n3、`__all__`可以控制模块内的那些方法可以被导入\n\n```python\n# 模块文件module.py\n__all__ = [test_A]\n\ndef test_A():\n	print(\'testA\')\ndel test_B():\n	print(\'testB\')\n\n# 测试文件test.py\nfrom module import *\ntest_A()  //运行正常\ntest_B()  //运行出错，显示没定义\n```\n\n#### 14.3 自创建包、导入包和通过pip安装第三方包\n\n1、自创建包\n\n> ①新建包“my_package”\n>\n> ②新建包内模块：\"my_module1.py\"和\"my_module2.py\"，然后在模块内写对应的类和方法\n>\n> ③新建包后，包内会自动创建init.py来管理和控制包的导入行为。\n\n**Pycharm中的步骤**：[New]      [Python Package]    输入包名    [OK]     新建功能模块(有联系的模块)\n\n2、包的导入\n方式一：\n\n```python\nimport 包名.模块名\n#使用\n包名.模块名.方法名\n```\n\n方法二：（前提：必须在init.py文件中添加`__all__=[]`，来控制允许导入的模块列表\n\n```python\nfrom 包名 import *\n# 注意：__all__这种方法针对的是from XXX import * ,对import XXX这种方式无效\n```\n\n3、第三方包的导入\n我们知道，包可以包含一堆的Python模块，而每个模块又内含许多的功能。\n\n所以，我们可以认为：一个包，就是一堆同类型功能的集合体。\n\n在Python程序的生态中，有许多非常多的第三方包（非Python官方），可以极大的帮助我们提高开发效率，如：\n\n+ 科学计算中常用的：numpy包\n+ 数据分析中常用的：pandas包\n+ 大数据计算中常用的：pyspark、apache-flink包\n+ 图形可视化常用的：matplotlib、pyecharts\n+ 人工智能常用的：tensorflow\n\n**安装方法**：\n1、直接：pip install 包名\n2、用国内源下载和安装：`pip install -i https://pypi.tuna.tsinghua.edu.cn/simple` 包名\n\n### 15、数据的可视化分析\n\n#### 15.1 折线图\n\n1、json数据格式\n\n```python\nimport json\ndata_dict={\"name\":\"老王\",\"sex\":\"famle\",\"age\":20}\n# 将python字典转换成json数据\ndata_json=json.dumps(data_dict)\n## 如果有中文，可以带上ensure_ascii=False来确保中文正常转换\ndata_json=json.dumps(data_dict,ensure_ascii=False)\n# 将json数据转换成python字典\ndata_dumps=json.loads(data_json)\n```\n\n关机json数据格式测试案例：\n![](https://s3.bmp.ovh/imgs/2022/10/16/321d1c102158afa7.png)\n![](https://s3.bmp.ovh/imgs/2022/10/16/3429e2e7a286ce02.png)\n\n2、pyecharts模块介绍和快速入门\n\nEcharts 是个由百度开源的数据可视化，凭借着良好的交互性，精巧的图表设计，得到了众多开发者的认可。而 Python 是门富有表达力的语言，很适合用于数据处理。\n\n开发可视化图表，需要用到这个包。[官方示例文档](https://gallery.pyecharts.org/#/README)\n\n2.1 画一个基础折线图：\n\n```python\n# 导包，导入Line功能来构建折线图\nfrom pyecharts.charts import Line\n\n# 得到折线图对象\nline=Line()\n# 添加x/y轴数据   axis的意思是轴\nline.add_xaxis([\"中国\",\"美国\",\"英国\"])\nline.add_yaxis(\"GDP\",[30,20,10])\n# 生成图表  render使成为，使表现\nline.render()\n```\n\n2.2 pyecharts的全局配置和系列配置选项\n\n全局配置项可以做很多工作：\n\n> 配置图表的标题\n>\n> 配置图例\n>\n> 配置鼠标移动效果\n>\n> 配置工具栏\n>\n> 等整体配置项\n\n代码示例：\n\n```python\nline.set_global_opts(\n	title_opts=TitleOpts(\"测试\"，pos_left=\"center\",pos_bottom=\"1%\"),\n	legend_opts=LegenfOpts(is_show=True),\n	visualmap_opts=VisualMapOpts(is_show=True),\n	toolbox_opts=ToolboxOpts(is_show=True),\n	tooltip_opts=TooltipOpts(is_show=True),\n)\n```\n\n系列配置：\n先导入包：\n\n```python\nfrom pyecharts.charts import Line\nimport pyecharts.options as opts\n```\n\n然后，折线图的相关配置选项\n![](https://s3.bmp.ovh/imgs/2022/10/16/1e3610da99f33f5b.png)\n然后，y轴坐标的配置选项\n![](https://s3.bmp.ovh/imgs/2022/10/16/fd22b3bc8c11fd9a.png)\n然后，全局配置选项\n![](https://s3.bmp.ovh/imgs/2022/10/16/fb1a846ba437877c.png)\n代码示例：\n\n```python\nfrom pyecharts.charts import Line\nimport pyecharts.options as opts\n\nl=(\n	Line(init_opts=opts.InitIpts(width=\"1600px\",height=\"800px\"))\n	.add_xaxis(xaxis_data=x1_data[0,-1,2])\n	.add_yaxix(\n		seriwa_name=\"美国确诊人数\"，\n		y_axix=y1_data[0；-1]，\n		symbol_size=10,\n		label_opts=opts.LabelOpts(is_show=False),\n		linestyle_opts=opts.LineStyleOpts(width=2)\n		)\n	.set_global_opts(\n        title_opts=opts.TitleOpts(title=\"测试\"，	pos_left=\"center\",pos_bottom=\"1%\"),\n       xaxis_opts=opts.AxisOpts(name=\"时间\")，\n       yaxis_opts=opts.AxisOpts(name=\"累计确诊人数\")，\n       legend_opts=opts.LegendOpts(pos_left=\"70%\"),\n		)\n	)\n```\n\n#### 15.2 地图\n\n从pyecharts导入模块Map和VisualMapOpts\n\n```python\nfrom pyecharts.charts import Map\nfrom pyecharts.options import VisualMapOpts\n```\n\n然后就是导入数据，设置格式，显示图片，略。\n\n\n\n#### 15.3 动态展示柱状图\n\n从pyecharts导入模块Bar\n1、基础柱状图\n\n```python\nfrom pyecharts.charts import Bar  # 基础柱状图\nbar=Bar()\nbar.add_xaxis([\"中国\",\"因果\",\"美国\"])\nbar.add_yaxis(\"GDP\",[10,20,30])\nbar.render(\"基础柱状图.html\")\n```\n\n反转x、y轴：`bar.reversal_axis()`\n设置数值标签在右侧：`bar.add_yaxis(\"GDP\",[10,20,30],label_opts=LabelOpts(position=\"right\"))`\n\n2、基础时间线柱状图\n\n> 掌握基础的时间线配置动态图表\n>\n> 掌握设置主题更改颜色样式\n\n柱状图描述的是分类数据，回答的是每一个分类中『有多少？』这个问题. 这是柱状图的主要特点,同时柱状图很难动态的描述一个趋势性的数据. 这里pyecharts为我们提供了一种解决方案-<font color=\'red\'>时间线</font>\n\n如果说一个Bar、Line对象是一张图表的话，时间线就是创建一个一维的x轴，轴上每一个点就是一个图表对象。要导入TimeLine模块：`from pyecharts.charts import Bar,TimeLine`。代码示例如下：\n\n```python\nfrom pyecharts.chrts import Bar,TimeLine\nfrom pyecharts.options import *\n\nbar1=Bar()\nbar1.add_xaxis([\"中国\",\"因果\",\"美国\"])\nbar1.add_yaxis(\"GDP\",[10,20,30],label_opts=LabelOpts(position=\"right\"))\nbar1.reversal_axis()\n\nbar2=Bar()\nbar2.add_xaxis([\"中国\",\"因果\",\"美国\"])\nbar2.add_yaxis(\"GDP\",[30,50,20],label_opts=LabelOpts(position=\"right\"))\nbar2.reversal_axis()\n\n# 创建时间线对象\ntimeline=TimeLine()\n# 将柱状图添加到时间线对象中\ntimeline.add(baar1,\"2021年GDP\")\ntimeline.add(bar2,\"2022年GDP\")\n# 通过时间线绘图\ntimeline.render(\"基础柱状图-时间线.html\")\n\n## 设置自动播放\ntimeline.add_schema(\n	play_interval=1000,     # 自动播放的时间间隔，单位毫秒\n	is_timeline_show=True,  # 是否在自动播放时，显示时间线\n	is_auto_play=True,      # 是否自动播放\n	is_loop_play=True,      # 是否循环自动播放\n)\n```\n\n时间线设置主题：\n\n```python\nfrom pyecharts.global import ThemeType\n# 创建时间线对象\ntimeline=TimeLine(\n	{\"theme\":ThemeType.LIGHT}\n)\n```\n\n主题的其他配置选项见下图：\n![](https://s3.bmp.ovh/imgs/2022/10/16/ee45d67c9af77da8.png)\n\n3、动态柱状图绘制\n\n> 1. 掌握列表的sort方法并配合lambda匿名函数完成列表排序\n>\n> 2. 完成图表所需的数据处理\n>\n> 3. 完成GDP动态图表绘制\n\n3.1 需求分析\n\n简单分析后，发现最终效果图中需要：\n\n1. GDP数据处理为亿级\n2. 有时间轴，按照年份为时间轴的点\n3. x轴和y轴反转，同时每一年的数据只要前8名国家\n4. 有标题，标题的年份会动态更改\n5. 设置了主题为LIGHT\n\n最终效果图：\n![](https://s3.bmp.ovh/imgs/2022/10/16/7c6087271250c484.png)\n\n代码示例：\n\n1、处理数据\n![](https://s3.bmp.ovh/imgs/2022/10/16/0b6ffdafd38e7a38.png)\n![](https://s3.bmp.ovh/imgs/2022/10/16/199b4d8405330400.png)\n\n2、准备时间线\n![](https://s3.bmp.ovh/imgs/2022/10/16/5d1c21a705f36697.png)\n\n3、自动播放和绘图\n![](https://s3.bmp.ovh/imgs/2022/10/16/379d6908a207ba41.png)\n\n\n\n\n### 16、python中的类与对象（封装、继承与多态）\n\n#### 16.1、类的封装与定义（方法、属性）\n\n1、关键点：掌握类的定义和使用，掌握成员方法的使用，掌握self关键字的作用（self是不是与c++的this指针很像？）\n\n```python\nclass Student:\n	name=None\n	age=None\n	def say_hi(self):\n		printf(f\"Hi,{self.name}!\")\n\n# 调用\nstu=Student()\nstu.name=HaoY\nstu.say_hi()\n```\n\n从上述实例可以看出类中有属性（成员变量），有方法（成员方法）。可以看到，类中定义的方法和外面定义的函数时非常类似的，仍需注意一点的是，类中方法的第一个形参必须是self，方法中调用类内属性时，必须使用self指针；类外调用方法时，不用填充第一个形参self。\n使用构造方法，通过传参的方式初始化类的对象（是不是与c++的构造函数很相似）\n\n2、self的作用\n\n+ 表示类对象本身的意思\n+ 只有通过self，成员方法才能访问类的成员变量\n+ self出现在形参列表中，但不占用参数位置，无需理会\n\n3、类的构造方法：使用`__init__`来实现类对象的初始化：\n\n```python\n# 该方法在构建类对象时，会自动运行：stu=Student(\"HaoY\",23,1100992)\ndef __init__(self,name,age,tel)\n	self.name=name\n	self.age=age\n	self.tel=tel\n```\n\n4、掌握python的其他内置方法  （类中的内置方法）\n上文学习的`__init__` 构造方法，是Python类内置的方法之一。这些内置的类方法，各自有各自特殊的功能，这些内置方法我们称之为：魔术方法。（以下部分内置方法为常用的）\n\n> `__init__`：类的构造方法\n>\n> `__str__`：字符串方法\n>\n> `__lt__` 和 `__gt__`：小于、大于符号比较\n>\n> `__le__`  和  `__ge__` ：小于等于、大于等于符号比较\n>\n> `__eq__`：等于符号比较\n\n4.1 `__str__`方法\n\n直接print(对象)，输出的结果是对象的内存地址。这个地址在python中没啥用。我们可以在类中新增`__str__`方法，这样当使用print(对象)时，输出的就是我们指定的字符串了。示例如下：\n\n```python\nclass Student:\n	def __init__(self,name,age):\n		self.name=name\n		self.age=age\n\n# 测试  （不使用__str__方法）\nstu=Student(\"HaoY\",23)\nprint(stu)   # 输出： <__main.Student object at 0x000002200CFD6040>\nprint(str(stu)) # 输出： <__main.Student object at 0x000002200CFD6040>\n--------------------------------------------------------------\nclass Student:\n	def __init__(self,name,age):\n		self.name=name\n		self.age=age\n	def __str__(self):\n		return f\"哈哈，你看到我了吗？\"\n\n# 测试   （使用__str__方法）\nstu=Student(\"HaoY\",23)\nprint(stu)   # 输出： 哈哈，你看到我了吗？\nprint(str(stu)) # 输出： 哈哈，你看到我了吗？\n```\n\n4.2 `__lt__`  /  `__gt__`小于/大于符号比较方法\n\n注意，直接用小于/大于福来来比较两个类对象，是错误的用法。但是在类中添加了`__lt__`内置方法后，就可以实现直接用大于小于符号来比较两个类对象的操作了。（有点像c++的重载大于小于操作符的方法）\n\n```python\nclass Student:\n	def __init(self,name,age):\n		self.name=name\n		self.age=age\n\n	def __lt__(self,other):\n		return self.age < other.age\n# 测试\nstu1=Student(\"HaoY\",23)\nstu2=Student(\"WuMan\",22)\nprint(stu1<stu2)  # 结果： False\nprint(stu1>stu2)  # 结果： True  注意，实现大于符号需要写`def __gt__`，上面的类未实现\n```\n\n4.3 `__le__`  /  `__ge__`小于等于 / 大于等于符号比较方法\n\n与4.2内容相似。还有`__eq__`也是类似的用法。\n\n5、类的封装：私有成员变量/方法的设置（注意与c++的不同）\n\n如何定义私有变量和私有方法？\n\n答：在变量名和方法名前，加上两个下划线即可。`__name`和`def __keep_score(self)`\n\n私有变量只能在类内使用，不能被对象调用。不能被对象赋值，不能被对象读值。在类内的方法中，通过self来调用私有变量。\n\n```python\npthon.__name=\"HaoY\"   # 不报错，但无效\nprint(pthon.__name)   # 报错，无法使用\n```\n\n#### 16.2、类的继承\n\n单继承：\n\n```python\n# 父类\nclass Phone:\n	IMEI=None\n	producer=None\n\n# 子类  继承表示：将从父类那里继承（复制）来成员变量和成员方法（不含私有）\nclass Xiao(Phone)\n	face_id=True\n\n```\n\n多继承（多父类的同名函数问题，继承顺序问题）还有pass关键字\n\n```python\nclass Phone:\n	IMEI=None\n	producer=None\n\nclass Ss:\n	face_id=True\n\nclass Bb:\n	face_chec=True\n	producer=\"HM\"\n	\nclass MyPhone(Phone,Ss,Bb)\n	pass\n\n## 温馨提示：关于多继承的优先级问题\n如上所示，子类MyPhone继承了三个类，而父类Phone和父类Ss都有成员属性producer，并且这个属性是公共属性并非私有属性。那么，在子类中使用该变量时（假设子类未重新定义该变量），子类实际调用的哪个父类的属性呢？\n\n答案：继承优先级从左到右，优先级从高到底。所以，子类调用producer属性时，输出None而不是HM。\n```\n\n复写：（与C++的虚函数类似）在子类中 重新定义同名的属性或方法即可\n\n一般在子类复写了父类方法后，在子类调用该方法就是调用子类中的方法。那有什么方式可以再子类中调用父类方法吗？\n\n```python\n## 前提：只能在子类内调用父类的同名成员。子类的类对象直接调用会调用子类复写的成员\n# 方式一：\n使用子类中的父类变量/方法来调用\n调用变量：父类成员.变量\n调用方法：父类成员.成员方法(self)\n# 方法二：\n使用super()调用父类变量/方法\n调用变量：super().变量\n调用方法：super().方法\n```\n\n#### 16.3、类的多态\n\n在C++中的多态有两种，一是函数多态，根据形参数据类数量和位置的不同，产生多态行为；而是类中函数为纯虚函数，此时类为抽象类，子类继承该父类并重新父类方法是另一种多台。\n\npython中没有函数多态，只有类的抽象继承。\n父类定义方法，但不实现，子类重新定义方法并实现。这样就实现了父类一个方法有多种输出结果的多态。示例;\n\n```python\nclass father:\n	def speak():\n		pass\nclass son1:\n	def speak()\n		print(\"哇哇哇\")\nclass son2:\n	def speak()\n		print(\"哈哈哈\")\n```\n\n>抽象类：含有抽象方法的类称之为抽象类\n>\n>抽象方法：方法体是空实现的（pass）称之为抽象方法\n\n\n\n#### 16.4、类型注解问题（ctrl+p弹出函数传参提示）\n\nPython3.5引入了类型注解，它的功能是方便静态类型检查工具、IDE等第三方工具，来为编程提供便利和提前排错。\n\n主要功能：\n\n+ 帮助第三方IDE工具（如PyCharm）对代码进行类型推断，协助做代码提示\n+ \n+ 帮助开发者自身对变量进行类型注释（备注）\n\n类型注解分为变量注解、函数（方法）形参列表和返回值注解和Union类型注解。注解只是提示性的，不是决定性的，不会真正的对类型做验证和判断。\n\n##### 16.4.1 变量的注解\n\n```python\n# 基本语法： 变量：类型\n# 1、基础数据类型注解\nvar_1： int = 10\nvar_2: float=3.12\nvar_3: bool=True\nvar_4: str=\"itheima\"\n#2、类对象的类型注解\nclass Student:\n	pass\nstu:student=Sthdent()\n#3、基础容器注解\nmy_list:list=[1,2,3]\nmy_tuple:tuple=(1,2,3)\nmy_set:set={1,2,3}\nmy_dict:dict={\"Aa\":1,\"Bb\":2}\nmy_str:str=\"itheima\"\n#4、容器类型详细注解\n## 注意：\n### + 元组类型设置类型详细注解，需要将每一个元素都标记出来。注意哦，元组很特殊，需要把每一个元素类型都标列出来\n### + 字典类型设置类型详细注解，需要2个类型，第一个是key第二个是value\nmy_list:list[int]=[1,2,3]\nmy_tuple:tuple[int]=(1,2,3)\nmy_set:set[int]={1,2,3}\nmy_dict:dict[str,int]={\"Aa\":1,\"Bb\":2}\n\n# 注意，警告！下面这种复合数据类型的写法，只在python3.9后才支持的。在python3.5~python3.9之间，对于复合型的数据类型，请使用Union类型\nmy_list:list[int,str,float]=[1,\"2\",3.12]\nmy_tuple:tuple[int,str,float]=(1,\"2\",3.12)\nmy_set:set[int,str,float,bool]={1,\"2\",3.12,True}\n```\n\n除了使用`变量：类型`的方式注解外，也可以在注释中进行类型注解\n语法：`#type:类型`\n\n```python\nvar_1=random.randint(1,10)  #type:int\nvar_2=json,loads(data)      #type:dict[str,int]\nvar_3=func()                #type:Student\n```\n\n一般直接定义的普通变量无需注解，一般能看出它的类型，但是存储函数返回值、类对象的返回值的变量，可能很难直接看出它的数据类型，所以需要注解：\n\n```python\n#小总结，第一种注解方式：\nvar_1:int=random.randint(1,10) \nvar_2:dict=json,loads(data)    \nvar_3:Student=func()\n# 第二种注解方式  在注释中：\nvar_1=random.randint(1,10)  #type:int\nvar_2=json,loads(data)      #type:dict[str,int]\nvar_3=func()                #type:Student\n```\n\n##### 16.4.2 函数（方法）的类型注解\n\n1、形参注解\n语法形式：\n\n```python\ndef 函数方法名(形参名1：类型1，形参名2：类型2，...):\n	pass\n```\n\n2、返回值注解\n语法形式：\n\n```python\ndef 函数方法名(形参名1：类型1，形参名2：类型2，...) -> 返回值类型：\n	pass\n```\n\n综合示例：\n\n```python\ndef add(x:int,y:int) -> int:\n	return x+y\ndef func(data:list[int]) -> list[int]\n	pass\n```\n\n##### 16.4.3 Union类型的注解\n\n在含有多种数据类型的数据容器中进行类型注释，就需要一点技巧了。Union类型就是解决这一问题的方法之一。\n\n先导包：`from typing import Union`\n对于单一数据类型的容器或函数形参/返回值注解，可以直接使用：\n\n```python\nmy_list:list[int]=[1,2,3]\nmy_dict:dict[str,int]={\"HM\":11,\"ds\":22}\n```\n\n对于含有多种数据类型的容器或函数形参、返回值，就需要Union类型的帮助了。\n\n```python\n# 也可以将复合的这几种数据类型拆开，不过这种写法只在python3.9后才支持\n# my_list:list[int,str]=[1,2,\"HM\",\"lalala\"]\n\nfrom typing import Union\nmy_list:list[Union[str,int]]=[1,2,\"HM\",\"lalala\"]\nmy_dict:dict[str,Union[str,int]]={\"HM\":11,\"sanaj\":\"heihie\"}\n# 使用Union[类型,类型,...]，\n# 可以实现联合类型注解  在函数形参和返回值上，也是可以用的：\ndef func(data:Union[int,str]) -> Union[int,str]:\n	pass\n```',1,0,0,0,1,'2023-06-07 16:39:33','2023-06-07 20:02:59');
INSERT INTO `t_article` VALUES (80,1,51,'https://upload.haoxx.site/article/2ec42f646cb85e6554ab21b4e9bc6c19.jpg','C++参考资料','---\ntitle: 参考资料汇总\ndate: 2022-10-30\nauthor: HaoXX\ncategory:\n - 1编程语言基础\n\nfooter: <a href=\"https://beian.miit.gov.cn/#/Integrated/index\">渝ICP备2023001651号</a>\n\n---\n\n:::tip\n参考资料汇总\n:::\n\n<!-- more -->\n\n<p align=\"center\" style=\"color:blue\">\n  <a href=\"https://mp.weixin.qq.com/s/ePhaYezFblgt0NgbvtWqww\" target=\"_blank\">\n    <h2 align=\"center\">\n        仓库内容持续更新中...\n    </h2>\n  </a>\n</p>\n\n\n<!-- <p>\n  <br>\n</p> -->\n\n<p align=\"center\">\n    <a href=\"https://mp.weixin.qq.com/s/ePhaYezFblgt0NgbvtWqww\" target=\"_blank\">\n        <img src=\"https://cdn.jsdelivr.net/gh/justacoder99/r2coding@master/img/r2coding_logo_index.15y992dieibg.png\" width=\"\"/>\n    </a>\n</p>\n\n\n\n<p align=\"center\">\n  <a href=\"https://github.com/rd2coding/Road2Coding\" target=\"_blank\"><img src=\"https://img.shields.io/badge/Github-r2coding-red.svg\"></a>\n  <a href=\"https://gitee.com/rd2coding/Road2Coding\" target=\"_blank\"><img src=\"https://img.shields.io/badge/Gitee-r2coding-blue.svg\"></a>\n  <a href=\"https://space.bilibili.com/384068749\" target=\"_blank\"><img src=\"https://img.shields.io/badge/bilibili-哔哩哔哩-critical\"></a>\n  <a href=\"https://mp.weixin.qq.com/s/ePhaYezFblgt0NgbvtWqww\" target=\"_blank\">\n    <img src=\"https://img.shields.io/badge/微信联系作者-WeChat-green.svg\" alt=\"微信联系\">\n  </a>\n</p>\n\n\n自学之路漫又长，唯有不断总结，不断回味，不断分享，才能成长！\n\n联系我可以[【微信】](#微信)私我\n\n---\n\n# **为什么会有这个开源仓库**\n\n---\n\n本仓库取名 **r2coding**，即 **Road To Coding**，意为「编程自学之路」，是自学编程以来所用资源和分享内容的大聚合。\n\n旨在为编程自学者提供一系列：\n\n>  - **清晰的编程自学路线**\n>  - **各编程岗位方向的知识点梳理**\n>  - **靠谱的资源**\n>  - **高效的工具**\n>  - **务实的技术文章**\n\n方便自己也方便他人。仓库内容会保持**持续更新**，欢迎收藏品鉴！\n\n---\n\n# **本仓库内容地图**\n\n---\n\n![](https://cdn.jsdelivr.net/gh/justacoder99/r2coding@master/img/contentmap.3sdmma4od740.png)\n\n---\n\n# **编程自学路线+知识大梳理**\n\n---\n\n本仓库目前整理收录了6个大方向（岗位）的学习路线+知识点大梳理，分别为：\n\n- **Java后端开发**\n- **前端开发**\n- **C/C++后台开发**\n- **大数据开发**\n- **嵌入式开发**\n- **网络安全方向**\n\n\n后续本仓库也会持续更新和增加更多方向岗位的学习路线...\n\n---\n\n<!-- tabs:start -->\n\n### **Java后端开发**\n\n详情链接 **→** [《Java后端开发学习路线+知识点大梳理》](https://mp.weixin.qq.com/s/rAoamIey7cARMES7kfIaLw)\n\n![](https://cdn.jsdelivr.net/gh/justacoder99/r2coding@master/img/jawa.391vqmg83lc0.png)\n\n> 注：图片上传后可能被压缩，如需无损版高清大图，可去微信公众号「**CodeSheep**」后台回复「**后端开发**」四个字获取即可\n\n详情链接 **→** [《Java后端开发学习路线+知识点大梳理》](https://mp.weixin.qq.com/s/rAoamIey7cARMES7kfIaLw)\n\n### **前端开发**\n\n详情链接 **→** [《前端开发学习路线+知识点大梳理》](https://mp.weixin.qq.com/s/_8lvpPDArM_Z-MI9iul1AA)\n\n![](https://cdn.jsdelivr.net/gh/justacoder99/r2coding@master/img/front.6uquir77a6c0.png)\n\n> 注：图片上传后可能被压缩，如需无损版高清大图，可去微信公众号「**CodeSheep**」后台回复「**前端开发**」四个字获取即可\n\n详情链接 **→** [《前端开发学习路线+知识点大梳理》](https://mp.weixin.qq.com/s/_8lvpPDArM_Z-MI9iul1AA)\n\n### **大数据开发**\n\n详情链接 **→** [《大数据开发学习路线+知识点大梳理》](https://mp.weixin.qq.com/s/dm2Qm4zZhHxEvcFgNS_mrA)\n\n![](https://cdn.jsdelivr.net/gh/justacoder99/r2coding@master/img/bigdata.21roso2lxdsw.png)\n\n> 注：图片上传后可能被压缩，如需无损版高清大图，可去微信公众号「**CodeSheep**」后台回复「**大数据**」三个字获取即可\n\n详情链接 **→** [《大数据开发学习路线+知识点大梳理》](https://mp.weixin.qq.com/s/dm2Qm4zZhHxEvcFgNS_mrA)\n\n### **嵌入式开发**\n\n详情链接 **→** [《嵌入式开发学习路线+知识点大梳理》](https://mp.weixin.qq.com/s/AJqbhz3InV3G8TVjTHn6dg)\n\n![](https://cdn.jsdelivr.net/gh/justacoder99/r2coding@master/img/embed.2kqjbi961600.png)\n\n> 注：图片上传后可能被压缩，如需无损版高清大图，可去微信公众号「**CodeSheep**」后台回复「**嵌入式**」三个字获取即可。\n\n详情链接 **→** [《嵌入式开发学习路线+知识点大梳理》](https://mp.weixin.qq.com/s/AJqbhz3InV3G8TVjTHn6dg)\n\n### **C/C++后台开发**\n\n详情链接 **→** [《C/C++（偏后台）开发学习路线+知识点大梳理》](https://mp.weixin.qq.com/s/tXilzUzN7cDhnc3ztw4Vlw)\n\n### **网络安全方向**\n\n详情链接 **→** [《网络安全方向学习路线+知识点大梳理》](https://mp.weixin.qq.com/s/pPs5Gm9I3a6-nMZQ42kaWg)\n\n<!-- tabs:end -->\n\n---\n\n# **常用编程软件和工具**\n\n---\n\n> [!NOTE]\n>\n>  - [**【置顶笔记下载1】熬10天夜，我肝出了这个PDF版「服务器软件安装手册」**](https://mp.weixin.qq.com/s/YNOZSQ5smo1uGE5ZttUZ_w)\n>\n>  - [**【置顶笔记下载2】再肝两夜，写了个「服务器项目部署」实战PDF手册**](https://mp.weixin.qq.com/s/JUJ6qu_ec3s1JmTxQt_V3g)\n\n> **工欲善其事，必先利其器！**\n\n一个易上手、好用、高效的软件工具对于程序员工作效率的提升是不言而喻的，这些常用开发软件和工具比如：\n\n> - 基础的软件开发环境和设施\n> - 好用高效的在线工具和网站\n> - 本地常用的一些编程软件\n> - Linux操作系统\n> - 版本控制工具\n> - 高效的IDE和编辑器\n> - API管理工具/文档管理工具\n> - CI守护系统\n> - ...... 等等\n\n接下来我们一项一项详细盘点。\n\n---\n\n## 常用在线工具集\n\n---\n\n> [!NOTE]\n>\n>  - [**【本章节置顶资源下载】自学编程一路走来，这些私藏工具和网站我全贡献出来了！（附我的浏览器书签下载）**](https://mp.weixin.qq.com/s/XUHnLCbq7mDWhOc9imTVzg)\n\n程序员在平时的日常**工作**、**学习**、**开发**、**做笔记**、**写博客**等过程中还是有很多好用并且高效的**在线工具推荐**的，毕竟我们不是每时每刻我们都需要那种很重量级的本地软件。\n\n下面将分成**16个大类**，共整理了约**130+个**常用的在线工具和网站供大家食用。\n\n---\n\n<!-- tabs:start -->\n\n#### **在线画图工具**\n\n程序员经常接触的无非也就是流程图、思维导图、原型图、UML图、网络拓扑图、组织结构图等等这些。\n\n下面这四个在线画图网站我想应该足够了，其中那个processon是我用得最多的，历史文章中几乎所有相关的图形都是用它绘制，然后导出图片的。\n\n- [在线画图工具ProcessOn](https://www.processon.com/)\n- [在线画图工具Draw.io](https://app.diagrams.net/)\n- [在线思维导图工具MindLine](http://www.mindline.cn/webapp)\n- [PlantUML在线编辑器](http://haha98k.com/)\n\n#### **在线编解码工具**\n\n- [BASE64编解码工具](https://base64.supfree.net/)\n- [MD5编码工具](https://www.zxgj.cn/g/md5)\n- [AES/DES加解密](http://www.fly63.com/tool/cipher/)\n- [JWT解码工具](http://jwt.calebb.net/)\n- [ASCII编解码工具](https://www.matools.com/code-convert-ascii)\n- [Unicode编解码工具](https://www.zxgj.cn/g/unicode)\n- [UTF-8编解码工具](https://www.zxgj.cn/g/utf8)\n- [字符串编解码工具](https://www.zxgj.cn/g/enstring)\n- [URL编解码工具](http://tool.chinaz.com/tools/urlencode.aspx?jdfwkey=lbixz1)\n\n#### **在线转换工具**\n\n- [在线ASCII码对照表](http://www.fly63.com/tool/ascii/)\n- [通用进制转换工具](https://www.zxgj.cn/g/jinzhi)\n- [在线浮点数十进制转换](http://www.binaryconvert.com/)\n- [RGB颜色转换](https://www.zxgj.cn/g/yansezhi)\n- [时间戳转换工具](https://www.zxgj.cn/g/unix)\n- [计量单位换算工具](http://www.fly63.com/tool/unitable/)\n- [在线JSON解析](http://www.json.cn/)\n- [在线JS代码格式化工具](https://prettier.io/playground/)\n- [SQL压缩/格式化工具](https://www.zxgj.cn/g/sqlformat)\n- [JSON和XML在线转换](https://www.zxgj.cn/g/jsonxml)\n- [JSON/YAML在线转换](http://www.fly63.com/tool/jsonyaml/)\n- [人民币大小写转换工具](http://www.fly63.com/tool/renmingbi/)\n\n#### **正则表达式工具**\n\n- [正则表达式调试工具](https://regexr.com/)\n- [正则表达式可视化工具](https://jex.im/regulex/)\n\n#### **网络工具**\n\n- [IP地址归属地查询](https://www.ip138.com/)\n- [IP地址查询](https://www.ipip.net/ip.html)\n- [HTTP在线接口测试工具](http://www.fly63.com/php/http/)\n\n#### **在线编译运行工具**\n\n- [C#在线编译运行](https://rextester.com/)\n- [C/C++在线编译调试](https://www.onlinegdb.com/)\n- [在线编译工具套装](https://c.runoob.com/)\n\n#### **可视化/格式化工具**\n\n- [在线前端编辑器](https://codepen.io/)\n- [在线数据可视化](https://flourish.studio/)\n- [在线JSON解析](http://www.json.cn/)\n- [在线CSS代码可视化工具](https://enjoycss.com/)\n- [XML格式化工具](https://www.zxgj.cn/g/xmlformat)\n- [在线JS代码格式化工具](https://prettier.io/playground/)\n- [SQL压缩/格式化工具](https://www.zxgj.cn/g/sqlformat)\n- [JSON和XML在线转换](https://www.zxgj.cn/g/jsonxml)\n- [JSON/YAML在线转换](http://www.fly63.com/tool/jsonyaml/)\n\n#### **在线生成器**\n\n- [UUID在线生成器](https://www.zxgj.cn/g/uuid)\n- [随机数生成器](https://www.zxgj.cn/g/suijishu)\n\n#### **其他常用在线开发相关工具**\n\n- [在线Nginx配置工具](https://nginxconfig.io/)\n- [在线文本代码比对工具](http://www.fly63.com/tool/textdiff/)\n- [在线Chrome浏览器插件](https://www.crx4chrome.com/)\n- [在线接口文档管理工具](http://www.docway.net/)\n\n#### **在线素材工具**\n\n如果你也写文章，或者做视频，那就一定少不了要找素材，包括各种图片、背景、emoji表情、表情包、壁纸、视频、gif图等等。\n\n如此一来，那些好用的在线素材工具就必不可少了，比如像各种表情包工具、icon图标库、矢量图库、图片素材库、壁纸库等等。\n\n- [免费透明背景图片素材](http://pngimg.com/)\n- [Emoji表情包下载](https://emojiisland.com/)\n- [open source icons](https://feathericons.com/)\n- [阿里巴巴矢量图标库](https://www.iconfont.cn/)\n- [表情包在线网站](https://fabiaoqing.com/)\n- [免费PNG图片库](https://pluspng.com/)\n- [ICON图标在线下载](https://www.iconfinder.com/)\n- [极简壁纸](https://bz.zzzmh.cn/)\n- [Wallpaper Abyss壁纸](https://wall.alphacoders.com)\n- [Pixabay图片素材库](https://pixabay.com/zh/)\n- [Unsplash图片素材库](https://unsplash.com)\n- [Pexels图片素材库](http://www.pexels.com)\n- [NASA图片视频素材库](https://images.nasa.gov)\n\n#### **设计制作类工具**\n\n对于那些文章创作者和视频创作者而言，设计封面，做海报，设计LOGO，图片美化等等基本也是刚需。\n\n这样大概率日常会用到一些简易好上手的在线设计制作类工具，比如在线P图、音/视频轻量化剪辑、logo制作、海报设计制作、图片美化、在线图片转换或生成等等，毕竟不是每时每刻我们都需要那种重量级的本地软件。\n\n- [在线PS](https://www.uupoop.com/)\n- [在线音频剪辑](https://www.weixinsyt.com/)\n- [在线视频剪辑](https://www.kapwing.com/)\n- [免费logo在线制作](http://www.uugai.com/)\n- [艺术字体在线生成](https://www.qt86.com/)\n- [在线表格转换工具](https://tableconvert.com/)\n- [在线海报设计工具](https://www.designcap.com/)\n- [图片智能放大工具](https://bigjpg.com/)\n- [二维码美化器](https://mh.cli.im/)\n- [在线代码截图工具](https://carbon.now.sh/)\n- [在线抠图工具](https://www.remove.bg/zh)\n- [ICO图标在线生成](http://www.fly63.com/php/ico/)\n- [SVG转PNG工具](http://www.fly63.com/tool/svg2img/)\n- [视频转GIF工具](http://www.fly63.com/tool/giftxt/)\n- [二维码在线生成器](http://www.fly63.com/tool/ewm/)\n- [二维码在线解码](http://www.fly63.com/php/decoder/)\n\n#### **写作辅助工具**\n\n在我写文章的过程中经常会用到和写作相关的辅助工具，比方说：字数统计工具、Markdown格式的文章排版工具、图床网站、代码截图工具等等，所以下面这些在线工具就能很好地满足我的需求。\n\n- [在线字数统计](https://www.eteste.com/)\n- [mdnice markdown排版工具](https://mdnice.com/)\n- [md2all markdown排版工具](http://md.aclickall.com/)\n- [在线图床神器](https://picx.xpoet.cn/)\n- [在线免费图床](https://sm.ms/)\n- [图壳图床](https://imgkr.com/)\n- [在线代码截图工具](https://carbon.now.sh/)\n- [在线短链接工具](https://urlify.cn/)\n- [在线文本替换](http://www.fly63.com/tool/textreplace/)\n\n#### **在线办公工具**\n\n这部分在线工具主要用来处理一些和文档以及文稿相关的事情，经常用到的比如：在线的全套pdf处理和转换工具、各种各样多媒体文件间的相互转换工具、在线识别工具、在线压缩工具等等。\n\n- [pdf在线处理工具套装1](https://smallpdf.com/cn/pdf-tools)\n- [pdf在线处理工具套装2](https://tools.pdf24.org/zh/)\n- [pdf转word在线工具](https://www.pdftoword.com/)\n- [在线多媒体转换器合集](https://cn.office-converter.com/)\n- [在线文字识别工具](https://ocr.wdku.net/)\n- [在线文件压缩工具](https://docsmall.com/)\n\n#### **文档笔记工具**\n\n好记性不如烂笔头，作为一个学习者，我觉得记笔记是必不可少的步骤。当然现在基本都做电子笔记和电子文档比较多。\n\n现如今各式各样优秀的文档工具和笔记软件鳞次栉比，好用的也有很多，整理成如下列表，这东西各有长处，使用哪个最合意还得看个人习惯和需求了。\n\n- [印象笔记](https://www.yinxiang.com/)\n- [有道笔记](https://note.youdao.com/)\n- [OneNote](https://www.onenote.com/)\n- [幕布](https://mubu.com/)\n- [为知笔记](https://www.wiz.cn/)\n- [石墨文档](https://shimo.im/)\n- [Simplenote](https://simplenote.com/)\n- [语雀](https://www.yuque.com/)\n\n#### **编程学习网**\n\n- [哔哩哔哩](https://www.bilibili.com/)\n- [C语言网](https://www.dotcpp.com/)\n- [cppreference](http://zh.cppreference.com/)\n- [中国大学MOOC](https://www.icourse163.org/)\n- [牛客网](www.nowcoder.com)\n- [网易公开课](https://open.163.com/)\n- [CodeGym](https://codegym.cc/)\n- [BeginnersBook](https://beginnersbook.com/)\n- [JavaSED](http://www.javased.com/)\n- [codecademy](https://www.codecademy.com/)\n- [Coursera](https://www.coursera.org/)\n- [StackOverFlow](https://stackoverflow.com/)\n- [LeetCode](https://leetcode-cn.com/)\n- [LintCode](https://www.lintcode.com/)\n\n#### **在线教程和文档**\n\n这部分主要集中了我在做开发过程中随手参考所要用到的几乎所有在线教程和官方文档，有中文版文档的我基本都优先列出来了，但更多时候是英文的官方文档。\n\n<!-- panels:start -->\n\n<!-- div:left-panel -->\n\n- [Git中文教程](https://git-scm.com/book/zh/v2)\n- [SVN中文手册](http://svnbook.red-bean.com/nightly/zh/index.html)\n- [jQuery API中文文档](https://jquery.cuishifeng.cn/)\n- [Nginx中文文档](https://www.nginx.cn/doc/index.html)\n- [Kafka中文文档](https://kafka.apachecn.org/)\n- [Mybatis中文文档](https://mybatis.org/mybatis-3/zh/index.html)\n- [微信小程序官方文档](https://developers.weixin.qq.com/miniprogram/dev/framework/)\n- [Nodejs中文教程文档](http://nodejs.cn/learn)\n- [Apache Web Server文档](http://httpd.apache.org/docs/)\n- [Spring文档中文版](https://www.springcloud.cc/spring-reference.html)\n- [Golang标准库文档中文版](https://studygolang.com/pkgdoc)\n- [Java 8官方文档](https://docs.oracle.com/javase/8/docs/api/index.html)\n- [Maven官方文档](http://maven.apache.org/guides/)\n- [Tomcat 8官方文档](http://tomcat.apache.org/tomcat-8.0-doc/index.html)\n\n<!-- div:right-panel -->\n\n- [Spring Boot官方文档](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/)\n- [RabbitMQ官方文档](https://www.rabbitmq.com/documentation.html)\n- [RocketMQ官方文档](http://rocketmq.apache.org/docs/quick-start/)\n- [Dubbo中文文档](https://dubbo.apache.org/zh/docs/)\n- [Netty官方文档](https://netty.io/wiki/index.html)\n- [Elasticsearch官方文档](https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html)\n- [Spring Cloud官方文档](https://spring.io/projects/spring-cloud)\n- [Docker官方文档](https://docs.docker.com/get-started/)\n- [Kubernetes中文文档](https://kubernetes.io/zh/docs/home/)\n- [Thymeleaf官方文档](https://www.thymeleaf.org/documentation.html)\n- [Vue.js中文文档](https://cn.vuejs.org/v2/guide/)\n- [React.js官方文档](https://reactjs.org/docs/getting-started.html)\n- [Jenkins中文文档](https://www.jenkins.io/zh/doc/)\n\n<!-- panels:end -->\n\n<!-- tabs:end -->\n\n---\n\n## 常用本地软件\n\n---\n\n<p align=\"left\">\n    <a href=\"https://mp.weixin.qq.com/s/ePhaYezFblgt0NgbvtWqww\" target=\"_blank\">\n        <img src=\"https://cdn.jsdelivr.net/gh/justacoder99/r2coding@master/img/localsoftware.2x9vakmja2g.png\" width=\"\"/>\n    </a>\n</p>\n\n\n这里将常用软件分为了5大类，包括：\n\n> - 社交/娱乐/上网\n> - 办公软件\n> - 效率和美化软件\n> - UP主必备\n> - 程序员生产力工具\n\n- [点击查看：我的常用软件大公开！](https://mp.weixin.qq.com/s/ONx6wjGjQSvOOIgnEBTNJQ)\n\n---\n\n## 基础软件开发环境和设施\n\n---\n\n**什么叫基础软件开发环境？**\n\n很好理解。学Java得要装JDK吧？学Python得要Python环境吧？学数据库得要MySQL吧？等等，这些在学习编程之前都是应该提前在自己的电脑上准备好的，而且尽量把全套都先备好，后面直接就用了。\n\n经常听到有小伙伴反馈和提问有关编程环境搭建和基础软件设施安装的相关问题。\n\n> - 啥？JDK明明装了，为啥还是not found？ \n> - 咦？Maven明明配了加速，咋下载依赖还这么慢？ \n> - 诶？MySQL明明装了，咋Navicat连会报错？ \n> - 哦？Tomcat咋出不来页面？......\n\n每次都是照着网上现搜的帖子操作，一顿操作猛如虎，一看结果各种有问题，要不报错，要不环境起不来，等等。装个环境就浪费了很多时间，而且过了一段时间又忘，还得重新搜帖子，该踩的坑一个都不少...\n\n既然大家有这方面需求，想来想去，关于这个问题，我还是决定写一个事无巨细的PDF文档，把所有编程环境和基础软件设施的安装过程给详细地记录下来了。\n\n[熬10天夜，我肝出了这个PDF版「编程软件（环境）安装手册」](https://mp.weixin.qq.com/s/YNOZSQ5smo1uGE5ZttUZ_w)\n\n内容包含常见基础开发环境和设施的安装部署，包括：\n\n> - Linux操作系统\n> - Git工具\n> - Java环境JDK\n> - Node基础环境\n> - Python基础环境\n> - Maven项目构建和管理\n> - MySQL数据库\n> - Redis缓存\n> - RabbitMQ消息队列\n> - Tomcat应用服务器\n> - Nginx Web服务器\n> - Docker环境\n> - Kubernetes环境\n> - Elasticsearch搜索引擎\n> - ZooKeeer环境\n> - Kafka消息队列\n\n大家有需要的可以：[点击此处 → 下载获取](https://mp.weixin.qq.com/s/YNOZSQ5smo1uGE5ZttUZ_w)！\n\n---\n\n## Linux操作系统\n\n---\n\n<p align=\"left\">\n    <a href=\"https://mp.weixin.qq.com/s/ePhaYezFblgt0NgbvtWqww\" target=\"_blank\">\n        <img src=\"https://cdn.jsdelivr.net/gh/justacoder99/r2coding@master/img/linuxos.qciprfz30dc.png\" width=\"\"/>\n    </a>\n</p>\n\n\n实际企业级开发和项目部署，大部分情况下基本都是基于Linux环境进行的，所以掌握常用的命令、配置、网络和系统管理、基本的Shell编程等尽量还是要熟练一些，对后续项目实践都大有裨益。\n\n> [!Note]\n>\n>  - [**本章节置顶资源1：《Linux命令速查备忘手册.pdf》下载**](https://mp.weixin.qq.com/s/GJYVt376C_g4406ux5uw0Q)\n>  - [**本章节置顶资源2：《Linux命令行大全.pdf》下载**](https://mp.weixin.qq.com/s/3rV556_0piRNsSpDYwuZ8g)\n\n- [常用Linux操作系统大盘点](https://mp.weixin.qq.com/s/x8rwsIOzYEPXmEVXmWJ4Tg)\n- [人手一套Linux环境之：macOS版教程](https://mp.weixin.qq.com/s/WeZLtfrMdnISpX3v5WpJfA)\n- [人手一套Linux环境之：Windows版教程](https://mp.weixin.qq.com/s/onVwwEQ1DAwbvK7qS2YNxg)\n- [69张图：详细记录Ubuntu 20.04安装配置过程](https://mp.weixin.qq.com/s/vkLZ_3Jp4HdQ8PDIMYsGEw)\n- [废柴电脑拯救计划：借助Debian搭建个人专属云服务器](https://mp.weixin.qq.com/s/YpWp-b3vcAtb_jBwCM7wtg)\n- [常用Linux命令大整理](https://mp.weixin.qq.com/s/Kog6AfXYINIDwKMpJMkGFQ)\n- [面试常问的20个Linux命令](https://mp.weixin.qq.com/s/3NI4FWuOfYMJBiKqqnpqMA)\n- [Linux 桌面进化史](https://mp.weixin.qq.com/s/jQAJQo28UsY3YIxC5ci1sA)\n- [Linux迎来29岁：从个人爱好到统治世界的操作系统内核！](https://mp.weixin.qq.com/s/6-yb1N-SwHr4EaQ-fvU4Ow)\n- [漫画：Linux 内核到底长啥样？](https://mp.weixin.qq.com/s/4G6re30hxAacxmCLjP8KpQ)\n- [资源下载 → 《Linux命令速查备忘手册.pdf》](https://mp.weixin.qq.com/s/GJYVt376C_g4406ux5uw0Q)\n- [资源下载 → 《Linux命令行大全.pdf》](https://mp.weixin.qq.com/s/3rV556_0piRNsSpDYwuZ8g)\n\n---\n\n## 版本控制工具\n\n---\n\n<p align=\"left\">\n    <a href=\"https://mp.weixin.qq.com/s/ePhaYezFblgt0NgbvtWqww\" target=\"_blank\">\n        <img src=\"https://cdn.jsdelivr.net/gh/justacoder99/r2coding@master/img/gcm.1sv6s8asfzc0.jpeg\" width=\"\"/>\n    </a>\n</p>\n\n\n- [资源下载 → 豆瓣9.1分的Pro Git学习手册YYDS！](https://mp.weixin.qq.com/s/xDYSG4uDz9rgNCuk0RxLjg)\n- [科普篇：Git和SVN对比](https://mp.weixin.qq.com/s/bUYz9JwqAYH_Fn6nHPSmTg)\n- [科普篇：5分钟了解Git的前世今生](https://mp.weixin.qq.com/s/VvpjFUXd6jcatACHyFPHfg)\n- [科普篇：Git操作与常用命令集锦](https://mp.weixin.qq.com/s/swnwBiuyVmhs5iPqv3H6BQ)\n- [原理篇：图解Git中的最常用命令](https://mp.weixin.qq.com/s/DRCeDhYiwQQToKukk4RM4g)\n- [原理篇：从原理角度理解记忆Git常见命令](https://mp.weixin.qq.com/s/DQVVYOWdOPuRsy3m0fg6Xg)\n- [实践篇：从实践中彻底上手Git](https://mp.weixin.qq.com/s/sp1YUQ2vnQaIGH4tO3j1Vw)\n- [实践篇：Git分支开发](https://mp.weixin.qq.com/s/touo-rygtz0tG6y8NKw65A)\n- [实践篇：如何使用GitHub Flow给开源项目贡献代码](https://mp.weixin.qq.com/s/JMNQi3BSTmKpF9vXMEdKHw)\n- [技巧篇：一招搞定GitHub下载加速！](https://mp.weixin.qq.com/s/SYR4zvjhAH1mX9fxdp8cbA)\n- [技巧篇：如何在同一台电脑上同时使用多个Git账号](https://mp.weixin.qq.com/s/Qt4bqReZU3ydIsMtCVC0eA)\n\n---\n\n## IDE/编辑器\n\n<p align=\"left\">\n    <a href=\"https://mp.weixin.qq.com/s/ePhaYezFblgt0NgbvtWqww\" target=\"_blank\">\n        <img src=\"https://cdn.jsdelivr.net/gh/justacoder99/r2coding@master/img/ide.720nw0czwbs0.png\" width=\"\"/>\n    </a>\n</p>\n\n\n- [IDEA 2021.3升级发布](https://mp.weixin.qq.com/s/9Ar4KhQYSEP8B2mBaudWpQ)\n- [IDEA 2021.2升级体验](https://mp.weixin.qq.com/s/WQiHpAv4bjEIz3fghzamEA)\n- [IDEA 2021.1升级体验](https://mp.weixin.qq.com/s/dojfVvkrxru1eH8Pep7irw)\n- [IDEA 2020.3升级体验](https://mp.weixin.qq.com/s/FhURpMKa9oi2FrV_0woOtw)\n- [IDEA 2020.1升级体验](https://mp.weixin.qq.com/s/Ua4TYlcNntLr-x9WQirHyg)\n- [IDEA插件分享：开发必备的IDEA神级插件大分享](https://mp.weixin.qq.com/s/xMwGAL_7sGkmnFvWZroVPw)\n- [我的IDEA写代码小技巧：幸福感+效率爆棚](https://mp.weixin.qq.com/s/V2uAxmdq2e0Hl-y5GaD-Qw)\n- [为啥我的IDEA Maven依赖下载总是失败？](https://mp.weixin.qq.com/s/KNk04dv6Z-ERrHiY03qdAw)\n- [试水JetBrains官方新编程字体](https://mp.weixin.qq.com/s/RK_ygHgMjayL5-qTnlHbeg)\n- [如何使用IDEA远程调试线上代码](https://mp.weixin.qq.com/s/WLTfgkPnJYJf9PZM8d8w4Q)\n- [利用VS Code进行远程开发教程](https://mp.weixin.qq.com/s/ZDVYk188oPLugRI6oeVYIQ)\n- [VS Code常用插件+快捷键整理](https://mp.weixin.qq.com/s/_3mwj5_MNln__3SSI8BJ3Q)\n\n---\n\n## API管理/文档管理\n\n---\n\n<p align=\"left\">\n    <a href=\"https://mp.weixin.qq.com/s/ePhaYezFblgt0NgbvtWqww\" target=\"_blank\">\n        <img src=\"https://cdn.jsdelivr.net/gh/justacoder99/r2coding@master/img/apidocs.2qlxsrvx2vy0.png\" width=\"\"/>\n    </a>\n</p>\n\n\n- [科普篇：前后端都分离了，有哪些好用的API管理系统？](https://mp.weixin.qq.com/s/Ahs6fnIfFVVPOn3NZpIsNA)\n- [科普篇：几款常用的在线文档神器](https://mp.weixin.qq.com/s/G6-6gqYnTvEsWOGIoj16ZQ)\n- [一款零注解API接口文档生成工具](https://mp.weixin.qq.com/s/I_pH1V9iUu-IUayMA5oQSg)\n\n---\n\n## CI系统\n\n---\n\n<p align=\"left\">\n    <a href=\"https://mp.weixin.qq.com/s/ePhaYezFblgt0NgbvtWqww\" target=\"_blank\">\n        <img src=\"https://cdn.jsdelivr.net/gh/justacoder99/r2coding@master/img/ci.3iokn4xypxy0.png\" width=\"\"/>\n    </a>\n</p>\n\n\n- [常用CI工具大盘点](https://mp.weixin.qq.com/s/PgoXJcJX_sm5132VGQoZ1w)\n- [Jenkins Pipeline使用入门](https://mp.weixin.qq.com/s/Y2gxBmBK2HPvr1uKUUxRYA)\n- [讨论：你们公司用啥CI守护系统？](https://mp.weixin.qq.com/s/4NlLEyy2QXX5_snX4r7FSw)\n\n## 其他软件/工具/网站\n\n- [自学数据结构和算法的9大工具和网站](https://mp.weixin.qq.com/s/f9dfQQbpKjMopH6m2Gjiiw)\n- [12个常见的编程开发自学网站汇总](https://mp.weixin.qq.com/s/jFc-6QK2Mv1zHuhuFrqhog)\n- [常用Web服务器软件大盘点](https://mp.weixin.qq.com/s/J1XjIwtEKjaltqWH-0qmgw)\n- [9款最佳编程字体推荐](https://mp.weixin.qq.com/s/VB1jGIWWp4XdsLwXe-PKlQ)\n- [5款时间管理工具推荐](https://mp.weixin.qq.com/s/71Cr9UxvQc6CdmguQIh-IA)\n- [一个程序员的常用在线工具网站分享](https://mp.weixin.qq.com/s/oMAJaKDfr_bmgCVD0CX1oA)\n- [2020年度开发者工具Top 100名单](https://mp.weixin.qq.com/s/VtmcuYGt96S4750UFYKnXQ)\n- [Linux服务器上几个常用的监控小工具整理](https://mp.weixin.qq.com/s/zWIv5yBTD0Tvt8txb8znrA)\n- [效率神器PowerToys使用攻略](https://mp.weixin.qq.com/s/LUPa_uSEd91Pj08VwxsxEQ)\n- [22款适合程序员的终端生产力小工具推荐](https://mp.weixin.qq.com/s/k19ZT_yH4lzNLUYkH2GUJA)\n- [9款优秀的代码比对工具推荐](https://mp.weixin.qq.com/s/IU5mmLxflgswICEo3BCWLA)\n- [几款提升效率的软件神器](https://mp.weixin.qq.com/s/HZRz_A8bLcOTuzcezYEFZg)\n- [命令行效率神器 NuShell ！](https://mp.weixin.qq.com/s/0f6JpBiPqCY8cZ2Ich0Lmg)\n\n---\n\n---\n\n# **计算机基础**\n\n---\n\n**计算机基础是最最重要的！** 即使后面的东西都没学（或者来不及学），基础部分是肯定需要完成的，这也是后面所有应用框架学习和做项目的基石；反之，在应用框架的学习或者做项目时如果感觉吃力，那就可能非常有必要回过头再来巩固对应的基础知识。\n\n计算机基础的学习不是一蹴而就的，需要一定的反复和回炉才能做到真正的融会贯通，需要一个过程。珍惜每一次回顾和复习基础的机会，应扎实精进，步步为营。\n\n那我们口口声声所说的编程基础（计算机基础）到底指是什么呢？\n\n此处整理为**六大方面：**\n\n- 一两门你最熟悉的编程语言（不求多，但求精！）\n- 数据结构和算法\n- 计算机网络\n- 操作系统（计组）\n- 数据库/SQL\n- 设计模式\n\n---\n\n## 编程语言\n\n---\n\n语言在精不在多，切记！完全掌握了一门语言，上手其他的都不难！\n\n---\n\n<!-- tabs:start -->\n\n#### **Java**\n\n\n- **基本功趣味学习（精讲）**\n\n  - [资源下载 → Java基础核心知识大总结pdf笔记下载](https://mp.weixin.qq.com/s/jn7oraFlhRkOmiv3rh74WA)\n  - [夯实基本功之：Java程序员找对象攻虐！](https://mp.weixin.qq.com/s/aZg9SZT3DWkCkEsjlUjTtQ)\n  - [夯实基本功之：浮点数在计算机中是如何表示的](https://mp.weixin.qq.com/s/LVpvmBO0GY6TC4gwL_12Yw)\n  - [夯实基本功之：flaot和double使用时的大坑](https://mp.weixin.qq.com/s/UyYDt3HB8IO_AoSDLndhxA)\n  - [夯实基本功之：为什么要面向接口编程](https://mp.weixin.qq.com/s/Dg9LcKJBrabcnvC_6wga-A)\n  - [夯实基本功之：枚举精讲](https://mp.weixin.qq.com/s/DgOr7cat8SP0zoY7Ke3toQ)\n  - [夯实基本功之：深拷贝/浅拷贝精讲](https://mp.weixin.qq.com/s/ypCIMGxyp7AX5cxG5UJ1Hg)\n  - [夯实基本功之：序列化和反序列化精讲](https://mp.weixin.qq.com/s/0EfIUB9E-0Oh_Clwuxswuw)\n  - [夯实基本功之：函数式编程例析](https://mp.weixin.qq.com/s/yI82juBiirJ56BZfGJezLw)\n  - [夯实基本功之：如何去掉冗长的if/else代码](https://mp.weixin.qq.com/s/ufRf8DQQRYQI0q2VxG3hQg)\n  - [夯实基本功之：注解精讲](https://mp.weixin.qq.com/s/gdYysBB3aD_HmPyvEThFXw)\n  - [夯实基本功之：为什么不要用Date表示时间](https://mp.weixin.qq.com/s/v-Va_GuSUGr9HVAW84kloQ)\n  - [夯实基本功之：去除烦人的NullPointerException空指针异常](https://mp.weixin.qq.com/s/RsC7peRsFaJAEcG2eTJb0Q)\n  - [夯实基本功之：为什么要重写hashcode和equals方法](https://mp.weixin.qq.com/s/QZPezSruj0qvBUJEM4jB0g)\n  - [夯实基本功之：Object类精讲](https://mp.weixin.qq.com/s/eJy74CbzthHMgRPOA_4wEA)\n  - [夯实基本功之：List使用踩坑记录](https://mp.weixin.qq.com/s/9bw2-pkuYSKEnstb4KGsqQ)\n  - [夯实基本功之：Map使用踩坑记录](https://mp.weixin.qq.com/s/D21mcfI4cxNf4D9ukjESog)\n  - [夯实基本功之：面试必问的ConcurrentHashMap精讲](https://mp.weixin.qq.com/s/cnpfLL4TeL2oyEcHia6Bmg)\n  - [夯实基本功之：死磕Java I/O流知识](https://mp.weixin.qq.com/s/xzV0uiQ0Q2ii5I54f8DPWQ)\n  - [夯实基本功之：你一般是怎么遍历HashMap的](https://mp.weixin.qq.com/s/d93H9TwJKSnpkSBMYJ7QWQ)\n  - [夯实基本功之：try-catch的使用姿势](https://mp.weixin.qq.com/s/AbZH57nUtePC728XfCvrcw)\n  - [夯实基本功之：if和swictch性能例析](https://mp.weixin.qq.com/s/YbXBWhSlZTwY_bBqpNP2YA)\n  - [夯实基本功之：Java HashMap源码剖析](https://mp.weixin.qq.com/s/xv0GmAU8fVlS_sxWKWUWYw)\n  - [夯实基本功之：String性能提升10倍的几个用法](https://mp.weixin.qq.com/s/KRRLt0EaIwDEPCTGvqnWJA)\n  - [实践篇：Java源码编译实战](https://mp.weixin.qq.com/s/K0ehqbxrzSz07nqnqRvn5A)\n  - [面试篇：这10道基础Java面试题，虐哭了多少人](https://mp.weixin.qq.com/s/oBDrFnuk1lbfuNHkrhAC5w)\n  - [面试篇：Java基础知识面试题大集合](https://mp.weixin.qq.com/s/f-qIQGbzwHcW5Ur51rCqgg)\n  - [Java 11新特性例析](https://mp.weixin.qq.com/s/kNMQp-vjVK6Fq07xalZkng)\n  - [Java 15新特性例析](https://mp.weixin.qq.com/s/1SVao6dMMLhNoFTOvnLy8g)\n  - [科普：Java收不收费跟我们有毛关系吗？](https://mp.weixin.qq.com/s/QrWASACHkMGVop7gNe2DOA)\n\n\n- **多线程和并发**\n\n  - [资源下载 → Java多线程+并发编程知识点详细总结PDF文档下载！](https://mp.weixin.qq.com/s/EGQAuvITVJT3fZUdQG84sw)\n  - [夯实基本功之：Java并发之原子性、有序性、可见性](https://mp.weixin.qq.com/s/30__VavtpJxEojUjYglGhQ)\n  - [夯实基本功之：ThreadLocal源码剖析](https://mp.weixin.qq.com/s/ND-nUCGvXTHkEClKqN1qrQ)\n  - [夯实基本功之：Java线程池使用例析](https://mp.weixin.qq.com/s/TF04dB-i0q0-dOTqlprmYA)\n  - [夯实基本功之：彻底搞懂多线程中的volatile](https://mp.weixin.qq.com/s/fxl3od5UObRrPGe2AVvAPA)\n  - [夯实基本功之：面试必问的ConcurrentHashMap精讲](https://mp.weixin.qq.com/s/cnpfLL4TeL2oyEcHia6Bmg)\n  - [夯实基本功之：详解Java并发编程中的各种锁](https://mp.weixin.qq.com/s/Sb1tZC_6CWE57TKvJeMmkA)\n  - [Java并发和多线程基础面试题大集合](https://mp.weixin.qq.com/s/pIVf97W4DuAPNxq6zgRvsQ)\n  - [科普向：Java线程和操作系统的线程到底有啥区别？](https://mp.weixin.qq.com/s/ykQ8wkBr-jHzbcD-7HGMEQ)\n\n\n- **JVM虚拟机**\n\n  - [夯实基本功之：Java内存模型精讲](https://mp.weixin.qq.com/s/lEgHPertXyguZIkv61LlKQ)\n  - [夯实基本功之：面试必问的JVM GC机制](https://mp.weixin.qq.com/s/bHkgpznnqixDNyDKwdAbOg)\n  - [夯实基本功之：JVM垃圾回收硬核18问（附答案）](https://mp.weixin.qq.com/s/XsZUF2nBUSEJoGIA8RimJw)\n  - [夯实基本功之：搞懂JVM的三大参数类型](https://mp.weixin.qq.com/s/TlX81xJ9fnuDIOTkDxrd1Q)\n  - [夯实基本功之：了解G1垃圾收集器](https://mp.weixin.qq.com/s/KASLkkZnjGwVgm_1jbe-mA)\n  - [实践篇：JDK源码编译上手实践](https://mp.weixin.qq.com/s/MDM6w2Dw_HYc9XzZevQNeA)\n  - [实践篇：线上服务的YGC问题排查例析](https://mp.weixin.qq.com/s/-8xYoAkBUoavcSl69I0XJw)\n  - [实践篇：线上服务的FGC问题排查例析](https://mp.weixin.qq.com/s/Sjh9qFPKF250vLQGZig6nw)\n  - [面试题：Java虚拟机（JVM）面试题大集合1](https://mp.weixin.qq.com/s/T2DqgJ9-0QiRZQYUeR3c8w)\n  - [面试题：Java虚拟机（JVM）面试题大集合2](https://mp.weixin.qq.com/s/ZYoeC8yyfReEJDFSqiW8hw)\n\n\n<!-- tabs:end -->\n\n---\n\n## 数据结构+算法题\n\n---\n\n数据结构和算法题对于程序员的重要性不言而喻。参加过笔试或者面试过的小伙伴应该知道，可以说这个东西某一程度上直接决定了面试的成败，现在的互联网公司技术岗面试，数据结构+算法题基本都是必选项。\n\n除了几种基础数据结构类型得烂熟于心，基本的几大算法(或者说算法思想)也要了如指掌之外，参加求职前，不论是校招还是社招，非常有必要好好刷一刷LeetCode上的数据结构和算法题，以保持题感。\n\n---\n\n- [资源下载 → LeetCode算法刷题Golang版答案PDF文档](https://mp.weixin.qq.com/s/EaDLaLy3YjrNiSoNofwMMA)\n- [资源下载 → LeetCode算法刷题C++版答案PDF文档](https://mp.weixin.qq.com/s/qR6KTfldk41lsOj1Ghp6Og)\n- [资源下载 → LeetCode算法刷题Java版答案PDF文档](https://mp.weixin.qq.com/s/kWTJ9640mPegr5wqVE0GMg)\n- [资源下载 → 谷歌学长的数据结构+算法题代码笔记手册](https://mp.weixin.qq.com/s/gXH98f1p5cCYVETCn9w9kA)\n- [数据结构：24张图详解九大数据结构](https://mp.weixin.qq.com/s/ZVwIUN-xf9FuxOFXW8H3Nw)\n- [数据结构：哈希表详解](https://mp.weixin.qq.com/s/UanDueZi3MwlcKYGMNQPGg)\n- [数据结构：栈Stack的几种含义理解](https://mp.weixin.qq.com/s/v6rr0M9AW_kSMEtjkc-Mqw)\n- [数据结构：各种树详解](https://mp.weixin.qq.com/s/k4-RaW4ROlo6chSXsO_4AA)\n- [数据结构：跳表精讲](https://mp.weixin.qq.com/s/czkZcQL8mEqG2xeX8huqsA)\n- [数据结构：数组和链表的性能对比](https://mp.weixin.qq.com/s/iG9zNHYLkEyHF3M4RpoWKw)\n- [算法：十大经典排序算法大梳理 (动图+代码)](https://mp.weixin.qq.com/s/ekGdneZrMa23ALxt5mvKpQ)\n- [算法：排序算法趣味对比](https://mp.weixin.qq.com/s/za_MJY3-r9Gfiu3BJfej7Q)\n- [算法：二分法及其变种](https://mp.weixin.qq.com/s/1ExIav9uK4bvVnnf4t0H2Q)\n- [算法：10张图搞定KMP算法](https://mp.weixin.qq.com/s/H1ttBFuBY5n3Dbh3YaTmlw)\n- [算法：面试官最爱的字符串匹配算法精讲](https://mp.weixin.qq.com/s/FYx3acRh9JXAIb7y97G39A)\n- [算法：8大常见算法思想总结](https://mp.weixin.qq.com/s/vGjcX4nHv6QT2-qKHZM8Dw)\n- [算法：一文彻底学会递归思路解题](https://mp.weixin.qq.com/s/JLbjzCdVlJ_de2uGgBsUzw)\n- [算法：10张动图理解递归](https://mp.weixin.qq.com/s/uuNaZfzhG3KaoEtez8Migw)\n- [算法：分治算法详解](https://mp.weixin.qq.com/s/a3_bMRmTqZxMBruYsPC9-w)\n- [算法：递归算法详解](https://mp.weixin.qq.com/s/tqGKHZzSyDBgEp-oWsOztQ)\n- [算法：动态规划常见算法题例析](https://mp.weixin.qq.com/s/bGH_o1BsJtgnC2rFugtsRw)\n- [算法：搞定算法复杂度分析](https://mp.weixin.qq.com/s/mBTyBkeNHoW7-Rcbv2Exwg)\n- [算法：常用算法复杂度速查表](https://mp.weixin.qq.com/s/U6D1PNjuBAcRd5UZRr0F3w)\n- [算法：常见刷题模式套路分析](https://mp.weixin.qq.com/s/JhHPAaOInIi4lZ-UrCLdgg)\n- [算法：算法题刷题的心得和建议](https://mp.weixin.qq.com/s/Gz9-f_G6P-0tKrReAinw0A)\n- [算法：求职必刷算法题大集锦](https://mp.weixin.qq.com/s/HUS12phrTbNzAE6uFHO9lg)\n- [工具推荐：自学数据结构和算法的9大工具和网站](https://mp.weixin.qq.com/s/f9dfQQbpKjMopH6m2Gjiiw)\n\n---\n\n## 计算机网络\n\n---\n\n**为什么一定要学好计算机网络？**\n\n原因很简单，因为计算机网络中的各种协议栈是当下繁荣的互联网通信的基石，尤其建议要牢固熟练地掌握TCP/IP协议栈。\n\n---\n\n- [视频科普：计算机网络该怎么学](https://www.bilibili.com/video/BV1U4411M71p)\n- [概念科普：如何系统地学习计算机网络](https://mp.weixin.qq.com/s/v34D8xWGPW8LgENy3G2QZA)\n- [概念科普：计算机网络的89个核心概念](https://mp.weixin.qq.com/s/t8Dz-4D6BuBevZYz5Jhklg)\n- [概念科普: 为什么网络IO会被阻塞](https://mp.weixin.qq.com/s/M9DANSrACS4xUt6UM03IxA)\n- [工具科普：学网络时，可以先落实这几款利器工具](https://mp.weixin.qq.com/s/hZF2P4oQE6dsuXKWLEgDKA)\n- [探究原理：浏览器输入网址一回车，后面到底发生了什么](https://mp.weixin.qq.com/s/t2Csrl7idUXISKW54cpV1g)\n- [探究原理：你可能没有细究过的TCP/IP](https://mp.weixin.qq.com/s/AjcW7ELOTTqqdnUHpMbccQ)\n- [探究原理：一个数据包在网络中到底是怎么游走的](https://mp.weixin.qq.com/s/07zloKKMUl-RHN6tWqZIJQ)\n- [探究原理：两台计算机之间究竟是如何通信的](https://mp.weixin.qq.com/s/ZCddesfN0qISh3Rqo2jbWA)\n- [探究原理：ping命令用得这么6，原理知道不](https://mp.weixin.qq.com/s/55bbQX2-SUNe6PEI9My5fA)\n- [探究原理：一台Linux服务器最多能支撑多少个TCP连接](https://mp.weixin.qq.com/s/QuCxkSjdM_E12lXlpnhKIQ)\n- [探究原理：都说HTTP协议无状态，这里的「状态」到底指什么](https://mp.weixin.qq.com/s/EZwOUGMrGKEF_POisJKmuw)\n- [探究原理：Session/Cookie/Token](https://mp.weixin.qq.com/s/5oFKdbFWgZrwqESNTZn77w)\n- [探究原理：Cookie、Session、Token 背后的故事](https://mp.weixin.qq.com/s/oMDCi0kLpn31T00QkxfkQA)\n- [探究原理：三次握手底层深度理解](https://mp.weixin.qq.com/s/u242LSHnePBg_KbMc0ioTA)\n- [知识总结：计网IP部分知识总结](https://mp.weixin.qq.com/s/21Tk-8gxpDoH9DNWNYCWmA)\n- [知识总结：图解HTTP的前世今生](https://mp.weixin.qq.com/s/vk_QZDpJLVEXXNe1jYzd8w)\n- [知识总结：HTTP和HTTPS协议大总结](https://mp.weixin.qq.com/s/8HJ-V1BbV9wp89HS-XulXw)\n- [面试相关：2w+字的计算机网络常见面试题整理](https://mp.weixin.qq.com/s/C82YpO0gwC8LHcJSHbR81A)\n- [面试相关：GET和POST到底有什么区别](https://mp.weixin.qq.com/s/H4gbg7bfnw61jZQcapTnMw)\n- [面试相关：面试最爱问的三次握手和四次挥手问题](https://mp.weixin.qq.com/s/lFnyBaaP3f0eNcKGW5RtCg)\n- [面试相关：HTTP常见面试题集合](https://mp.weixin.qq.com/s/FJGKObVnU61ve_ioejLrtw)\n- [面试相关：计网TCP/UDP部分高频面试题集合](https://mp.weixin.qq.com/s/doxVJZ1G6187B4AOXb0JlA)\n- [面试相关：计算机网络高频12问](https://mp.weixin.qq.com/s/PIGfhMaAx9R5C4x5eJQnIw)\n- [实践系列：网络排错思路大总结](https://mp.weixin.qq.com/s/L8jmABzoI_e4dCcECenHtQ)\n- [实践系列：抓个包看一看浏览器里的HTTP请求到底是如何完成的](https://mp.weixin.qq.com/s/_fB7r53BGZRvpG9YAPRQ8A)\n\n---\n\n## 操作系统\n\n---\n\n学好操作系统有利于我们深入理解计算机底层，这样平时在遇到疑难杂症时，能够更容易看到问题的本质，并高效解决；另外操作系统里的很多优秀的设计思想、经典的架构、算法、思路也值得我们反复理解和思考，很多思想在平时的工作中也可以借鉴和运用。\n\n---\n\n- [知识总结：学编程要懂的操作系统基础](https://mp.weixin.qq.com/s/ttncekujB82g88GRx3a6lQ)\n- [知识总结：程序员必知的89个操作系统核心概念](https://mp.weixin.qq.com/s/VsQ7IpP-jnXSjJhOAzl-ew)\n- [知识总结：操作系统主要概念硬核讲解](https://mp.weixin.qq.com/s/1Rzvu9uCTef5l_8Qw3ff0A)\n- [知识总结：20张图详解操作系统内存管理部分知识点](https://mp.weixin.qq.com/s/m-AmxDVUfko7OTUsCapnPA)\n- [知识总结：这才是对进程和线程最通俗易懂的解释](https://mp.weixin.qq.com/s/FoYiPB-2LuIpnTW8gck2EQ)\n- [知识总结：操作系统并发三剑客之进程/线程/协程](https://mp.weixin.qq.com/s/Pfc31qoWfL6_uva6ePBmVA)\n- [知识总结：操作系统高并发服务模型大科普](https://mp.weixin.qq.com/s/yXMgpAhz3JhtCtutMQnXvQ)\n- [知识总结：这可能是讲死锁最通俗的一篇文章](https://mp.weixin.qq.com/s/7AHS5AlY2OaiLO4ag6zVMQ)\n- [知识总结：一举拿下网络IO模型](https://mp.weixin.qq.com/s/vwJ5T7x1Jv4wa_x7nwr54Q)\n- [知识总结：用一个故事来感受一下什么叫NIO](https://mp.weixin.qq.com/s/iFIt8t-q6hU-Ghwlj0hohw0)\n- [知识总结：多路复用、非阻塞、线程与协程](https://mp.weixin.qq.com/s/xIfxzxCfbvBvQ2c0aUuA0A)\n- [知识总结：搞懂原码/反码/补码](https://mp.weixin.qq.com/s/laP7Vxl6o40mIYBS7Cuj7A)\n- [知识总结：30张图解高并发服务模型哪家强](https://mp.weixin.qq.com/s/a2Q1DQqOHdhtGEjJ4QxPew)\n- [原理探究：新建一个空文件到底会占用多少磁盘空间？](https://mp.weixin.qq.com/s/vMvAgo9IWaLtDwxW1627YA)\n- [面试相关：2.5w字+36张图+1周时间：爆肝操作系统面试题！](https://mp.weixin.qq.com/s/lR_A3jbfRiRjchz_lyyKxw)\n- [面试相关：1.3w字的操作系统高频面试题大分享](https://mp.weixin.qq.com/s/oTEMOQY1xcG8uVceW-kLDA)\n- [面试相关：学完操作系统内存管理，能回答这8个问题吗](https://mp.weixin.qq.com/s/5f3ku77xSO8UlaOsTkOnHQ)\n\n---\n\n## 数据库/SQL\n\n- [原理探究：详解一条SQL的执行过程](https://mp.weixin.qq.com/s/OnGaqyUpB58pC2rqqzIzgw)\n- [原理探究：MySQL的数据存在磁盘上到底长什么样](https://mp.weixin.qq.com/s/36Jaj79Y8BxFoDB3Bwe7mg)\n- [原理探究：数据库索引到底是什么](https://mp.weixin.qq.com/s/WMuxdG3ymNMWWDk1XhLwZQ)\n- [原理探究：为什么MySQL索引要用B+ tree](https://mp.weixin.qq.com/s/d7Zfat2fP6IX5DMKKtEIjQ)\n- [原理探究：为什么用了索引，SQL查询还是慢](https://mp.weixin.qq.com/s/-mOOchaXx_pKI6qWhohEnA)\n- [原理探究：数据库索引的原理和使用准则](https://mp.weixin.qq.com/s/4K3borSZXt-yc5t5UJnJpQ)\n- [原理探究：为什么你写的SQL那么慢](https://mp.weixin.qq.com/s/iBnav_WPrX5vjR-NbdNeQg)\n- [原理探究：count(1)和count(*)到底哪个效率高](https://mp.weixin.qq.com/s/lyAFcnZIoyhACw78Nf9xQg)\n- [原理探究：为什么阿里规定超过三张表禁止join](https://mp.weixin.qq.com/s/7vN9Nf20NGnvLKALHw_O1Q)\n- [原理研究：什么是MySQL索引下推？](https://mp.weixin.qq.com/s/aPVs9Jrk07KsXcXdPOpx5A)\n- [原理探究：为什么大公司后台数据库都要搞分库分表？](https://mp.weixin.qq.com/s/yflzIQFiNa3tDJm7U9P8ig)\n- [原理探究：MySQL不会丢失数据的奥秘就藏在这里](https://mp.weixin.qq.com/s/QBeyJz2gVq1p7wBxcY1Gfw)\n- [原理探究：MySQL主从复制那些事儿](https://mp.weixin.qq.com/s/CCLsmKSsodtkz4iX84Cdig)\n- [实践应用：常见的SQL错误（不当）写法例析](https://mp.weixin.qq.com/s/caBYeVtZvNzbSs4q-6710Q)\n- [实践应用：SQL优化的几个角度](https://mp.weixin.qq.com/s/hl11JYMwl30FsDVZ40CLVQ)\n- [实践应用：数据库、数据表设计规范例析](https://mp.weixin.qq.com/s/hE2uKE2ffNCmeHLRn2KSTQ)\n- [实践应用：梳理开发中常用的SQL优化途径](https://mp.weixin.qq.com/s/jl0j-T6XldN6Nq-jYoQ-gA)\n- [实践应用：先更新数据库还是先更新缓存？](https://mp.weixin.qq.com/s/SPgtpfgv6bz2AfPa1CYYeQ)\n- [实践应用：百亿级数据分表后如何分页查](https://mp.weixin.qq.com/s/EplL3kBx5vOXGDhDOP8NjQ)\n- [实践应用：什么是SQL注入攻击](https://mp.weixin.qq.com/s/mnZT0Z5L6Hi6gRgEO1C9tg)\n- [实践应用：用对这些场景下的数据库索引，领导说我有点东西](https://mp.weixin.qq.com/s/4K3borSZXt-yc5t5UJnJpQ)\n- [实践应用：一个遗留项目的SQL优化实战录](https://mp.weixin.qq.com/s/MA7FVeJDMg8WDJABiBWpBA)\n- [实践应用：误删数据库后该如何恢复](https://mp.weixin.qq.com/s/UYZZkrbAetgnPUjGa71fJA)\n- [实践应用：如何科学根治慢SQL？](https://mp.weixin.qq.com/s/eQKphrkPeN_-EcWIxETz9Q)\n- [面试相关：面试官最爱的数据库索引连环问](https://mp.weixin.qq.com/s/MLvJsJuFAHHcllqvk1nVRQ)\n- [面试相关：30道保底的MySQL数据库面试题集合](https://mp.weixin.qq.com/s/aBboeqEphejICklAKLqS2Q)\n- [面试相关：数据库自增ID用完了会怎样](https://mp.weixin.qq.com/s/WqM5mhnLOqZhcdzPLeWh5w)\n- [面试相关：如何保证缓存和数据库的一致性问题？](https://mp.weixin.qq.com/s/RDOKLnG7P1j5Ehu3EyrsCQ)\n- [面试相关：面试官最爱的MySQL连环问](https://mp.weixin.qq.com/s/8ddEzG-NzzFD35ehvbER7A)\n- [面试相关：如何实现丝滑的数据库扩容](https://mp.weixin.qq.com/s/1VCC3i6ZCk7sb9kVRZ1czQ)\n\n---\n\n## 设计模式\n\n  - [资源下载 → 23种设计模式学习笔记PDF文档](https://mp.weixin.qq.com/s/miV4SH1Eb_FMogQ2XYvPuA)\n  - [单例模式详解](https://mp.weixin.qq.com/s/dXUgiMacKjwTBwX16cXNBA)\n  - [工厂模式讲解, 引入Spring IOC](https://mp.weixin.qq.com/s/8TfJ1uhMiKHnTmlF9D0L2Q)\n  - [什么是动态代理模式](https://mp.weixin.qq.com/s/GT1-yrxJ5KF0xeMydbJDCQ)\n  - [经典面试题：Spring用到了哪些设计模式](https://mp.weixin.qq.com/s/ZcKqGT2Sn4wVScExSF9Alg)\n\n## 其他\n\n- [每个开发人员都应该了解一点的UML规范](https://mp.weixin.qq.com/s/7-CTSWN-VLYgPH5H2nPU8w)\n- [计算机时间到底是怎么来的](https://mp.weixin.qq.com/s/VFUg1S0ApuFzlTNYSCLkMQ)\n- [乱码问题科普：“锟斤拷”的前世今生~](https://mp.weixin.qq.com/s/kTADQtTeOWPuXsvR9HsUIg)\n- [从一个面试题看程序员的几项基本功](https://mp.weixin.qq.com/s/dVgDv1bNH8ivO0Ft0FtmZg)\n\n---\n\n# **应用框架和工具**\n\n---\n\n计算机基础聊完了，接下来就是应用和实践的环节了。这部分通常会涉及到一些**工具**、**编程环境**、以及**应用框架**。\n\n企业级开发不同于个人自学，出于**可复用性**、**稳定性**、**开发成本**、**开发效率**、**质量保证**等一系列因素的考量，不可能每一个功能、每一个组件都从0开始徒手造轮子，所以这时候各种应用框架和工具的出现就非常有帮助了。\n\n其实框架讲白了就是别人经过多年迭代写好的一套**工具**、**代码库**、**逻辑**、亦或是**流程**，把原本都需要从0开始手写的基本功能和组件都给封装进去，用户只要符合框架约定的规则进行编码，或者调用框架提供的方法或者工具，就能快速拉起业务功能，创造实际经济价值。\n\n所以框架的出现从不同的角度看也是有多面性的：对于企业级开发效率提升而言肯定是有帮助的，但是对于程序员个人思考编码能力提升却未必是好事，所以多注重基础、深挖原理，提升自身竞争力还是非常有必要的。\n\n\n## Spring系列框架\n\n<!-- panels:start -->\n\n<!-- div:left-panel -->\n\n- [原理探究：Spring Boot项目究竟是怎么启动的？源码剖析](https://mp.weixin.qq.com/s/-MYQ-meSUcr-wZhfUbGq3Q)\n- [原理探究：SpringBoot中@SpringBootApplication注解探秘](https://mp.weixin.qq.com/s/NqG7GzsPhwI76h3nujTCgQ)\n- [原理探究：Spring @Autowired注解详解](https://mp.weixin.qq.com/s/uYNpoxcZ22goiev3uSus2w)\n- [原理探究：Spring @Value注解详解](https://mp.weixin.qq.com/s/LGYSChfDLKuCQVMYGi0Omg)\n- [原理探究：Spring框架是如何解决循环依赖问题的](https://mp.weixin.qq.com/s/m2DrtDxBzShtNF2Uk6zSAg)\n- [原理探究：Spring中竟然有12种定义Bean的方法](https://mp.weixin.qq.com/s/YZT7NURQsNBSoSNsWBciQg)\n- [原理探究：Spring的Controller究竟是单例还是多例，如何保证并发安全](https://mp.weixin.qq.com/s/PNmlpv786kgk5Pyhr5XSsw)\n- [原理探究：为什么Spring的Bean默认是单例的](https://mp.weixin.qq.com/s/uQxxGpJJo4XfkLfHHp8nHw)\n- [原理探究：单点登录(SSO)原理和实现](https://mp.weixin.qq.com/s/8brVERYV-XMIGB0Qly_mOg)\n- [原理探究：面试常问的Spring IoC原理解析](https://mp.weixin.qq.com/s/0zRks2Cz36S8N70Uonb0OA)\n- [原理探究：了解这些，就可以在Spring启动时为所欲为了](https://mp.weixin.qq.com/s/yXKPNB2dB99K_9gOWw6UHg)\n- [实践应用：Spring Boot日志框架实践](https://mp.weixin.qq.com/s/uVqkLkkxot-zsoVPo1ri1A)\n- [实践应用：利用神器BTrace追踪线上Spring Boot应用运行时信息](https://mp.weixin.qq.com/s/NH7ck79I3U0bJTEv37aECw)\n- [实践应用：Spring Boot项目集成全局唯一ID生成器UidGenerator](https://mp.weixin.qq.com/s/GGeavPrGAzF1YOxCSk3YrQ)\n- [实践应用：Spring Boot Admin2.0开箱体验](https://mp.weixin.qq.com/s/jdV8X_R9eeZRus5bfoSNNg)\n- [实践应用：Spring Boot项目传参校验最佳实践](https://mp.weixin.qq.com/s/WQ-2fPOxk0GvSHiRR5-kQw)\n- [实践应用：Spring Boot项目优雅传参方式讨论与实践](https://mp.weixin.qq.com/s/AdtUX9davFH-C60gBypnoA)\n- [实践应用：基于Spring Security Oauth2的SSO单点登录+JWT权限控制实践](hhttps://mp.weixin.qq.com/s/ZLUOWYVsf6gDcT94X_saJg)\n- [实践应用：封装一个好用的流水号ID生成器id-spring-boot-starter](https://mp.weixin.qq.com/s/AEWjwIEjVMf_cRixiIb7-Q)\n- [实践应用：封装一个好用的elasticsearch-spring-boot-starter](https://mp.weixin.qq.com/s/V2jGlNn4EsM-_RheIk0TYg)\n- [实践应用：Spring Boot项目集成jasypt-spring-boot加密组件](https://mp.weixin.qq.com/s/CTDEFxTKdk0qxK9VNSEIqw)\n- [实践应用：基于Spring Security+JWT的权限系统设计](https://mp.weixin.qq.com/s/sMi1__Rw_s75YDaIdmTWKw)\n  <!-- div:right-panel -->\n- [实践应用：Spring Boot项目集成全局唯一ID生成器Vesta](https://mp.weixin.qq.com/s/u3ioahBPOno81dp3f2IDJA)\n- [实践应用：Spring Boot项目集成Mybatis-Plus](https://mp.weixin.qq.com/s/SeXKbp9ee-FMNKfuSqpZFw)\n- [实践应用：如何自制一个Spring Boot Starter并推到远端公服](https://mp.weixin.qq.com/s/J0UcedPhgHiTndk80CNikA)\n- [实践应用：Spring Boot项目集成Ehcache缓存](https://mp.weixin.qq.com/s/OWX-hsk1F11Bvk2PWmnzxA)\n- [实践应用：Spring Boot项目集成自然语言处理工具包HanLP](https://mp.weixin.qq.com/s/2-HdLggtBSmiyJI449cLow)\n- [实践应用：基于Spring Boot实现图片上传/加水印一把梭操作](https://mp.weixin.qq.com/s/PGFDNoNuzlOR0m-tiIQGWw)\n- [实践应用：Spring Boot项目集成EVCache缓存实践](https://mp.weixin.qq.com/s/d7do5NZeu4-yRo2RfJK7uA)\n- [实践应用：Spring Boot项目集成Guava Cache本地缓存实践](https://mp.weixin.qq.com/s/C4VBAm4N3AjvXJ303wdV5A)\n- [实践应用：Spring Boot项目集成MyBatis Generator进行数据层代码自动生成](https://mp.weixin.qq.com/s/ehe7Ub5RAYAql_oPZmerAQ)\n- [实践应用：初探Kotlin+SpringBoot联合编程](http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247484900&idx=2&sn=45df41412575afb244f75de08b6bbe7f&chksm=fdded320caa95a36e85c510a1a72951b97a579511db7bd58aba2270020434b5579b8c3ce578f&scene=21#wechat_redirect)\n- [实践应用：Spring Boot项目集成神器Lombok实践](http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247485020&idx=1&sn=3c3405807f96a597398f513c48bb094e&chksm=fdded098caa9598e6159bd7315180e149e6a789a3ee75d42b4acaaae96669504e08378eeddae&scene=21#wechat_redirect)\n- [实践应用：Spring项目集成Lombok插件的优缺点分析](https://mp.weixin.qq.com/s/7pv9TwWHzF624sVMFDypvQ)\n- [实践应用：Spring Boot应用监控实战](https://mp.weixin.qq.com/s/dt2B8Pku1dSXQuzDJYiEgQ)\n- [实践应用：Spring Boot项目部署于外置Tomcat容器](https://mp.weixin.qq.com/s/UvFWTyFUUwfRXi1ZqmZdGA)\n- [实践应用：Spring Boot热部署加持](https://mp.weixin.qq.com/s/M5Y1VInGRkx_RHJn9KWBpA)\n- [实践应用：Spring Boot高效数据聚合之道](https://mp.weixin.qq.com/s/N7hzj4IR-di_KEgOts5OBg)\n- [实践应用：Spring项目日志打印常见问题](https://mp.weixin.qq.com/s/p5LTCPgsGoEjuKL0F65PAg)\n- [面试相关：Spring面试夺命连环10连问](https://mp.weixin.qq.com/s/euzbHPpQG2BSKl93N5L1Hg)\n- [面试相关：Spring经典面试题集合](https://mp.weixin.qq.com/s/q4CajkpSUC8TCgv55VK5aQ)\n- [面试相关：Spring Boot基础面试题集合](https://mp.weixin.qq.com/s/cLh9xCDkVG0KV-uaX8PkNw)\n- [面试相关：Spring Cloud基础面试题集合](https://mp.weixin.qq.com/s/g0br3PfTmm8C_nkKbzE_ig)\n- [面试相关：说说Spring用到了哪些设计模式？](https://mp.weixin.qq.com/s/ZcKqGT2Sn4wVScExSF9Alg)\n- 内容持续更新中...\n\n\n<!-- panels:end -->\n\n<!-- panels:start -->\n\n<!-- div:left-panel -->\n\n## 前后端分离\n\n- [概念科普：到底什么是RESTful ？](https://mp.weixin.qq.com/s/um5kDYBscf5sy7FUhmP7ww)\n- [概念科普：RESTful风格的前世今生](https://mp.weixin.qq.com/s/lrFQUEITm_3zASIBR1mcQw)\n- [概念科普：为什么需要前后端分离？](https://mp.weixin.qq.com/s/Y0z-3r_Mdm-etCwa0GmQmQ)\n- [实践应用：前后端分离的接口规范，我们是如何做的？](https://mp.weixin.qq.com/s/zAOYAcR-6DEJU_s0qXe91g)\n- [实践应用：前后端分离式开发：高效协作10条准则](https://mp.weixin.qq.com/s/niYHlrCDIkA1NqPVI_VJ8w)\n- [实践应用：前后端分离后，接口联调总是甩锅怎么办？](https://mp.weixin.qq.com/s/TqSQ21nNvV5WwWDY_WItQA)\n- [实践应用：前后端分离项目接口优雅数据交互例析](https://mp.weixin.qq.com/s/B-mJjBeJy5W7s2O79Iitqg)\n- [实践应用：前后端分离实践中常遇到的跨域问题](https://mp.weixin.qq.com/s/Sjrgf3Tp3vR5zsNIiYzdpA)\n- [工具推荐：前后端都分离了，该搞个好用的API管理系统了](https://mp.weixin.qq.com/s/Ahs6fnIfFVVPOn3NZpIsNA)\n\n<!-- div:right-panel -->\n\n## 分布式/微服务\n\n- [科普篇：企业里常用的软件架构剖析](https://mp.weixin.qq.com/s/NJFJ5UrzGk0cMGL1oZe0Bg)\n- [科普篇：单体→分布式→微服务，这些年的软件架构是如何发育的](https://mp.weixin.qq.com/s/kfhCEDSUGwnNUbtGDL_rvQ)\n- [科普篇：微服务架构的全局图景分析](https://mp.weixin.qq.com/s/Iy1dguNFkU73r1FxYIvlIQ)\n- [科普篇：分布式架构负载均衡的几种方式](https://mp.weixin.qq.com/s/8CvoGCtGDvMHR91Lx89pxQ)\n- [科普篇：RPC 技术(框架) 大科普](https://mp.weixin.qq.com/s/iTnKumgre3SzrBuWf8KB6g)\n- [原理探究：什么是分布式事务](https://mp.weixin.qq.com/s/_56jq_p_nDUiBwaI2MTlmA)\n- [原理探究：Redis分布式锁保姆级无死角分析](https://mp.weixin.qq.com/s/RViDM1WHE61SDLNKzUmTAg)\n- [原理探究：如何设计一个高并发的秒杀架构？](https://mp.weixin.qq.com/s/fLLd-ml-gdo3-700iJso_A)\n- [原理探究：亿级流量网关设计思路](https://mp.weixin.qq.com/s/J0aSVry1-Ss1OTA-jQAX3w)\n- [原理探究：分布式架构的几个常见的坑](https://mp.weixin.qq.com/s/pg6lyAkgAaqSAZjiPgQTWA)\n- [原理探究：什么是异地多活架构](https://mp.weixin.qq.com/s/Uv9pAOocep2rUW5qgGFSSw)\n- [实践应用：RPC框架实践之：Apache Thrift](https://mp.weixin.qq.com/s/iCw-CHa5ITz6zoQI78Wb3w)\n- [实践应用：RPC框架实践之：Google gRPC](https://mp.weixin.qq.com/s/LdzkBUzvyjMVW7pgzkA23w)\n- [实践应用：Spring Cloud Feign的两种使用姿势](https://mp.weixin.qq.com/s/U4eustBBu9N-6B1SRsYc7w)\n- [实践应用：Spring Cloud Eureka Server高可用之：在线扩容](https://mp.weixin.qq.com/s/oMsZquaphqEJqoGt1dt9WA)\n- [实践应用：Eureka Server 开启Spring Security Basic认证](https://mp.weixin.qq.com/s/tRRwG1jnWi5r1XlbeBlv8g)\n- [实践应用：Eureka Server启用 https服务指北](https://mp.weixin.qq.com/s/EAi7F3lBQ7ZrjSjNnFkj4g)\n- [实践应用：微服务调用链追踪中心搭建](https://mp.weixin.qq.com/s/c55ejzWEU6SQBdcmTTRC1g)\n- [实践应用：利用Zipkin追踪Mysql数据库调用链](https://mp.weixin.qq.com/s/wQRBxBBXCnP0YKPvtIPRcA)\n- [实践应用：一个小团队的微服务架构改造之路](https://mp.weixin.qq.com/s/VjBiUmQNQPpSHeSVjK1C2A)\n- 内容持续更新中...\n\n\n<!-- div:left-panel -->\n\n## 容器/集群\n\n- [知识总结：常用虚拟化技术（VMware/KVM/Docker）对比](https://mp.weixin.qq.com/s/hVNMfh9nWdilXHSqvyS9ng)\n- [知识总结：Docker从入门到干活，看这一篇入门](https://mp.weixin.qq.com/s/YlcvlUQ-xkz25PuYkeEQqw)\n- [知识总结：Docker Swarm的前世今生](https://mp.weixin.qq.com/s/jf4qWaEYfn0CH5A6fG6MKw)\n- [知识总结：编写高效Dockerfile的几条准则](https://mp.weixin.qq.com/s/MDGvWKkk4npWtqo2k4tsfg)\n- [实践应用：Docker Swarm集群初探](https://my.oschina.net/hansonwang99/blog/1603378)\n- [实践应用：利用ELK搭建Docker容器化应用日志中心](https://mp.weixin.qq.com/s/sO9_TixS0XrKoCKIS9oETw)\n- [实践应用：Docker容器可视化监控中心搭建](https://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247483763&idx=1&sn=6ceb9e73540b5016dadfb212636b3855&scene=21#wechat_redirect)\n- [实践应用：Docker容器跨主机通信之直接路由方式](https://mp.weixin.qq.com/s/evxiE6nhK6_y6zLMFWHTKQ)\n- [实践应用：利用TICK搭建Docker容器可视化监控中心](https://mp.weixin.qq.com/s/-54IZbsX2nQIHaMZ1y6fTQ)\n- [实践应用：利用Kubeadm部署Kubernetes 1.13.1集群实践录](https://mp.weixin.qq.com/s/wx68Chw1XaKQ1cb57jTiOw)\n- [实践应用：利用K8S技术栈打造个人私有云（连载之：初章）](http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247483699&idx=1&sn=57b84f4ec72c8a578934cdb4225e6fe7&chksm=fdded7f7caa95ee198652c295b48b74565fd244afc4dccc0551b036c8216caab0397a1342d99&scene=21#wechat_redirect)\n- [实践应用：利用K8S技术栈打造个人私有云（连载之：K8S集群搭建）](http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247483755&idx=1&sn=92a547c579aeacf1db9a8f0e56601b52&chksm=fdded7afcaa95eb9d6aa6cf323bff1df46692fc6a6672e0a483105f091ddf9670fb06d034e2a&scene=21#wechat_redirect)\n- [实践应用：利用K8S技术栈打造个人私有云（连载之：K8S环境理解和练手）](http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247483758&idx=1&sn=629b6219a06374b2050703b9549037fa&chksm=fdded7aacaa95ebc9a3e88e839515b13109752c26c586032ae60219d2c3b24e13385e1bcd37c&scene=21#wechat_redirect)\n- [实践应用：利用K8S技术栈打造个人私有云（连载之：基础镜像制作与实验）](http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247483759&idx=1&sn=8403d42fe1769a252f9ee2997fc2f561&chksm=fdded7abcaa95ebd8cdae86f4d692f1f6e92daab74dbbd8c56c6db8fe6aa2a3616ccce1eebb1&scene=21#wechat_redirect)\n- [实践应用：利用K8S技术栈打造个人私有云（连载之：K8S资源控制）](http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247483760&idx=1&sn=d44f2c744ccdc965fb6c7e4d9efe9f92&chksm=fdded7b4caa95ea278d7363b4b4788d84914b915422a9cc98e7936c3bce0c7ce1197abfac13f&scene=21#wechat_redirect)\n- 内容持续更新中...\n\n<!-- div:right-panel -->\n\n## 缓存/MQ/中间件/服务器\n\n- [缓存：Redis字符串类型内部编码剖析](https://mp.weixin.qq.com/s/tL2HVoeEH9hnalb9-tuoXg)\n- [缓存：Redis哈希结构内存模型剖析](https://mp.weixin.qq.com/s/TdPcIMnv4iKIx3dRjei95A)\n- [缓存：15张图解：为什么Redis这么快](https://mp.weixin.qq.com/s/0R0Evh1QX5BPOQt9233vpQ)\n- [缓存：Redis面试全攻略、面试题大集合](https://mp.weixin.qq.com/s/6NobACeeKCcUy98Ikanryg)\n- [缓存：把Redis当作队列来用，真的合适吗？](https://mp.weixin.qq.com/s/aNdWL3xKtjOd_briXL6Bjg)\n- [缓存：缓存和数据库一致性问题，看这个就够了](https://mp.weixin.qq.com/s/RDOKLnG7P1j5Ehu3EyrsCQ)\n- [缓存：面试官爱问的Redis高频面试题大集合](https://mp.weixin.qq.com/s/lxMP4-Z3DzQg5fRqLs9XNA)\n- [缓存：1分钟科普：什么是缓存穿透、缓存雪崩、缓存击穿？](https://mp.weixin.qq.com/s/m9trzqE3Zd0KHC1cA3PlZQ)\n- [缓存：如何构建一个稳定的高性能Redis集群？](https://mp.weixin.qq.com/s/x1AobPWpMufNWqrBnc5sZg)\n- [缓存：轻量级memcached缓存代理twemproxy初探实践](https://mp.weixin.qq.com/s/Fgg2bNhdOTRfHIzGX86X3Q)\n- [缓存：先更新数据库还是先更新缓存](https://mp.weixin.qq.com/s/SPgtpfgv6bz2AfPa1CYYeQ)\n- [MQ：消息队列RabbitMQ快速入门上手](https://mp.weixin.qq.com/s/WMriUm27CZkiSWEt1f4lig)\n- [MQ：Kafka快速入门上手](https://mp.weixin.qq.com/s/bUNAD2fkGTD73jVLw8rDHg)\n- [MQ：从面试角度一文学完Kafka](https://mp.weixin.qq.com/s/o-rqnOH4FHeHaz0VqoHnFg)\n- [MQ：为什么Kafka用得这么多？](https://mp.weixin.qq.com/s/vC0YbMJxHqs0JfcdAxjhHg)\n- [MQ：刨根问底之Kafka到底会不会丢消息](https://mp.weixin.qq.com/s/PDvG5vSuA_NCkJ3mMUua5w)\n- [MQ：大厂面试必备之消息队列连环问](https://mp.weixin.qq.com/s/u6_WH-r1bRc4m7CUm21Tew)\n- [MQ：后端岗面试必备之Dubbo九连问](https://mp.weixin.qq.com/s/wM0Vj_YMh7881NwK-AwKSw)\n- [服务器：Nginx服务器开箱体验](https://mp.weixin.qq.com/s/mif0NmY1Ij6lapHppb6LFg)\n- [服务器：从一份配置清单详解Nginx服务器配置](https://mp.weixin.qq.com/s/099PJZE89JVNnaF0kwePDQ)\n- [服务器：为什么Nginx能轻松撑起几万并发](https://mp.weixin.qq.com/s/VR1jEhJVXCfja3Pmo_kKkw)\n- [搜索引擎：CentOS7上搭建多节点Elasticsearch集群](https://mp.weixin.qq.com/s/pdQNDMQQnXpoVKIA8JpyQQ)\n- [搜索引擎：一文上手Elasticsearch常用可视化管理工具](https://mp.weixin.qq.com/s/BE8LrpviJNXGV41bhzGFTw)\n- [搜索引擎：从一份定义文件详解ELK中Logstash插件结构](https://mp.weixin.qq.com/s/d2maG61HB2_rU56DYD2A9w)\n- [搜索引擎：Elasticsearch索引的映射配置详解](https://mp.weixin.qq.com/s/C8JTxdjeSCR22xeAiLHHGg)\n- [其他中间件：ZooKeeper面试常见十二问](https://mp.weixin.qq.com/s/ir0uurwo95hB3g__vTceJQ)\n- [其他中间件：基于代理的数据库分库分表框架Mycat实践](https://mp.weixin.qq.com/s/3L5PcA0dGlrqJ2FjM_C77Q)\n- 内容持续更新中...\n\n<!-- div:left-panel -->\n\n\n<!-- panels:end -->\n\n---\n\n---\n\n# **书籍/资料推荐**\n\n---\n\n<p align=\"left\">\n    <a href=\"https://mp.weixin.qq.com/s/ePhaYezFblgt0NgbvtWqww\" target=\"_blank\">\n        <img src=\"https://cdn.jsdelivr.net/gh/justacoder99/r2coding@master/img/bookref.32p5e3kiqri0.jpg\" width=\"\"/>\n    </a>\n</p>\n\n\n---\n\n毫无疑问的是，对于上文提到的 **「编程基础」** 部分，有大量经典的书籍值得阅读，每一本都是大师们若干年经验的汇聚，所以学好编程基础，对于我们普通人来说，看书是一个非常直接有效的方式。\n\n很多经典书看一遍可能远远不够，正所谓 **「初看懵、再看迷、三看发现有点小意思」** 讲的就是这个道理，这事急不得，而且有些东西的确需要一个反反复复的过程，有些甚至是在工作后的实践中才会遇到，所以珍惜每一次回炉重造的过程吧。\n\n---\n\n书籍资料推荐：\n\n- [Java开发：我的Java后端开发小书架](https://mp.weixin.qq.com/s/voNG467kSVfR-yjwelQhow)\n- [Java开发：一份Java程序员的珍藏书单](https://mp.weixin.qq.com/s/OislKcvk-YSFstIl2PcrbA)\n- [C/C++开发：自学C/C++书籍整理](https://www.bilibili.com/video/BV1ob411m76i)\n- [前端开发：前端开发学习资料+书籍盘点](https://mp.weixin.qq.com/s/JFmj5cMhpJ2BKFq2p4IQGw)\n- [嵌入式开发：嵌入式开发学习资料+书籍推荐](https://mp.weixin.qq.com/s/nkBsUgbuMK3ArHfFc2417w)\n- [视频：我的计算机编程书单](https://www.bilibili.com/video/BV1kJ411W7pi)\n\n互联网开源教程推荐：\n\n- [羊哥当时自学数据结构和算法的9大工具](https://mp.weixin.qq.com/s/f9dfQQbpKjMopH6m2Gjiiw)\n- [拜访了这位小哥的GitHub后，我失眠了](https://mp.weixin.qq.com/s/-Xp84QH5zQvvHaGWTJF9MA)\n- [GitHub上这份计算机自学指南火了~](https://mp.weixin.qq.com/s/C48HcLYlLbYx1O82U0mpyg)\n- [GitHub 40000星！收下这份宇宙最强「程序员生存指南」](https://mp.weixin.qq.com/s/V_Dfs44C3wtzlMGdUgY7qg)\n\n\n**编程资源汇总和下载** → [点击查看](#资源下载)\n\n编程视频教程推荐 →  [点击查看](#视频教程)\n\n---\n\n# **项目经验获得**\n\n## 自学党如何获得项目经验？\n\n[---> 点击查看](https://www.bilibili.com/video/BV1Ai4y1V7PX)\n\n<!-- panels:start -->\n\n<!-- div:left-panel -->\n\n## 个人博客/网站搭建\n\n- [手把手教你从0开始搭建自己的个人博客之：Hexo版](https://www.bilibili.com/video/BV1Yb411a7ty)\n- [手把手教你从0开始搭建自己的个人博客之：Hugo版](https://www.bilibili.com/video/BV1q4411i7gL)\n- [手把手教你从0开始搭建自己的个人博客之：Wordpress+Docker版](https://www.bilibili.com/video/BV12E41127Uj)\n- [建站神器：Hexo+Kaze+Gitee！](https://mp.weixin.qq.com/s/DrEc8FqycC15hp2X010wxQ)\n- [Win10下Hexo博客搭建教程及阿里云服务器部署实战](https://mp.weixin.qq.com/s/JTTUYJTvtdT6X2fvLUBFZg)\n\n## 开源项目\n\n- [开源协议：开源软件的许可协议，先了解一下](https://mp.weixin.qq.com/s/ojGRSWSaJutAsBC0i5_6jA)\n- [Java开源项目：看完这篇，别人的Java开源项目结构应该能看懂](https://mp.weixin.qq.com/s/5Ar5B9Ah2BdO8i9YjMQ7Qg)\n- [Java开源项目：Java领域学习和练手的开源项目分享：第一弹](https://mp.weixin.qq.com/s/PmxVlkI9LUmnqqSk0Frqeg)\n- [Java开源项目：Java领域学习和练手的开源项目分享：第二弹](https://mp.weixin.qq.com/s/y59hmDbQj1QglVj90viZqw)\n- [Java开源项目：Java领域学习和练手的开源项目分享：第三弹](https://mp.weixin.qq.com/s/jjugnXIr3G0u7i9krbmmqg)\n- [C/C++开源项目：几款适合初学者学习和练手的C/C++开源项目](https://mp.weixin.qq.com/s/bRNiqhZZXaoRwPEt8GIpLg)\n- [C/C++开源项目：几款适合进阶学习和练手的C/C++开源项目](https://mp.weixin.qq.com/s/fNgOqKlITKa4yTbULO2Atw)\n- [人工智能开源项目：AI领域几款标杆开源项目大巡礼](https://mp.weixin.qq.com/s/I9lr_SEg70OO_v-GOIUgjQ)\n- [Python开源项目：几个炫酷的Python开源项目](https://mp.weixin.qq.com/s/Fu4OMojTJK0MrZohsLOx4w)\n- [B站开源了哪些优秀的开源项目](https://mp.weixin.qq.com/s/Uq_Pf_mn6clC9XrgKclMDw)\n- [读源码的7大心得总结](https://mp.weixin.qq.com/s/eWN7I8eHGE2exrdF3xziIA)\n\n<!-- div:right-panel -->\n\n## 实际项目需求和问题例析\n\n- [实践案例：实际项目业务接口的幂等性问题](https://mp.weixin.qq.com/s/gqvgysyGcP3yr0of_GwaTw)\n- [实践案例：URL短链接服务如何设计](https://mp.weixin.qq.com/s/KPUuCU-q1SqnHzeyQeQzhw)\n- [实践案例：亿行数据超大文件如何高效导入生产数据库](https://mp.weixin.qq.com/s/A-ZwcxlkB7Groe4k4Vq1Ew)\n- [实践案例：订单系统一般怎么设计](https://mp.weixin.qq.com/s/-3g1ljoIrYWhhTHTF2RmLw)\n- [实践案例：百亿级数据分表后如何分页查](https://mp.weixin.qq.com/s/EplL3kBx5vOXGDhDOP8NjQ)\n- [实践案例：线上服务的YGC问题排查例析](https://mp.weixin.qq.com/s/-8xYoAkBUoavcSl69I0XJw)\n- [实践案例：线上服务的FGC问题排查例析](https://mp.weixin.qq.com/s/Sjh9qFPKF250vLQGZig6nw)\n- [实践案例：一个小团队的微服务架构改造之路](https://mp.weixin.qq.com/s/VjBiUmQNQPpSHeSVjK1C2A)\n- [实践案例：一个遗留项目的SQL优化实战录](https://mp.weixin.qq.com/s/MA7FVeJDMg8WDJABiBWpBA)\n- [实践案例：分布式锁使用不当导致的业务损失例析](https://mp.weixin.qq.com/s/OhkdQJ10biLOIezXc_vhkA)\n- [实践案例：定时任务的几种简单方案](https://mp.weixin.qq.com/s/0p44f213fYdtr5LPJlrfLQ)\n- [实践案例：项目常用的6种URL去重方案汇总](https://mp.weixin.qq.com/s/3zXdH2MALmWj57MWt0dImw)\n- [实践案例：分布式系统架构的几个常见的坑](https://mp.weixin.qq.com/s/pg6lyAkgAaqSAZjiPgQTWA)\n- [项目架构科普：企业里常用的软件架构剖析](https://mp.weixin.qq.com/s/NJFJ5UrzGk0cMGL1oZe0Bg)\n- [项目架构科普：单体→分布式→微服务，这些年的软件架构是如何发育的](https://mp.weixin.qq.com/s/kfhCEDSUGwnNUbtGDL_rvQ)\n- [项目架构科普：微服务架构的全局图景分析](https://mp.weixin.qq.com/s/Iy1dguNFkU73r1FxYIvlIQ)\n- [原理解析：如何设计一个高并发的秒杀架构？](https://mp.weixin.qq.com/s/fLLd-ml-gdo3-700iJso_A)\n- [原理解析：高并发系统设计的常见问题小结](https://mp.weixin.qq.com/s/ZzxmDbs08waUCtO7PeUhqw)\n- [原理解析：亿级流量网关设计思路](https://mp.weixin.qq.com/s/J0aSVry1-Ss1OTA-jQAX3w)\n- [原理解析：实际网站用户密码是如何存储的](https://mp.weixin.qq.com/s/Fd3cUDrqr0CsCl7FvZgd7Q)\n- [原理解析：死磕搜索引擎背后的故事](https://mp.weixin.qq.com/s/Q1rZYvgklC_mBqfmIEC0Dw)\n- [原理解析：用微信扫码登录的背后发生了什么](https://mp.weixin.qq.com/s/1lG-aAyVycO4zTbOqdy6BA)\n- [原理解析：扫码付款背后的原理解析](https://mp.weixin.qq.com/s/RjVLsAhiMIYzsMhXJiReNg)\n- [原理解析：收款码背后的原理剖析](https://mp.weixin.qq.com/s/1b9jBfwM9_RLkMPquqAuMw)\n- [原理解析：支付掉单背后的几个问题](https://mp.weixin.qq.com/s/Kske9ahRcIUM5XEs2ZIN3A)\n- [原理解析：手机没网却能支付成功的背后原理](https://mp.weixin.qq.com/s/VROp_0M3mz5Zhhnz0ZSmKQ)\n- [原理解析：高并发场景下，先更新缓存还是先更新数据库？](https://mp.weixin.qq.com/s/1FDb63R_OMbSJo9VOWSr3Q)\n- [原理解析：如何保证缓存和数据库的一致性问题？](https://mp.weixin.qq.com/s/RDOKLnG7P1j5Ehu3EyrsCQ)\n- [原理解析：什么是分布式事务？](https://mp.weixin.qq.com/s/_56jq_p_nDUiBwaI2MTlmA)\n- [原理解析：Redis分布式锁实践分析](https://mp.weixin.qq.com/s/RViDM1WHE61SDLNKzUmTAg)\n- [原理解析：高并发下如何保证接口的幂等性？](https://mp.weixin.qq.com/s/QgliAGeUAISQVR4VNWqdgA)\n- [原理解析：如何实现丝滑的数据库扩容](https://mp.weixin.qq.com/s/1VCC3i6ZCk7sb9kVRZ1czQ)\n- [原理解析：如何构建一个稳定的高性能Redis集群？](https://mp.weixin.qq.com/s/x1AobPWpMufNWqrBnc5sZg)\n- 内容持续更新中...\n\n\n<!-- panels:end -->\n\n---\n\n# **面试准备和求职**\n\n---\n\n该板块会持续更新各技术方向的求职面试题集合、面经、以及一些小伙伴的求职心得与经历感悟。\n\n## 简历相关\n\n- [资源下载 → 简历模板下载（word版）](https://mp.weixin.qq.com/s/-qlU2-a-vvXWOHXzKHRm6A)\n- [程序员写简历时必须注意的技术词汇拼写](https://mp.weixin.qq.com/s/q5gPSIiJqVvbI6Xa4dMXwA)\n- [国内程序员最容易发音错误的单词集合](https://mp.weixin.qq.com/s/VJsp5SzGuOCGl-mWdbtCxQ)\n\n## 工作岗位科普\n\n- [科普：学C++的以后能从事哪些岗位](https://mp.weixin.qq.com/s/LEWBkJ5wkAIIcuv98g1Yhg)\n- [科普：物联网行业的岗位、技能](https://mp.weixin.qq.com/s/AtSMfjq0GXQdVxo2o6s3-g)\n- [科普：学Linux的以后能做什么](https://mp.weixin.qq.com/s/EA_iYwpSIMQGgpCrvvVOzA)\n- 持续更新中 ...\n\n## 面试题集合\n\n<!-- panels:start -->\n\n<!-- div:left-panel -->\n\n- [C/C++：C语言/C++基础面试知识大集合](https://mp.weixin.qq.com/s/7mx58Idw1pL0MjPIFBUB1Q)\n- [C/C++：68道C语言/C++常见面试题集合](https://mp.weixin.qq.com/s/BRQ-3uvstdZPO-cnLGCVzA)\n- [Java：Java面试题硬核全梳理 ~](https://mp.weixin.qq.com/s/p1zxnGVeTDJiyjgowRIoBA)\n- [Java：10道精选Java基础面试题集合](https://mp.weixin.qq.com/s/oBDrFnuk1lbfuNHkrhAC5w)\n- [Java：Java基础知识面试题大集合](https://mp.weixin.qq.com/s/f-qIQGbzwHcW5Ur51rCqgg)\n- [Java：Java集合硬核面试50问（附答案）](https://mp.weixin.qq.com/s/si_V6J_6ZZn4Akc12mMk2g)\n- [Java：面试必问的JVM GC机制精讲](https://mp.weixin.qq.com/s/bHkgpznnqixDNyDKwdAbOg)\n- [Java：JVM虚拟机面试题大集合](https://mp.weixin.qq.com/s/T2DqgJ9-0QiRZQYUeR3c8w)\n- [Java：JVM垃圾回收硬核18问](https://mp.weixin.qq.com/s/XsZUF2nBUSEJoGIA8RimJw)\n- [Java：面试官常问的一些JVM面试题](https://mp.weixin.qq.com/s/ZYoeC8yyfReEJDFSqiW8hw)\n- [Java：Java并发和多线程基础面试题大集合](https://mp.weixin.qq.com/s/pIVf97W4DuAPNxq6zgRvsQ)\n- [Java：面试常问的ThreadLocal源码剖析](https://mp.weixin.qq.com/s/ND-nUCGvXTHkEClKqN1qrQ)\n- [Java：面试常问的线程池例析](https://mp.weixin.qq.com/s/TF04dB-i0q0-dOTqlprmYA)\n- [Java：面试常问的volatile剖析](https://mp.weixin.qq.com/s/kQ498ifh4OUEDd829JIhnQ)\n- [Java：面试必问的ConcurrentHashMap精讲](https://mp.weixin.qq.com/s/cnpfLL4TeL2oyEcHia6Bmg)\n- [Java：说说什么是Java内存模型](https://mp.weixin.qq.com/s/lEgHPertXyguZIkv61LlKQ)\n- [Java：浮点数精度问题面试例析](https://mp.weixin.qq.com/s/VXRRMabz_fvwnZeLWT-ybg)\n- [计网：2w+字的计算机网络常见面试题整理](https://mp.weixin.qq.com/s/C82YpO0gwC8LHcJSHbR81A)\n- [计网：面试最爱问的三次握手和四次挥手问题](https://mp.weixin.qq.com/s/lFnyBaaP3f0eNcKGW5RtCg)\n- [计网：计算机网络高频12问](https://mp.weixin.qq.com/s/PIGfhMaAx9R5C4x5eJQnIw)\n- [计网：GET和POST到底有什么区别](https://mp.weixin.qq.com/s/H4gbg7bfnw61jZQcapTnMw)\n- [计网：TCP/UDP 部分高频面试题大集合](https://mp.weixin.qq.com/s/doxVJZ1G6187B4AOXb0JlA)\n- [计网：HTTP常见面试题集合](https://mp.weixin.qq.com/s/FJGKObVnU61ve_ioejLrtw)\n- [计网：浏览器输入网址并回车，后面到底发生了什么](https://mp.weixin.qq.com/s/t2Csrl7idUXISKW54cpV1g)\n- [计网：都说HTTP协议是无状态的，这里的「状态」到底指什么？](https://mp.weixin.qq.com/s/EZwOUGMrGKEF_POisJKmuw)\n- [操作系统：操作系统面试题集合](https://mp.weixin.qq.com/s/lR_A3jbfRiRjchz_lyyKxw)\n- [操作系统：内存管理部分8个常见面试题汇总](https://mp.weixin.qq.com/s/5f3ku77xSO8UlaOsTkOnHQ)\n- [操作系统：操作系统面试题大分享](https://mp.weixin.qq.com/s/oTEMOQY1xcG8uVceW-kLDA)\n- [操作系统：面试常问的20个Linux命令](https://mp.weixin.qq.com/s/3NI4FWuOfYMJBiKqqnpqMA)\n- [应用框架：Spring夺命连环10连问](https://mp.weixin.qq.com/s/euzbHPpQG2BSKl93N5L1Hg)\n- [应用框架：Spring 经典面试题大集合](https://mp.weixin.qq.com/s/q4CajkpSUC8TCgv55VK5aQ)\n- [应用框架：Spring Boot基础面试题大集合](https://mp.weixin.qq.com/s/cLh9xCDkVG0KV-uaX8PkNw)\n- [应用框架：Spring Cloud基础面试题大集合](https://mp.weixin.qq.com/s/g0br3PfTmm8C_nkKbzE_ig)\n\n<!-- div:right-panel -->\n\n- [数据库：MySQL面试硬核25问（附答案）](https://mp.weixin.qq.com/s/vdOOVQtZhrJXsvRUjq0HqQ)\n- [数据库：先更新数据库还是先更新缓存？](https://mp.weixin.qq.com/s/SPgtpfgv6bz2AfPa1CYYeQ)\n- [数据库：如何保证缓存和数据库的一致性问题？](https://mp.weixin.qq.com/s/RDOKLnG7P1j5Ehu3EyrsCQ)\n- [数据库：面试官最爱的MySQL连环问](https://mp.weixin.qq.com/s/8ddEzG-NzzFD35ehvbER7A)\n- [数据库：如何实现丝滑的数据库扩容](https://mp.weixin.qq.com/s/1VCC3i6ZCk7sb9kVRZ1czQ)\n- [数据库：数据库索引到底是什么](https://mp.weixin.qq.com/s/WMuxdG3ymNMWWDk1XhLwZQ)\n- [数据库：为什么MySQL索引要用B+ tree](https://mp.weixin.qq.com/s/d7Zfat2fP6IX5DMKKtEIjQ)\n- [数据库：为什么用了索引，SQL查询还是慢](https://mp.weixin.qq.com/s/-mOOchaXx_pKI6qWhohEnA)\n- [数据库：慢SQL背后的原理是什么](https://mp.weixin.qq.com/s/iBnav_WPrX5vjR-NbdNeQg)\n- [数据库：30道保底的MySQL数据库面试题汇总](https://mp.weixin.qq.com/s/aBboeqEphejICklAKLqS2Q)\n- [数据库：用心整理的9道MySQL面试题](https://mp.weixin.qq.com/s/JQCtqM6aep3jtgiRL_9J5g)\n- [中间件：面试官爱问的Redis高频面试题集合](https://mp.weixin.qq.com/s/lxMP4-Z3DzQg5fRqLs9XNA)\n- [中间件：Redis面试全攻略、面试题大集合](https://mp.weixin.qq.com/s/6NobACeeKCcUy98Ikanryg)\n- [中间件：什么是缓存穿透、缓存雪崩、缓存击穿？](https://mp.weixin.qq.com/s/m9trzqE3Zd0KHC1cA3PlZQ)\n- [中间件：说说为什么Redis能这么快？](https://mp.weixin.qq.com/s/0R0Evh1QX5BPOQt9233vpQ)\n- [中间件：如何构建一个稳定的高性能Redis集群？](https://mp.weixin.qq.com/s/x1AobPWpMufNWqrBnc5sZg)\n- [中间件：把Redis当作队列来用，真的合适吗？](https://mp.weixin.qq.com/s/aNdWL3xKtjOd_briXL6Bjg)\n- [中间件：Redis分布式锁的详细分析](https://mp.weixin.qq.com/s/RViDM1WHE61SDLNKzUmTAg)\n- [中间件：ZooKeeper面试十二连问](https://mp.weixin.qq.com/s/ir0uurwo95hB3g__vTceJQ)\n- [中间件：消息队列面试连环问总结](https://mp.weixin.qq.com/s/xpSel2nsLkf3yck5edNMJQ)\n- [中间件：Kafka面试要点梳理](https://mp.weixin.qq.com/s/o-rqnOH4FHeHaz0VqoHnFg)\n- [中间件：说说你对RPC技术是怎么理解的？](https://mp.weixin.qq.com/s/iTnKumgre3SzrBuWf8KB6g)\n- [中间件：后端岗面试必备之Dubbo九连问](https://mp.weixin.qq.com/s/wM0Vj_YMh7881NwK-AwKSw)\n- [中间件：为什么Nginx能轻松撑起几万并发？](https://mp.weixin.qq.com/s/VR1jEhJVXCfja3Pmo_kKkw)\n- [系统架构：企业里常用的软件架构科普](https://mp.weixin.qq.com/s/NJFJ5UrzGk0cMGL1oZe0Bg)\n- [系统架构：单体→分布式→微服务，这些年的软件架构是怎么发展的](https://mp.weixin.qq.com/s/kfhCEDSUGwnNUbtGDL_rvQ)\n- [系统架构：如何设计一个高并发的秒杀架构？](https://mp.weixin.qq.com/s/fLLd-ml-gdo3-700iJso_A)\n- [系统架构：分布式架构的几个常见的坑](https://mp.weixin.qq.com/s/pg6lyAkgAaqSAZjiPgQTWA)\n- [系统架构：说说分布式架构负载均衡的几种方式](https://mp.weixin.qq.com/s/8CvoGCtGDvMHR91Lx89pxQ)\n- [系统架构：说说什么是分布式事务？](https://mp.weixin.qq.com/s/_56jq_p_nDUiBwaI2MTlmA)\n- [系统架构：亿级流量网关的设计思路](https://mp.weixin.qq.com/s/J0aSVry1-Ss1OTA-jQAX3w)\n- [设计模式：说说Spring用到了哪些设计模式？](https://mp.weixin.qq.com/s/ZcKqGT2Sn4wVScExSF9Alg)\n\n<!-- panels:end -->\n\n## 求职经历分享\n\n- [小伙伴经历分享：Linux后台开发该如何准备](https://mp.weixin.qq.com/s/joFBDntI9PmyVRiKPHwpRg)\n- [二本无实习上岸滴滴京东58复盘(一)](https://mp.weixin.qq.com/s/V0nRwXQlkNBnBneERZQURQ)\n- [二本无实习上岸滴滴京东58复盘(二)](https://mp.weixin.qq.com/s/BnbBQGL-S2sGdRtNh7DN1A)\n- [小伙伴面经分享(一)：深信服(含答案)](https://mp.weixin.qq.com/s/3YfKHo2lW-NC1tEA_u-mlQ)\n- [小伙伴面经分享(二)：京东(含答案)](https://mp.weixin.qq.com/s/sc-7rc6obYZNFcc1mjNPAg)\n- [一位程序媛的秋招软件开发岗面试经历](https://mp.weixin.qq.com/s/jAPYcMULqQl6AE_Vv7BZhQ)\n- [写简历→面试→谈薪：一绿向北](https://mp.weixin.qq.com/s/0RoFVAezxW8cl3bjlAHbQg)\n- [小红书后台开发岗面试经历复盘~](https://mp.weixin.qq.com/s/4L3J45Wj81yjoZIQ3ZVSog)\n- [国企和银行：面试都问些啥？如何准备？](https://mp.weixin.qq.com/s/34SdkDyMvpVmoCFEB4UF-g)\n- [招银网络（银行科技岗）面试都问了些啥？](https://mp.weixin.qq.com/s/4hP8s7TzsOv_tdQtOdCdig)\n- [准备提前批？还是去实习？还是准备秋招？](https://mp.weixin.qq.com/s/jy0g3ohLzbtD-6JeCeMVvw)\n- [7面Google，面经分享](https://mp.weixin.qq.com/s/9Fb8w2XwkXQpj8agBtdmFg)\n- [化学专业大二转码的抉择之路](https://mp.weixin.qq.com/s/j6poLkiomb80jTE7EaFVJA)\n- [拿到腾讯实习Offer的经历分享](https://mp.weixin.qq.com/s/-27fvvzBpmwwuAFANRoeIA)\n- [怎么准备国企和银行？](https://mp.weixin.qq.com/s/YP4qafQ8gPbB7W0CkfACug)\n- [去银行当程序员是一种什么体验](https://mp.weixin.qq.com/s/u_jIpGfmH4BHYS7hIlQk9w)\n\n\n## 城市/公司选择\n\n- [一二线城市知名IT互联网公司总名单](https://mp.weixin.qq.com/s/VFocc914mGTrDzodI-MF1A)\n- [常见互联网公司职级和薪资一览](https://mp.weixin.qq.com/s/5gtu7B05EKbPDXvhha5uNQ)\n- [常见互联网公司时薪排行榜](https://mp.weixin.qq.com/s/wvdzBTcLLaeEtCqZI6T_Qg)\n\n---\n\n- [北京有哪些知名的IT/互联网公司？](https://mp.weixin.qq.com/s/f8J0pW8Sdj9_PKO2kV3mqw)\n- [成都有哪些知名的IT/互联网公司？](https://mp.weixin.qq.com/s/UDWHt3QwsZBfZ25-pddwhQ)\n- [武汉有哪些知名的IT/互联网公司？](https://mp.weixin.qq.com/s/bjHmAtPrSKQCDjfr9Mu0_Q)\n- [南京有哪些知名的IT/互联网公司？](https://mp.weixin.qq.com/s/kskE2wJx_QtT6vCgsrUgIA)\n- [合肥有哪些知名的IT/互联网公司？](https://mp.weixin.qq.com/s/tBNWFJbkjkV0bEPh4t9VQg)\n- [深圳有哪些知名的IT/互联网公司？](https://mp.weixin.qq.com/s/dtJBi4QXXTrGkKTPM0y7VA)\n- [成都有哪些知名的IT/互联网公司？](https://mp.weixin.qq.com/s/t4L45znsZRmWQ7MIQQtvhg)\n- [西安有哪些知名的IT/互联网公司？](https://mp.weixin.qq.com/s/eD3tjUC4qASHH0WSWhz57Q)\n- [长沙有哪些知名的IT/互联网公司？](https://mp.weixin.qq.com/s/UQHJ-iZDvQb3RLwQsELbUQ)\n- [武汉有哪些知名的IT/互联网公司？](https://mp.weixin.qq.com/s/6dh1jbmuDqnHBoM7beTQbg)\n- [天津有哪些知名的IT/互联网公司？](https://mp.weixin.qq.com/s/Ks9XLLUh099wSHWG0OBf1g)\n- [郑州有哪些知名的IT/互联网公司？](https://mp.weixin.qq.com/s/8-uZUrG8_ziR5tKl1K8YNw)\n- [杭州有哪些知名的IT/互联网公司？](https://mp.weixin.qq.com/s/Bwu0MDQhZiaY0vj3HsEsLg)\n- [广州有哪些知名的IT/互联网公司？](https://mp.weixin.qq.com/s/s5UhdFyj9-8bqwQyZUMvVA)\n- [青岛有哪些知名的IT/互联网公司？](https://mp.weixin.qq.com/s/Miu3eC6hqJlK8fi8Qr-DtQ)\n- [上海有哪些知名的IT/互联网公司？](https://mp.weixin.qq.com/s/zYI8qW3Zfu2ySeO-PDqwZA)\n- [大连有哪些知名的IT/互联网公司？](https://mp.weixin.qq.com/s/12inr2oRTULf7NhYOBGMYw)\n- [苏州有哪些知名的IT/互联网公司？](https://mp.weixin.qq.com/s/529Zv24uToDW4xxEOFdiqw)\n\n## 其他求职相关问题\n\n- [为什么有些大公司技术却弱爆了？](https://mp.weixin.qq.com/s/QUJzl1ZG77DDnQNK0OAsHg)\n- [嵌入式行业到底有没有搞头？](https://mp.weixin.qq.com/s/iV7DMApxhEw5YL-upIowVA)\n- [找工作时，公司所说的「给期权」到底是什么东西？](https://mp.weixin.qq.com/s/9XMAvP_t0B1Ev57-ZC42yw)\n- [入职一家公司，应该选择新业务还是老业务？](https://mp.weixin.qq.com/s/cu7mDeU2q2uEG8Q0CPzDEA)\n- [采访了一位技术总监：聊了聊跳槽的心态问题](https://mp.weixin.qq.com/s/NGJc71cW2TKEONe6jhIUSg)\n- [程序员从技术→管理，要走哪些路？](https://mp.weixin.qq.com/s/4_MB3L511h7qoXNxPRdOvQ)\n\n\n---\n\n<a name=\"视频教程\"></a>\n\n# **视频教程推荐**\n\n---\n\n对于学习编程的小伙伴来说，网上有海量现成的宝贵视频学习资源可供食用。\n\n所以该板块会持续甄选和更新互联网上那些优秀的、值得反复观看的技术视频教程。\n\n---\n\n- [数据结构和算法：《郝斌 数据结构入门》](https://www.bilibili.com/video/BV11s41167h6)\n- [数据结构和算法：《数据结构-浙江大学》](https://www.bilibili.com/video/BV1JW411i731)\n- [数据结构和算法：《数据结构与算法基础（青岛大学-王卓）》](https://www.bilibili.com/video/BV1nJ411V7bd)\n- [数据结构和算法：《尚硅谷 Java数据结构与算法）》](https://www.bilibili.com/video/BV1E4411H73v)\n- [计算机网络：《计算机网络微课堂》](https://www.bilibili.com/video/BV1c4411d7jb)\n- [计算机网络：《2019 王道考研 计算机网络》](https://www.bilibili.com/video/BV19E411D78Q)\n- [计算机网络：《韩立刚 计算机网络》](https://www.bilibili.com/video/BV1gV411h7r7)\n- [计算机网络：《计算机网络（谢希仁第七版）》](https://www.bilibili.com/video/BV1H3411y7q6)\n- [操作系统：《2020 南京大学  操作系统：设计与实现 (蒋炎岩) 》](https://www.bilibili.com/video/BV1N741177F5)\n- [操作系统：《操作系统（哈工大李治军老师）》](https://www.bilibili.com/video/BV1d4411v7u7)\n- [计算机组成原理：《计算机组成原理（哈工大刘宏伟）》](https://www.bilibili.com/video/BV1t4411e7LH)\n- [编译原理：《编译原理（哈工大）》](https://www.bilibili.com/video/BV1zW411t7YE)\n- 更多的视频教程资源会持续更新，敬请期待…\n\n\n---\n\n<a name=\"资源下载\"></a>\n\n# **资源汇总和下载**\n\n---\n\n该版块会持续更新那些优秀的编程资源，**包括但不限于：** 各种硬核的PDF笔记、软件包、技术手册、自制文档、题解解析、简历模板、面试题文档 等等。\n\n---\n\n## 编程学习资源大整理\n\n前段时间我花了大把力气，把自用的编程学习资源做了个大整理。\n\n都是纯肝货，目录如下，有需要的可以自取。\n\n![](https://cdn.jsdelivr.net/gh/justacoder99/r2coding@master/img/rescollection.2twl61h5k0s0.jpeg)\n\n- 下载链接：https://pan.baidu.com/s/1jEjcF96iVAXEXaadE1V6RQ\n- 提取码：f23d\n\n## PDF干货笔记下载\n\n- [下载 → LeetCode算法刷题Golang版答案PDF文档](https://mp.weixin.qq.com/s/EaDLaLy3YjrNiSoNofwMMA)\n- [下载 → LeetCode算法刷题C++版答案PDF文档](https://mp.weixin.qq.com/s/qR6KTfldk41lsOj1Ghp6Og)\n- [下载 → LeetCode算法刷题Java版答案PDF文档](https://mp.weixin.qq.com/s/kWTJ9640mPegr5wqVE0GMg)\n- [下载 → 谷歌学长的数据结构+算法题代码笔记手册](https://mp.weixin.qq.com/s/gXH98f1p5cCYVETCn9w9kA)\n- [下载 → 再肝两夜，写了个「服务器项目部署」实战PDF手册](https://mp.weixin.qq.com/s/JUJ6qu_ec3s1JmTxQt_V3g)\n- [下载 → 熬10天夜，肝出了这个PDF版「软件安装手册」](https://mp.weixin.qq.com/s/YNOZSQ5smo1uGE5ZttUZ_w)\n- [下载 → 熬了7天夜，羊哥肝了个Linux速查备忘手册！](https://mp.weixin.qq.com/s/GJYVt376C_g4406ux5uw0Q)\n- [下载 → Java后端开发学习路线+知识点梳理总结](https://mp.weixin.qq.com/s/x9E7ogAxFNpODXkAXCZZ3w)\n- [下载 → 前端开发学习路线+知识点梳理总结](https://mp.weixin.qq.com/s/xUKlD-Ro4x55NfANAwxJUw)\n- [下载 → 大数据开发学习路线+知识点梳理总结](https://mp.weixin.qq.com/s/vBCwU-BCsGVNpjJM__LheQ)\n- [下载 → 嵌入式开发学习路线+知识点梳理总结](https://mp.weixin.qq.com/s/nkBsUgbuMK3ArHfFc2417w)\n- [下载 → C/C++后台开发学习路线+知识点梳理总结](https://mp.weixin.qq.com/s/ac8vgjob8nDqM1Q7FGLRiA)\n- [下载 → 找工作简历模板集(word格式) ](https://mp.weixin.qq.com/s/EKBRCNr_3n0y8CCSUNPdPg)\n- [下载 → 程序员写简历时的技术词汇拼写规范PDF手册](https://mp.weixin.qq.com/s/q5gPSIiJqVvbI6Xa4dMXwA)\n- [下载 → Java基础核心知识大总结PDF文档](https://mp.weixin.qq.com/s/jn7oraFlhRkOmiv3rh74WA)\n- [下载 → C/C++常见面试题（含答案）PDF文档](https://mp.weixin.qq.com/s/BRQ-3uvstdZPO-cnLGCVzA)\n- [下载 → 设计模式学习笔记PDF文档](https://mp.weixin.qq.com/s/miV4SH1Eb_FMogQ2XYvPuA)\n- [下载 → Java多线程+并发编程知识点详细总结PDF](https://mp.weixin.qq.com/s/EGQAuvITVJT3fZUdQG84sw)\n- [下载 → 阿里Java开发手册PDF全套](https://mp.weixin.qq.com/s/J-vlX5tIuXWdglXWewK0FQ)\n\n\n## 其他资源下载\n\n- [下载 → 我的浏览器收藏夹大公开（附浏览器收藏夹书签下载）](https://mp.weixin.qq.com/s/XUHnLCbq7mDWhOc9imTVzg)\n- [下载 → 豆瓣9.1分的Pro Git学习手册YYDS！](https://mp.weixin.qq.com/s/xDYSG4uDz9rgNCuk0RxLjg)\n- [下载 → 《Linux命令行大全》.pdf手册](https://mp.weixin.qq.com/s/3rV556_0piRNsSpDYwuZ8g)\n\n---\n\n# **编码之外**\n\n---\n\n诚然，程序员应该重视代码，但眼里也不应该只有代码，很多代码之外的东西也很精彩。工作也是为了更好的生活，多看看身边的事，多关心身边的人，终究我们还是要回归到平凡的生活中\n\n**我们所热爱的，就是自己的生活！**\n\n---\n\n## 码农生活\n\n- [办公室划水？嘿嘿，这事我擅长...](https://mp.weixin.qq.com/s/zRU-n-5VOgrMqG09477RyQ)\n- [戴着耳机敲代码，我都听些啥？](https://mp.weixin.qq.com/s/7_2ibVNVMZLEYl89zT7sGQ)\n- [程序员猪队友行为大赏，你遇到过哪些？](https://mp.weixin.qq.com/s/1dJO8VJ6GaZykv33IUslkw)\n- [写给程序员看的买房+考公务员攻略](https://mp.weixin.qq.com/s/f8KtgdRx6ATbR-4RY_I_aA)\n- [毕业租房避坑攻略（含购物清单）](https://mp.weixin.qq.com/s/9fyrQPqfXx2bhbXjyYdnaw)\n- [加班严重时该如何自我提升？](https://mp.weixin.qq.com/s/oCQWlUkQ7ezgtYdono3BzA)\n- [在腾讯待了9年还离了职](https://mp.weixin.qq.com/s/SclEMeRJTqSVq-HsXaLNTQ)\n- [聊一聊自学计算机的辛酸史](https://mp.weixin.qq.com/s/AFnB33Rs7ahbjiX1CqfccQ)\n- [一个算法工程师的日常](https://mp.weixin.qq.com/s/-vBrii3kn5lNn0Bj4rzAdg)\n- [测试岗与开发岗的那些爱恨情仇](https://mp.weixin.qq.com/s/3Vf49cYXfwp6znt_SJhgsg)\n- [采访了一位技术总监：聊了聊跳槽的心态问题](https://mp.weixin.qq.com/s/NGJc71cW2TKEONe6jhIUSg)\n- [这就是架构师一天的生活，还羡慕不？](https://mp.weixin.qq.com/s/rMqSG84kNtLJ5Oiwk-S7Qw)\n- [程序员是如何玩浪漫的？](https://mp.weixin.qq.com/s/vI7EGqo7YbljRdZn2nUSMQ)\n- [假如曹操是一名程序员，你猜怎么着？](https://mp.weixin.qq.com/s/AE8dGz9asZ1de2-kvCiZwQ)\n- [周末无聊，我都逛哪些资讯类网站充电呢？](https://mp.weixin.qq.com/s/yE_fShdcgE1e1bnpHiLWyA)\n- [亲历分享：一行代码，百万人民币打水漂](https://mp.weixin.qq.com/s/dj3Z8-kgpCzzc-bQQgg__g)\n- [程序员从技术→管理，要走哪些路？](https://mp.weixin.qq.com/s/4_MB3L511h7qoXNxPRdOvQ)\n- [IT领域的2/8法则，扎心了](https://mp.weixin.qq.com/s/wd9QkLsrygO8ADW6heJg8w)\n- [周一划水必备：程序员专属GIF动图批发](https://mp.weixin.qq.com/s/Gy-Qs80rHKDJwapCmYGGEg)\n- [521坦白帖：当年念书时是怎么写情书的？](https://mp.weixin.qq.com/s/9DxslnAKgBHG85iZ8m6yYQ)\n- [一位半路转行计算机的女生](https://mp.weixin.qq.com/s/xfKoK3cQvcz-WGh50LiSBg)\n- [程序员界的孔乙己](https://mp.weixin.qq.com/s/dW81quoXMRA2ObwTzIv74g)\n- [我的大学四年收获及工作感悟](https://mp.weixin.qq.com/s/x9EEDlGNIOPOL3v_qZiiAQ)\n- [离职后，华为的哪些东西是自己最留恋的？](https://mp.weixin.qq.com/s/g5nb-yti5bv9_OCRqIjFCQ)\n- [华为最美小姐姐，被外派到墨西哥后...](https://mp.weixin.qq.com/s/Dk-9se1eFl44NdmWB_sFOQ)\n- [我在南大的七年](https://mp.weixin.qq.com/s/HrSitzmxTxWw4atXQHCa_A)\n- [垃圾领导把我的功劳全抢走了！](https://mp.weixin.qq.com/s/gknm-6k1zLY-1Cey12whSw)\n- [用随机梯度下降法来优化自己的人生！！](https://mp.weixin.qq.com/s/Rc2_rR9rJ7tx_LO_q80zuQ)\n- [美团大佬分享：写给工程师的几条精进建议](https://mp.weixin.qq.com/s/gJby-f46_hv5Wjk3Eu5iaw)\n- [我，生物专业出身，自学转到了互联网](https://mp.weixin.qq.com/s/yhY1VfuCEB0DSWYtBzMKDA)\n- [坦白贴：十一在家我都逛哪些技术网站？](https://mp.weixin.qq.com/s/jboZwMaxfs1mOdf5mxPbeA)\n- [在国外当程序员是一种什么样的体验](https://mp.weixin.qq.com/s/Qd3zNLGDYbifACJn82p1PA)\n- [很佩服的一个Google大佬，离职了](https://mp.weixin.qq.com/s/LdTDhE8sUjLZf0My1AXK2g)\n- [雷军：我的程序人生路](https://mp.weixin.qq.com/s/wxpJKTbivM63izuyHsneUw)\n\n## 读研深造\n\n- [整整5年了！老羊斗胆聊一聊和自己导师的相处](https://mp.weixin.qq.com/s/6h8GIqCdqs0pkNuwR-M7Yg)\n- [学弟跨考浙大计算机的掏心窝子分享！](https://mp.weixin.qq.com/s/cgtbhh7lrhsHXquFz7d1Ow)\n- [既然硕士毕业也去搞开发，那我还读个喵的研？](https://mp.weixin.qq.com/s/_Kt9OmaBVDDj6S7rsdC-Aw)\n- [一篇所有研究生都该读的好文：阳光温热，科研静好！](https://mp.weixin.qq.com/s/kbRlOB9hdU4j54VGF1s8oQ)\n- [如何优雅地向老师表达我这周任务没啥进展？](https://mp.weixin.qq.com/s/gbIGNXIkOpw8tQ5aIoJMtw)\n- [好不容易读个研，遇到放羊的导师怎么办？](https://mp.weixin.qq.com/s/OkxMe3Eaywx-KF9tBmjf-Q)\n- [研究生/专升本都扩招，我们没有理由放弃](https://mp.weixin.qq.com/s/MvZFLDHItPR7InzrtYRL5w)\n- [本科、硕士、博士，究竟有何区别？](https://mp.weixin.qq.com/s/Oa-1F1h6FmgodjG__2AZ_Q)\n- [一位博士的自白：毕业时想大哭一场](https://mp.weixin.qq.com/s/h6o5XpA8-M97MWILhdrO5A)\n- [一个农村博士的独白：全家为什么只有我读到了博士](https://mp.weixin.qq.com/s/EhWWnpLuhLM3_lX8Ja3qMQ)\n- [考研上岸哈工大的经历分享](https://mp.weixin.qq.com/s/hDR4FKDA4Hkc_yvXgyvI8A)\n\n## 闲聊唠嗑\n\n- [深夜闲聊：还敢无脑梭哈计算机么？](https://mp.weixin.qq.com/s/AAMmLDeZSLPkKzzGrkHd9g)\n- [那些学计算机的女生后来都怎么样了？](https://mp.weixin.qq.com/s/xweKJoGKG5NUssZioROQZw)\n- [程序员缺乏经验的7种表现](https://mp.weixin.qq.com/s/UT1muuGblZ6hFvLViti6OQ)\n- [程序员的酒后真言，都不容易](https://mp.weixin.qq.com/s/oKFHpaItmlB57gCE0sbzig)\n- [自学技术时，看书还是看视频？](https://mp.weixin.qq.com/s/1AabNVmQTyhlEnaghoyGOg)\n- [学校出身一般，该怎么办](https://mp.weixin.qq.com/s/7oOoThASit_ipIgyYzuMfA)\n- [如何写出让同事无法维护的代码？](https://mp.weixin.qq.com/s/8zP5DX79-aEuFF17MYnHtg)\n- [六成大学生认为自己毕业10年内会年入百万？](https://mp.weixin.qq.com/s/bj6LG7bq1Og8-fplcLjROA)\n- [拼多多和电网offer，要你会选哪个？](https://mp.weixin.qq.com/s/bWcoi4oEIq6_F_NSkO7lOA)\n- [C语言，50岁了！永远滴神！](https://mp.weixin.qq.com/s/Bhj0hj43jW7Ua78QENeC1g)\n- [围观Linus大佬吐槽桌面版Linux](https://mp.weixin.qq.com/s/9GoTYs9IQZ3q9saz8p8VbQ)\n\n\n## 读书写作\n\n- [羊哥今年的闲读书单！](https://mp.weixin.qq.com/s/rk0eOgioOj7yw3EjfTt5zQ)\n- [大公开：我技术文章里的动图是怎么做的？](https://mp.weixin.qq.com/s/40nmWT6DtPqcqblQuwv9Tw)\n- [坚持写博客三年了，分享几个私藏小工具](https://mp.weixin.qq.com/s/T-b7GfBoMGRuOqtp3T_HaA)\n- [白瞟七牛云作为个人博客免费图床](https://mp.weixin.qq.com/s/UU4Ha5bym4VhEDAlMZwVFQ)\n\n---\n\n- [在线画图工具ProcessOn](https://www.processon.com/)\n- [在线画图工具Draw.io](https://app.diagrams.net/)\n- [在线思维导图工具MindLine](http://www.mindline.cn/webapp)\n- [在线字数统计工具](https://www.eteste.com/)\n- [mdnice markdown排版工具](https://mdnice.com/)\n- [md2all markdown排版工具](http://md.aclickall.com/)\n- [在线代码截图工具](https://carbon.now.sh/)\n\n\n## 摸鱼时间\n\n咳咳。。。\n\n  - [0x00000001](https://www.bilibili.com/)\n  - [0x00000002](https://mo.fish/)\n  - [0x00000003](http://www.mazegenerator.net/)\n  - [0x00000004](https://duomoyu.com/)\n  - [0x00000005](http://slither.io/)\n  - [0x00000006](https://www.anyknew.com/#/)\n  - [0x00000007](http://gogoame.sumbioun.com/)\n  - [0x00000008](https://flipanim.com/)\n  - [0x00000009](https://zty.pe/)\n  - [0x0000000a](https://aidn.jp/mikutap/)\n  - [0x0000000b](http://zoomquilt.org/)\n  - [0x0000000c](https://lab.bangbang93.com/wsyw)\n  - [0x0000000d](https://lmbtfy.cn/)\n  - [0x0000000e](https://suulnnka.github.io/BullshitGenerator/index.html)\n  - [0x0000000f](https://zzkia.noddl.me/)\n  - [0x00000010](https://www.dgtle.com/)\n  - [0x00000011](https://sspai.com/)\n\n---\n\n# **联系作者**\n\n---\n\n## 关于作者\n\n- 普通开发者，热情的学习者，狂热的数码迷\n- 90后，硕士毕业于华中科技大学电信专业，现从事IT类工作\n- 目前在南京栖息，天天被业务折腾得死去活来的同时依然保有对各项技术热忱的追求\n- 参加工作以后越来越理解交流与分享的重要性，我在不停地汲取大家宝贵经验的同时，也想回馈自己的所学所感给读者\n- 本仓库是作者自学编程以来所用资源和分享内容的聚合，旨在为编程自学者提供一系列清晰的学习路线/靠谱的资源/高效的工具/务实的技术文章，方便自己也方便他人。网站内容会保持持续更新，欢迎收藏品鉴\n\n---\n\n## 心路历程\n\n- [2021-12-23：我的小网站被打挂了。](https://mp.weixin.qq.com/s/VtgMAMRoox97p6e8hyONng)\n- [2021-12-01：最近状态一般，聊聊正在做的一件小事](https://mp.weixin.qq.com/s/-yC_t4onUsopuIQdiFNq3w)\n- [2021-10-14：我坚持两年了！](https://mp.weixin.qq.com/s/GPVeZtMokBI_LwmcM5XEtA)\n- [2021-09-12：羊哥今年的书单！](https://mp.weixin.qq.com/s/rk0eOgioOj7yw3EjfTt5zQ)\n- [2021-08-29：读了7年通信最后还是转了码，羊哥你后悔吗？](https://mp.weixin.qq.com/s/gU5jhu9wcZHTgGuawpKE8g)\n- [2021-08-05：羊哥竟然翻出了当年的大学成绩单。。](https://mp.weixin.qq.com/s/yhOep3tFNpJ5-4YkDigVxw)\n- [2021-07-16：羊嫂偷偷抹了两个小时眼泪](https://mp.weixin.qq.com/s/OQ5dNnxFKXVt7rgRxxygyw)\n- [2021-06-23：还敢无脑梭哈计算机么？](https://mp.weixin.qq.com/s/AAMmLDeZSLPkKzzGrkHd9g)\n- [2021-06-17：羊家坝村首席高考志愿填报推荐官](https://mp.weixin.qq.com/s/oqopuK0mMP-FAxiDvPUeCg)\n- [2021-06-13：羊哥接到了百万大V的邀请！起飞了~](https://mp.weixin.qq.com/s/8CxIPP2Amb3HXPY7hKUWGA)\n- [2021-06-06：整整5年了！老羊斗胆聊一聊和自己导师的相处](https://mp.weixin.qq.com/s/6h8GIqCdqs0pkNuwR-M7Yg)\n- [2021-05-27：拜访了这位小哥的GitHub后，羊哥失眠了](https://mp.weixin.qq.com/s/-Xp84QH5zQvvHaGWTJF9MA)\n- [2021-05-21：521坦白帖：当年念书时是怎么写情书的？](https://mp.weixin.qq.com/s/9DxslnAKgBHG85iZ8m6yYQ)\n- [2021-05-09：卧槽，人品爆了 ...](https://mp.weixin.qq.com/s/q-fHPCz9YQzVDC4wC9P4YA)\n- [2021-05-05：生产队的驴都不敢这么过五一](https://mp.weixin.qq.com/s/sYPGrLBhojhqIkVAKXLZNg)\n- [2021-04-24：日子浑浑噩噩地过，这可能是我最开心的一周了](https://mp.weixin.qq.com/s/EfYQgGxOYUb6mLs4EBuCCw)\n- [2021-03-28：痴声痴色痴梦痴情几辈痴人](https://mp.weixin.qq.com/s/VqVFhueNtm9jN1GrW4Ebsg)\n- [2021-03-21：我和羊嫂的3平米小书房](https://mp.weixin.qq.com/s/KTD15ZQ4xdTJXt-MVWa7zg)\n- [2021-02-28：哎，我也想有一个这样的老婆啊](https://mp.weixin.qq.com/s/-Odh3JZNzJzGLGLiCf_uzw)\n- [2021-01-14：熬夜多疯狂，体检报告就有多刺激！我怂了](https://mp.weixin.qq.com/s/B9iPfm4DVAwHR1e-wWNPOg)\n- [2021-01-10：去芜湖、看房子、拿体检报告，魔幻的2021开端~](https://mp.weixin.qq.com/s/v1TiNA7XJeMp92u-YLLxjg)\n- [2020-12-13：今天的南京，很冷很冷](https://mp.weixin.qq.com/s/lfm_y0WskLrQJc55JYdu2Q)\n- [2020-10-22：和字节跳动面试官学长聊了聊人生~](https://mp.weixin.qq.com/s/WDatlUIMnADEASTzBTQZQw)\n- [2020-10-15：愿那只在天堂的猫，能够被温柔相待](https://mp.weixin.qq.com/s/ukyCJTXeD9ZoSaNK-WV0Ig)\n- [2020-10-06：老家被拆了，我的少年记忆也无处安放了](https://mp.weixin.qq.com/s/9hw1FTUGZANgcecCFUDovQ)\n- [2020-09-06：没有什么事是一顿撸串解决不了的~](https://mp.weixin.qq.com/s/QHvFgYQLvTrwAsxdWe_eAQ)\n- [2020-08-08：实不相瞒，我就是鹤岗的女婿~](https://mp.weixin.qq.com/s/kXjD-lIZpVjSroKkGHA7SQ)\n- [2020-07-18：最近厚着脸皮联系了不少同学](https://mp.weixin.qq.com/s/FlnZuzmZ9eNK1ahkvC98CA)\n- [2020-07-03：自学党/野生猿，项目经验上哪搞？](https://mp.weixin.qq.com/s/-mFZnE8-DNG6XVM-t589-Q)\n- [2020-06-21：既然硕士毕业也去搞开发，那我还读个喵的研？](https://mp.weixin.qq.com/s/_Kt9OmaBVDDj6S7rsdC-Aw)\n- [2020-06-14：我的毕业季，没有一点点仪式感](https://mp.weixin.qq.com/s/0iSzqJBj7YHkijGxbFUqCQ)\n- [2020-05-08：最近状态不咋好...](https://mp.weixin.qq.com/s/C9HuUYis2zu6ThJAjXRqpA)\n- [2020-05-01：二线城市的程序员活得好吗？](https://mp.weixin.qq.com/s/gOo8ztVLdXp3m_rvBozQpQ)\n- [2020-04-21：自学编程的八大误区！克服它！](https://mp.weixin.qq.com/s/r_vm7lA2Ul_ZFhkx60wplg)\n- [2020-04-08：我的本科回忆录：从迷茫自卑到保送华科](https://mp.weixin.qq.com/s/t9F6Z-DrybWLUxVrPTRPJw)\n- [2020-03-15：到底要不要考研？](https://mp.weixin.qq.com/s/pwInIR-h1gkPXGuu4u1aWw)\n- [2020-02-23：实不相瞒，在家远程办公15天，我有点自闭](https://mp.weixin.qq.com/s/gJBlu5gXL5vqYWG6ggisRw)\n- [2020-02-16：昨夜，我梦回武汉 . . .](https://mp.weixin.qq.com/s/lfGqTBuyRSiA9NL-8Na-xg)\n- [2020-02-02：转行的路，走起来其实有点累...](https://mp.weixin.qq.com/s/FPreCde-JHl2D6HZDGK7qg)\n- [2020-01-23：来B站一年，我活成了人的模样！](https://mp.weixin.qq.com/s/-RWgqMi2iKFUQGWbgyyo3w)\n- [2019-10-28：快30岁的我，终于赚到人生第一个10W！](https://mp.weixin.qq.com/s/i-EFuFb7yPpoOidme18EWA)\n- [2019-09-08：华科研究生学长想对导师们说的话！](https://mp.weixin.qq.com/s/TO9-kBWKFs2sV1z0Hw3qWw)\n\n---\n\n## 微信联系\n\n<a name=\"微信\"></a>  <a name=\"公众号\"></a>\n\n<p align=\"left\">\n    <a href=\"https://mp.weixin.qq.com/s/ePhaYezFblgt0NgbvtWqww\" target=\"_blank\">\n        <img src=\"https://cdn.jsdelivr.net/gh/justacoder99/r2coding@master/img/qrcode_for_gh_1537917051d0_258.nd3fymuhyts.jpeg\" width=\"\"/>\n    </a>\n</p>\n\n\n\n---\n\n# 持续更新中...\n\n[本仓库内容会持续保持更新 → 欢迎收藏品鉴！](https://mp.weixin.qq.com/s/ePhaYezFblgt0NgbvtWqww)',1,0,0,0,1,'2023-06-07 16:40:01','2023-06-07 20:02:04');
INSERT INTO `t_article` VALUES (81,1,51,'https://upload.haoxx.site/article/9a42c06ea0f36c4eacc2fb9bfc59781d.jpg','结构体字节大小计算手册','---\ntitle: 结构体字节大小计算手册\ndate: 2023-04-01\ncategory:\n - 1编程语言基础\n\nfooter: <a href=\"https://beian.miit.gov.cn/#/Integrated/index\">渝ICP备2023001651号</a>\n\n---\n\n:::tip\n结构体字节大小计算手册\n:::\n\n<!-- more -->\n\n\n结构体\n1、结构体计算字节数规则\n总结规则如下:\n\n+ 0:结构体变量的首地址能够被其最宽基本类型成员的大小所整除\n+ 1: VC6和VC71默认的内存对齐方式是#pragam pack(8)\n+ 2: 结构体中每个成员按其类型的对齐参数(通常是这个类型的大小)和指定对齐参数中较小的个对齐.\n+ 3:结构体每 个成员相对于结构体首地址的偏移量都是成员大小的整数倍.\n+ 4:结构体本身也存在着对齐要求规则，不能比它所有字段中要求最严格的那个宽松\n+ 5:结构体的总大小为结构体最宽基本类型成员大小的整数倍.且应尽量节省内存。\n+ 6: 在GCC中，对齐模数的准则是:对齐模数最大只能是4，也就是说，即使结构体中有\n  double类型，对齐模数还是4，所以对齐模数只能是1，2，4。而且在上述的规则中，第3条里，offset必须是成员大小的整数倍:\n    + (1):如果这个成员大小小于等于4则按照上述准则是可行的，\n    + (2):如果成员的大小大于4，则结构体每个成员相对于结构体首地址的偏移量只能按照是4的整数倍来进行判断是否添加填充。\n\n2、位域\n[参考链接](http://www.javashuo.com/article/p-pyhbyxqy-bh.html)\n\n1. 一个位域必须存储在同一个字节中，不能跨两个字节，故位域的长度不能大于一个字节的长度。\n2. 取地址操做符&不能应用在位域字段上;\n3. 位域字段不能是类的静态成员;\n4. 位域字段在内存中的位置是按照从低位向高位的顺序放置的;\n5. 位域的对齐\n\n>1. 若是相邻位域字段的类型相同，且其位宽之和小于类型的sizeof大小，则后面的字段将紧邻前一个字段存储，直到不能容纳为止；\n>2. 若是相邻位域字段的类型相同，但其位宽之和大于类型的sizeof大小，则后面的字段将重新的存储单元开始，其偏移量为其类型大小的整数倍；\n>3. 若是相邻的两个位域字段的类型不一样,则各个编译器的具体实现有差别,VC6采起不压缩方式,GCC和Dev-C++都采用压缩方式;\n>4. 整个结构体的总大小为最宽基本类型成员大小的整数倍。\n>5. 若是位域字段之间穿插着非位域字段，则不进行压缩；（不针对全部的编译器）\n\n1. 当要把某个成员说明成位域时,其类型只能是int,unsigned int与signed int三者之一(说明:int类型一般表明特定机器中整数的天然长度。short类型一般为16位,long类型一般为32位,int类型能够为16位或32位.各编译器能够根据硬件特性自主选择合适的类型长度.见The C Programming Language中文 P32)。\n\n',1,0,0,0,1,'2023-06-07 16:40:21','2023-06-07 19:57:02');
INSERT INTO `t_article` VALUES (82,1,51,'https://upload.haoxx.site/article/ca35f9ff3043e951a604aeee51064499.jpg','内存分区问题','---\ntitle: 内存分区问题\ndate: 2023-04-01\ncategory:\n - 1编程语言基础\n\nfooter: <a href=\"https://beian.miit.gov.cn/#/Integrated/index\">渝ICP备2023001651号</a>\n\n---\n\n:::tip\n内存分区问题\n:::\n\n<!-- more -->\n\n## 1、自动存储、静态存储和动态存储\n\n(第四章内容)4.8.5\n自动存储：用时创建，结束时销毁。一般存储在栈区。在c语言和C++11之前，auto关键字表示变量为自动存储类型，auto可缺省。在C++11新标准中，auto的意思改为了“自动推导变量类型”。\n\n静态存储：变量定义在函数外，或者用static关键字修饰时为静态存储。在c语言古老版本中，智能初始化静态数组和静态结构，在C++Release2.0及以后和ANSI C中，也可以初始化自动数组和自动结构。\n\n动态存储：用new/delete来管理堆区空间。\n\n\n（第九章内容）9.2\n\n## 2、存储持续性、作用域和链接性\n\n注意，C++使用三种不同的方案来管理存储数据，这些方案的区别就在于数据保留在内存中的时间。但是在C++11新标准中，新增加了一种“线程存储持续性”：`当前，多核处理器很常见，这些CPU可同时处理多个执行任务。这让程序能够将计算放在可并行处理的不同线程中。如果变量是使用关键字thread_local 声明的，则其生命周期与所属的线程一样长。本书不探讨并行编程。`\n\n自动存储持续性：C++中有两种存储持续性为自动的变量：auto自动变量（栈）和寄存器变量(register)。不过register也只是建议编译器将这个变量存储在cpu的寄存器中，以提高对变量的访问速度，但具体是否实现有编译器决定。\n\n静态存储持续性：C++为静态存储持续性提供了3种链接性：外部链接性（可在其他文件中访问）、内部连接性（只能在当前文件中访问）、无连接性（只能在函数或当前块中访问）。这些变量在程序执行期间一直存在。\n\n原文：\n\n```cpp\n参考：C++ Primer Plus第9.2章的内容和[CSDN](https://blog.csdn.net/EJoft/article/details/122703902)\nC++为在内存中存储数据提供了多种选择，可以选择数据保存在内存中的时间长度（存储持续性 storage duration）以及程序哪一部分可以访问数据（作用域 scope 和链接 linkage）\n\nC++中有四种不同的方案来存储数据，这些方案的区别就在于数据保留在内存中的时间\n\n**自动存储持续性(Automatic Storage Duration)：**在函数定义中声明的变量（包括函数参数）在存储持续性上是自动的。它们在程序开始执行其所属的函数或者代码块时被创建，在执行完函数或代码块时，他们使用的内存被释放。C++有两种存储持续性为自动的变量：自动变量和寄存器变量。\n静态存储持续性(Static Storage Duration)：在函数定义外定义的变量和使用关键字 static 定义的变量。它们在程序运行的运行的整个过程中都存在，C++有三种该变量。\n线程存储持续性(C++11 Thread Storage Duration)：多核处理器很常见，这些CPU能同时处理多个执行任务，这让程序能将计算放在可并行处理的不同线程中。如果变量用 thread_local 声明，那么其生命周期和所属的线程一样长。\n动态存储持续性(Dynamic Storage Duration)：用 new 运算符分配的内存将一直存在，直到使用 delete 运算符将其释放或程序结束为止，有时被称为 自由存储 (free store)或 堆 (heap)\n\n```\n\n表格总结：\n![图1](https://s3.bmp.ovh/imgs/2022/08/11/86e4ae613499dbe6.png)\n![图2](https://s3.bmp.ovh/imgs/2022/08/11/52776a151f9c0f98.png)\n\n[参考CSDN](https://blog.csdn.net/qq_40739219/article/details/121436579)\n\n## 3、C/C++内存分区\n\n局部变量：栈（即：我们常说的堆栈）\nstatic变量：数据区、data区和.bss区\n静态局部变量和全局变量：静态存储区\n常量：位于常量区，ro.data区\n\n堆：一种内存管理机制，通过malloc、calloc或realloc申请内存，free释放内存（new/delete)\n以下图片来源于《嵌入式linux与c语言内核》P92左右：\n![图1](https://s3.bmp.ovh/imgs/2022/08/24/1cddf7efc782aa82.jpg)\n![图2](https://s3.bmp.ovh/imgs/2022/08/24/2af970a315cb201d.jpg)\n![图3](https://s3.bmp.ovh/imgs/2022/08/24/cee421c0402b884a.jpg)\n\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n程序的内存五区:\n\n全局区（静态数据区），存放全局变量、静态变量。初始化的\n全局变量和静态变量在一块区域.Data段， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域.bss段。 程序结束后由系统释放。注意，显式初始化的全局变量和静态变量存放在.Data段，未显式初始化的变量存放在.bss段，并由编译器自动初始化为0。\n堆，程序员管理。\n栈，存放程序局部变量。\n文字常量区:—常量字符串就是放在这里的。 程序结束后由系统释放。还有const关键字修饰的值也是存放在此。\n代码区.text:  存放函数体的二进制代码\n\n\n\n还有一种内存四分区: 将全局（静态）变量和常量结合到一起，归结为“数据区”。 \n栈区: 系统使用\n堆区: 程序员使用\n数据区: 由全局变量/静态变量（.Data段和.bss段）和常量组成。\n代码区（.text）:存放函数的二进制代码',1,0,0,0,1,'2023-06-07 16:40:38','2023-06-07 20:01:38');
INSERT INTO `t_article` VALUES (83,1,51,'https://upload.haoxx.site/article/b6877ebd88b9d69396333c5769e07c05.jpg','综合资料（待完善待补充）','---\ntitle: 综合资料（待完善待补充）\ndate: 2022-10-30\ncategory:\n - 1编程语言基础\n\nfooter: <a href=\"https://beian.miit.gov.cn/#/Integrated/index\">渝ICP备2023001651号</a>\n\n---\n\n:::tip\n综合资料（待完善待补充）\n:::\n\n<!-- more -->\n\n\n# 待完成待补充\n\n来源，参考：[公众号](https://mp.weixin.qq.com/s/joFBDntI9PmyVRiKPHwpRg)\n\n### 1、C/C++相关\n\n+ C++虚函数原理\n+ 智能指针\n+ c语言如何实现C++对象以及私有成员\n+ C++多态实现\n+ new和malloc的区别以及底层实现原理\n+ STL中的vector怎么扩容\n+ 虚函数指针的初始化过程\n+ C++11原子变量介绍\n+ C++11特性有哪些，说用过的\n+ 怎么理解重载与重写\n+ 怎么理解C++中的static关键字\n+ vector和list 的区别\n+ C++的内存分配\n+ map与set的底层实现\n+ 类静态变量的初始化\n+ 析构函数可以是虚函数？为什么\n+ 深拷贝与浅拷贝\n+ 指针常量，常量指针的区别\n\n> c语言语法推荐书籍: 《c专家编程》《c与指针》\n>\n> C++语言语言推荐书籍:《C++ primer》《effect C++》\n>\n> C++语言stl底层原理：《STL源码剖析》\n\n\n### 2、计算机网络\n\n+ 介绍下proactor和reactor\n+ reactor的组成\n+ TIME_WAIT危害\n+ TIME_WAIT时长，为什么？\n+ IP为什么要分片\n+ 项目中说用到线程池，开多大，为什么运用线程池？\n+ select和epoll区别\n+ select什么情况返回0\n+ epoll可读情况有哪些\n+ 什么时候需要TCP四次挥手？\n+ 如何设置非阻塞\n+ 什么是零拷贝？\n+ tcp与udp的区别以及应用场景\n+ 如何设计一个可靠的udp\n+ 粘包如何解决\n+ 讲一下拥塞控制和流量控制\n+ http和https区别\n+ 是否了解中间人劫持原理\n+ http协议格式，几种方法，功能是什么\n+ chunked块了解？介绍下\n+ 有chunked的时候contentlength是什么样子\n+ 半连接在哪个阶段\n+ 三次握手四次握手详细过程，越详细越好\n+ libevent结构，内部实现\n+ tcp的可靠性体现在哪里\n+ ARP协议工作流程\n+ epoll中的ET和LT模式\n+ 介绍下滑动窗口\n+ 指针与引用的区别\n+ Accept发生在三次握手哪个阶段\n+ Udp的接收缓冲区和发送缓冲区和tcp的区别\n+ http长连接与短连接的区别\n+ udp包长度\n+ 一次url访问会经历哪些过程\n+ 数据包乱序会处理？\n+ seq为1000，发送了1000个数据，下一个seq是多少?\n+ syn如果丢了，重传多少次\n\n> tcp/ip相关推荐书籍:《tcp/详解：1》\n>\n> 熟悉使用wireshark捕包工具，加深印象可以使用python的一个库，scapy/dpkt.\n\n\n\n### 3、数据结构相关\n\n+ hash处理冲突的方法\n+ 二分查找及其变种\n+ 数组与链表的区别\n+ redis数据结构用过哪些，了解跳表？\n+ 红黑树比平衡二叉树有哪些优点\n+ 二叉树，b+树，hash，二叉查找树区别\n+ 说说红黑树的特性\n+ 各种树，排序的时间复杂度\n+ 数据库索引，事务，事务级别\n+ 不考虑事务的隔离性会出现什么问题\n+ 事务隔离级别\n+ 索引的类型\n+ AC自动机时间复杂度\n\n> 数据结构书籍《大话数据结构》\n>\n> 极客时间王大佬/谭大佬专栏\n\n### 4、操作系统相关\n\n+ 进程与线程的区别\n+ 多进程与多线程区别，应用场景\n+ volatile和原子变量的区别\n+ proc文件系统\n+ 自旋锁与普通锁的区别\n+ 虚拟内存\n+ 进程的内存分布\n+ 栈内存为什么由系统自动分配和释放\n+ 守护进程如何创建\n+ 进程间的通信方式及其区别，应用场景\n+ 死锁条件和解除\n+ 进程调度方式\n+ 对编译连接的理解\n+ 共享内存实现原理\n+ 僵尸进程是什么，如何处理\n+ 自旋锁在单cpu与多cpu下的使用\n+ 用户态与内核态\n\n> 操作系统推荐书籍:《深入理解操作系统》，《Linux内核设计与实现》\n\n\n\n### 5、Linux基础知识及应用编程\n\n+ 如何查看进程打开的文件\n+ 介绍下nm与ldd命令\n+ shell命令查内存，端口 ，io访问量，读写速率\n+ awk grep具体应用\n+ 硬链接与软连接，目录可不可以用硬链接\n+ 常见命令netstat iptable tcpdump top\n+ makefile介绍下(cmake介绍下)\n+ gdb查看堆栈中所有遍历\n+ gdb查看shared_ptr指向的内容\n+ gdb如何调试多进程多线程\n+ g++和gcc编译出来有什么区别\n+ 死锁怎么调试\n+ core文件中是什么，gdb调试core文件\n+ 如何读取一个10G文件，cat一个10g文件会发生什么\n\n> Linux基础命令推荐书籍:《Linux就该这么学》\n>\n> Linux应用编程推荐书籍：《后台开发核心技术与应用实践》《Linux多线程服务端编程》《高性能Linux服务器编程》 《linux环境编程:从应用到内核》《unix高级环境编程》\n>\n> 补充资料:gdb手册和makefile详解\n\n',1,0,0,0,1,'2023-06-07 16:40:55','2023-06-07 20:01:51');
INSERT INTO `t_article` VALUES (84,1,52,'https://upload.haoxx.site/article/27d6c34fad9892fa82032f4bfa681d4f.jpg','大话数据结构和算法','---\ntitle: 大话数据结构和算法\ndate: 2022-10-30\ncategory:\n - 2数据结构与算法\n\nfooter: <a href=\"https://beian.miit.gov.cn/#/Integrated/index\">渝ICP备2023001651号</a>\n\n---\n\n:::tip\n大话数据结构和算法\n:::\n\n<!-- more -->\n\n\n注：内容来源于书籍《大话数据结构》，部分内容来源于网络补充。\n\n数据结构：使相互之间存在的一种或多种特定关系的数据元素的集合。从不同的角度来讨论，会有不同的分类。按照逻辑结构来分，有“集合结构、线性结构、树状结构和图形结构”，按照物理结构分类，有“顺序存储结构、链式存储结构”。\n\n算法：是解决特定问题求解步骤的描述，在计算机中表现为指令的优先序列，并且每条指令表示一个或多个操作。\n\n算法的五大基本特性：输入、输出、有穷性】确定性和可行性。\n\n算法设计的要求：正确性、可读性、健壮性、时间效率高和存储量低。\n\n## 一、算法优劣的度量\n\n算法优劣的度量有事前分析法和事后统计法。一般采用事前分析法，分析算法的时间效率和空间存储量。\n\n大O记法：T(n)=O(f(n))，一般说来，随着n的增大，T(n)增长最慢的算法为最优算法。\n\n> 推导大O阶：\n>\n> + 用常数1来取代运行时间中的所有加法常数\n> + 在修改后的运行次数函数中，只保留最高阶项\n> + 如果最高阶项存在且系数不为1，就像系数调整为1\n\n1、常数阶O(1)\n\n一般顺序结构的时间复杂度是O(1)。对于分支结构而言，无论是镇还是假，执行的次数都是恒定的，不会随着n的变大而发生变化，所以单纯的分支结构（不包含在循环结构里），其时间复杂度也是O(1)。\n\n```c\nint sum=0,n=100  //执行一次\nsum=(1+n)*n/2;   //执行一次\n```\n\n2、线性阶O(n)\n\n一般循环结构都要重复执行n次，所以循环结构的时间复杂度为O(n)。一般分析算法的复杂度，主要就是分析循环结构的复杂度。\n\n```c\nint i;\nfor(i=0;i<n;i++)  //时间复杂度为n\n{\n//时间复杂度为1的代码序列\n}\n```\n\n3、对数阶O(logn)\n\n如果在循环中，对循环因子进行了处理，那这段代码的时间复杂度就会发生变化，比如：\n\n```c\nint count=1;\nwhile(count<n)\n{\ncount = count*2;\n//时间复杂度为1的代码序列\n}\n```\n\n因为每次count乘以2之后，就距离n更近了一步，也就是说有多少个2相乘后大于n，则会退出循环，有2^x^=n可以得到x=log~2~n。所以该类算法的时间复杂度为log~2~n。\n\n4、平方阶\n\n1、简单循环结构的循环嵌套，其算法时间度一般为O(n^2^)。\n2、如果外层循环改为了m，那么时间复杂度就该为了O(mxn);\n3、有些排序和搜索算法会用到这种循环结构：\n\n```c\nfor(i=0;i<n;i++)\n{\n	for(j=i;j<n;j++)\n	{\n	//时间复杂度为1的程序代码片段\n	}\n}\n```\n\n当i=0时，内循环了n次；当i=1时，内循环了n-1次，...，当i=n-1时，内循环了1次。综上，这个代码块的总运行时间为：n+(n-1)+(n-2)+...+1=(n+1)n/2=1/2(n^2^+n)。根据大O算法，推导出时间复杂度为O(n^2^)。\n\n下面这段代码相对而言更复杂：\n\n```c\nn++;   //执行次数为1\nfunction(n);//执行次数为n\nint i,j;//执行次数为1\nfor(i=0;i<n;i++)//执行次数为n*n\n{\n	function(i);\n}\nfor(i=0;i<n;i++)//执行次数为n*(n+1)/2\n{\n	for(j=i;j<n;j++)\n	{\n		//时间复杂度为1的代码\n	}\n}\nvoid function(int n)\n{\n	for(int i=0;i<n;i++)\n	{\n		//时间复杂度为1的代码\n	}\n}\n```\n\n综上，它的执行次数为1+n+1+n\\*n+n\\*(n+1)/2，时间复杂度为O(n^2^)。\n![](https://s3.bmp.ovh/imgs/2022/11/05/dda3163c8daa0b01.png)\n\n算法的空间复杂度S(n)=O(f(n))，其中n为问题的规模，f(n)为语句关于n所占存储空间的函数。\n\n一般来说，一个程序在机器上执行时，出了需要存储程序本身的指令、常数、变量和输入数据外，还需要存储对数据操作的存储单元。若输入数据所占空间只取决于问题本身，和算法无关，这样只需要分析该算法在实现时所需的辅助单元即可。若算法执行时所需的辅助空间相对于输入数据量而言是个常数，则称此算法为原地工作，空间复杂度为O(1)。\n\n\n\n## 二、线性表（顺序存储结构和链式存储结构）\n\n线性表：零个或多个数据元素的有限序列。分为顺序存储结构（数组）和链式存储结构（链表）。\n线性表的两个特点：1）有序；2）有限。有序是指，首元素无前驱结点，尾元素无后继节点，其余元素都有唯一的前驱结点和后继节点。有限是指元素个数是可以统计的。\n\n<font color=\'red\'>线性表的顺序存储结构</font>代码：\n\n```c\n#define MAXSIZE 30\ntypedef int ElemType\ntypedef struct\n{\n	ElemType data[MAXSIZE];\n	int length;\n}Sqlist;\n```\n\n这里，我们可以发现描述顺序存储结构需要三个属性：\n\n+ 存储空间的起始位置，数组data\n+ 线性表的最大存储容量；\n+ 线性表当前的长度；\n\n通过上述分析，不难看出数组、链表(单链表、双向链表、循环链表)、栈、队列和字符串都是一种线性表结构。他们都有下面几种操作(除字符串以外)\n\n```c\n1、初始化  InitList(*L)\n2、验证是否为空：ListEmpty(L)\n3、清空 ClearList(*L)\n3.2 摧毁 DestroyList(*L)\n\n4、通过序号获取元素GetElem(L,i,*e)\n5、通过元素查找序号LocateElem(L,e)\n\n6、增ListInsert(*L,i,e)\n7、删ListDelete(*L,i,*e)\n8、改Modify(*L,i,e)\n9、统计长度ListLength(L)\n\n//细节\n当然，各自的细节不一样。比如1、数组不需要清空和验证是否为空，还有通过元素获取序号、通过序号查询值也是不需要的。在插入上，单链表、循环链表、双向链表上有微小差异。2、栈只有查询栈顶元素，队列只有查询队首元素 3、注意区分线性表长度和数组长度（针对顺序存储结构），数组长度一般是指这个数据结构对象的容量，而线性表长度是指这个对象的实际存储数据的数量。4、关于字符串，它是一种特殊的线性表，他符合线性表的特征，它是线性表，他也有顺序存储和链式存储，不过其他几种线性表能关注单个元素的操作，比如查找、插入和删除，但是串中更多的查找子串、得到指定位置的子串和替换子串等操作。\n\n```\n\n\n线性表顺序存储结构的优缺点：\n\n> 优点\n>\n> + 无需为表示表中元素之间的逻辑关系而增加额外的存储空间；\n> + 可以快速地存储、查找表中任意位置的元素\n>\n> 缺点\n>\n> + 插入/删除元素的效率较低。特别是在首部插入和删除元素时，时间效率为O(n)，平均插入/删除的小绿尾O((n-1)/2)\n> + 当线性表长度变化较大时，难以确定存储空间的容量\n> + 造成存储空间的“碎片”\n\n<font color=\'red\'>线性表的链式存储结构</font>：\n\n顺序存储结构最大的缺点就是插入和删除元素的效率问题，而链式存储可以解决该问题。链式存储解除了空间上的连续性，使得元素存储自由化，就可以提高元素插入/删除的效率，但也带来了额外的空间消耗。\n\n除了其本身的信息之外，还需存储一个指向其直接后继的信息(即直接后继的存储位置)。\n\n链表的分类有很多种，可以分为有头结点、无头结点；可以分为单链表、双向链表、循环链表。双向链表是有头尾指针，可以前进也可以后退。循环链表是头尾相连的链表。双向循环链表指的是在循环链表和双向链表的基础上，将两种链表的最后一个结点指向第一个结点从而实现循环。\n\n```c\ntypedef struct Node\n{\n	int data;\n	struct Node *next;\n}List;\n```\n\n1、从查找性能上看，顺序存储结构的性能为O(1)，链式存储的性能为O(n)；2、从插入/删除的性能上看，顺序存储结构的性能为O(n)，链式存储的性能为O(1)；3、从空间性能上看，顺序存储需要预先分配空间，分配大了就浪费，分配小了会溢出，而链式存储不需要提前分配空间。\n\n<font color=\'red\'>结论</font>：情况1：若线性表需要频繁查找，很少进行插入和删除操作时，宜采用顺序存储结构。若需要频繁插入和删除时，宜采用单链表结构。举个简单的例子，游戏开发中的玩家账号信息，只有注册时需要插入，平时一般是查询操作，最好采用顺序结构。游戏装备会频繁刷新，经常读写，最好采用链式结构。\n\n情况2：如果元素总数变化较大或者不知道有多少总数时，宜采用链式结构。\n\n补充一点，散列表（Hash哈希表）：一种由数组和链表组合起来的数据结构，（也可能是数组、链表和红黑树组合起来），它兼顾数组和链表的优点，有较好的查询性能和插入/删除性能。[参考CSDN博客](https://blog.csdn.net/heyuchang666/article/details/49996237)，哈希表的结构如图所示：\n![](https://s3.bmp.ovh/imgs/2022/11/15/65762f5ec5f6d72a.png)\n\n\n数组和链表的对比：\n![](https://s3.bmp.ovh/imgs/2022/10/30/106260aed0a641e5.png)\n\n跳表：上表说过，链表的优点是可以更灵活的使用内存空间，长度可以动态变化，且插入/删除数据灵活。但是链表查询元素必须遍历链表，效率低。所以提出了一种跳表。在原链表的基础上，在新增一条或多条索引链表，加速对元素的查询。\n![](https://s3.bmp.ovh/imgs/2022/10/30/1db5cfb2d228ca2b.png)\n\n### 2.2 链表小总结\n\n```c\n//单链表插入元素\n//在p节点后插入新节点new:\nnew->next=p->next;\np->next=new;\n```\n\n普通链表、静态链表、循环链表、双向链表\n\n为了使空链表与非空链表处理 致，我们通常设一个头结点，当然 这并不是说，循环链表一定要头结点，这需要注意。\n\n普通链表，各节点之间通过指针相连，无需提前设计容量，无数据溢出风险。数据插入/删除效率高，但是遍历效率低。数组是查询效率高。对于遍历效率低的问题，可以使用循环链表解决。对于链表只能前进不能后退的问题，引入了双向链表。\n\n### 2.2.2 循环链表\n\n头尾相连的链表，为了使空链表的处理和非空链表的处理保持一致，通常要设置一个头结点。\n\n除了头结点，还需要一个指针。设置头指针还是尾指针？设置头指针：访问第一个元素，时间复杂度为O(1)，访问尾元素为O(n)。设置尾指针，访问尾元素，时间复杂度为O(1)，访问首元素为O(2)，即为`rear->next->next`（因为要跳过头结点）。\n\n有了尾指针，两个循环链表的结合也变得非常简单了，如下图所示。\n![](https://s3.bmp.ovh/imgs/2022/12/15/c7b7bf6fb88cb300.png)\n\n```c\np=rearA->next;\nrearA->next=rearB->next->next;\nq=rearB->next;\nrearB->next=p;\nfree(q);\n```\n\n### 2.2.3 双向链表\n\n双向循环链表是从单链表里面扩展出来的，所以他的很多操作都与单链表相同。比如求长度、查元素位置和通过位置查元素等。只是涉及到插入和删除的时候，需要两个指针的参与。\n\n```c\n有：p->next->prior=p=p->prior->next;\n//双向链表的插入：\n//在p节点后插入新节点e\ne->next=p->next;\ne->prior=p;\np->next->prior=e;\np->next=e;\n//双向链表的插入-2 李慧芹方法\ne->next=p->next;\ne->prior=p;\ne->next->prior=e;\ne->prior->next=e;\n//双向链表的删除  删除节点p\np->prior->next=p->next;\np->next->prior=p->prior;\nfree(p);\n\n```\n\n\n## 三、栈与队列\n\n栈是先进后出的FILO，队列是先进先出的FIFO。栈和队列都有链式结构和顺序结构的实现。虽然把栈和队列从第二章线性表中分离来讲，但是栈和队列也是一种线性表。\n\n特殊之处在于，栈和队列限制了元素的插入和删除的位置。对于该部分的重点只是在于：\n\n- [ ] 不同情况的出栈顺序，其出栈结果不同\n- [ ] 栈和队列都有链式存储和顺序存储两种结构\n- [ ] 两栈共享空间(一般是顺序存储结构)\n- [ ] 栈的应用：浏览器网页的后退功能、word的后退功能、用栈实现递归(斐波那契数列)、用栈实现计算器(包含如何将中缀运算符转换成后缀元素安抚、后缀运算符的计算规则)\n- [ ] 队列的应用：任务队列\n- [ ] 队列的顺序存储的不足(循环队列)、链式队列\n\n### 3.1 栈的顺序存储和两栈共享空间\n\n顺序存储一般使用数组实现，栈底为a[0]元素。栈顶指针top随元素增减而变化。\n\n顺序存储的弊端在于长度固定，所以容量设置小了容易溢出，设置打了容易浪费。对于浪费这种情况，可以采用“两栈共享的方法”来解决。两个栈各占数组的一端，\n\n```c\n1)当top1=-1时，栈1为空，当top2=n时，栈2位空\n2)当top1为n-1，或top2位0，又或者top+1=top2时栈满\n```\n\n事实上，使用这种数据结构的情况，一般是“当两个栈的空间需求为相反关系时，也就是一个栈增长同时另一个栈减小的情况”，比如投票、买卖股票。\n\n栈的链式存储，因为链表有头结点，栈有栈顶指针，所以索性就把这两个指针合二为一了。在（栈顶指针）头结点后插入元素。\n\n### 3.2 斐波那契数列\n\n其核心就是使用了递归。递归是自己调用自己，迭代是循环。\n递归：自己调用自己，重复运行函数，选择结构，[优}结构简单，节省代码，[缺]费时费空间]\n迭代：循环重复运行代码，循环结构，[优]占内存小  [缺]\n这是斐波那契数列的公式：\n$$\nF(n)=\\left\\{\\begin{array}{l}\n0, \\text { 当 } n=0 \\\\\n1, \\text { 当 } n=1 \\\\\nF(n-1)+F(n-2), \\text { 当 } n>1\n\\end{array}\\right.\n$$\n\n### 3.3 用栈实现计算器\n\n1、 用后缀运算符来计算\n\n后缀运算符又称逆波兰表示法， 它的特点是所有符号都是在要运算的数字后面出现，例如：\n\n```c\n前缀模式：9+(3-1)*3+10/2\n后缀模式：9 3 1 - * 3 + 10 2 / +\n```\n\n计算机喜欢用后缀模式来处理运算符，是因为栈的结构。1）左括号进，直到遇到右括号才弹出。2）遇到数字进栈，遇到运算符取两个数字进行运算。注意，后缀运算符中只有数字和运算符了。\n\n还有一点是，在栈中数字从上往下依次为1和3，然后遇到减号，则1先弹出做减数，然后3后弹出做被减数，所以为：`3-1`。\n\n2、中缀转后缀表达式\n\n规则：从左到右遍历中缀表达式的每个数字和符号，若是数字就输出，即成为后缀表达式的一部分；若是符号，则判断其与楼顶符号的优先级，是右括号或优先级不高于栈顶符号(乘除优先加减)则栈顶元素依次弹出并输出，并将当前符号进栈，一直到最终输出后缀表达式为止。\n\n即：1）数字直接输出，2）符号考虑情况，要不要进栈。2.1 左括号直接进，2.2 右括号直接出，并且把左右括号之间的东西一起弹出  2.3 如果是运算符之间，要比较大小。外头的运算符大，不弹，直接进栈。2.4 否则，先把栈里面的小的或相同的弹出并输出，然后再把栈外新元素（运算符）入栈。\n\n### 顺序存储队列的不足\n\n1、一方面，顺序存储的通病就是在不知道最大长度的情况下，容量不好设置。设置大了浪费，小了就溢出。\n\n2、另一方面，插入和删除元素问题。更改一个，整个数组就要跟着动。影响效率。\n\n解决方案1：新增一个队头和队尾的指针，插入和删除只是这两指针在动。新问题：“假溢出”：数组前半部分空着，但是数据都在后面存着，数据插入时会出现溢出错误。\n\n解决方案2：循环队列\n\n特点就是头尾相连。\n\n问题又来了：如何判断队列是否为空？\n\n在前面带两个指针的队列，队头指向首元素，队尾指向尾元素的下一个。这样，队列为空是就是front=rear。那这里的循环队列呢？front=rear有可能是空，有可能是满队列。\n\n方案1：设置标志量flag。当队列为空时，flag=0,队列满时，flag=1\n方案2：保留了个元素空间。当front=rear时，就是表示队列为空。当(rear+1)%QueueSize=front时，队列为满。\n\n计算队列长度的公式：(rear-front+QueueSize)%QueueSize\n\n\n## 四、字符串\n\n字符串操作常见的有：生成字符串、复制字符串、清空字符串、字符串是否为空？、字符串长度、字符串比较和字符串拼接、子串、子串索引、替换子串、插入子串、删除子串\n\n其中的核心操作就是字符串的比较。这里一共提到了三种匹配操作：\n1）朴素的模式匹配方法  \n2）KMP模式匹配算法\n3）改进的KMP模式匹配算法\n\n朴素的模式匹配方法：\n\n通过循环，将主串的每一个字符和测试串T的每个元素进行比较。采用双层循环结构。优点是想法简单，容易实现，缺点是算法效率低。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## 五、树\n\n> 完全二叉树：除了最后一层节点，其余层的节点数已经达到了最大值，且最后一层的节点是按照从左到右的顺序排列的。\n>\n> 满二叉树：除了最后一层，其余层的节点都有两个子节点。\n>\n> 二叉排序树：左节点的值一定小于根节点；右节点的值一定大于根节点。 \n>\n> 平衡二叉树：又称AVL树，它是一颗二叉平衡树，且具有以下性质：它是一颗空树或左右两个子树的高度差绝对值不超过1，并且左右两个子树都是一颗平衡二叉树。\n>\n> > 说明：平衡因子：左子树高度 - 右子树高度    \n>\n> 红黑树：一种自平衡二叉查找树，是一种特化的平衡二叉树。\n\n![](https://s3.bmp.ovh/imgs/2022/10/30/ad75abd7cfbc22ba.png)\n\n**二叉排序树**：\n\n二叉排序树：是一棵空树，或者：若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；它的左、右子树也分别为二叉排序树。\n\n二叉排序树意味着二叉树中的数据是排好序的，顺序为左结点<根节点<右结点，这表明二叉排序树的中序遍历结果是有序的。\n\n**平衡二叉树**：\n平衡二叉树的产生是为了解决二叉排序树在插入时发生线性排列的现象。由于二叉排序树本身为有序，当插入一个有序程度十分高的序列时，生成的二叉排序树会持续在某个方向的字数上插入数据，导致最终的二叉排序树会退化为链表，从而使得二叉树的查询和插入效率恶化。\n![](https://s3.bmp.ovh/imgs/2022/10/30/a88628b6aef2dec2.png)\n\n平衡二叉树的出现能够解决上述问题，但是在构造平衡二叉树时，却需要采用不同的调整方式，使得二叉树在插入数据后保持平衡。主要的四种调整方式有LL（左旋）、RR（右旋）、LR（先左旋再右旋）、RL（先右旋再左旋）。这里先给大家介绍下简单的单旋转操作，左旋和右旋。LR和RL本质上只是LL和RR的组合。\n\n> 在插入一个结点后应该沿搜索路径将路径上的结点平衡因子进行修改，当平衡因子大于1时，就需要进行平衡化处理。从发生不平衡的结点起，沿刚才回溯的路径取直接下两层的结点，如果这三个结点在一条直线上，则采用单旋转进行平衡化，如果这三个结点位于一条折线上，则采用双旋转进行平衡化。\n\n左旋：S为当前需要左旋的结点，E为当前结点的父节点。\n![](https://s3.bmp.ovh/imgs/2022/10/30/d9a414037fcbe702.png)\n左旋的操作可以用一句话简单表示：将当前结点S的左孩子旋转为当前结点父结点E的右孩子，同时将父结点E旋转为当前结点S的左孩子。\n\n二叉排序树：当插入的数据高度有序时，二叉树会退化成链表，从而使得二叉树的查询和插入效率恶化。\n\n平衡二叉树优化了查询效率问题。但是在构造平衡二叉树时，却需要采用不同的调整方式使得二叉树在插入数据后保持平衡。高度平衡带来的好处是能够提供更高的搜索效率，其最坏的查找时间复杂度都是O(logN)。\n\n平衡二叉树带来了插入效率低的问题。有没有一种方法可以兼顾插入效率和查询效率呢？--答案是红黑树。\n\n**红黑树**：\n\n平衡二叉树（AVL）为了追求高度平衡，需要通过平衡处理使得左右子树的高度差必须小于等于1。高度平衡带来的好处是能够提供更高的搜索效率，其最坏的查找时间复杂度都是O(logN)。但是由于需要维持这份高度平衡，所付出的代价就是当对树种结点进行插入和删除时，需要经过多次旋转实现复衡。这导致AVL的插入和删除效率并不高。\n\n为了解决这样的问题，能不能找一种结构能够兼顾搜索和插入删除的效率呢？这时候红黑树便申请出战了。\n\n红黑树的五个特性：\n\n> 1、每个结点要么是红的要么是黑的。\n>\n> 2、根结点是黑的。\n>\n> 3、每个叶结点（叶结点即指树尾端NIL指针或NULL结点）都是黑的。\n>\n> 4、如果一个结点是红的，那么它的两个儿子都是黑的。\n>\n> 5、对于任意结点而言，其到叶结点树尾端NIL指针的每条路径都包含相同数目的黑结点。\n>\n> ![](https://s3.bmp.ovh/imgs/2022/10/30/6810891e8e72ed25.png)\n> 黑树通过将结点进行红黑着色，使得原本高度平衡的树结构被稍微打乱，平衡程度降低。红黑树不追求完全平衡，只要求达到部分平衡。这是一种折中的方案，大大提高了结点删除和插入的效率。C++中的STL就常用到红黑树作为底层的数据结构。\n\n红黑树VS平衡二叉树\n![](https://s3.bmp.ovh/imgs/2022/10/30/285dcb87b89c0d04.png)\n\n除了上面所提及的树结构，还有许多广泛应用在数据库、磁盘存储等场景下的树结构。比如B树、B+树等。这里就先不介绍了诶，下次在讲述相关存储原理的时候将会着重介绍。（其实是因为懒）\n\n\n\n\n## 六、堆与散列表（哈希表）\n\n### 6.1 堆\n\n了解完二叉树，再来理解堆就不是什么难事了。堆通常是一个可以被看做一棵树的数组对象。堆的具体实现一般不通过指针域，而是通过构建一个一维数组与二叉树的父子结点进行对应，因此堆总是一颗完全二叉树。\n\n对于任意一个父节点的序号n来说（这里n从0算），它的子节点的序号一定是2n+1，2n+2，因此可以直接用数组来表示一个堆。\n\n不仅如此，堆还有一个性质：堆中某个节点的值总是不大于或不小于其父节点的值。将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。\n\n![](https://s3.bmp.ovh/imgs/2022/10/30/a0e7cdbcd8e45b1d.png)\n堆常用来实现优先队列，在面试中经常考的问题都是与排序有关，比如堆排序、topK问题等。由于堆的根节点是序列中最大或者最小值，因而可以在建堆以及重建堆的过程中，筛选出数据序列中的极值，从而达到排序或者挑选topK值的目的。\n\n### 6.2 哈希表\n\n散列表也叫哈希表，是一种通过键值对直接访问数据的机构。在初中，我们就学过一种能够将一个x值通过一个函数获得对应的一个y值的操作，叫做映射。散列表的实现原理正是映射的原理，通过设定的一个关键字和一个映射函数，就可以直接获得访问数据的地址，实现O(1)的数据访问效率。在映射的过程中，事先设定的函数就是一个映射表，也可以称作散列函数或者哈希函数。\n![](https://s3.bmp.ovh/imgs/2022/10/30/3ba468006ba54746.png)\n散列表的实现最关键的就是散列函数的定义和选择。一般常用的有以下几种散列函数：\n\n> 直接寻址法：取关键字或关键字的某个线性函数值为散列地址。\n>\n> 数字分析法：通过对数据的分析，发现数据中冲突较少的部分，并构造散列地址。例如同学们的学号，通常同一届学生的学号，其中前面的部分差别不太大，所以用后面的部分来构造散列地址。\n>\n> 平方取中法：当无法确定关键字里哪几位的分布相对比较均匀时，可以先求出关键字的平方值，然后按需要取平方值的中间几位作为散列地址。这是因为：计算平方之后的中间几位和关键字中的每一位都相关，所以不同的关键字会以较高的概率产生不同的散列地址。\n>\n> 取随机数法：使用一个随机函数，取关键字的随机值作为散列地址，这种方式通常用于关键字长度不同的场合。\n>\n> 除留取余法：取关键字被某个不大于散列表的表长 n 的数 m 除后所得的余数 p 为散列地址。这种方式也可以在用过其他方法后再使用。该函数对 m 的选择很重要，一般取素数或者直接用 n。\n\n确定好散列函数之后，通过某个key值的确会得到一个唯一的value地址。但是却会出现一些特殊情况。即通过不同的key值可能会访问到同一个地址，这个现象称之为冲突。\n\n冲突在发生之后，当在对不同的key值进行操作时会使得造成相同地址的数据发生覆盖或者丢失，是非常危险的。所以在设计散列表往往还需要采用冲突解决的办法。\n\n常用的冲突处理方式有很多，常用的包括以下几种：\n\n> 开放地址法（也叫开放寻址法）：实际上就是当需要存储值时，对Key哈希之后，发现这个地址已经有值了，这时该怎么办？不能放在这个地址，不然之前的映射会被覆盖。这时对计算出来的地址进行一个探测再哈希，比如往后移动一个地址，如果没人占用，就用这个地址。如果超过最大长度，则可以对总长度取余。这里移动的地址是产生冲突时的增列序量。\n>\n> 再哈希法：在产生冲突之后，使用关键字的其他部分继续计算地址，如果还是有冲突，则继续使用其他部分再计算地址。这种方式的缺点是时间增加了。\n>\n> 链地址法：链地址法其实就是对Key通过哈希之后落在同一个地址上的值，做一个链表。其实在很多高级语言的实现当中，也是使用这种方式处理冲突的。\n>\n> 公共溢出区：这种方式是建立一个公共溢出区，当地址存在冲突时，把新的地址放在公共溢出区里。\n\n目前比较常用的冲突解决方法是链地址法，一般可以通过数组和链表的结合达到冲突数据缓存的目的。\n![](https://s3.bmp.ovh/imgs/2022/10/30/77f0d941522f5204.png)\n\n左侧数组的每个成员包括一个指针，指向一个链表的头。每发生一个冲突的数据，就将该数据作为链表的节点链接到链表尾部。这样一来，就可以保证冲突的数据能够区分并顺利访问。\n\n考虑到链表过长造成的问题，还可以使用红黑树替换链表进行冲突数据的处理操作，来提高散列表的查询稳定性。\n\n\n\n## 七、图\n\n图相较于上文的几个结构可能接触的不多，但是在实际的应用场景中却经常出现。比方说交通中的线路图，常见的思维导图都可以看作是图的具体表现形式。\n\n图结构一般包括顶点和边，顶点通常用圆圈来表示，边就是这些圆圈之间的连线。边还可以根据顶点之间的关系设置不同的权重，默认权重相同皆为1。此外根据边的方向性，还可将图分为有向图和无向图。\n![](https://s3.bmp.ovh/imgs/2022/10/30/6895b3dbf5ae8d5f.png)\n图结构用抽象的图线来表示十分简单，顶点和边之间的关系非常清晰明了。但是在具体的代码实现中，为了将各个顶点和边的关系存储下来，却不是一件易事。\n\n\n\n\n\n\n\n\n\n\n\n## 八、算法：查找\n\n参考： https://blog.csdn.net/chenlong_cxy/article/details/116563972?spm=1001.2101.3001.6661.1&depth_1-\n\n参考：https://blog.csdn.net/heyuchang666/article/details/50041455?spm=1001.2101.3001.6650.1&depth_1-\n\n参考：https://blog.csdn.net/heyuchang666/article/details/47275047\n\n\n\n\n\n\n\n\n\n\n\n## 九、算法：排序\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n',1,0,0,0,1,'2023-06-07 16:41:44','2023-06-07 19:56:52');
INSERT INTO `t_article` VALUES (85,1,53,'https://upload.haoxx.site/article/a9ac1c3c7feb616dd40892fdb8fdf1ec.jpg','进程与线程','---\ntitle: 进程与线程\ndate: 2022-10-30\ncategory:\n - 3操作系统与计算机组成原理\n\nfooter: <a href=\"https://beian.miit.gov.cn/#/Integrated/index\">渝ICP备2023001651号</a>\n\n---\n\n:::tip\n进程与线程\n:::\n\n<!-- more -->\n\n\n“进程是操作系统分配资源的单位，线程是调度的基本单位，线程之间共享进程资源。”\n进程是拥有资源的最小单位，线程是参与内核调度的最小单位。\n\n## 1、同一进程的不同线程之间，共享的资源有：\n\n+ 可执行的指令\n+ 静态数据\n+ 进程中打开的文件描述符\n+ 当前工作目录\n+ 用户ID\n+ 用户组\n\n## 2、同一进程的不同线程之间，私有的资源有：\n\n+ 线程ID\n+ PC程序寄存器和 其他相关寄存器\n+ 堆栈\n+ 每个线程中的局部变量是私有的\n+ 错误号\n+ 优先级\n+ 执行状态和属性',1,0,0,0,1,'2023-06-07 16:59:04','2023-06-07 20:01:25');
INSERT INTO `t_article` VALUES (86,1,54,'https://upload.haoxx.site/article/916b2acdd31a579849fb9f1e706fd1ac.jpg','IP地址说明','---\ntitle: IP地址说明\ndate: 2022-10-30\ncategory:\n - 4计算机网络\n\nfooter: <a href=\"https://beian.miit.gov.cn/#/Integrated/index\">渝ICP备2023001651号</a>\n\n---\n\n:::tip\nIP地址说明\n:::\n\n<!-- more -->\n\n\n[参考资料](https://www.cnblogs.com/zpcdbky/p/16107981.html)',1,0,0,0,1,'2023-06-07 16:59:38','2023-06-07 20:01:05');
INSERT INTO `t_article` VALUES (87,1,54,'https://upload.haoxx.site/article/9c533384183255ee7a33c3f702e1a718.jpg','IPv4学习记录','---\ntitle: IPv4学习记录\ndate: 2020-12-15\ntag:\n - tag3\ncategory: \n - 4计算机网络\n\nfooter: <a href=\"https://beian.miit.gov.cn/#/Integrated/index\">渝ICP备2023001651号</a>\n\n---\n\n:::tip\nIPv4学习记录\n:::\n\n<!-- more -->\n\n\n[参考资料](https://space.bilibili.com/360996402/channel/seriesdetail?sid=1721882)  B站up主：湖科大教书匠，计算机网络微课堂，第47-53讲，加上第60讲。\n1、第47讲：IPv4地址概述\n2、第48讲：分类编址的IPv4地址（分为ABCDE五类）\n3、第49讲：划分子网的IPv4地址\n4、第50讲：无分类编址的IPv4地址（无分类域间路由选择CIDR、斜线记法）\n5、第51讲：IP地址的应用规划\n6、第52讲：IP数据包的发送和转发过程\n7、第53讲：静态路由的配置及其可能产生的路由环路问题\n8、第60讲：虚拟专用网络VPN和网络地址转换NAT\n\n1、IPv4地址概述\n分为三个历史阶段：分类编址、划分子网和五分类编址三个阶段。\n\n2、分类编址的IPv4地址\n![图1](https://s3.bmp.ovh/imgs/2022/10/11/7a8cc0531f1d06f7.png)\n![图2](https://s3.bmp.ovh/imgs/2022/10/11/a1a7e6a41ac812a8.png)\n![图3](https://s3.bmp.ovh/imgs/2022/10/11/76aa90cdc5048e17.png)\n![图4](https://s3.bmp.ovh/imgs/2022/10/11/813f395e6ae9d19c.png)\n![图5](https://s3.bmp.ovh/imgs/2022/10/11/859076c54f7efad2.png)\n\n3、划分子网\n\n将划分子网的IP地址与相对应的子网掩码进行逻辑与运算就可得到IPv4地址所在<font color=\'red\'>子网的网络地址</font>。\n\n网络地址：仅包含网络号，主机号全部清零后的IP地址\n\n给定一个分类的IP和对应的子网掩码，就可以知道子网划分的细节：\n\n+ 划分区子网的数量\n+ 每个子网可分配IP的数量\n+ 每个子网的网络地址和广播地址\n+ 每个子网可分配的最小和最大地址\n\n例：已知某个网络的地址是218.75.230.0，使用子网掩码255.255.255.192对其进行子网划分，请给出划分细节。\n解析：\n\n首先，A类网是1 ~ 126，127作为本地回环地址，不指派。B类网是128 ~ 191，C类网是192 ~ 223，D类网是组播地址，E类网保留未使用。还有0号开头的为网络IP地址，127开头的为本地回环测试地址，不对外使用。10/8开头的、172.16/12开头和192.168/16的IP自由分配，可做局域网IP使用。\n![图](https://s3.bmp.ovh/imgs/2022/10/12/b3644b1fd443eb7a.png)\n\n前往[IANA官网](https://www.iana.org/assignments/iana-ipv4-special-registry/iana-ipv4-special-registry.xhtml)查看IPv4分配细节。\n\n其次，题中的218为C类地址，网络号占3个字节（24bits），主机号占一个字节（8bits），子网掩码没设定的话，默认为255.255.255.0，而题目中为255.255.255.192,其中192的二进制为1100 0000，即网络号由26位bits构成，主机号由6位bits构成，如果用CIDR斜线记法表示为218.75.230.0/26。\n\n可划分子网数量2^2^=4个子网，每个子网可分配IP地址数量为2^(8-2)^-2=2^6^-2=62个。\n![图6](https://s3.bmp.ovh/imgs/2022/10/12/e689726999c60be1.png)\n\n4、无分类的IPv4地址\n\n划分子网划分子网在一定程度上缓解了因特网在发展中晕倒的瓶颈，但是数量巨大的C类网因为其地址空间太小而没有得到充分的利用。\n\n为此，因特网工程任务组有提出了采用无分类编制的方法解决IP地址紧张的问题。无分类域间路由选择CIDR\n\nCIDR消除了划分IP地址分类和划分子网的概念，可以更有效地分配IPv4的地址空间。CISR采用斜线记法，即在IP地址后面写上斜线，斜线后加上网络前缀的数量。\n\n我们只要知道CIDR地址块中的任何一个地址，就可以知道该地址块的全部细节：\n\n+ 地址块的最小地址\n+ 地址块的最大地址\n+ 地址块的地址数量\n+ 地址块聚合某类网络（A类、B类或C类）的数量\n+ 地址掩码（也可继续称为子网掩码）\n\n例：请给出CIDR地址块128.14.35.7/20的全部细节（最小地址，最大地址，地址数量，聚合C类网数量，地址掩码）\n	解析：\n20位网络号，所以子网掩码为255.255.240.0，(B类IP，16bits网络号，16bits主机号)\nIPv4地址：128.14.35.7  =  <font color=\'red\'>1000 0000. 0000 1110. 0010 </font>0011. 0000 0111 \n掩码：    255.255.240.0 =   1111 1111.  1111  1111. 1111  0000. 0000 0000\n逻辑按位与的结果为：        <font color=\'red\'>1000 0000. 0000 1110. 0010</font> 0000. 0000 0000 = 128.14.32.0\n\n所以，总共有2^(32-20)^=4096个IP地址,因为是聚合C类网，主机号：网络号=24:8，所以，每个子网的IP地址数量为2^8^个地址，聚合C类网的数量为总IP地址数量除以单个子网IP地址数量，即为2^(32-20)^ / 2^8^ =2^12^ / 2^8^ = 2^4^=16个聚合C类子网。\n将主机号全部取零，得到最小地址128.14.32.0；将主机号全部取1，得到最大地址128.14.47.255。\n\n无分类编址的IPv4地址还可以用来构成超网：路由聚合\n举例：172.1.4.0/25  172.1.4.128/25   \n	172.1.5.0/24 172.1.6.0/24  172.1.7.0/24\n找网络号的共同前缀：主要在于第三个字节：\n172.1.4.0/25  -->   172.1.0000  0100.0\n172.1.4.128/25 -> 172.1.0000  0100.128\n172.1.5.0/24  -->  172.1.0000   0101.0\n172.1.6.0/24  -->  172.1.0000   0110.0\n172.1.7.0/24  -->  172.1.0000   0111.0\n找共同前缀----->   172.1.4.0/22\n注意，<font color=\'red\'>在网关路由中，网络前缀越长，地址块越小，路由越具体</font>。若路由器查表转发分组时发现有多条路由可选，则选择网络前缀最长的那条，这称为<font color=\'red\'>最长前缀匹配</font>。\n\n举例：在子网192.168.4.0/30中，能接受目的地址为192.168.4.3的IP分组的最大主机数为：____\n解析：\n\n子网192.168.4.0，即：192.168.0000 0100.0000 0000  ，其中192.168.4.0000 00位网络号，最后两位00表示主机号，所以主机数量为4，但是主机号为0的主机只能做源IP地址，不能做目的IP地址；主机号全为1的地址，只能做广播地址，所以符合条件的主机号为2。\n\n最长前缀匹配(最佳匹配)：使用 CIDR 时，路由表中的每个项目由 \"网络前缀\" 和 \"下一跳地址\" 组成。在查询路由表时可能会得到不止一个匹配结果。应当从匹配结果中选择具有最长网络前缀的路由，因为网络前缀越长，其地址块越小，因此路由就越具体。\n\n**路由聚合的优点**：减小路由规模，加快路由匹配速度；降低路由更新时的流量开销。\n\n注意：\n\n(1) 划分子网只是把IP地址的主机号这部分进行再划分，而不是改变IP地址原来的网络号。因此，从一个IP地址本身或IP数据报的首部，并无法判断源主机或目的主机所连接的网络是否进行了子网划分。\n\n(2) 对分类的IPv4地址进行子网划分时，子网号不能为全0或全1。但随着CIDR的广泛使用，现在全0和全1的子网号也可以使用了。\n\n(3) 无论是分类IPv4地址还是CIDR，其子网中的主机号为全0或全1的地址都不能被指派。\n\n5、IPv4的应用规划\n定长的子网掩码FLSM  /  变长的子网掩码VLSM\n举例：使用定长的子网掩码FLSM方式来将218.75.230.0进行子网划分：\n![图](https://s3.bmp.ovh/imgs/2022/10/12/caf1ef498ee2d87c.png)\n解析：\n\n题目内容如上图所示，用定长的子网掩码来进行子网划分，考虑到N2子网数最多，为28台，并且218为C类网络，网络号24位，主机号为8位。综上，从8个主机号中划分5个做主机号，可满足最多32个主机，符合题目要求；剩余3个做子网号，可满足最多8个子网，满足题目中5个子网的要求。最终，定长子网划分结果如下：\n子网划分依据：  218.75.230. 000<font color=\'red\'>0   0000</font>\nN1： 218.75.230.1 ~ ~ 218.75.230.9    （9个IP）\nN2： 218.75.230.33 ~ ~ 218.75.230.60  (28个IP)\nN3： 218.75.230.65 ~ ~ 218.75.230.79  （15个IP）\nN4： 218.75.230.97 ~ ~ 218.75.230.109   (13个IP)\nN5： 218.75.230.129 ~ ~ 218.75.230.132 （4个IP)\n![](https://s3.bmp.ovh/imgs/2022/10/12/fe7eb0646e3b1f63.png)\n\n\n![](https://s3.bmp.ovh/imgs/2022/10/12/11e458750a1cc671.png)\n\n显然，使用定长的子网掩码来进行分组会极大地浪费IP，故而采用变长的子网掩码分组，按需使用IP。\n\n使用变长的子网掩码VLSM  --- IP： 218.75.230.0/24\n分析题目中各个局域网的情况：\nN1：6台主机，一个路由器，一个网络IP(全0)，一个广播IP(全1)，一共9个IP\nN2：25台主机，需要28个IP\nN3：12台主机，需要15个IP\nN4：10台主机，需要13个IP\nN5：0个主机，两个路由器，一个网络地址，一个广播地址，一共4个IP\n\n分配结果：\nN1：9个IP，用4个主机号表示，即：/28\nN2：28个IP，用5个主机号表示，即：/27\nN3：15个IP，用4个主机号表示，即：/28\nN4：13个IP，用4个主机号表示，即：/28\nN5：4个IP，用2个主机号表示，即：/30\n最终，从地址块中划分出5个子网地址块：1个/27地址块，3个/28地址块，1个/30地址块。先从主机号最多的子网开始分配。\nN2：28个IP，子网地址块218.75.230.0 ~ ~ 218.75.230.31\nN1：9个IP，子网地址块218.75.230.32 ~ ~ 218.75.230.47\nN3：15个IP，子网地址块218.75.230.48 ~ ~ 218.75.230.63\nN4：13个IP，子网地址块218.75.230.64 ~ ~ 218.75.230.79\nN5：4个IP，子网地址块218.75.230.80 ~ ~ 218.75.230.83\n其他子网地址块待分配\n![](https://s3.bmp.ovh/imgs/2022/10/12/d0e1a20bba0a0c96.png)\n![](https://s3.bmp.ovh/imgs/2022/10/12/0d6b104fe4c200a5.png)\n\n6、第52讲：IP数据包的发送和转发过程\n![](https://s3.bmp.ovh/imgs/2022/10/12/63899dae2a42cd37.png)\nIP路由器工作在TCP/IP体系结构的网际层（或称IP层），TCP/IP体系结构的网际层并不负责可靠传输，也就是不能确保传输的IP分组不丢失。IP路由器会对收到的IP分组头进行差错校验，当发现错误是会丢弃并报告源主机。\n\n\nIP数据报的发送和转发过程包含以下两部分：\n主机发送IP数据报；路由器转发IP数据报。\n![](https://s3.bmp.ovh/imgs/2022/10/12/aa24315f888d2a56.png)\n\n**FAQ**\n1、怎么判断发送主机IP和目的主机IP处于同一网络？\n答：发送主机将自身掩码与自身IP相与，得到自己所处的网络地址；然后发送主机将自己掩码与目的主机在相与，得到目的主机在该掩码下的网络地址。\n\n如果两个网络地址相同，则表示处于同一网段，同一网段的主机可以直接通信，这是“直接交付”。\n\n如果两个网络地址不同，则IP数据报先交给局域网的网关，听过路由表查询前往目的主机IP的下一跳，然后离开本局域网，前往下一跳的局域网，最终达到目的主机，这是“间接交付”。\n\n2、路由器怎么根据IP数据报的目的地址，在路由表中查找匹配的条目呢？\n答：①路由器先从数据报中得到源地址和目的地址；\n②路由器根据其接口以及用户手动配置的路由表，可以得到所有的目的网络（如下图所示）。\n![](https://s3.bmp.ovh/imgs/2022/10/12/a72362ec7a303a1a.png)\n③将目的地址与路由表中的地址掩码相与，得到目的网络地址，然后检查得到的这个目的网络地址与路由表中的目的网络地址是否相同，相同就转发。\n![](https://s3.bmp.ovh/imgs/2022/10/12/1513533a674d6acf.png)\n\n![](https://s3.bmp.ovh/imgs/2022/10/12/1e84edfd2f92a8c6.png)\n\n注意！局域网下的广播数据包交付给路由器后，路由器不会转发。也正因此，路由器可以有效地遏制网络风暴。\n\n中继器和集线器工作在物理层，既不隔离冲突域，也不隔离广播域；\n网桥和交换机（多端口网桥）工作在数据链路层，可以隔离冲突域，不能隔离广播域。\n路由器工作在网络层，既隔离冲突域，也隔离广播域。\n\n7、第53讲：静态路由的配置及其可能产生的路由环路问题\n略\n注意，手动添加路由表时，可以指定笼统的目的网络（即多个网络IP，取其相同数据的位，然后后面用斜线加数字来表示），可以指定特定的主机路由，例如192.168.1.1/32，可以指定默认路由0.0.0.0。但是需要注意，网络前缀越长，路由越具体；网络前缀越短，路由越模糊。多条路由可选时。最长前缀匹配！\n\n8、第60讲：虚拟专用网络VPN和网络地址转换NAT\n以下三个地址块可以设置为局域网IP：\n![](https://s3.bmp.ovh/imgs/2022/10/12/f99009b18204f73f.png)\nNAT：网络地址转换，当专用网内部的主机已经分配了本地IP，但又想和因特网上的主机通信时，可使用NAT方法。这种方法需要安装NAT软件，且该软件至少拥有一个有效的公网IP，当本地地址想与外界通信时，都要在NAT路由器上将本地地址转换成临时的公网全球IP地址。\n\n',1,0,0,0,1,'2023-06-07 16:59:58','2023-06-07 20:00:58');
INSERT INTO `t_article` VALUES (88,1,55,'https://upload.haoxx.site/article/370336be7166eb151f9877379c989b33.jpg','UML图图示','---\ntitle: UML图图示\ndate: 2022-10-30\ncategory:\n - 5设计模式\n\nfooter: <a href=\"https://beian.miit.gov.cn/#/Integrated/index\">渝ICP备2023001651号</a>\n\n---\n\n:::tip\nUML图图示\n:::\n\n<!-- more -->\n\n\n基本关系预览图如下：\n![图1](https://s3.bmp.ovh/imgs/2022/08/26/b5cd7823d6081560.png)\n\n首先，一个矩形就表示一个类，分为三行。第一行为类名，如果为斜体就是抽象类，第二行为类的属性（变量），第三行为类的方法（函数）。第二行的属性名和第三行的方法名前，+表示public，-表示private，#表示protected。如下图所示。\n![图2](https://s3.bmp.ovh/imgs/2022/08/26/31e4605813d2c887.jpg)\n\n然后，是接口。接口有两种表示方法。方法一：矩阵表示法。矩阵第一行顶端有《interface》,第一行还有接口的名称，第二行是接口的方法。方法二：棒棒糖表示法：圆圈旁为接口名称，接口方法在实现类中出现。见下图所示：\n![图3](https://s3.bmp.ovh/imgs/2022/08/26/65811fa415ced78b.png)\n\n再然后，是类与类之间和类与接口之间的关系。类与类之间，有继承关系、关联关系、聚合关系、合成（组合）关系和依赖关系。类与接口之间有实现接口关系。\n\n|            关系            |     表示方式      |\n| :------------------------: | :---------------: |\n|          继承关系          |  空心三角形+实线  |\n|          关联关系          |     实线箭头      |\n|          聚合关系          | 空心菱形+实线箭头 |\n|          组合关系          | 实心菱形+实线箭头 |\n|          依赖关系          |     虚线箭头      |\n| （类与接口）实现接口的关系 |  空心三角形+虚线  |\n\n1.1  类一类之间的继承关系。用**空心三角形+实线**来表示。\n![图4](https://s3.bmp.ovh/imgs/2022/08/26/04d598806cfc056e.png)\n1.2  类一类之间的关联关系。用**实心箭头**来表示。\n\n企鹅与气候有很大的关联，企鹅需要知道气候的变化，需要了解气候规律。所以，企鹅继承于鸟基类，且有一个私有属性：气候。\n![图5](https://s3.bmp.ovh/imgs/2022/08/26/21502e3c6a8adcef.jpg)\n1.3  类一类之间的聚合关系。用**空心的菱形+实线箭头**来表示。\n\n聚合表示一种弱的拥有关系。体现的是A对象可以包含B对象，但B对象不是A对象的一部分。大雁可以聚合起来，称为大雁群，也可以不聚合，称为单雁。\n![图6](https://s3.bmp.ovh/imgs/2022/08/26/cb326bbfa3cfd4ac.jpg)\n1.4  类一类之间的合成（组合）关系。用**实心菱形+实线箭头**来表示。\n\n合成关系与聚合关系不同，合成关系表示一种强的拥有关系。鸟拥有羽毛，这是必然的，他们两是整体与部分的关系，并且生命周期相同。合成关系用**实心菱形和实线箭头**来表示，另外，你会注意到合成关系的连线两端还有一个数字‘1’和\'2\'，这被称为基数，表明这一段的类可以有几个实例。很显然，一只鸟应该有两只翅膀。注意：关联关系、聚合关系也可以有基数。\n![图7](https://s3.bmp.ovh/imgs/2022/08/26/454c5f84f6533087.png)\n1.5  类一类之间的依赖关系。用**虚线箭头**来表示。\n\n依赖关系就如字面意思，动物依赖于水，依赖于氧气。依赖关系用**虚线箭头**表示。\n![图8](https://s3.bmp.ovh/imgs/2022/08/26/1fe1c94bb8cb10bd.jpg)\n2.1 类与接口之间的实现接口关系，用空心三角形+虚线表示。\n\n实现接口和继承很类似，继承关系是空心三角形+实线来表示的。注意，仅当用矩阵表示法来表示接口时采用空心三角形+虚线表示，用棒棒糖法来表示接口时，无需其他说明。\n![图9](https://s3.bmp.ovh/imgs/2022/08/26/022180a1216da787.png)\n\n**总结**：\n更一般地，一个小总结：继承关系/关联关系/聚合关系/合成关系/依赖关系，以及一个实现接口关系。\n\n继承关系就是在子类名的定义中，类名后加上：public 基类名。\n\n关联关系就是在类中定义一个私有属性，例如企鹅和气候有关联关系，那么就在企鹅类中定义一个气候的私有变量。\n\n聚合关系就是在B类中定义一个私有数组变量，该数组变量的类型是A类。\n\n合成关系就是在B类中定义一个A类的私有变量，并在B类的构造函数中完成A类对象的实例化。他们两同时生成，同时死亡。\n\n依赖关系：动物类的属性是有生命，方法是新陈代谢。氧气类和水类是与方法--新陈代谢有关，所以在动物类的新陈代谢方法里，氧气类和水类作为方法的形参进行传递。\n\n',1,0,0,0,1,'2023-06-07 17:00:36','2023-06-07 20:00:43');
INSERT INTO `t_article` VALUES (89,1,55,'https://upload.haoxx.site/article/0ee03ae43908303571e0982183382565.jpg','设计模式总结','---\ntitle: 设计模式总结\ndate: 2022-10-30\ncategory:\n - 5设计模式\n\nfooter: <a href=\"https://beian.miit.gov.cn/#/Integrated/index\">渝ICP备2023001651号</a>\n\n---\n\n:::tip\n设计模式总结\n:::\n\n<!-- more -->\n\n\n由GoF提出的设计模式有23种，再加上一种简单工厂模式，一共有24种模式，并大致分为三类。内容参考了[BiliBili视频黑马程序员(学完c++提高后在学这个)](https://www.bilibili.com/video/BV1Mb411t7ut?p=11&vd_source=d0ee64ac63fa4af6553687c1e0a80570)，以及热心网友整理的学习笔记：[CSDN博客](https://blog.csdn.net/weixin_42636062/category_11313224.html)，此外，程杰的《大话设计模式》一书也给此次笔记整理提供了巨大的帮助。\n\n| 创建型模式                            | 描述 |\n| ------------------------------------- | ---- |\n| <font color=\'red\'>简单工厂模式</font> |      |\n| <font color=\'red\'>工厂方法模式</font> |      |\n| <font color=\'red\'>抽象工厂模式</font> |      |\n| <font color=\'red\'>单例模式</font>     |      |\n| 原型模式                              |      |\n| 建造者模式                            |      |\n\n\n结构型模式，就是让类和类进行组合，获得更大的结构。\n\n| 结构型模式                          | 描述 |\n| ----------------------------------- | ---- |\n| <font color=\'red\'>代理模式</font>   |      |\n| <font color=\'red\'>装饰模式</font>   |      |\n| <font color=\'red\'>外观模式</font>   |      |\n| <font color=\'red\'>适配器模式</font> |      |\n| 桥接模式                            |      |\n| 组合模式                            |      |\n| 享元模式（共享）                    |      |\n\n\n行为型模式，用来对类或对象怎样交互和怎样分配职责进行描述。\n\n| 行为型模式                          | 描述 |\n| ----------------------------------- | ---- |\n| <font color=\'red\'>模板模式</font>   |      |\n| <font color=\'red\'>命令模式</font>   |      |\n| <font color=\'red\'>策略模式</font>   |      |\n| <font color=\'red\'>观察者模式</font> |      |\n| 职责链模式                          |      |\n| 解释器模式                          |      |\n| 迭代器模式                          |      |\n| 中介者模式                          |      |\n| 备忘录模式                          |      |\n| 状态模式                            |      |\n| 访问者模式                          |      |\n\n',1,0,0,0,1,'2023-06-07 17:00:53','2023-06-07 20:00:32');
INSERT INTO `t_article` VALUES (90,1,56,'https://upload.haoxx.site/article/da9646e2e30563537d21e5a36a4ac461.jpg','代码随想录学习笔记_第一部分[总结]','---\ntitle: 代码随想录学习笔记[总结]\ndate: 2023-04-12\ncategory:\n - 找工作相关\nstar: true\ncover: \"https://w.wallhaven.cc/full/72/wallhaven-7286w9.png\"\narticle: true\nfooter: <a href=\"https://beian.miit.gov.cn/#/Integrated/index\">渝ICP备2023001651号</a>\n\n---\n\n:::tip\n这是在学习代码随想录网站上的知识时，所做的一部分笔记\n:::\n\n<!-- more -->\n\n\n代码随想录学习笔记--文章修订记录：\n\n+ 2023/04/11 第一版仍在撰写\n\n\n[[TOC]]\n\n## 一、数组\n\n数组和链表是数组结构中的基本数据结构。数组的特点是查询方便，链表的特点是插入/删除方便。还有个特点是，数组一般长度固定，二链表长度可以扩展。在存储方面的特点是，数组元素连续存储，链表元素不连续。\n\n数组是存放在连续内存空间上的想同类型数据的集合。数组的特点是元素下标从0开始，元素存储空间连续。数组的元素不能删，只能覆盖。\n\n二维数组在内存中如何存储的？对于cpp而言，二维数组在内存空间中也是连续存储的。对于Java而言，同一行下的数组元素存储式连续的，二不同行之间的数据不是连续存储的。类似于哈希表一样，用链表将多个行数组串联起来。\n\n在数组部分的知识点有：\n\n+ 二分查找\n+ 移除元素\n+ 有序数组的平方\n+ 长度最小的子数组\n+ 螺旋矩阵2\n\n### 1.1 二分查找\n\n前提必须是有序、不重复数组才能使用二分查找（已经按照从小到大或者从大到小的顺序排好了）。通过将数组中间元素值作为分割点，将数组分割为两部分，来减小一半的搜索量。通过比较数组中间元素值和target值，来更新left和right索引值。\n\n这里强调无重复元素是因为一旦有重复元素就会使得二分查找的返回值不唯一。二分查找的关键在于边界条件的框定。区间的定义是不变量，在循环过程中要遵循循环不变量原则。如果一开始就定义区间为左闭右闭，那就在循环中移植保持这种状态不改变。\n\n1. 第一种写法：左闭右闭。定义target在[left,right]区间中，所以有以下两点：\n\n+ `while(left <= right) `要用` <=` ，因为`left == right`是有意义的；\n+ `if (nums[middle] > target)` 目标值偏小，搜索区间选择左侧子空间。那么right要赋值为`middle-1`，因为当前这个`nums[middle]`一定不是target，那么接下来要查找的左侧子区间的右端下标位置就从`middle-1`开始。\n\n2. 第二种写法：左闭右开。定义target在[left,right )区间中，所以有以下两点：\n\n+ `while(left < right)` 要用 < ，因为`left == right`是没有意义的，数组值不能够取值right；\n+ `if (nums[middle] > target) `目标值偏小，搜索区间选择左侧子空间。那么right要赋值为middle，因为当前这个`nums[middle]`不等于target，那么接下来要查找的左侧子区间的右端下标位置就从middle开始。\n\n### 1.2 移除元素\n\n**问题描述**：给你一个数组和一个val，你需要原地移除数组中所有值等于val的元素，并返回移除后数组的新长度。要求：不能使用额外的数组空间，你必须使用O(1)额外空间并原地修改输入数组。例如，给定数组nums=[0,1,2,3,0,2,1,0,9,8,0,3],val=0,则新数组为[1,2,3,2,1,9,8,3]，返回长度为8。当然，返回数组的元素是否需要保存原有的相对位置并未作出限制。\n\n如何解决呢？1）使用双层for循环的暴力解法可以解决。外层for循环用来遍历数组，内层for循环用来更新删除元素后面的数组元素，将后面的元素依次向前挪一位来覆盖待删除的元素。时间复杂度为O(n2)。\n\n```cpp\nint removeElement(vector<int>&nums, int val) {\n	int size = nums.size();\n	for (int i = 0; i < size; i++) {\n		if (val == nums[i]) {\n			for (int j = i; j < size-1; j++) {\n					nums[j] = nums[j+1];\n			}\n		i--; //因为下标i以后的数据往前挪了一位，所以i也往前挪一位\n		size--;\n		}\n	} \n	return size;\n}\n```\n\n//上述代码的时间复杂度为O(n^2)，空间复杂度为O(1)。\n\n2）使用双指针法。通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。**快指针**：遍历整个数组，用来寻找新数组的元素，新数组就是不含目标元素值的数组。**慢指针**：指向更新后的新数组最后元素的下标。\n\n```cpp\nfor (int fastIndex = 0; fastIndex < nums.size(); fastIndex++) {\n    if (val != nums[fastIndex]) {\n    	nums[slowIndex++] = nums[fastIndex];\n    }\n}\n```\n\n//上述代码的时间复杂度为O(n)，空间复杂度为O(1)。\n\n### 1.3 有序数组的平方\n\n在这部分，主要考虑不管是包含负数还是不包含负数，数组元素的平方最大值一定在两端，绝不会在中间。所以对于题目要求的给定一个非递减顺序排序的整数数组，返回每个元素的平方组成的新数组，要求也按照非递减的顺序排序。可以确定的是，平方后的元素最大值一定在两端，所以最后的结果数组可以先从nums.size()-1元素先填值，最后在填充nums[0]的值。综上所述，有：\n\n```cpp\nvector<int> sortedSquares(vector<int>&A) {\n	vector<int> result(A.size(),0);\n	int k = A.size() – 1;\n	//注意：这里要i <= j，因为最后要处理两个元素\n	for(int i = 0,int j = A.size()-1; i < A.size();i <= j) {\n		if (A[i]*A[i] > A[j]*A[j]) {\n				result[k--] = A[i]*A[i];\n				i++;\n			}\n		else {\n			result[k--] = A[j]*A[j];\n			j--;\n		}\n	}\n	return result;\n}\n```\n\n双指针法的时间复杂度为O(n)。\n\n补充说明：暴力解法：先平方，再排序。\n\n```cpp\nvector<int> sortedSquares(vector<int>& A) {\n	for(int i = 0; i < A.size();i++) {\n	A[i]*=A[i];\n	}\n	sort(A.begin(),A,end()); //快速排序\n	return A;\n}\n```\n\n时间复杂度为`O(n+nlogn)`，可以说是`O(nlogn)`。\n\n### 1.4 长度最小的子数组\n\n**题目**：给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。例如输入：s = 7, nums = [2,3,1,2,4,3] 输出：2 解释：子数组 [4,3] 是该条件下的长度最小的子数组。\n\n先介绍暴力解法：使用双层for循环来求解。外层for[i]循环用来遍历整个数组，内层for[j]循环从i开始遍历，直至元素之和大于等于s后才停止，然后此时就计算单次数组长度subLength，并更新整体最小数组长度result。\n\n```cpp\nint minSubArrayLen(int s, vector<int> &nums) {\nint result = INT32_MAX;\nint subLength = 0;\nint sum = 0;\nfor(int i = 0; i < nums.size(); i++) {\n	sum = 0;\n	for(int j=i ; j< nums.size();j++) {\n		sum += nums[j];\n		if (sum >= s) {\n			subLength = j-i+1;\n			result = result < subLength ? result : subLength;\n			break;\n			}\n		}\n	}\nreturn result == INT32_MAX? 0 : result;\n}\n```\n\n前面讲了暴力算法是用两个for循环来实现的，外层的for[i]的作用是遍历整个数组并提供窗口的起始位置，内层for[j]的作用设置满足条件的窗口终止位置。这样的缺点就是时间复杂度高，为O(n2)。类似的，我们可以考虑用滑动窗口来替换一个for循环，降低时间复杂度。那个滑动窗口的起始点如何确定呢？\n\n接下来就开始介绍数组操作中另一个重要的方法：滑动窗口。所谓滑动窗口，**就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果**。\n\n在暴力解法中，是一个for循环滑动窗口的起始位置，一个for循环为滑动窗口的终止位置，用两个for循环完成了一个不断搜索区间的过程。那么滑动窗口如何用一个for循环来完成这个操作呢。首先要思考如果用一个for循环，那么应该表示滑动窗口的起始位置，还是终止位置。\n\n如果用for[i]来指定滑动窗口的起始位置，那最终就会陷入暴力算法的怪圈，所以for[i]应当是来指定滑动窗口的终止位置。\n\n> 滑动窗口的终止位置（如何移动）：由for[i]指定，就是遍历数组的指针\n> 滑动窗口内的元素：满足其和大于等于s条件最短子数组\n> 滑动窗口的起始条件（如何移动）：如果窗口内的元素之和大于等于s之后，需要向前进来缩小窗口内的值。\n\n下面这段代码就是滑动窗口，此代码的精髓就在于动态调节滑动窗口的起始位置：\n\n```cpp\nwhile(sum >= s) {\n	subLength = j – i + 1; //取子序列的长度\n	result = result < subLength ? result : subLength;\n	sum -= nums[i++]; //这里体现出滑动窗口的精髓之处，不断变更i（子序列的起始位置）\n}\n```\n\n使用滑动窗口法（单for循环）来解题：\n\n```cpp\nint minSubArrayLen(int s,vector<int> &nums) {\n	int subLength = 0;\n	int result = INT32_MAX;\n	int sum = 0;\n	int i = 0; //窗口的起始位置\n	for(int j = 0; j < nums.size(); j++) {\n		sum+=nums[j];\n		while (sum >= s) {\n			subLength = j – i + 1;\n			result = result < subLength ? result : subLength;\n			sum-=nums[i++];// 这里体现出滑动窗口的精髓之处，不断变更i（子序列的起始位置）\n		}\n	}\n	return result == INT32_MAX ? 0 : result;\n}\n```\n\n### 1.5 螺旋矩阵2\n\n**题目**：给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。例如，给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。\n\n这道题目可以说在面试中出现频率较高的题目，本题并不涉及到什么算法，就是模拟过程，但却十分考察对代码的掌控能力。\n\n在之前二分查找法中就提到过的循环不变量原则，这里同样适用。这里是模拟顺时针画矩阵的过程：\n\n+ 填充上行从左到右；\n+ 填充右行从上到下；\n+ 填充下行从右到左；\n+ 填充左行从下到上；\n\n由外向内一圈一圈这样画下去。这里一圈下来，我们要画每四条边，这四条边怎么画，每画一条边都要坚持一致的左闭右开，或者左开右闭的原则，这样这一圈才能按照统一的规则画下来。下图是按照左闭右开的原则来画的。\n\n<div align=center>\n<img src = \'https://s3.bmp.ovh/imgs/2023/03/24/eea1feac93f415db.png\' >\n</div>\n\n最后，整体cpp代码如下所示：\n\n```cpp\nvector<vector<int>> generateMatrix(int n) {\n	vector<vector<int>> res(n, vector<int>(n, 0)); // 使用vector定义一个二维数组\n	int startx = 0, starty = 0; // 定义每循环一个圈的起始位置\n	int loop =n/2;//每个圈循环几次，例如n为奇数3，那么loop=1只是循环一圈，矩阵中间的值需要单独处理\n	int mid = n / 2; // 矩阵中间的位置，例如：n为3， 中间的位置就是(1，1)，n为5，中间位置为(2, 2)\n	int count = 1; // 用来给矩阵中每一个空格赋值\n	int offset = 1; // 需要控制每一条边遍历的长度，每次循环右边界收缩一位\n	int i,j;\n	while (loop --) {\n		i = startx;\n		j = starty;\n		// 下面开始的四个for就是模拟转了一圈\n		// 模拟填充上行从左到右(左闭右开)\n		for (j = starty; j < n - offset; j++) {\n			res[startx][j] = count++;\n		}\n		// 模拟填充右列从上到下(左闭右开)\n		for (i = startx; i < n - offset; i++) {\n			res[i][j] = count++;\n		}\n		// 模拟填充下行从右到左(左闭右开)\n		for (; j > starty; j--) {\n			res[i][j] = count++;\n		}\n		// 模拟填充左列从下到上(左闭右开)\n		for (; i > startx; i--) {\n			res[i][j] = count++;\n		}\n		// 第二圈开始的时候，起始位置要各自加1，例如：第一圈起始位置是(0, 0)，第二圈起始位置是(1, 1)\n		startx++;\n		starty++;\n		// offset 控制每一圈里每一条边遍历的长度\n		offset += 1;\n	}\n	// 如果n为奇数的话，需要单独给矩阵最中间的位置赋值\n	if (n % 2) {\n		 res[mid][mid] = count;\n	}\n	return res;\n}\n```\n\n### 1.6 总结篇\n\n数组是非常基础的数据结构，它是存放在连续内存空间上的相同类型数据的集合。需要注意的是，数组下标从0开始，且数组内存空间地址都是连续的。正因为数组在内存空间上的地址是连续的，所以在增删元素时就难免需要移动其他元素。数组元素不能删除，只能覆盖。对于二维数组，在cpp中是连续存储的，而Java中单行数组是连续存储的，而行与行之间是连接在一个链表上，并非连续存储。所以Java的二维数组在内存中不是完全连续的地址空间，而是由（行数）条连续地址空间构成，每个连续地址空间的长度是列数。\n\n<div align=center>\n<img src = \'https://s3.bmp.ovh/imgs/2023/03/24/f9f79f108b25c45d.png\' >\n</div>\n\n数组基础的一些经典题目有二分查找、双指针法、滑动窗口法还有模拟行为。\n\n<div align=center>\n<img src = \'https://s3.bmp.ovh/imgs/2023/03/24/65074287759d1295.png\' >\n</div>\n\n## 二、链表\n\n链表与数组一样，都是线性结构，不过数组各个元素之间是连续存储，而链表是分散存储。也正因为该特性，链表在增删方面的效率要高于数组，但是相对的在查找方面的效率要低于数组。链表的种类有：单链表、双向链表、循环链表。循环链表可以用来解决约瑟夫环问题。\n\n约瑟夫环问题：0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。**例如**：0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。\n\n链表的定义(//单链表)：\n\n```cpp\nstruct ListNode {\n	int val;\n	ListNode *next;\n	ListNode(int x) : val(x),next(NULL) {} //节点的构造函数\n}；\n```\n\n注意，你也可以不定义构造函数，cpp会自动生成默认的构造函数，但该构造函数不会初始化任何成员变量。使用默认的构造函数来初始化节点：`ListNode* head = new ListNode(),head->val = 5`。使用自定的节点构造函数则为：`ListNode* head = new ListNode(5)`;所以，对于使用默认的构造函数，是不能再定义时直接赋值的。链表的头指针是一定存在的，它指向第一个节点，是链表的标志。头结点不一定存在，**但是如果头结点存在，那么操作第一个节点的增删就和其他节点的增删操作是一样的了**。如果在链表的listcreat创建函数中有开辟空间的操作，一般就是有头结点的（例如以前写的C语言链表操作）。在这里的cpp代码中链表的创建是通过结构体和new操作的，没有创建额外的空间，是没有头结点的。头结点就是在头指针和第一个节点之间，添加的节点值为无效值的节点。\n\n**链表的操作**：删除节点、增加节点。对于C/cpp的链表删除节点操作，最好要进行内存的手动释放，避免内存泄漏，而Java和Python无需手动释放。下面是单链表的添加节点和删除节点操作。\n\n<div align=center>\n<img src = \'https://s3.bmp.ovh/imgs/2023/03/24/8564202a88941271.png\' >\n</div>\n\nF节点为new节点，C节点为p，则**添加**新节点可以表达为1）`new->next=p->next;2）p->next=new`。\n\n<div align=center>\n<img src = \'https://s3.bmp.ovh/imgs/2023/03/24/9cb09bc8cb8823ba.png\' >\n</div>\n\n**删除**节点可以表达为：`if(p->next->val == val)，ListNode* tmp=p->next;1）p->next=p->next->next;2）delete tmp`;\n\n循环链表就是头尾相连的链表，将单链表的尾结点的next指针从NULL指向头结点，便使得整个单链表形成了一个环，这种头尾相接的单链表称为单循环链表，简称循环链表。为了使得空链表的处理与非空链表一致，我们通常设置一个头结点，但是不是说循环链表一定要头结点，这点要注意。\n\n其实，循环链表与单链表的差异就在循环的判断条件上，原来试试判断`p->next==NULL`，现在是判断`p->next`等于头结点，则循环结束。\n\n对循环链表进行改造，使用尾指针而非头指针，可以使得对尾结点的访问为O(1)，并且对头结点的访问也是O(1)。举个程序的例子，需要将两个循环链表合并为一个链表时，使用为指针就十分方便了。\n\n<div align=center>\n<img src = \'https://s3.bmp.ovh/imgs/2023/03/24/ef20cbea2d6919e6.png\' >\n</div>\n<div align=center>\n<img src = \'https://s3.bmp.ovh/imgs/2023/03/24/28e9daa9809379b3.png\' >\n</div>\n\n使用以下代码块来实现：\n\n```cpp\np=rearA->next; //保存A表的头结点，即①\nrearA->next=rearB->next->next; //舍弃B表的头结点，将本是指向B表的第一个节点（不是头结点）赋值给rearA->next，即②\nrearB->next=p; //将原来A表的头结点赋值给rearB->next，即③\nfree(p); //释放p\n```\n\n双向链表就是在单链表的基础上新增了一个向前的指针，有双指针prior和next，还可以组合成双向循环链表。另外，对于双向链表，节点后继的前驱、节点前驱的后继都是节点本身，如：`p->next->prior=p=p->prior->next`。下面开始介绍双向链表的插入和删除操作。\n\n我们假设存储元素e的新节点为s，要将新节点插入到节点p和p->next之间有以下几步，如下图所示。\n\n<div align=center>\n<img src = \'https://s3.bmp.ovh/imgs/2023/03/24/cd2a6675b201a79d.png\' >\n</div>\n\n代码块如下所示：\n\n```cpp\ns->prior=p;\ns->next=p->next;\np->next->prior=s;\np->next=s;\n```\n\n关键点在于它们的顺序，由于最后三步都用到了p->next，所以如果第四步先执行会出错。注意：如果把第四步提前，会失去对a~i+1~节点的控制，造成插入节点出错的问题。\n\n<div align=center>\n<img src = \'https://s3.bmp.ovh/imgs/2023/03/24/d5b28bb5a3bf7c52.png\' >\n</div>\n\n代码块如下所示：\n\n```cpp\np->prior-next=p->next; //仔细观察，删除节点p对外指向的指针不需要变动\np->next->prior=p->prior;//主要变动指向节点p的指针，即ai-1->next和ai+1->prior\nfree(p);\n```\n\n### 2.1移除链表元素\n\n**题意**：删除链表中等于给定值 val 的所有节点\n\n注意：对于含头结点的节点删除，第一个节点的操作与其他节点的操作是一致的；对于不含头结点的节点删除，删除第一个节点的操作就是头指针后移+第一个节点内存释放。下面是cpp代码示例。\n\n**直接使用原来的链表进行节点删除操作**\n\n```cpp\nListNode* removeElements(ListNode* head, int val) {\n// 删除头结点\nwhile (head != NULL && head->val == val) { // 注意这里不是if\n	ListNode* tmp = head;\n	head = head->next;\n	delete tmp;\n}\n// 删除非头结点\nListNode* cur = head;\nwhile (cur != NULL && cur->next!= NULL) {\n	if (cur->next->val == val) {\n		ListNode* tmp = cur->next;\n		cur->next = cur->next->next;\n		delete tmp;\n} else {\n	cur = cur->next;\n	}\n}\nreturn head;\n}\n```\n\n**直接使用原来的链表进行节点删除操作**\n\n```cpp\nListNode* removeElements(ListNode* head, int val) {\n	ListNode* dummyHead = new ListNode(0); // 设置一个虚拟头结点\n	dummyHead->next = head; // 将虚拟头结点指向head，这样方面后面做删除操作\n	ListNode* cur = dummyHead;\n	while (cur->next != NULL) {\n		if(cur->next->val == val) {\n			ListNode* tmp = cur->next;\n			cur->next = cur->next->next;\n			delete tmp;\n		} else {\n			cur = cur->next;\n		}\n	}\n	head = dummyHead->next;\n	delete dummyHead;\n	return head;\n}\n```\n\n### 2.2 设计链表\n\n**题意**：设计一个基本的链表类，它应当具有以下功能：\n\n+ `get(index)`：获取链表中第index个节点的值。如果索引无效，则返回-1。\n+ `addAtHead(val)`：在链表的第一个元素之前添加一个值为val的节点。插入后，新节点将成为链表的第一个节点。\n+ `addAtTail(val)`：将值为val的节点追加到链表的最后一个元素。\n+ `addAtIndex(index,val)`：在链表中的第index个节点之前添加值为val的节点。如果index等于链表的长度，则该节点将附加到链表的末尾。如果index大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。\n+ `deleteAtIndex(index)`：如果索引index有效，则删除链表中的第index个节点。\n\n示例：\n\n<div align=center>\n<img src = \'https://s3.bmp.ovh/imgs/2023/03/24/ee4506ef4a51361b.png\' >\n</div>\n\n\n这道题目设计链表的五个接口：\n\n+ 获取链表第index个节点的数值\n+ 在链表的最前面插入一个节点\n+ 在链表的最后面插入一个节点\n+ 在链表第index个节点前面插入一个节点\n+ 删除链表的第index个节点\n\n可以说这五个接口，已经覆盖了链表的常见操作，是练习链表操作非常好的一道题目。\n\n**链表操作的两种方式**\n\n1.	直接使用原来的链表进行操作\n2.	设置一个虚拟的头结点在进行操作\n\n下面分别是cpp和C语言的链表设计：\n\n```cpp\n/*************cpp实现链表设计****************/\nclass MyLinkedList {\npublic:\n// 定义链表节点结构体\nstruct LinkedNode {\n	int val;\n	LinkedNode* next;\n	LinkedNode(int val):val(val), next(nullptr){}\n};\n// 初始化链表\nMyLinkedList() {\n	_dummyHead = new LinkedNode(0); // 这里定义的头结点是一个虚拟头结点，而不是真正的链表头结点\n	_size = 0;\n}\n// 获取到第index个节点数值，如果index是非法数值直接返回-1， 注意index是从0开始的，第0个节点就是头结点\nint get(int index) {\n	if (index > (_size - 1) || index < 0) {\n		return -1;\n	}\n	LinkedNode* cur = _dummyHead->next;\n	while(index--){ // 如果--index 就会陷入死循环\n		cur = cur->next;\n	}\n	return cur->val;\n}\n// 在链表最前面插入一个节点，插入完成后，新插入的节点为链表的新的头结点\nvoid addAtHead(int val) {\n	LinkedNode* newNode = new LinkedNode(val);\n	newNode->next = _dummyHead->next;\n	_dummyHead->next = newNode;\n	_size++;\n}\n// 在链表最后面添加一个节点\nvoid addAtTail(int val) {\n	LinkedNode* newNode = new LinkedNode(val);\n	LinkedNode* cur = _dummyHead;\n	while(cur->next != nullptr){\n		cur = cur->next;\n	}\n	cur->next = newNode;\n	_size++;\n}\n// 在第index个节点之前插入一个新节点，例如index为0，那么新插入的节点为链表的新头节点。\n// 如果index 等于链表的长度，则说明是新插入的节点为链表的尾结点\n// 如果index大于链表的长度，则返回空\n// 如果index小于0，则在头部插入节点\nvoid addAtIndex(int index, int val) {\n	if(index > _size) return;\n	if(index < 0) index = 0;        \n	LinkedNode* newNode = new LinkedNode(val);\n	LinkedNode* cur = _dummyHead;\n	while(index--) {\n	cur = cur->next;\n	}\n	newNode->next = cur->next;\n	cur->next = newNode;\n	_size++;\n}\n//删除第index个节点，如果index大于等于链表的长度，直接return，注意index是从0开始的\nvoid deleteAtIndex(int index) {\n	if (index >= _size || index < 0) {\n		return;\n	}\n	LinkedNode* cur = _dummyHead;\n	while(index--) {\n		cur = cur ->next;\n	}\n	LinkedNode* tmp = cur->next;\n	cur->next = cur->next->next;\n	delete tmp;\n	_size--;\n}\n\n// 打印链表\nvoid printLinkedList() {\n	LinkedNode* cur = _dummyHead;\n	while (cur->next != nullptr) {\n		cout << cur->next->val << \" \";\n		cur = cur->next;\n	}\n	cout << endl;\n}\nprivate:\n	int _size;\n	LinkedNode* _dummyHead;\n};\n```\n\n下面是用C语言来实现链表：\n\n```c\n/*************C语言实现链表设计****************/\ntypedef struct MyLinkedList {\n	int val;\n	struct MyLinkedList* next;\n}MyLinkedList;\n/**在这里初始化你的结构体数据**/\nMyLinkedList* myLinkedListCreate() {\n//这个题必须用虚拟头指针,参数都是一级指针,头节点确定后没法改指向了!!!\n	MyLinkedList* head = (MyLinkedList *)malloc(sizeof (MyLinkedList));\n	head->next = NULL;\n	return head;\n}\n/**根据索引获取到链表的值**/\nint myLinkedListGet(MyLinkedList* obj, int index) {\n	MyLinkedList *cur = obj->next;\n	for (int i = 0; cur != NULL; i++){\n		if (i == index){\n			return cur->val;\n		}\n		else{\n			cur = cur->next;\n		}\n	}\n	return -1;\n}\n/**在头节点前添加新节点**/\nvoid myLinkedListAddAtHead(MyLinkedList* obj, int val) {\n	MyLinkedList *nhead = (MyLinkedList *)malloc(sizeof (MyLinkedList));\n	nhead->val = val;\n	nhead->next = obj->next;\n	obj->next = nhead;\n}\n/**在尾部插入新节点**/\nvoid myLinkedListAddAtTail(MyLinkedList* obj, int val) {\n	MyLinkedList *cur = obj;\n	while(cur->next != NULL){\n		cur = cur->next;\n	}\n	MyLinkedList *ntail = (MyLinkedList *)malloc(sizeof (MyLinkedList));\n	ntail->val = val;\n	ntail->next = NULL;\n	cur->next = ntail;\n}\n/**在指定索引节点后插入，如果索引值为0表示头插，如果索引值大于长度就插入无效*/\nvoid myLinkedListAddAtIndex(MyLinkedList* obj, int index, int val) {\n	if (index == 0){\n		myLinkedListAddAtHead(obj, val);\n		return;\n	}\n	MyLinkedList *cur = obj->next;\n	for (int i = 1 ;cur != NULL; i++){\n		if (i == index){\n			MyLinkedList* newnode = (MyLinkedList *)malloc(sizeof (MyLinkedList));\n			newnode->val = val;\n			newnode->next = cur->next;\n			cur->next = newnode;\n			return;\n		}\n		else{\n			cur = cur->next;\n		}\n	}\n}\n/** 按索引来删除节点，删除索引值后的一个节点 **/\nvoid myLinkedListDeleteAtIndex(MyLinkedList* obj, int index) {\n	if (index == 0){\n		MyLinkedList *tmp = obj->next;\n		if (tmp != NULL){\n			obj->next = tmp->next;\n			free(tmp);     \n	 	}\n		return;\n	}\n	MyLinkedList *cur = obj->next;\n	for (int i = 1 ;cur != NULL && cur->next != NULL; i++){\n		if (i == index){\n			MyLinkedList *tmp = cur->next;\n			if (tmp != NULL) {\n				cur->next = tmp->next;\n				free(tmp);\n			}\n			return;\n		}\n		else{\n			cur = cur->next;\n		}\n	}\n}\nvoid myLinkedListFree(MyLinkedList* obj) {\n	while(obj != NULL){\n		MyLinkedList *tmp = obj;\n		obj = obj->next;\n		free(tmp);\n	}\n}\n/**\n *你可以如此调用你的程序:\n * MyLinkedList* obj = myLinkedListCreate();\n * int param_1 = myLinkedListGet(obj, index);\n * myLinkedListAddAtHead(obj, val);\n * myLinkedListAddAtTail(obj, val);\n * myLinkedListAddAtIndex(obj, index, val);\n * myLinkedListDeleteAtIndex(obj, index);\n * myLinkedListFree(obj);\n*/\n```\n\n### 2.3 翻转链表\n\n**题意**：翻转链表，即输入：1->2->3->4->5->NULL 输出: 5->4->3->2->1->NULL\n**思路**：关键在于链表next指针的翻转。\n\n<div align=center>\n<img src = \'https://s3.bmp.ovh/imgs/2023/03/24/abb4acd8d087c152.png\' >\n</div>\n\n+ 首先定义一个cur指针，指向头结点，再定义一个pre指针，初始化为null。\n+ 然后就要开始反转了，首先要把 cur->next 节点用tmp指针保存一下，也就是保存一下这个节点。\n+ 为什么要保存一下这个节点呢，因为接下来要改变 cur->next 的指向了，将cur->next 指向pre ，此时已经反转了第一个节点了。\n+ 接下来，就是循环走如下代码逻辑了，继续移动pre和cur指针。\n+ 最后，cur 指针已经指向了null，循环结束，链表也反转完毕了。 此时我们return pre指针就可以了，pre指针就指向了新的头结点。\n\n<font color=\'orange\'>==1）下面是cpp双指针法的代码实现==</font>：\n\n```cpp\nListNode* reverseList(ListNode* head) {\n	ListNode* tmp; //保存cur的下一个节点\n	ListNode* cur = head;\n	ListNode* pre = NULL;\n	while(cur) {\n	tmp = cur->next;\n	cur->next = pre; 	// 翻转操作\n	pre = cur;\n	cur = tmp;\n	}\n	return pre;\n}\n```\n\n<font color=\'orange\'>==2）下面是cpp递归法的实现==</font>：\n\n递归法相对抽象一些，但是其实和双指针法是一样的逻辑，同样是当cur为空的时候循环结束，不断将cur指向pre的过程。\n关键是初始化的地方，可能有的同学会不理解，可以看到双指针法中初始化 cur = head，pre = NULL，在递归法中可以从如下代码看出初始化的逻辑也是一样的，只不过写法变了。**双指针法写出来之后，理解如下递归写法就不难了，代码逻辑都是一样的**。\n\n```cpp\nListNode* reverse(ListNode* pre,ListNode* cur) {\n	if(cur == NULL) return pre;\n	ListNode *tmp = cur->next;\n	cur->next = pre;\n	return reverse(cur,tmp);\n}\nListNode* reverseList(ListNode* head) {\n	return reverse(NULL,head);\n}\n```\n\n我们可以发现，上面的递归写法和双指针法实质上都是从前往后翻转指针指向，其实还有另外一种与双指针法不同思路的递归写法：从后往前翻转指针指向。\n\n<font color=\'orange\'>==3）下面是从后往前翻转指针指向(十分精巧)==</font>：\n\n```cpp\nListNode* reverseList() {\n	//边缘条件检测\n	if(head == NULL) return NULL;\n	if(head->next == NULL ) return head;\n	//递归调用\n	ListNode* last = reverseList(head->next);\n	head->next->next = head;\n	head->next = NULL;\n	return last;\n}\n```\n\n<font color=\'orange\'>==4）是用虚拟节点和头插法来解决链表翻转问题（不需要栈）==</font>：\n\n```cpp\nListNode* reverseList(ListNode* head) {\n	ListNode* dumpyHead = new ListNode(-1);\n	dumpyHead->next = NULL;\n	ListNode* cur = head;\n	while(cur!=NULL) {\n		ListNode* tmp = cur->next;\n		//头插法：把第一个节点拆下来，插在虚拟头结点后头；把第二个节点拆下来，再插在虚拟头结点后头。就实现节点1和2的翻转，后面的类似操作即可。\n		//感觉和双指针法差不多，cur指向当前，tmp保存cur->next，然后cur指向pre，最后pre由cur更新，cur由tmp更新。而这里的虚拟头插法相当于把pre换成了虚拟头dumptHead。\n		cur->next = dumpyHead->next;\n		dumpyHead ->next = cur;\n		cur = tmp;\n	}\n	return dumpyHead ->next;\n}\n```\n\n<font color=\'orange\'>==5）使用栈来解决链表翻转问题（本质也是和递归一样的）==</font>：\n\n首先把所有节点入栈，然后cur指向虚拟头结点，再然后循环出栈，每出来一个元素就把它加入到虚拟头结点为头结点的链表当中，最后返回即可。\n\n**采用这种方法需要注意一点。就是当整个出栈循环结束以后，cur正好指向原来链表的第一个结点，而此时结点1中的next指向的是结点2，因此最后还需要`cur.next = null`**。\n\n<div align=center>\n<img src = \'https://s3.bmp.ovh/imgs/2023/03/24/f35d9150f6961bd6.png\' >\n</div>\n\n\n![](https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlHgdz7m76yDUi9PH/root/content)\n\n**注意**：代码随想录的上述原代码在力扣实际测试时，有些问题，更正为上述代码后正常运行（实际上网站提供的是Java代码，我改成了cpp，所以有些方法名不对头）。例如在STL中的栈名字叫stack而非Stack，且没有isEmpty()方法而是empty()方法。此外第三点就是pop()方法的返回值是void，要想获取栈顶值应当使用top()方法，在使用pop()方法弹出元素。\n\n### 2.4 两两交换链表中的节点\n\n**题目**：给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。*你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换*。\n\n示例：\n\n<div align=center>\n<img src = \'https://s3.bmp.ovh/imgs/2023/03/24/a14cd19641a753e9.png\' >\n</div>\n\n对于输入head=[1,2,3,4],输出为[2,1,4,3]\n\n**思路**：建议使用虚拟头结点，这样会方便很多，要不然每次针对头结点（没有前一个指针指向头结点），还要单独处理。\n![两两交换链表中的节点--程序设计示意图](https://s3.bmp.ovh/imgs/2023/03/24/c5275104b2c0b5f5.png)\n\n仔细分析上述示意图，可以知道至少需要两个tmp临时指针来保存节点指针才能正确实现“每两个节点进行一次互换”的操作，cpp代码如下：\n\n```cpp\nListNode* swapPairs(ListNode* head) {\n	ListNode* dummyHead = new ListNode(0);\n	dummyHead->next = head;\n	ListNode* cur = dummyHead;//设置虚拟节点，并为cur指针赋初始值\n	while (cur->next!=NULL&&cur->next->next!=NULL) {\n		ListNode* tmp = cur->next; //cur后的第一个节点\n		ListNode* tmp2 = cur->next->next->next;//cur后的第三个节点\n		\n		cur->next = cur->next->next; //步骤一\n		cur->next->next = tmp; //步骤二\n		cur->next->next->next = tmp2; //步骤三\n		\n		cur = cur->next->next;\n	}\n	return dummyHead->next;\n	//时间复杂度O(n)，空间复杂度O(1)\n}\n```\n\n【关于<font color=\"red\">递归</font>】\n\n在代码随想录二叉树递归遍历那一章，讲了一下递归的三要素：\n\n1. **确定递归函数的参数和返回值**： 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。\n\n2. **确定终止条件**： 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。\n\n3. **确定单层递归的逻辑**： 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。\n\n下面以本次两两交换链表中的节点为例，再来强化一遍。本次递归程序设计中，1）递归的参数和返回值都是链表头指针。2）终止条件就是链表访问结束，有NULL。就是cur->next和cur->next->next为NULL。3）单层递归的逻辑，就是每两个节点为一对，1）本对的第一个节点指向下一对，2）对内，第二个节点指向第一个节点，3）第二个节点坐标作为一个结构体返回。下图是程序设计示意图。\n\n![程序设计示意图](https://s3.bmp.ovh/imgs/2023/03/24/67a571af0d281e5a.png)\n\nC语言实现两两交换链表中的节点（递归版本)\n\n```c\n//单链表的格式为：\ntypedef struct node {\n	int val;\n	struct node *next;\n}ListNode;\n//递归版本 （该代码认为链表没有头结点，第一个head节点就是有效节点）\nListNode* swapPairs(ListNode* head) {\n//递归结束条件：头节点不存在或头节点的下一个节点不存在。此时不需要交换，直接返回head\n	if (!head || !head->next)\n		return head;\n	//创建一个节点指针类型保存头结点下一个节点\n	ListNode* newHead = head->next;\n	//更改头结点+2位节点后的值，并将头结点的next指针指向这个更改过的list\n	head->next = swapPairs(newHead->next);\n	//将新的头结点的next指针指向老的头节点\n	newHead->next = head;\n	return newHead;\n}\n```\n\nC语言实现两两交换链表中的节点（迭代版本）\n\n```c\n//迭代版本\nstruct ListNode* swapPairs(struct ListNode* head){\n    //使用双指针避免使用中间变量\n    typedef struct ListNode ListNode;\n    ListNode *fakehead = (ListNode *)malloc(sizeof(ListNode));\n    fakehead->next = head;\n    ListNode* right = fakehead->next;\n    ListNode* left = fakehead;\n    while(left && right && right->next ){\n        left->next = right->next;\n        right->next = left->next->next;\n        left->next->next = right;\n        left = right;\n        right = left->next;\n    }\n    return fakehead->next;\n}\n```\n\n### 2.5 删除链表的倒数第N个节点\n\n**题意**：删除链表的倒数第N个节点\n\n**思路**：采用双指针的方法来实现：定义两个指针，fast指针先走N+1步，然后slow指针再走。当fast指针走到NULL时，slow指针刚好就在待删除节点的前一个节点。\n\n### 2.6 链表相交\n\n**题意**：给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。\n\n题目数据 保证 整个链式结构中不存在环。注意，函数返回结果后，链表必须 保持其原始结构 。图示两个链表在节点 c1 开始相交：\n![](https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlEiHrW36nF7-bhD4/root/content)\n**思路**：采用双指针的方法来解决，考虑到两链表相交一定是在后面有相同点，所以1）将两链表尾端对齐，2）然后长链表的指针移动（两个链表长度之差的）距离，3）循环，判断什么时候两指针相等。此时我们就可以比较curA和curB是否相同，如果不相同，同时向后移动curA和curB，如果遇到curA == curB，则找到交点。如果`curA == NULL`则说明链表不相交思路如下图所示：\n\n![链表相交的思路](https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlEn2uZpsaGxK5jgn/root/content)\n\ncpp代码示例：\n\n```cpp\nListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        ListNode* curA = headA;\n        ListNode* curB = headB;\n        int lenA = 0, lenB = 0;\n        while (curA != NULL) { // 求链表A的长度\n            lenA++;\n            curA = curA->next;\n        }\n        while (curB != NULL) { // 求链表B的长度\n            lenB++;\n            curB = curB->next;\n        }\n        curA = headA;\n        curB = headB;\n        // 让curA为最长链表的头，lenA为其长度\n        if (lenB > lenA) {\n            swap (lenA, lenB);\n            swap (curA, curB);\n        }\n        // 求长度差\n        int gap = lenA - lenB;\n        // 让curA和curB在同一起点上（末尾位置对齐）\n        while (gap--) {\n            curA = curA->next;\n        }\n        // 遍历curA 和 curB，遇到相同则直接返回\n        while (curA != NULL) {\n            if (curA == curB) {\n                return curA;\n            }\n            curA = curA->next;\n            curB = curB->next;\n        }\n        return NULL;\n    }\n```\n\n注意：时间复杂度是O(m+n)\n\n### 2.7 环形链表2\n\n**题意**：环形链表2，这题是给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。为了表示给定链表中的环，使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。【给定一个链表，判断是否有环，有环的话返回环的入口节点地址】\n\n**说明**：不允许修改给定的链表\n\n**示例**：输入：head = [3,2,0,-4], pos = 1 ; 输出 tail connects to node index 1 ; 解释：链表中有一个环，其尾部连接到第二个节点。本示例的图示如下：\n\n![示例](https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlEpR5iFQiiqqWqzH/root/content)\n\n**思路**：这道题不仅要考链表操作，还考察数学运算。主要考察两个知识点：\n\n+  判断链表是否有环；\n+  如果有环，如何找到这个环的入口\n\n1）**判断链表是否有环**\n\n方法：可以使用快慢指针法，分别定义 fast 和 slow 指针，从头结点出发，fast指针每次移动两个节点，slow指针每次移动一个节点，如果 fast 和 slow指针在途中相遇 ，说明这个链表有环。\n\n原理：首先第一点：**fast指针一定先进入环中，如果fast指针和slow指针相遇的话，一定是在环中相遇，这是毋庸置疑的**。其实相对于slow来说，**fast是一个节点一个节点的靠近slow的，所以fast一定可以和slow重合**。\n\n![双指针法：判断是否有环](https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlEyj6F0jegrnBGxW/root/content)\n\n2）**如果有环，如何找到这个环的入口** （要用到数学知识了）\n\n**方法&&原理**：假设从头结点到环形入口节点 的节点数为x。 **环形入口**节点到 fast指针与slow指针**相遇节点**节点数为y。 从相遇节点 再到环形入口节点节点数为 z。 如图所示：\n\n![](https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlE0iChKekHjyQs1F/root/content)\n\n那么相遇时：slow指针走过的节点数位`x+y`，fast指针走过的节点数为：`x+y+n(y+z)`，n为fast指针在环内走了n圈才遇到slow指针， （y+z）为 一圈内节点的个数A。因为fast指针是一步走两个节点，slow指针一步走一个节点， 所以 fast指针走过的节点数 = slow指针走过的节点数 * 2：\n\n                                        `(x+y)*2 = x+y+n(y+z)`\n\n两边消掉一个`(x+y)`：即：`x+y = n (y+z)`\n\n因为要找环形的入口，那么要求的是x，因为x表示 头结点到 环形入口节点的的距离。\n\n所以要求x ，将x单独放在左面：x = n (y + z) - y ,\n\n再从n(y+z)中提出一个 （y+z）来，整理公式之后为如下公式：x = (n - 1) (y + z) + z 注意这里n一定是大于等于1的，因为 fast指针至少要多走一圈才能相遇slow指针。\n\n这个公式说明什么呢？\n\n**情况1）**：先拿n为1的情况来举例，意味着fast指针在环形里转了一圈之后，就遇到了 slow指针了。当 n为1的时候，公式就化解为 x = z，这就意味着，**从头结点出发一个指针，从相遇节点 也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是 环形入口的节点**。\n\n也就是在相遇节点处，定义一个指针index1，在头结点处定一个指针index2。让index1和index2同时移动，每次移动一个节点， 那么他们相遇的地方就是 环形入口的节点。如下面的动图所示：\n\n![](https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlE7bx0qLRJ9_JVDz/root/content)\n\n**情况2）**：那么 n如果大于1是什么情况呢，就是fast指针在环形转n圈之后才遇到 slow指针。\n\n其实这种情况和n为1的时候 效果是一样的，一样可以通过这个方法找到 环形的入口节点，只不过，index1 指针在环里 多转了(n-1)圈，然后再遇到index2，相遇点依然是环形的入口节点。\n\n代码如下：\n\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        ListNode* fast = head;\n        ListNode* slow = head;\n        while(fast != NULL && fast->next != NULL) {\n            slow = slow->next;\n            fast = fast->next->next;\n            // 快慢指针相遇，此时从head 和 相遇点，同时查找直至相遇\n            if (slow == fast) {\n                ListNode* index1 = fast;\n                ListNode* index2 = head;\n                while (index1 != index2) {\n                    index1 = index1->next;\n                    index2 = index2->next;\n                }\n                return index2; // 返回环的入口\n            }\n        }\n        return NULL;\n    }\n};\n```\n\n**补充**：\n\n在推理过程中，大家可能有一个疑问就是：为什么第一次在环中相遇，slow的步数是 x+y 而不是 x + 若干环的长度 + y 呢？\n\n首先slow进环的时候，fast一定是先进环来了。如果slow进环入口，fast也在环入口，那么把这个环展开成直线，就是如下图的样子：\n\n![](https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlE_T1DmcUQ4sVEFJ/root/content)\n\n可以看出如果slow 和 fast同时在环入口开始走，一定会在环入口3相遇，slow走了一圈，fast走了两圈。重点来了，slow进环的时候，fast一定是在环的任意一个位置，如图：\n\n![](https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlFDmQaMBFYVeFEDo/root/content)\n\n那么fast指针走到环入口3的时候，已经走了k + n 个节点，slow相应的应该走了(k + n) / 2 个节点。\n\n因为k是小于n的（图中可以看出），所以(k + n) / 2 一定小于n。\n\n也就是说slow一定没有走到环入口3，而fast已经到环入口3了。\n\n这说明什么呢？\n\n在slow开始走的那一环已经和fast相遇了。\n\n那有同学又说了，为什么fast不能跳过去呢？ 在刚刚已经说过一次了，fast相对于slow是一次移动一个节点，所以不可能跳过去。\n\n### 2.8 总结篇\n\n在本章，主要讲了链表的基础知识，讲了链表的基本构造，还有移除链表元素、翻转链表（双指针法或递归法）、两两交换链表中的节点、删除链表的倒数第N个节点、链表相交（双指针法）、环形链表2等题目。上述问题都能通过双指针法解决：\n\n+ ** 翻转链表**：一个cur指向当前指针，一个pre在前一个指针，还需要tmp指针记录下一次cur跳转的位置。趁cur指向还没改变，先记录tmp即cur的下一跳。然后，原来是pre指向cur的，现在将cur指向pre即可，最后给cur、pre赋值，进行下一次循环；\n+ **两两交换链表中的节点**：两两个节点一对来进行操作，但是为了和下一对联系起来，实际上操作时需要有三个节点参与。同时需要两个临时指针来记录节点1和节点3的地址。\n\n```cpp\ntmp1 = cur->next;\ntmp2 = cur->next->next->next;\ncur->next = cur->next->next;\ncur->next->next = tmp1;\ncur->next->next->next = tmp2;\n```\n\n+ **删除链表的倒数第N个节点**：双指针法，让fast指针先出发N+1步，然后slow指针再出发。当fast到达NULL时，slow刚好就在待删除节点的前一个位置；\n+ **链表相交**：先求两个链表的长度，然后链表尾端对齐。长链表那个指针先移动两个链表长度之差的步数，然后两个链表指针在同时移动。当两个链表指针相等时，即为找到相交节点地址了；\n+ **环形链表2**：思路是fast指针每次走两步，slow指针每次走一步，如果他两相遇了则存在环。然后，指针index1从头结点出发，指针index2从相遇节点出发，他们两个的再次相遇点就是环的入口节点地址了。\n\n另外，对于**反转链表**问题，建议先学透迭代法，然后再看递归法，因为递归法比较绕，如果迭代还写不明白，递归基本也写不明白了。\n\n最后，下图是对上述知识点的总结：\n\n![](https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlFEAlN4E-tIPYtjg/root/content)\n\n## 三、哈希表\n\n### 3.1 哈希表的理论基础\n\n哈希表，又或称散列表，它是**根据关键码的值而直接进行访问的数据结构**。它主要解决的问题就是元素的快速搜索，用来快速判断一个元素是否出现集合里。直白来讲，数组就是一张哈希表，哈希表的关键码就是数组索引下标，然后通过下标来直接访问数组元素。然后，将元素值映射到哈希表上与特定的关键码对应，就用到了**哈希函数**。\n\n特点：查找元素的速度很快，但是牺牲了空间来换取时间。\n\n哈希函数与哈希碰撞，哈希碰撞的解决方法有：拉链法和线性探测法。拉链法：多个元素在一个哈希值上冲突，就把这多个元素做成一个链表插在该位置上；线性探测法：当前位置冲突了，就顺次找下一个不冲突的位置，这种方法就要求哈希表长度必须大于数据个数才行。（略）\n\n常见的哈希结构：当我们想使用哈希法来解决问题的时候，我们一般会选择如下三种数据结构。\n\n+ 数组\n+ set集合\n+ map映射\n\n这里数据就没啥好说的了，我们来看看set和map。在cpp中，set 和 map 分别提供以下三种数据结构，其底层实现以及优劣如下表所示：\n\n| 集合               | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 | 增删效率 |\n| ------------------ | -------- | -------- | ---------------- | ------------ | -------- | -------- |\n| std::set           | 红黑树   | 有序     | 否               | 否           | O(log n) | O(log n) |\n| std::multiset      | 红黑树   | 有序     | 是               | 否           | O(logn)  | O(logn)  |\n| std::unordered_set | 哈希表   | 无序     | 否               | 否           | O(1)     | O(1)     |\n\nstd::unordered_set底层实现为哈希表，std::set 和std::multiset 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。\n\n| 映射               | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 | 增删效率 |\n| ------------------ | -------- | -------- | ---------------- | ------------ | -------- | -------- |\n| std::map           | 红黑树   | key有序  | key不可重复      | key不可修改  | O(logn)  | O(logn)  |\n| std::multimap      | 红黑树   | key有序  | key可重复        | key不可修改  | O(log n) | O(log n) |\n| std::unordered_map | 哈希表   | key无序  | key不可重复      | key不可修改  | O(1)     | O(1)     |\n\nstd::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）\n\n当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset。\n\n那么再来看一下map ，在map 是一个key value 的数据结构，map中，对key是有限制，对value没有限制的，因为key的存储方式使用红黑树实现的。\n\n其他语言例如：java里的HashMap ，TreeMap 都是一样的原理。可以灵活贯通。\n\n虽然std::set、std::multiset 的底层实现是红黑树，不是哈希表，std::set、std::multiset 使用红黑树来索引和存储，不过给我们的使用方式，还是哈希法的使用方式，即key和value。所以使用这些数据结构来解决映射问题的方法，我们依然称之为哈希法。 map也是一样的道理。\n\n这里在说一下，一些cpp的经典书籍上 例如STL源码剖析，说到了hash_set hash_map，这个与unordered_set，unordered_map又有什么关系呢？\n\n实际上功能都是一样一样的， 但是unordered_set在cpp11的时候被引入标准库了，而hash_set并没有，所以建议还是使用unordered_set比较好，这就好比一个是官方认证的，hash_set，hash_map 是cpp11标准之前民间高手自发造的轮子。\n\n![](https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlFLHzQIWbM3ru_iG/root/content)\n\n总结一下，**当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法**。\n\n但是哈希法也是**牺牲了空间换取了时间**，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。\n\n如果在做面试题目的时候遇到需要判断一个元素是否出现过的场景也应该第一时间想到哈希法！\n\n### 3.2 有效的字母异位词\n\n**题意**：给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。示例 1: 输入: s = \"anagram\", t = \"nagaram\" 输出: true。示例 2: 输入: s = \"rat\", t = \"car\" 输出: false。**说明**: 你可以假设字符串只包含小写字母。【字母异位词，即字母的种类和个数全部相同，只是字母的位置不相同的两个单词，可以用哈希表或map存储起来比较，得出结论】\n\n**思路**：1）暴力解法就是两层for循环；2）**数组其实就是一个简单哈希表**，而且这道题目中字母串只有小写字符，那么就可以定义一个数组record，来记录字符串s中字符的出现次数，定义数组长度为26。例如：对于字符串a=\"aea\"，有record[0]=2,record[4]=1；同样的，对于字符串b=\"eaa\"，也有record[0]=2,record[4]=1。所以字符串a和b是字母异位词。\n\n**步骤**：1）不需要记住具体是哪个字符a-z，只需要判断字符的相对位置，定义数组record[26]，字符\'a\'对应record[0]，字符record[25]对应\'z\'。2）在遍历字符串a时，只需要将record[a[i]-\'a\']元素值+1即可，并不需要记住字符a的ASCII值。这样就把字符串a中字符出现的次数统计出来了。\n\n3）在遍历字符串b，将record[b[i]-\'a\']的值-1，如果每一个数组元素的值不为0，那就是某个位多了一个字符或少了一个字符，则返回false，如果每一个数组元素都为0，满足题意返回true。\n\ncpp代码块如下所示：\n\n```cpp\nbool isAnagram(string s, string t) {\n    int record[26] = {0};\n    for (int i = 0; i < s.size(); i++) {\n        // 并不需要记住字符a的ASCII，只要求出一个相对数值就可以了\n        record[s[i] - \'a\']++;\n    }\n    for (int i = 0; i < t.size(); i++) {\n    	record[t[i] - \'a\']--;\n    }\n    for (int i = 0; i < 26; i++) {\n    	if (record[i] != 0) {\n// record数组如果有的元素不为零0，说明字符串s和t 一定是谁多了字符或者谁少了字符。\n    	return false;\n    	}\n    }\n// record数组所有元素都为零0，说明字符串s和t是字母异位词\n    return true;\n}\n```\n\n### 3.3 两个数组的交集\n\n**题意**：编写一个函数，来判断两个数组的交集。注意：输出结果中的每个元素应当是唯一的，且不考虑输出结果的顺序。举例：输入nums1=[1,2,2,1]，nums2=[2,2]，输出：[2]；举例2：nums1=[4,9,5]，nums2=[9,4,9,8,4]，输出：[9,4]。\n\n**思路**：注意：前一题使用数组来做哈希表是因为题目限定了数值的大小，元素最大不会超过26。但是这里的话，1）**数值没有明显边界**，不建议使用数组。2）其次，**如果哈希值比较少、特别分散、跨度特别大**，也无法使用数组来做哈希表。\n\n此时就要使用另一种结构体了，set ，关于set，cpp 给提供了如下三种可用的数据结构：\n\n+ std::set\n+ std::multiset\n+ std::unordered_set\n\nstd::set和std::multiset底层实现都是红黑树，std::unordered_set的底层实现是哈希表， 使用unordered_set 读写效率是最高的，并不需要对数据进行排序，而且还不要让数据重复，所以选择unordered_set。这里主要是学会使用一种哈希数据结构：**unordered_set**。该数据结构无序、不允许重复。\n\n思路如下图所示：\n\n![](https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlFN3LVBY8kwU0hs1/root/content)\n\n```cpp\nVector<int> intersection(vector<int>& nums1, vecotr<int>& nums2) {\n	unordered_set<int> result_set; //存放结果，之所以用unordered_set是为了去重\n	//第一步，将nums1将存入unordered_set中，这里是使用迭代器构造\n	unordered_set<int> nums_set(nums1.begin(),nums1.end());\n	//第二步，比较unordered_set和nums2\n	for (int num : nums2) {\n		if (nums_set.find(num) != nums_set.end()) {\n			result_set.insert(num);\n		}\n	}\n	return vector<int>(result_set.begin(),result_set.end());\n}\n```\n\n无序集合unordered_set内部元素不可重复，没有顺序，值也不可修改。对于无序集合unordered_set，有以下几种初始化方法：\n\n+ 直接创建空的set：`unordered_set<int> set1;`\n+ 拷贝构造：`unordered_set<int> set2(set1);`\n+ 使用迭代器构造：`unordered_set<int> set3(set1.begin(),set1.end());`\n+ 使用数组作为其初始值进行构造：`unordered_set<int> set4(arr,arr+5);`\n+ 移动构造：`unordered_set<int> set5(move(set2));`\n+ 使用初值列表来进行构造：`unordered_set<int> set6 {1,2,10,10};`\n\n**注意**：学到这，我们已经学习了unordered_set和数组两种哈希数据结构，但是要注意各自存在的缺点，数组对数据的长度有限制，且对于分布离散的数据而言存取效率低。而unordered_set内部元素不重复，不排序，十分适合需要数据去重的情况。但是相对于数组而言，不仅占用空间比数组大，而且速度要比数组慢，set把数值映射到key上都要做hash计算的。\n\n**说明**：后来力扣改了数据，对数组的长度做了限制，数据长度在0~1000，所以可以考虑用数组来做哈希算法。\n\n```cpp\nvector<int> intersection(vector<int>&nums1,vector<int>&nums2) {\n	unordered_set<int> result_set; //选择set是为了去重\n	int hash[1005]={0};\n	for (int num : nums1) {\n		hash[num] = 1;\n	}\n	for (int num : nums2) {\n		if (hash[num] == 1) {\n			result_set.insert(num);\n		}\n	}\n	return vector<int>(result_set.begin(),result_set.end());\n}\n```\n\n### 3.4 快乐数\n\n**题意**:编写一个算法来判断一个数是不是快乐数。**快乐数**：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为  1，那么这个数就是快乐数。\n\n如果是快乐数就返回True，否则返回False。\n\n**示例**：\n`输入`：19\n`输出`：true\n`解释`：\n1^2 + 9^2 = 82\n8^2 + 2^2 = 68\n6^2 + 8^2 = 100\n1^2 + 0^2 + 0^2 = 1\n\n**思路**:这道题目看上去貌似一道数学问题，其实并不是！题目中说了会**无限循环**，那么也就是说**求和的过程中，sum会重复出现，这对解题很重要**！\n\n难点1）判断一个数是否重复出现？难点2）就是对一个数每个位上的操作，求和的过程。\n\n**当我们遇到需要快速判断一个元素是否存在与一个集合中时，就要用到哈希算法了**。所以这道题目使用哈希法，来判断这个sum是否重复出现，如果重复了就是return false， 否则一直找到sum为1为止。\n\n```cpp\n//求每个位上的单数之和\nint getSum(int n) {\n	int sum = 0;\n	while (n) {\n		sum += (n % 10)*(n % 10);\n		n /= 10;\n	}\n	return sum;\n}\n\nbool isHappy(int n) {\n	unordered_set<int> set;\n	int n_temp = n;\n	while(1) {\n		int sum = getSum(n_temp);\n		if (sum == 1) {\n			return true;\n		}\n        // 如果这个sum曾经出现过，说明已经陷入了无限循环了，立即return false\n        if (set.find(sum) != set.end()) {\n            return false;\n        } else {\n            set.insert(sum);\n        }\n		n_temp = sum;\n	}\n}\n```\n\n### 3.5 两数之和\n\n**题意**:给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那**两个**整数，并返回他们的数组下标。假设每种输入只会对应一个答案。注意，数组中同一个元素不能使用两遍。例如，给定 nums = [2, 7, 11, 15], target = 9，因为 nums[0] + nums[1] = 2 + 7 = 9，所以返回 [0, 1]。\n\n在强调一下**什么时候使用哈希法**，当我们需要查询一个元素是否出现过，或者一个元素是否在集合里的时候，就要第一时间想到哈希法。\n\n本题需要一个集合来存放我们遍历过的元素，然后在遍历数组的时候去询问这个集合，某元素是否遍历过，也就是是否出现在这个集合。\n\n因为本题中不仅要知道元素的值，还要记录元素的下标索引，所以用map更加合适。\n\n再来看一下使用数组和set来做哈希法的局限。\n\n+ **数组**的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。\n+ **set**是一个集合，里面放的元素只能是一个key，而两数之和这道题目，不仅要判断y是否存在而且还要记录y的下标位置，因为要返回x 和 y的下标。所以set 也不能用。\n\ncpp中的map，有三种类型：\n\n| **映射**           | **底层实现** | **是否有序**                     | **数值是否可以重复**               | **能否更改数值** | **查询效率** | **增删效率** |\n| ------------------ | ------------ | -------------------------------- | ---------------------------------- | ---------------- | ------------ | ------------ |\n| std::map           | 红黑树       | key有序                          | key不可重复                        | key不可修改      | `O(logn)`    | `O(logn)`    |\n| std::mutilmap      | 红黑树       | key有序                          | <font color=\"red\">key可重复</font> | key不可修改      | `O(logn)`    | `O(logn)`    |\n| std::unordered_map | 红黑树       | <font color=\"red\">key无序</font> | key不可重复                        | key不可修改      | `O(1)`       | `O(1)`       |\n\n\n这道题目中并不需要key有序，选择std::unordered_map 效率更高！ \n\n接下来需要明确两点：\n\n+ **map用来做什么**\n+ **map中key和value分别表示什么**\n\nmap目的用来存放我们访问过的元素，因为遍历数组的时候，需要记录我们之前遍历过哪些元素和对应的下标，这样才能找到与当前元素相匹配的（也就是相加等于target）\n\nmap中key和value分别表示什么?这道题 我们需要处理数组的每个元素，判断这个元素是否出现过，如果出现过，返回这个元素的下标。那么判断元素是否出现，这个元素就要作为key，所以数组中的元素作为key，有key对应的就是value，value用来存下标。所以 map中的存储结构为`{key：数据元素，value：数组元素对应的下标}`。\n\n在遍历数组的时候，只需要向map去查询是否有和目前遍历元素匹配的数值，如果有，就找到的匹配对，如果没有，就把目前遍历的元素放进map中，因为map存放的就是我们访问过的元素。\n\n过程如下：\n\n![](https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlFS9JsCzF1wX-qId/root/content)\n\n![](https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlFUyAhmd6WUtK3mO/root/content)\n\n```cpp\n//注意：map的key为元素值，value为元素下标\nvector<int> twoSum(vector<int>& nums, int target) {\n	std::unordered_map <int,int> map;\n	for(int i = 0; i < nums.size(); i++) {\n		// 遍历当前元素，并在map中寻找是否有匹配的key。找到一个合适的，立即返回\n        auto iter = map.find(target - nums[i]); \n        if(iter != map.end()) {\n        	return {iter->second, i};\n		}\n		// 如果没找到匹配对，就把访问过的元素和下标加入到map中\n		map.insert(pair<int, int>(nums[i], i)); \n	}\n	//循环结束后还没return说明没找到，就返回空vector\n	return {};\n}\n```\n\n**总结**:\n本题其实有四个重点：\n\n+ 为什么会想到用哈希表\n+ 哈希表为什么用map\n+ 本题map是用来存什么的\n+ map中的key和value用来存什么的\n\n本题的目的就是从一个数组中找到两个不同的元素，要求他们的和满足target。换句话说，我们拧着一个元素，然后在map中去找`target - 元素值`，如果找到了就直接返回。如果没找到，就将当前元素值存入map，然后进入下一次循环。最终循环结束后，没有返回return，说明没找到。\n\n### 3.6 四数相加2\n\n**题意**：给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -2^28 到 2^28 - 1 之间，最终结果不会超过 2^31 - 1 。\n\n例如：\n\n输入：\n\n+ A = [ 1, 2]  B = [-2,-1]  C = [-1, 2]  D = [ 0, 2]\n\n输出：\n\n+ 2\n\n**解释**：两个元组如下：\n\n1. (0, 0, 0, 1) -> A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0\n2. (1, 1, 0, 0) -> A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0\n\n**思路**：本题是使用哈希法的经典题目，而后面的**三数之和**、**四数之和**并不适合使用哈希法。因为三数之和和四数之和这两道题目使用哈希法在不超时的情况下做到对结果去重是很困难的，很有多细节需要处理。\n\n而这道题目是四个独立的数组，只要找到A[i] + B[j] + C[k] + D[l] = 0就可以，不用考虑有重复的四个元素相加等于0的情况，所以相对于题目18. 四数之和，题目15.三数之和，还是简单了不少！\n\n如果本题想难度升级：就是给出一个数组（而不是四个数组），在这里找出四个元素相加等于0，答案中不可以包含重复的四元组，大家可以思考一下，后续的文章我也会讲到的。\n\n**本题解题步骤**：\n\n1. 首先定义 一个unordered_map，key放a和b两数之和，value 放a和b两数之和出现的次数。\n2. 遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中。\n3. 定义int变量count，用来统计 a+b+c+d = 0 出现的次数。\n4. 在遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就用count把map中key对应的value也就是出现次数统计出来。\n5. 最后返回统计值 count 就可以了\n\n```cpp\n//这道题相对于“四数之和”，简单点在于不需要去重。本次时间复杂度为O(n^2)\nint fourSumCount(vector<int>& A,vector<int>& B,vector<int>& C,vector<int>& D) {\n	unordered_map<int,int> umap;\n	for (int a : A) {\n		for (int b : B) {\n			umap[a+b]++;\n		}\n	}\n	int count = 0;\n	for (int c : C) {\n		for (int d : D) {\n			if (umap.find(0-(c+d)) != umap.end()) {\n				count += umap[0-(c+d)];\n			}\n		}\n	}\n	return count;\n}\n```\n\n### 3.7 赎金信\n\n**题意**：给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串 ransom 能不能由第二个字符串 magazines 里面的字符构成。如果可以构成，返回 true ；否则返回 false。\n\n(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。杂志字符串中的每个字符只能在赎金信字符串中使用一次。)\n\n注意：\n\n你可以假设两个字符串均只含有小写字母，下面三个是示例：\n`canConstruct(\"a\", \"b\") -> false`\n`canConstruct(\"aa\", \"ab\") -> false`\n`canConstruct(\"aa\", \"aab\") -> true`\n\n**思路**：这道题和“有效的字母异位词”很像。**字母异位词**是字符串a和b的字符类型和数量应当完全相同，才能相互组成，而这里只需要保证字符串a中的字符类型和数量`<=`字符串b中的字符类型和数量，即字符串b完全能组成a，而a能否组成b不需要考虑。\n\n方法1：暴力解法，直接用双重for循环解决。外层循环是长字符串，内层循环是短字符串，每找到一个字符，就在对应位置删除掉短字符串上对应的字符，当短字符串长度为0时，返回true，否则返回false。\n\n```cpp\nbool canConstruct(string ransomNote, string magazine) {\n	for (int i = 0; i < magazine.length(); i++) {\n		for (int j = 0; j < ransomNote.lenth(); j++) {\n			if (magazine[i] == ransomNote[j]) {\n				ransomNote.erase(ransomNote.begin()+j);\n				break;\n			}\n		}\n	}\n	if (ransomNote.length() == 0) {\n		return true;\n	}\n	return false;\n//这里时间复杂度是比较高的O(n^2)，而且里面还有一个字符串删除也就是erase的操作，也是费时的\n}\n```\n\n方法2：哈希解法（大的是magazine，小的字符串是ransomNote）\n\n因为题目所只有小写字母，那可以采用空间换取时间的哈希策略， 用一个长度为26的数组还记录magazine里字母出现的次数。然后再用ransomNote去验证这个数组是否包含了ransomNote所需要的所有字母。一般来说，哈希数据结构的话，能用数组就用数组。使用map的空间消耗要比数组大一些的，因为map要维护红黑树或者哈希表，而且还要做哈希函数，是费时的！数据量大的话就能体现出来差别了。\n\n```cpp\n//补充说明：string容器求长度用length()或size()方法都可以\nbool canConstruct(string ransomNote, string magazine) {\n	int record[26]={0};\n	if (ransomNote.length() > magazine.length()) {\n		return false;\n	}\n	for (int i=0; i < magazine.length(); i++) {\n		record[magazine[i]-\'a\']++;\n	}\n	for (int j=0; j < ransomNote.length(); j++) {\n		record[ransomNote[j] -\'a\']--;\n		if (record[ransomNote[j] -\'a\'] < 0) {\n			return false;\n		}\n	}\n	return true;\n}\n```\n\n### 3.8 三数之和\n\n**题意**：给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。 **注意**：答案中不可以包含重复的三元组。**再次注意**：注意[0,0,0,0]这组数据。\n\n示例：给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ]\n\n**回忆**：两数之和也是在一个数组中找到两个不同的元素，其和为target。该题的做法建立一个map数据结构，key为元素值，value为下标索引。然后遍历每个元素，在map中寻找是否存在[target-key]的值存在；如果存在就找到，直接返回；如果不存在就将当前元素存入map，继续遍历。遍历结束后仍为返回就return {}空vector。\n\n**解法1）哈希法**（不推荐）：\n\n两层for循环就可以确定 a 和b 的数值了，可以使用哈希法来确定 0-(a+b) 是否在 数组里出现过，其实这个思路是正确的，但是我们有一个非常棘手的问题，就是题目中说的不可以包含重复的三元组。把符合条件的三元组放进vector中，然后再去重，这样是非常费时的，很容易超时，也是这道题目通过率如此之低的根源所在。\n\n时间复杂度可以做到O(n^2)，但还是比较费时的，因为不好做剪枝操作。\n\n```cpp\nvector<vector<int>> threeSum(vector<int>& nums) {\n	vector<vector<int>> result;\n	unordered_set<int> set;\n	sort(nums.begin(),nums.end());\n	for (int i=0; i<nums.size();i++) {\n		// 排序之后如果第一个元素已经大于零，那么不可能凑成三元组\n		if (nums[i] > 0) {\n			break;\n		}\n		if (i > 0 && nums[i] == nums[i - 1]) { //三元组元素a去重\n			continue;\n		}\n		for (int j =i+1; j < nums.size();j++) {\n			if ( j > i + 2 && nums[j] == nums[j-1] && nums[j-1] == nums[j-2]) {\n				continue; //三元组的元素b去重\n			}\n		int c = 0 -(nums[i]+nums[j]);\n		if (set.find(c) != set.end()) {\n			result.push_back({nums[i],nums[j],c});\n			set.erase(c);  //三元组去重c\n		} else {\n			set.insert(nums[j]);\n		}\n		}\n	}\n	return result;\n} \n```\n\n**解法2）双指针**：\n\n动画效果如下：\n\n![](https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlFh1FaSArZZ1UxyE/root/content)\n\n拿这个nums数组来举例，首先将数组排序，然后有一层for循环，i从下标0的地方开始，同时定一个下标left 定义在i+1的位置上，定义下标right 在数组结尾的位置上。依然还是在数组中找到 abc 使得a + b +c =0，我们这里相当于 a = nums[i]，b = nums[left]，c = nums[right]。\n\n接下来如何移动left 和right呢？1） 如果nums[i] + nums[left] + nums[right] > 0 就说明 此时三数之和大了，因为数组是排序后了，所以right下标就应该向左移动，这样才能让三数之和小一些。2）如果 nums[i] + nums[left] + nums[right] < 0 说明 此时 三数之和小了，left 就向右移动，才能让三数之和大一些，直到left与right相遇为止。时间复杂度：O(n^2)。\n\n```cpp\nvector<vector<int>> threeSum(vector<int>& nums) {\n	vector<vector<int>> result;\n	sort(nums.begin(),nums.end());\n	for (int i = 0; i < nums.size(); i++) {\n        // 排序之后如果第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，直接返回结果就可以了\n        if (nums[i] > 0) {\n            return result;\n        }\n        // 错误去重a方法，将会漏掉-1,-1,2 这种情况\n        /*\n        if (nums[i] == nums[i + 1]) {\n        continue;\n        }\n        */\n        // 正确去重a方法\n        if (i > 0 && nums[i] == nums[i - 1]) {\n        continue;\n        }\n        int left = i+1;\n        int right = nums.size() -1;\n        while (right > left) {\n// 去重复逻辑如果放在这里，0，0，0 的情况，可能直接导致 right<=left 了，从而漏掉了 0,0,0 这种三元组	\n			/*\n			while (right > left && nums[right] == nums[right - 1]) right--;\n			while (right > left && nums[left] == nums[left + 1]) left++;\n			*/\n			if (nums[i]+nums[left]+nums[right] > 0) right--;\n			else if (nums[i]+nums[left]+nums[right] < 0) left++;\n			else {\n				result.push_back(vector<int>{nums[i],nums[left],nums[right]});\n				//去重逻辑应该放在找到一个三元组后，对b和c去重\n				while(right > left && nums[right] == nums[right-1]) right--;\n				while(right > left && nums[left] == nums[left+1]) left++;\n				找到答案时，双指针同时收缩\n				left++;\n				right--;			\n			}\n		}\n	}\n	return result;\n} \n```\n\n**去重逻辑的思考**：\n\n**a的去重**：\n\n说到去重，其实主要考虑三个数的去重。 a, b ,c, 对应的就是 nums[i]，nums[left]，nums[right]。\n\na 如果重复了怎么办，a是nums里遍历的元素，那么应该直接跳过去。但这里有一个问题，是判断 nums[i] 与 nums[i + 1]是否相同，还是判断 nums[i] 与 nums[i-1] 是否相同。有同学可能想，这不都一样吗。其实不一样！都是和 nums[i]进行比较，是比较它的前一个，还是比较他的后一个。如果我们的写法是：\n\n```cpp\nif (nums[i] == nums[i+1]) {\n	continue;\n}\n```\n\n那就我们就把三元组中出现重复元素的情况直接pass掉了。 例如{-1, -1 ,2} 这组数据，当遍历到第一个-1 的时候，判断下一个也是-1，那这组数据就pass了。这样就会出现漏判。**我们要做的是不能有重复的三元组，但三元组内的元素是可以重复的！** 那么应该这么写：\n\n```cpp\nif (i > 0 && nums[i] == nums[i-1]) {\n	continue;\n}\n```\n\n这么写就是当前使用 nums[i]，我们判断前一位是不是一样的元素，在看 {-1, -1 ,2} 这组数据，当遍历到 第一个 -1 的时候，只要前一位没有-1，那么 {-1, -1 ,2} 这组数据一样可以收录到结果集里。\n\n**b与c的去重**：\n\n类似于a的考虑，遍历b和c的时候，是不是也需要在每一步进行去重呢？代码如下：\n\n```cpp\nwhile (eight > left) {\n	if (nums[i] + nums[left] + nums[right] > 0) {\n		right--;\n		//while(left < right && nums[right]==nums[right+1]) right--;\n	} else if (nums[i] + nums[left] + nums[right] < 0) {\n		left++;\n		//while(left < eight && nums[left] == nums[left-1]) left++;\n	} else {\n		//Todo\n	}\n}\n```\n\n上文注释掉的部分就是思考的过程，似乎按照a的思路，在每次遍历的时候，需要与前一个已经遍历过的值进行比较，若相同就需要去重（不能与后一个值进行比较去重，不然会丢失诸如-1，-1，2这组值）。但仔细观察又会发现，b和c遍历的过程本身就是去重的过程，在遍历b和c时，如果三数之和大于0，则按照规则应该是右指针right左移++，类似的，下一次循环时，如果righ是重复值，也会走这个if语句，继续right++。所以遍历时就已经去重，不需要额外在用while来去重了（上述代码中被注释掉的部分）。\n\n**思考**：\n\n既然三数之和可以使用哈希法和双指针法，那我们之前讲过的两数之和可以使用双指针法吗？\n\n**回忆**：两数之和：从一个数组中找到两个不同的值，其和为target。只需要找到一组答案即可。**解法**：以元素值为map的key，以元素下标作为map的value，建立哈希数据结构unordered_map来求解。遍历整个数组，如果找到`map.find(target-nums[i])!=map.end()`，就直接返回`vector<int>{iter->second,i}`；如果未找到就将当前`nums[i]`和`i`存入`ma`p并进行下一次循环。循环结束后仍为`return`就直接返回空`vector{}`，表示未找到。\n\n本题三数之和也是从一个数组中找多个不同元素满足其和为target，但是本体的返回结果有多个且不允许重复。所以单纯使用哈希法来求解需要多考虑去重的问题，更麻烦。那两数之和能用双指针法求解吗？**不能**：因为两数之和返回的是元素下标，而在本题中使用双指针法必须对数组元素进行排序，一旦排序，下标就变了。如果两数之和的题目改成返回元素值那么就可以使用双指针法。\n\n### 3.9 四数之和\n\n**题意**：给定一个数组nums和一个target目标值，判断nums中是否存在四个元素满足其和为target，找出所有满足条件且不重复的四元组。\n\n**注意**：\n\n答案中不可以包含重复的四元组。示例： 给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。 满足要求的四元组集合为： [ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2] ]\n\n\n**回忆**：前面两数之和、三数之和都是从一个数组中找到k个元素满足其和为target，两数之和是找到任意一对且返回元素下标；三数之和是找到全部且返回的是由元素组成的vector。还有四数之和2是从四个数组中分别找到四个数满足其和为target的条件，且返回的值是满足条件的元组个数。\n\n**回忆2**：四数之和2是采用的哈希法，a组和b组用双for循环和unordered_map来统计，c组和d组也用双for循环和unordered_map[0-(a+b)]来找符合条件的元组，并统计个数，最后的返回值是满足条件的元组个数。\n\n**思路**： \n\n\n四数之和，和15.三数之和是一个思路，都是使用双指针法, 基本解法就是在15.三数之和的基础上再套一层for循环。\n\n```cpp\nvector<vector<int>> fourSum(vector<int>& nums, int target) {\n	vector<vector<int>> result;\n	sort(nums.begin(),nums.end());\n	for (int k=0;k<nums.size();k++) {\n		//剪枝处理\n		if (nums[k]> target && nums[k]>=0){\n			break;//这里使用break统一最后return处理\n		}\n		//对nums[k]去重\n		if(k>0&&nums[k] == nums[k-1]) {\n			continue;\n		}\n		\n		for(int i=k+1;i<nums.size();i++) {\n			//2级剪枝处理\n			if (nums[k]+nums[i]>target && nums[i]>=0) {\n			break; //已经不满足条件了\n			}\n			//对nums[i]去重\n			if (i>k+1;nms[i]==nums[i-1]) {\n				continue;\n			}\n			\n			int left=i+1;\n			int right = nums.size()-1;\n			while(right > left) {\n				if((long)nums[i]+nums[k]+nums[left]+nums[right] > target) {\n					right--;\n				} else if((long)nums[i]+nums[k]+nums[left]+nums[right] < target) {\n					left++;\n				} else {\n                    result.push_back(vector<int>{nums[i],nums[k],nums[left],nums[right]});\n                    while(righ>left && nums[left] ==nums[left++]){\n                        left++;\n                    }\n                    while(right>left && nums[right]== nums[right--]) {\n                        right--;\n                    }\n                    right--;\n                    left++;\n				}\n			}\n		}\n	}\n	return result;\n}\n```\n\n### 3.10 总结\n\n在哈希表这部分，我们主要介绍了数据、集合和映射三种哈希数据结构，并解决了字母异位词、两个数组交集、快乐数、四数相加2、书尽心和两数之和、三数之和、四数之和等问题。\n\n数组作为最基础最简单的哈希数据结构，应用简单且广泛，但也有它的局限性。首先，他只适合于数据长度有限且分布不要太过分散的情况。如果数据分散的太开，反而会造成效率和内存上的浪费。unordered_set（注：set和mutilset使用的是红黑树，unordered_set使用的是哈希表）就没有数据长度上的限制了，但是它的存储数据知识值类型，对于既要存储数组元素值又要存储数组下标的情况就得使用map映射了。类似的，只有unordered_map的底层是使用的哈希表，map和mutilmap使用的都是红黑树。使用map或set既要维护哈希表（或红黑树），又要去做哈希函数，所以效率上肯定是比不过数组的。综上，三种数据结构各有优劣，应该要视情况来选定。\n\n字母异位词和赎金信都是字母，而且还是小写字母，这样的话用长度为26的字符数组来做哈希算法的话就很容易了。这两者不同的是，字母异位是两个字符串的字符种类和数量要完全相同，而赎金信则是b的字符和数量要大于等于字符串a才行。\n\n快乐数是求一个数的每一位上数值的平方值和，其和是否为1，若不为1就再次进行计算。如果最终为1了就是快乐数，如果后面陷入了死循环就是非快乐数。这里的数据长度不固定，不能用数组，且数组为单一数值类型，还有解题的关键点在于从已有数据中找某个元素，因此选用哈希法解题，且使用unordered_set来解决。\n\n两个数组的交集，这题也是使用unordered_set来解题。先将nums1数组中的元素全部存入set中，然后在遍历数组nums2，查看nums2中的元素是否在set中，存在就加入result，最后再返回return result即可。\n\n四数相加2是从四个数组中找四个数，要找满足这四个数之和为target的元组个数。这里可以使用哈希法解决，且又要记录元素又要记录次数，所以采用unordered_map的数据结构。数组a和B使用双层for循环来统计（a+b)和的次数，如：`umap[a+b]++;`，初始化count值，然后数组c和d组成一个双层for循环，在umap中寻找满足元素值等于`target-(c+d)`的键值对，并用count变量将该键值对的值累加，最后返回count即可。\n\n两数之和、三数之和、四数之和都是从一个数组里面，找k个不重复的元素，要求其和为target。两数之和要求找出至少一队并返回该元组，三数之和、四数之和要求返回所有满足条件且不重复的元组集合。\n\n+ 两数之和因为只需找出一队，且返回的是元素下标，所以采用unordered_map来求解。遍历数组，如果在umap中找到了满足条件`umap.find(target-nums[i])`的元素，就返回`vector<int>{i,iter->second}`，否则就将当前元素存入umap:`map.insert(pair<int,int>(nums[i],i))`。\n+ 三数之和可以使用哈希法，但是针对去重这个问题就比较麻烦。1）哈希法：第一层for，索引为i，从0到nums.size()-1;第二层for，索引为j，从i+1到nums.size()-1；然后在定义一个uset，从这个uset里面找满足条件`0-(nums[i]+nums[j])`的元素，找到了就插入到result中，代码片段如：`1/int c=0-nums[i]-nums[j]；2/if(uset.find(c)!=set.end()) 3/result.push_back({nums[i],nums[j],c});`(代码中还有对元素a,b,c的去重操作，这里未展示)。2）使用双指针法：使用双指针法的时间复杂度也是O(n^2)，但没有使用umap，少去了维护哈希表和做哈希映射的操作，更加高效。第一层for，索引为i，从0到nums.size()-1；定义left为i+1;定义right为nums.size()-1;然后第二层while(left<right)循环。在第二层循环中做这几样事：1/判断三数之和是否大于target，是的话就让right--；2/判断三数之和是否小于target，是的话就让left++；3/三数之和恰好等于target，满足题意，存入result(代码中还有对元素a,b,c的去重操作，这里未展示)。\n+ 四数之和类似的道理，只不过增加了一层循环。第一层for，索引为i，从0到nums.size()-1；第二层for，索引为j，从i+1到nums.size()-1；然后定义left为j+1;定义right为nums.size()-1;然后第三层while(left<right)循环。\n\n## 四、字符串\n\n### 4.1 反转字符串1\n\n**题意**：对于用char[]给出的字符串，如果反转字符串，使用输入[\'H\',\'e\',\'l\',\'l\',\'o\']，输出[\'o\',\'l\',\'l\',\'e\',\'H\']?且要求不分配额外的内存空间。\n\n\n**思路**：可以直接用库函数reverse()解决，但是有些场合不建议直接套用库函数。这里的反转字符串和反转链表很像，可以用双指针法解决。使用swap()函数来调换两个字符。\n\nswap有两种实现方式：1）使用tmp变量的值替换和2）通过为运算。\n\n```cpp\n//1、值替换\nint tmp=s[i];\ns[i]=s[j];\ns[j]=tmp;\n//2、位运算\ns[i] ^= s[j];\ns[j] ^= s[i];\ns[i] ^= s[j];\n```\n\n最终的cpp代码如下：\n\n```cpp\nvoid reverseString(vector<char>& s) {\n	for(int i=0,j=s.size()-1;i<s.size()/2;i++,j--) {\n		swap(nums[i],nums[j]);\n	}\n}\n```\n\n### 4.2 反转字符串2\n\n**题意**： 给定一个字符串 s 和一个整数 k，从字符串开头算起, 每计数至 2k 个字符，就反转这 2k 个字符中的前 k 个字符。如果剩余字符少于 k 个，则将剩余字符全部反转。如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。\n\n示例：\n\n输入：s=\"abcdefg\",k=2\n\n输出：\"bacdfeg\"\n\n**思路**：这里的终点就是i+=(2\\*k)，i 每次移动 2 \\* k 就可以了，然后判断是否需要有反转的区间。\n使用库函数reverse来求解（reverse函数不是本题的问题核心，可以使用）：\n\n```cpp\nstring reverseStr(string s,int k) {\n	for (int i=0 ;i<s.zise();i+=2*k) {\n		//1. 每隔2k个字符的前k个字符进行反转\n		//2. 剩余字符小于2k但大于等于k个的，则反转前k个\n		if (i+k <= s.size()) {\n			reverse(s.begin()+i,s.begin()+i+k);\n		} else {\n			//3. 剩余字符小于k，就全部翻转\n			reverse(s.begin()+i,s.end());\n		}\n	}\n	return s;\n}\n```\n\n另一种方法是实现自己的reverse函数，下面的reverse函数时左闭右闭区间的，代码如下：\n\n```cpp\nvoid reverse(string& s,int start,int end) {\n	for(int i=start,j=end;i<j;i++,j--)\n		swap(s[i],s[j]);\n}\nstring reverseStr(string s, int k) {\n	for (int i = 0; i < s.size(); i += (2 * k)) {\n        // 1. 每隔 2k 个字符的前 k 个字符进行反转\n        // 2. 剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符\n        if (i + k <= s.size()) {\n            reverse(s, i, i + k - 1);\n            continue;\n        }\n        // 3. 剩余字符少于 k 个，则将剩余字符全部反转。\n        reverse(s, i, s.size() - 1);\n	}\n	return s;\n}\n```\n\n### 4.3 替换空格\n\n**题意**:将字符串中的空格替换成\"%20\"。\n\n**思路**：不使用额外的辅助空间。首先，扩充数组到每隔空格替换成\"%20\"之后的大小，然后从后往前替换空格，也就是双指针法。i指向新长度的末尾，j指向旧长度的末尾，过程如下：\n\n![](https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlFkgwS4cMqYe6Hq2/root/content)\n\n**其实很多数组填充类的问题，都可以先预先给数组扩容带填充后的大小，然后在从后向前进行操作**。\n\n这么做有两个好处：\n\n1. 不用申请新数组。\n2. 从后向前填充元素，避免了从前向后填充元素时，每次添加元素都要将添加元素之后的所有元素向后移动的问题。\n\n```cpp\nstring replaceSpace(string s){\n	int count = 0; //统计空格的数量\n	int sOldSize = s.size();\n	for(int i=0;i<sOldSize;i++) {\n		if(s[i] == \' \') count++;\n	}\n	//扩充字符串的大小，也就是每个空格替换成\"%20\"之后的大小\n	s.resize(s.size()+count*2);\n	int sNewSize = s.size();\n	//从后往前将空格替换成\"%20\"\n	for(int i=sNewSize-1,j=sOldSize-1;j<i;i--,j--) {\n		if(s[j]!=\' \'){\n			s[i]=s[j];\n		} else {\n			s[i]=\'0\';\n			s[i-1]=\'2\';\n			s[i-2]=\'%\';\n			i-=2;\n		}\n	}\n	return s;//时间和空间复杂度都为O(1)\n}\n```\n\n### 4.4 翻转字符串里的单词\n\n+ 这是一道考察字符串操作的好题。\n\n**题意**：给定一个字符串，逐个翻转字符串中的每个单词。请注意，是反转单词，而非字符，示例：输入\"hello  world!  \"，输出：\"world! hello\"。说明：若两个单词之间有多个空格，应减少到只包含一个，若字符串末尾有多余的空格，也应该删掉。\n\n**思路**：这道题综合考察了字符串的许多操作。一些同学会使用split库函数，分隔单词，然后定义一个新的string字符串，最后再把单词倒序相加，那么这道题题目就是一道水题了，失去了它的意义。所以，提高一下本题的难度：**不要使用辅助空间，空间复杂度为O(1)**。\n\n想一下，我们将整个字符串都反转过来，那么单词的顺序指定是倒序了，只不过单词本身也倒序了，那么再把单词反转一下，单词不就正过来了。所以解题思路如下：\n\n+ 移除多余空格\n+ 将整个字符串反转\n+ 将每个单词反转\n\n举个例子，源字符串为：\"the sky is blue \":\n\n+ 移除多余空格 : \"the sky is blue\"\n+ 字符串反转：\"eulb si yks eht\"\n+ 单词反转：\"blue is sky the\"\n\n代码上的细节：\n\n1）移除多余空格：一些同学可能会上来写如下代码（使用erase的方法来删除空格，时间复杂度会很高）：\n\n```cpp\nvoid removeExtraSpaces(string& s) {\n	for(int i=s.size()-1;i>0;i--) {\n		if(s[i]==s[i--]&&s[i]==\' \') {\n			s.erase(s.begin()+i);\n		}\n	}\n	//删除字符串最后面的空格\n	if(s.size()>0 && s[s.size()-1] ==\' \') {\n		s.erase(s.begin()+s.size()-1);\n	}\n	//删除最前面的空格\n	if(s.size()>0 && s[0] == \' \') {\n		s.erase(s.begin());\n	}\n}\n```\n\n**问题在哪**:上述代码一琢磨似乎时间复杂度为O(n)，但其实erase()的时间复杂度为也是O(n)，所以实际的时间复杂度就是O(n^2)。有的同学可能发现用erase来移除空格，在leetcode上性能也还行。主要是以下几点：\n\n+ leetcode上的测试集里，字符串的长度不够长，如果足够长，性能差距会非常明显。\n+ leetcode的测程序耗时不是很准确的。\n\n2）使用双指针的方法按照去除最前面的空格、中间部分的空格和末尾空格的思路来写代码\n\n```cpp\n//版本一 \nvoid removeExtraSpaces(string& s) {\n    int slowIndex = 0, fastIndex = 0; // 定义快指针，慢指针\n    // 去掉字符串前面的空格\n    while (s.size() > 0 && fastIndex < s.size() && s[fastIndex] == \' \') {\n        fastIndex++;\n    }\n    for (; fastIndex < s.size(); fastIndex++) {\n        // 去掉字符串中间部分的冗余空格\n        if (fastIndex - 1 > 0\n                && s[fastIndex - 1] == s[fastIndex]\n                && s[fastIndex] == \' \') {\n            continue;\n        } else {\n            s[slowIndex++] = s[fastIndex];\n        }\n    }\n    if (slowIndex - 1 > 0 && s[slowIndex - 1] == \' \') { // 去掉字符串末尾的空格\n        s.resize(slowIndex - 1);\n    } else {\n        s.resize(slowIndex); // 重新设置字符串大小\n    }\n}\n```\n\n仔细考虑这个问题，是不是和数组操作的\"移除指定元素\"这个操作比较像？还是使用双指针法，将所有空格都视作需要被移除的对象，然后手动为每个单词后添加空格：\n\n```cpp\n// 版本二 使用双指针法，快指针为索引，遍历所有元素，慢指针只接受满足条件的元素\nvoid removeExtraSpaces(string& s) {//去除所有空格并在相邻单词之间添加空格, 快慢指针。\n    int slow = 0;   //整体思想参考https://programmercarl.com/0027.移除元素.html\n    for (int i = 0; i < s.size(); ++i) { \n        if (s[i] != \' \') { //遇到非空格就处理，即删除所有空格。\n            if (slow != 0) s[slow++] = \' \'; //手动控制空格，给单词之间添加空格。slow != 0说明不是第一个单词，需要在单词前添加空格。\n            while (i < s.size() && s[i] != \' \') { //补上该单词，遇到空格说明单词结束。\n                s[slow++] = s[i++];\n            }\n        }\n    }\n    s.resize(slow); //slow的大小即为去除多余空格后的大小。\n}\n```\n\n3）实现反转字符串的功能，这在上文已经讲了：\n\n```cpp\n// 反转字符串s中左闭右闭的区间[start, end]\nvoid reverse(string& s, int start, int end) {\n    for (int i = start, j = end; i < j; i++, j--) {\n        swap(s[i], s[j]);\n    }\n}\n```\n\n综上，翻转字符串里的单词这道题的最终代码为：\n\n```cpp\nvoid reverse(string& s, int start, int end){ //翻转，区间写法：左闭右闭 []\n	for (int i = start, j = end; i < j; i++, j--) {\n		swap(s[i], s[j]);\n	}\n}\n\nvoid removeExtraSpaces(string& s) {//去除所有空格并在相邻单词之间添加空格, 快慢指针。\n	int slow = 0;   //整体思想参考https://programmercarl.com/0027.移除元素.html\n	for (int i = 0; i < s.size(); ++i) { //\n		if (s[i] != \' \') { //遇到非空格就处理，即删除所有空格。\n			if (slow != 0) s[slow++] = \' \'; //手动控制空格，给单词之间添加空格。slow != 0说明不是第一个单词，需要在单词前添加空格。\n			while (i < s.size() && s[i] != \' \') { //补上该单词，遇到空格说明单词结束。\n				s[slow++] = s[i++];\n			}\n		}\n	}\n	s.resize(slow); //slow的大小即为去除多余空格后的大小。\n}\n\nstring reverseWords(string s) {\n	removeExtraSpaces(s); //去除多余空格，保证单词之间之只有一个空格，且字符串首尾没空格。\n	reverse(s, 0, s.size() - 1);\n	int start = 0; //removeExtraSpaces后保证第一个单词的开始下标一定是0。\n	for (int i = 0; i <= s.size(); ++i) {\n		if (i == s.size() || s[i] == \' \') { //到达空格或者串尾，说明一个单词结束。进行翻转。\n			reverse(s, start, i - 1); //翻转，注意是左闭右闭 []的翻转。\n			start = i + 1; //更新下一个单词的开始下标start\n		}\n	}\n	return s;\n}\n```\n\n### 4.5 左旋转字符串\n\n**题意**：字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串\"abcdefg\"和数字2，该函数将返回左旋转两位得到的结果\"cdefgab\"。\n\n**思路**：如果能申请额外空间的话，就可以用提取子串的方法substr()将前n个字符提取出来，然后在追加到原字符串末尾就行了(但是substr()方法需要申请额外的空间)。为了让本题更有意义，提升一下本题难度：**不能申请额外空间，只能在本串上操作**。回顾上一题，翻转字符串里的单词，是使用整体反转+局部反转的方式来实现反转单词顺序的目的。这道题也类似，具体步骤为：\n\n1. 反转区间为前n的子串；\n2. 反转区间为n到末尾的子串；\n3. 反转整个字符串\n\n![](https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlFpfBs6U4gvnd_wZ/root/content)\n\ncpp代码如下所示：\n\n```cpp\nstring reverseLeftWords(string s, int n) {\n	reverse(s.begin(), s.begin() + n);\n	reverse(s.begin() + n, s.end());\n	reverse(s.begin(), s.end());\n	return s;\n }\n```\n\n**总结**：\n\n此时我们已经反转过很多次字符串了，一起来回顾一下。\n\n在\"反转字符串1\"中，第一次降到反转一个字符串该怎么做，使用了双指针法。\n\n在\"反转字符串2\"中，对反转限定了条件，要求前2k个字符只翻转前k个，需要固定规律一段一段去处理字符串的时候，就要在for循环的表达式上去做文章。\n\n在\"反转字符串里的单词\"中，要对一句话里的单词顺序进行反转，发现先整体反转、在局部反转是个不错的思路。\n\n最后在讲到本题，本题是先局部反转再整体反转，也是一种新思路。\n\n最后补充说明一下，substr()这个方法和反转时间复杂度都是一样的，都是O(n)，但是substr()需要申请额外空间。\n\n\n### 4.6 实现strStr()\n\n**题意**：实现 strStr() 函数。给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。例如：输入: haystack = \"hello\", needle = \"ll\" 输出: 2。说明: 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。\n\n**思路**：本题是KMP的经典题目。KMP的经典思想就是:**当出现字符串不匹配时，可以记录一部分之前已经匹配的文本内容，利用这些信息避免从头再去做匹配**。\n\n**KMP算法**：\n字符串的匹配算法有两种：1）BF算法(Brute-Force，暴力解法)，就是目标串和模式串都从0开始比较，当遇到不匹配的字符时，模式串索引值j直接返回到起点0，而目标串的索引`i=i-j+2`。为什么加2呢？如下图所示，因为理论上模式串匹配完一次后，如果没匹配上，模式串j直接回到0，而目标串i回到遍历的下一个位置（下图中手写笔画的位置，也就是索引1的位置）。但是在上一次的匹配过程中，i已经走到了3号的位置，所以不仅是j要回头开头，i也要回溯。这也是暴力解法时间复杂度高的原因所在O(m\\*n)。\n\n![](https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlFxIwhkqFTYq0xCx/root/content)\n\n2）KMP算法原理：KMP算法就是让目标串的i不要回溯，向遍历指针一样一直往前走。并且分析模式串字符构成特点，尽量让j不要回到0处重复匹配来提高匹配效率。通过分析模式串的字符构成特点，来设计一个\"如果匹配失败就指示下次跳转的位置的数组\"，这个数组就是next[]数组。KMP的主要思想是**当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了**。\n\n前缀表：前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。前缀表是**记录下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。**\n\n前缀：是指不包含最后一个字符的所有以第一个字符开头的连续子串。\n\n后缀：是指不包含第一个字符的所有以最后一个字符结尾的连续子串。\n\n前缀表：要求的就是最大的相同前后缀的长度。\n\n**为什么一定要使用前缀表**：\n\n刚刚匹配的过程在下标5的地方遇到不匹配，模式串是指向f，如下图：\n\n![](https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlF2fBMmjPS2yUa3A/root/content)\n\n然后就找到了下标2，指向b，继续匹配：如图：\n\n![](https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlF5rdletPm7T6ZJH/root/content)\n\n以下这句话，对于理解为什么使用前缀表可以告诉我们匹配失败之后跳到哪里重新匹配 非常重要！\n\n**下标5之前这部分的字符串（也就是字符串`aabaa`）的最长相等的前缀 和 后缀字符串是 子字符串`aa` ，因为找到了最长相等的前缀和后缀，匹配失败的位置是后缀子串的后面，那么我们找到与其相同的前缀的后面重新匹配就可以了。**\n\n所以前缀表具有告诉我们当前位置匹配失败，跳到之前已经匹配过的地方的能力。\n\n前缀表与next数组：\n\n有的是直接把next数组做前缀表，有的是把next数组每一位减一后的数组做next数组，有的是把next数组统一右移一位做next数组。注意：这题的next数组是从下表索引0开始计算的，而很多课程或教材，例如《大话数据结构》是从数组下标1开始计算的。\n\n**时间复杂度分析**：\n\n暴力算法是O(m\\*n)，使用KMP算法是O(m+n)，不过KMP算法针对模式串中有较多重复字符时才能提高搜索效率，这点也需注意。\n\n**一、构造next数组**：\n\n**构造next数组其实就是计算模式串s，前缀表的过程**。 主要有如下三步：\n\n+ 初始化\n+ 处理前后缀不相同的情况\n+ 处理前后缀相同的情况\n\n接下来详细叙述一下（直接使用next数组做前缀表，且next数组从数组下标0开始）：\n\n1. 初始化\n\n定义两个指针i和j，j指向前缀末尾位置，i指向后缀末尾位置。然后还要对next数组进行初始化赋值，如下：\n\n```cpp\nint j = 0;\nnext[0] = 0;//next[i] 表示 i（包括i）之前最长相等的前后缀长度（其实就是j）所以初始化next[0] = j 。\n```\n\n2. 处理前后缀不相同的情况\n\n遍历模式串的循环下标索引从1开始，因为下标为0时，显然最大公共前后缀为0，即next[0]的初始值；\n`for(int i=1;i<s.size();i++) {`\n如果 s[i] 与 s[j]不相同，也就是遇到前后缀末尾不相同的情况，就要向前回退。使用next数组来回退：`j=next[j-1]`。\n\n3. 处理前后缀相同的情况\n   如果 s[i] 与 s[j + 1] 相同，那么就同时向后移动i 和j 说明找到了相同的前后缀，同时还要将j（前缀的长度）赋给next[i], 因为next[i]要记录相同前后缀的长度。\n\n```cpp\nif(s[i] == s[j]) {\n	j++;\n}\nnext[i]=j;\n```\n\n**二、使用next数组来做匹配**：\n\n1. 目标串（主串）从0开始遍历字符串数组：\n\n```cpp\nfor(int i=0;i<s.size();i++)\n```\n\n2. 接下来就是`s[i]` 与 `t[j]` （因为j从0开始的） 进行比较。\n\n如果 `s[i]` 与 `t[j + 1]` 不相同，j就要从next数组里寻找下一个匹配的位置。\n\n```cpp\nwhile(j>=0 && s[i]!=t[j]) {\n	j=next[j];\n}\n```\n\n3. 如果s[i]和t[j]相同，那么i和j同时往后移动\n\n```\nif (s[i] == t[j]) {\n	j++;\n}\n```\n\n如何判断在文本串s里出现了模式串t呢，如果j指向了模式串t的末尾，那么就说明模式串t完全匹配文本串s里的某个子串了。\n\n本题要在文本串字符串中找出模式串出现的第一个位置 (从0开始)，所以返回当前在文本串匹配模式串的位置i 减去 模式串的长度，就是文本串字符串中出现模式串的第一个位置。\n\n代码如下：\n\n```cpp\nif (j == (t.size() - 1) ) {\n    return (i - t.size() + 1);\n}\n```\n\n所有代码如下：\n\n```cpp\nvoid getNext(int* next, const string& s) {\n	int j = 0;\n	next[0] = 0;\n	for(int i = 1; i < s.size(); i++) {\n		while (j > 0 && s[i] != s[j]) {\n			j = next[j - 1];\n		}\n		if (s[i] == s[j]) {\n			j++;\n		}\n		next[i] = j;\n	}\n}\nint strStr(string haystack, string needle) {\n	if (needle.size() == 0) {\n		return 0;\n	}\n	int next[needle.size()];\n	getNext(next, needle);\n	int j = 0;\n	for (int i = 0; i < haystack.size(); i++) {\n		while(j > 0 && haystack[i] != needle[j]) {\n		j = next[j - 1];\n		}\n		if (haystack[i] == needle[j]) {\n			j++;\n		}\n		if (j == needle.size() ) {\n			return (i - needle.size() + 1);\n		}\n	}\n	return -1;\n}\n```\n\n**总结**：\n\n我们介绍了什么是KMP，KMP可以解决什么问题，然后分析KMP算法里的next数组，知道了next数组就是前缀表，再分析为什么要是前缀表而不是什么其他表。\n\n接着从给出的模式串中，我们一步一步的推导出了前缀表，得出前缀表无论是统一减一还是不减一得到的next数组仅仅是kmp的实现方式的不同。\n\n其中还分析了KMP算法的时间复杂度，并且和暴力方法做了对比。\n\n然后先用前缀表统一减一得到的next数组，求得文本串s里是否出现过模式串t，并给出了具体分析代码。\n\n又给出了直接用前缀表作为next数组，来做匹配的实现代码。\n\n**求next数组的小技巧（以下图为例）**：\n\n![](https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlGG-X8nEvHZ1plBp/root/content)\n\n第一个字符a，无前缀后缀，所以为0；\n第二个字符串as，无最长公共前后缀，所以为0；\n第三个字符串asd，无最长公共前后缀，所以为0；\n...\n第五个字符串asdfa,最长公共前后缀是a，所以是1；\n类似的，第9个字符串asdfasdfa,（最长前缀是asdfasdf，最长后缀是sdfasdfa。不相同，所以不是8）最长公共前后缀asdfa：前缀是asdfa(从[0]到[4]),后缀是asdfa(从[4]到[8])，随意最长公共前后缀为5\n...\n上述计算结束后，每一位在统一减一，就可以得到上图中的next数组了。\n\n### 4.7 重复的子字符串\n\n**题意**：给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。示例：输入：\"abab\"，输出True.\n**思路**：主要有三种方法：1）暴力解法：第一层循环遍历整个字符串，第二层来寻找最小子串，子串的起点始终为起点，终点为当前遍历点，然后看这个子串能否构成整个大串。2）移动匹配法；3）KMP算法。\n\n**移动匹配**：\n\n当一个字符串s：`abcabc`，内部由重复的子串组成，那么这个字符串的结构一定是由前后相同的子串组成。那么既然前面有相同的子串，后面有相同的子串，用 s + s，这样组成的字符串中，后面的子串做前串，前后的子串做后串，就一定还能组成一个s。**所以判断字符串s是否由重复子串组成，只要两个s拼接在一起，里面还出现一个s的话，就说明是由重复子串组成**。也就是说，假设字符串s由a和b组成，若`s=a+b`，当`a+b+a+b`中仍然存在一个s时，说明`s=b+a`，说明a和b是一样的，也就是说s可以由重复子串a(或b)构成。\n\n当然，我们在判断 s + s 拼接的字符串里是否出现一个s的的时候，**要刨除 s + s 的首字符和尾字符**，这样避免在s+s中搜索出原来的s，我们要保证搜索的是中间拼接出来的s。\n\n```cpp\nbool repeatedSubstringPattern(string s) {\n	string t = s + s;\n	t.erase(t.begin());//掐头去尾\n	t.erase(t.end()-1);\n	if(t.find(s) != std::string::npos)//std::string::npos\n		return true;\n	return false;\n}\n```\n\n注：\n\n关于std::string::npos的使用说明：\n\n+ （1）它是一个常量静态成员值，对于 size_t 类型的元素具有最高可能值。\n+ （2）它实际上意味着直到字符串的末尾。\n+ （3）它用作字符串成员函数中长度参数的值。\n+ （4）作为返回值，它通常用于表示没有匹配项。\n+ （5）数据类型为size_t的话string:npos常量被定义为-1，因为size_t是无符号整数类型，-1是该类型的最大可能表示值。\n\n```cpp\n//1、std::string::npos一般最常见用于表示未找到的情况\nstring str = \"I am cver\";\nsize_t index = str.find(\'.\');\n//字符没找到\nif (index == string::npos) {\n	cout<<\"this does not contain any period!\"<<endl;\n	cout<<index<<endl;\n}\n//2、作字符串成员函数中长度参数的值\n#include <iostream>\n#include <string>\nusing namespace std;\nint main()\n{\n	string str = \"I am cver.\";\n	size_t index = str.find(\'.\'); \n	if(index == string::npos)\n	{\n		cout << \"This does not contain any period!\" << endl;\n		cout << index << endl;\n	}\n	else\n	{\n		str.replace(index, string::npos, \"!\"); //string& replace(int p0, int n0,const char *s);删除从p0开始的n0个字符，然后在p0处插入串s\n		cout << str << endl;\n		cout << index << endl;\n	}		\n}\n```\n\n不过这种解法还有一个问题，就是 我们最终还是要判断 一个字符串（s + s）是否出现过 s 的过程，大家可能直接用contains，find 之类的库函数。 却忽略了实现这些函数的时间复杂度（暴力解法是m * n，一般库函数实现为 O(m + n)）。如果我们做过 28.实现strStr (opens new window)题目的话，其实就知道，实现一个 高效的算法来判断 一个字符串中是否出现另一个字符串是很复杂的，这里就涉及到了KMP算法。\n\n**KMP**：\n\n<为什么使用MKP算法>？\n\n在一个串中查找是否出现过另一个串，这是KMP的看家本领。那么寻找重复子串怎么也涉及到KMP算法了呢？\n\n在由重复子串组成的字符串中，最长相等前后缀不包含的子串就是最小重复子串，这里拿字符串s：abababab 来举例，ab就是最小重复单位，如图所示：\n\n![](https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlF8PCVBCA1rDlM4M/root/content)\n\n<如何找到最小重复子串>？\n\n步骤一：因为 这是相等的前缀和后缀，t[0] 与 k[0]相同， t[1] 与 k[1]相同，所以 s[0] 一定和 s[2]相同，s[1] 一定和 s[3]相同，即：，s[0]s[1]与s[2]s[3]相同 。\n\n步骤二： 因为在同一个字符串位置，所以 t[2] 与 k[0]相同，t[3] 与 k[1]相同。\n\n步骤三： 因为 这是相等的前缀和后缀，t[2] 与 k[2]相同 ，t[3]与k[3] 相同，所以，s[2]一定和s[4]相同，s[3]一定和s[5]相同，即：s[2]s[3] 与 s[4]s[5]相同。\n\n步骤四：循环往复。\n\n所以字符串s，s[0]s[1]与s[2]s[3]相同， s[2]s[3] 与 s[4]s[5]相同，s[4]s[5] 与 s[6]s[7] 相同。\n\n正是因为 最长相等前后缀的规则，当一个字符串由重复子串组成的，最长相等前后缀不包含的子串就是最小重复子串。\n\n![](https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlGCHOJOsongi-3Eh/root/content)\n\n**简单推理**：\n\n这里再给出一个数学推导，就容易理解很多。\n\n假设字符串s使用多个重复子串构成（这个子串是最小重复单位），重复出现的子字符串长度是x，所以s是由n * x组成。\n\n因为字符串s的最长相同前后缀的长度一定是不包含s本身，所以 最长相同前后缀长度必然是m * x，而且 n - m = 1，（这里如果不懂，看上面的推理）\n\n所以如果 nx % (n - m)x = 0，就可以判定有重复出现的子字符串。\n\nnext 数组记录的就是最长相同前后缀 字符串：KMP算法精讲 (opens new window)这里介绍了什么是前缀，什么是后缀，什么又是最长相同前后缀)， 如果 next[len - 1] != -1，则说明字符串有最长相同的前后缀（就是字符串里的前缀子串和后缀子串相同的最长长度）。\n\n最长相等前后缀的长度为：next[len - 1] + 1。(这里的next数组是以统一减一的方式计算的，因此需要+1，两种计算next数组的具体区别看这里：字符串：KMP算法精讲 (opens new window))\n\n数组长度为：len。\n\n如果len % (len - (next[len - 1] + 1)) == 0 ，则说明数组的长度正好可以被 (数组长度-最长相等前后缀的长度) 整除 ，说明该字符串有重复的子字符串。\n\n**数组长度减去最长相同前后缀的长度相当于是第一个周期的长度，也就是一个周期的长度，如果这个周期可以被整除，就说明整个数组就是这个周期的循环。**\n\n例如下图：\n\n![](https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlGG-X8nEvHZ1plBp/root/content)\n\n`next[len - 1] = 7，next[len - 1] + 1 = 8`，8就是此时字符串asdfasdfasdf的最长相同前后缀的长度。\n\n`(len - (next[len - 1] + 1))` 也就是： 12(字符串的长度) - 8(最长公共前后缀的长度) = 4， 4正好可以被 12(字符串的长度) 整除，所以说明有重复的子字符串（asdf）。\n\ncpp代码实现：\n\n```cpp\nvoid getNext (int* next, const string& s){\n	next[0] = 0;\n	int j = 0;\n	for(int i = 1;i < s.size(); i++){\n		 while(j > 0 && s[i] != s[j]) {\n			 j = next[j - 1];\n		}\n		if(s[i] == s[j]) {\n			j++;\n		}\n		next[i] = j;\n	}\n}\nbool repeatedSubstringPattern (string s) {\n	if (s.size() == 0) {\n		return false;\n	}\n	int next[s.size()];\n	getNext(next, s);\n	int len = s.size();\n	if (next[len - 1] != 0 && len % (len - (next[len - 1] )) == 0) {\n		return true;\n	}\n	return false;\n}\n```\n\n### 4.8 总结\n\n**什么是字符串**：\n\n字符串是若干字符组成的有限序列，也可以理解为是一个字符数组，但是很多语言对字符串做了特殊的规定，接下来我来说一说C/cpp中的字符串。在C语言中，把一个字符串存入一个数组时，也把结束符 \'\\0\'存入数组，并以此作为该字符串是否结束的标志。\n\n在cpp中，提供一个string类，string类会提供 size接口，可以用来判断string类字符串是否结束，就不用\'\\0\'来判断是否结束。\n\n字符串的长度计算有`size()`也可以用`length()`，那么`vector<char>`和string的区别在哪？基本上没差别，不过string提供了更多的字符串处理的相关接口，例如string重载了+，而vector却没有。\n\n**双指针法**：\n\n在**反转字符串1**中，是反转字符串中的所有字符，可以使用双指针，两个指针一个从头开始，一个从未开始进行交换，以实现题目的功能。\n\n在**字符串：替换空格**中，我们需要将空格全部替换成指定的字符串，本题中是将空格替换成“%20”。**其实很多数组填充类的问题，都可以先预先给数组扩容带填充后的大小，然后在从后向前进行操作**。\n\n在**翻转字符串中的单词**中，与之前**移除数组元素**类似，双指针法，一个快指针做遍历，另一个慢指针来保留有用的元素。在这里，我们将空格全部当成需要移除的元素来处理，就与以前移除数组元素的操作相同了。然后，后面在对每个单词后面添加一个空格。这样就达到了“移除字符串中多余空格的目的”。\n\n需要注意的是，库函数erase()的时间复杂度为O(n)。\n\n**反转系列**：\n\n反转其实实在考察队代码的掌控能力。\n\n在**反转字符串2**中，每隔2k字符就翻转前k个字符，不足k的话就翻转全部字符。其实，当需要固定规律一段一段去处理字符串时，可以在for循环的表达式上坐坐文章。\n\n在**翻转字符串里的单词**中要求翻转字符串里面的单词，这道题目可以说是考察了字符串的多种操作，是考察字符串的一道好题。解法是：1）先去掉多余的空格；2）在整体反转，3）再局部反转。\n\n还有一个字符串的左转：剑指Offer58-II.左旋转字符串：给定字符串和一个数字，实现将数字前的字符移动到字符串末尾，如：输入\"abcdefg\"和2，得到\"cdefgab\"。这道题的思路是：1）先反转前n个字符，2）再反转n到末尾的字符，3）最后在反转整个字符串。而这三步骤，其核心就是”给定一个字符串，反转其全部字符“，就是本章节的第一题，使用双指针从头和从尾两端同时替换即可。\n\n**KMP系列**：\n\n问题1是实现子串问题，判断字符串2是不是字符串1的子串。采用KMP的方法，先对子串2进行分析，得到其next数组（该next数组反映了子串2的字符排列特点，可以在与主串的匹配查找过程中提供指针跳转的参考依据）。然后就是在next数组的基础上进行两字符串匹配的过程了。\n\n问题2是重复子串问题，就是说一个字符串能否由它的子串完整构成，例如主串\"abababab\"可以有子串\"ab\"完整构成。方法主要有移动匹配和KMP算法。移动构造：判断字符串s是否可以由子串构成，就1）构造s+s的字符串，2）刨除首字符和尾字符，3）判断剩余的字符中有无字符串s。有就是满足题意。\n\n```cpp\nbool repeatSubstring(string s) {\n	string t = s + s;\n	t.erase(t.begin());\n	t.erase(t.end()-1);\n	if(t.find(s) != std::string::npos) \n		return true;\n	return false;\n}\n```\n\n注意，一般暴力解法的复杂度是O(N^2)，库函数（如contains、find)的复杂度是O(m+n)。\n\n## 五、双指针法\n\n本章节主要是复习前面的内容。双指针法在数组、链表和字符串中很常用。\n\n**数组**：\n\n1. 移除元素\n\n**链表**：\n\n1. 翻转链表\n2. 删除链表的倒数第N个节点\n3. 链表相交\n4. 环形链表2\n\n**哈希表**：\n\n1. 三数之和\n2. 四数之和\n\n**字符串**：\n\n1. 反转字符串(单个字符串内的全部字符)\n2. 替换空格\n3. 反转字符串中的单词\n\n**__总结__**：\n在【数组篇】中有删除元素一节，一些同学可能会写出下列代码(伪代码)：\n\n```cpp\nfor (int i = 0; i>array.size(); i++) {\n	if (array[i] == target) {\n		array.erase(i);\n	}\n}\n```\n\n这个代码看着是只有O(n)的复杂度，其实是O(n^2)的复杂度，因为erase操作也是O(n)的操作。数组本身不能真正的删除元素，只能覆盖。\n\n在【链表篇】中，使用双指针法来翻转链表、确定单链表是否有环和环入口。\n\n在【哈希表篇】中，使用双指针法实现了N数之和。\n\n在【字符串篇】中，使用双指针法实现了反转字符串、替换空格和删除冗余空格。\n\n## 六、栈与队列\n\n\n\n\n\n\n## 七、二叉树\n\n## 八、回溯算法\n\n## 九、贪心算法\n\n## 十、动态规划\n\n## 十一、单调栈\n\n## 十二、额外题目\n\n',1,0,0,0,1,'2023-06-07 17:01:45','2023-06-07 20:00:08');
INSERT INTO `t_article` VALUES (91,1,57,'https://upload.haoxx.site/article/93c917e6b636c7a56c9473e6c29a3081.jpg','markdown基本规则学习笔记','---\ntitle: markdown基本规则学习笔记\ndate: 2021-2-15 20:00:01\ntag:\n - tag4\ncategory: \n - markdown基本规则\npublish: true\nfooter: <a href=\"https://beian.miit.gov.cn/#/Integrated/index\">渝ICP备2023001651号</a>\n\n---\n\n:::tip\nMakeDown的基本书写规则\n:::\n\n<!-- more -->\n\n\n\n@(示例笔记)[马克飞象|帮助|Markdown]\n说明：TOC为table of contents，即目录表，语法为：`[[TOC]]`\n\n是撒啊阿萨\n\n飒飒飒订单\n\n\n\n[[TOC]]\n\n\n<Boxx  changeTime=\"5000\" />\n\n\n```yaml\n插入名人名言：<Boxx />\n\n使用title和content属性自定义文字：<Boxx type=\'tip\' tilte=\'Haoxx\' content=\'勤能补拙，懒惰则一事无成\' />\n```\n\n<Boxx type=\'tip\' tilte=\'Haoxx\' content=\'勤能补拙，懒惰则一事无成\'/>\n\nchangeTime=\"1000\" 指定更新时间，单位为ms\n\n<Boxx type=\"danger\" changeTime=\"5000\"    title=\"我是一个大大的且变化的 title\" content=\'文本\' />\n\n## 1、标题\n\n标题：一级标题用“#+**空格**+文字”的格式，二级标题用“##+**空格**+文字”的格式，以此类推。\n\n## 1.1 新增（vuepress中可用）\n\n你可以在标题中，使用这个Badge组件来为某些 API（标题） 添加一些状态：\n\n```yaml\n### 标题名 <标题名 text=\"beta\" type=\"warning\"/> <标题名 text=\"默认主题\"/>\n\ntype可以换成tip、warning、danger  details\n```\n\n## 2、粗体\n\n* 粗体\n  粗体的格式是：前后各两个星号 `**测试**` ，效果为：**测试**\n* 斜体\n  斜体的格式是：前后各一个星号 `*测试*`，效果为：*测试*\n* 分隔符\n  分隔符的格式是：三个星号 `***` ,或者连续三个短横线`---`，效果为：\n\n***\n\n## 3、换行\n\n1. 段内换行\n   段内换行使用“结尾空两个空格再回车”的方式。\n\n2. 段落换行\n   向下空一行\n\n3. 空多行\n   使用HTML的\\<br>标签来实现\n\n4. 附加说明\n   在使用typora软件时，`三个换行`表示真正的换行；\"四个空格\"功能未知。\n\n   \n\n## 4、列表\n\n1. 无序列表\n   一般用“\\*号+**空格**+内容”或者“+号+**空格**+内容”，再或者“-号+**空格**+内容”。\n\n&emsp;&emsp;<font color=\'red\'>怎么做</font>：`* 列表内容`或`+ 列表内容`或`- 列表内容` ，效果为：\n\n- 列表测试\n\n\n2. 有序列表\n   格式为：\"1.+空格+项目1\"\n\n&emsp;&emsp;<font color=\'red\'>怎么做</font>：`1. 有序列表`\n\n3. 列表嵌套\n   在上层列表下“添加四个空格”即可。\n\n&emsp;&emsp;<font color=\'red\'>怎么做</font>：\n\n```markdown\n- 列表1\n[四个空格]- 列表1.1\n```\n\n效果为：\n\n- 列表1\n  - 列表1.1\n\n## 5、引用\n\n1. 引用\n   “>”加上空格，就是引用。\n2. 多层引用\n   “>>”加上空格，就是多层引用。\n\n> 引用1\n> 继续\n\n>> 二级引用\n>\n>>> 三级引用\n\n## 6、代码\n\n1. 段落文字中的代码\n   文字中的代码，用反引号`printf(\"hello,world!\");`包裹。\n2. 独立代码块\n   独立的代码块用三个反引号包含，并指明类型，如：\n\n```c\nprintf(\"hello,world!\");\n```\n\n\n\n## 7、链接\n\n1. 方式1 []和（）\n   格式为：\\[链接名](链接地址)\n   圆括号中可以为网络地址，也可以为本地的绝对地址、相对地址。\n   例如：[VSCode背景图](C:\\backgroud.jpg)  ，\n   可以添加链接的标题：\\[VSCode背景图](C:\\backgroud.jpg \"链接的标题\") \n2. 方式2 采用类似参考文献的格式\n   类似于参考文献，\\[链接名][1]   ,然后在文件内容的最后面，写上[1]:链接地址\n\n\n\n## 8、图片\n\n图片的插入和链接类似，可以网络，也可以本地。\n格式为：\\!\\[图片名](图片的地址)\n例如：\\!\\[VSCode背景图](C:\\backgroud.jpg)\n再比如：![网络图片](https://imgtu.com/i/ObErMq)\n\n## 9、表格\n\n表格用“|”来分隔。&emsp;&emsp;<font color=\'red\'>怎么做</font>：\n\n```markdown\n|表头1|表头2|\n|---|:----:|\n|单元格1|单元格2|\n```\n\n效果如下所示：\n\n| 表头1   |  表头2  |\n| ------- | :-----: |\n| 单元格1 | 单元格2 |\n\n注意：（空一行表示表格结束）短横线做分割线，至少要三个。\n说明：用冒号:来设置左右对齐方式，如`左对齐：\":单元格\" `；`右对齐 “单元格:”`；`居中： “:单元格:”`。\n\n\n\n## 10、markdown高级\n\n1、支持使用HTML标签\n除了用过的`<br>`表示换行以外，`<kbd>`表示用小框框把指定文字框起来，如<kbd>测试</kbd>\n其他的还有，如 \\<kbd>  \\<b> \\<i> \\<em> \\<sup>  \\<sub>,还有\\<img src = https://xx.png alt=\"我的图片\" style=\"zoom:33%\">\\</img>\n2、双`$`符号\n`$$`符号用来表示公式，格式如：\n\n```latex\n$$\n-xxx-\n$$\n```\n\n此外，行间公式`$a+b=c$`  ，或者块级公式：\n`$$ a+b=c $$`\n\n## 11、markdown语法的后续补充\n\n(1)、**高亮**格式： ==高亮的内容==  ，说明：该部分内容在“typora->文件->偏好设置->Markdown->Markdown扩展语法”中的对应选项要先勾选上才会生效。\n\n&emsp;&emsp;<font color=\'red\'>怎么做</font>：`==高亮的内容== `\n\n(2)、**删除线**：~~alt+shift+5~~  ，文字的前后加上两个波浪号。\n\n&emsp;&emsp;<font color=\'red\'>怎么做</font>：`~~alt+shift+5~~`\n\n(3)、**加粗**：前后两个星号,ctrl+B\n\n&emsp;&emsp;<font color=\'red\'>怎么做</font>：`**ctrl+b**`\n\n(4)、**斜体**：前后一个星号,ctrl+I\n\n&emsp;&emsp;<font color=\'red\'>怎么做</font>：`*ctrl+b*`\n\n(5)、**下划线**：<u>ctrl+u</u>   前后加上\\<u>和\\</u>\n\n&emsp;&emsp;<font color=\'red\'>怎么做</font>：`<u>ctrl+u</u>`\n\n(6)、**表格** ctrl+t\n\n&emsp;&emsp;<font color=\'red\'>怎么做</font>：1) 使用`ctrl+t`弹出表格创建提示框； 2) 使用以下语法来创建表格：\n\n```markdown\n|英文代码|对应颜色|----|英文代码|对应颜色|\n|:-----|:-----:|:--:|:----:|:-----:|  //表头和内容的分割符号\n\n//其中：|:--:|表示居中对齐，|:--|表示左对齐\n\n|red|红色|----|purple|紫色|\n|green|绿色|----|skyblue|天蓝色|\n|blue|蓝色|----|lightgreen|淡绿色|\n|Gold|金色|----|grey|灰色|\n|Orange|橙色|----|blueviolet|深紫罗兰色|\n```\n\n效果为：\n\n| 英文代码 | 对应颜色 | ---- |  英文代码  |  对应颜色  |\n| :------- | :------: | :--: | :--------: | :--------: |\n| red      |   红色   | ---- |   purple   |    紫色    |\n| green    |   绿色   | ---- |  skyblue   |   天蓝色   |\n| blue     |   蓝色   | ---- | lightgreen |   淡绿色   |\n| Gold     |   金色   | ---- |    grey    |    灰色    |\n| Orange   |   橙色   | ---- | blueviolet | 深紫罗兰色 |\n\n(7)、**流程图**\n\n&emsp;&emsp;<font color=\'red\'>怎么做</font>： 使用以下语法来创建表格：\n\n```markdown\n//[这里有三个反引号]flow\nst=>start: Start\ne=>end\nop=>operation: My Operation\ncond=>condition: Yes or No?\n\nst->op->cond\ncond(yes)->e\ncond(no)->op\n[这里有三个反引号]\n```\n\n下面就是上述代码的渲染效果了：\n\n```flow\nst=>start: Start\ne=>end\nop=>operation: My Operation\ncond=>condition: Yes or No?\n\nst->op->cond\ncond(yes)->e\ncond(no)->op\n```\n\n(8)、**时序图**\n\n&emsp;&emsp;<font color=\'red\'>怎么做</font>： 使用以下语法来创建表格：\n\n```markdown\n[这里有三个反引号]sequence\nAlice->Bob: Hello Bob, how are you?\nNote right of Bob: Bob thinks\nBob-->Alice: I am good thanks!\n[这里有三个反引号]\n```\n\n下面就是上述代码的渲染效果了：\n\n```sequence\nAlice->Bob: Hello Bob, how are you?\nNote right of Bob: Bob thinks\nBob-->Alice: I am good thanks!\n```\n\n(9)、**复选框**\n\n&emsp;&emsp;<font color=\'red\'>怎么做</font>： 使用`- []`和`- [x]`语法来创建复选框，实现todo-list功能。\n\n- [x] 已完成事项\n- [ ] 代办事项 \n\n(10)、**上下标**\n\n&emsp;&emsp;<font color=\'red\'>怎么做</font>： 上标：`x^2^`，下标：`H~2~O`。\n\n效果如下：\n\n上标： x^2^\n下标：H~2~O\n\n(11)、**链接和脚注**\n\n链接在前面已经说过了，这里简单再提一下：\\[链接名](链接地址)\n\n&emsp;&emsp;<font color=\'red\'>怎么做</font>：脚注的格式是： \n\n```markdown\n在待脚注的位置写上A`[^1]`。是多少\n\n然后在后文，空一行，再加上：B`[^1]:脚注的内容`\n\n这部分脚注B的内容会被移动到文章的最末尾显示，并且会在A处留校一个可以跳转的链接，同时B处也有往回跳转的链接。主要注意的是，上述A和B仅是为了方便说明，实际使用是不要加上这两个字符。\n\n```\n\n下面是脚注的效果：\n\n脚注的格式是： 在待脚注的位置写上[^1]。是多少\n\n[^1]: 示例：脚注的内容\n\n(12)、**实现空格**\n\n&emsp;&emsp;<font color=\'red\'>怎么做</font>：用该字符`&emsp;`来实现一个空字符，对于某些需要首行缩进两个字符的情况，使用两个字符来实现：`&emsp;&emsp;`\n\n\n\n## 12、修改字体颜色\n\n格式为：`<font color=\'orange\'>并发</font>`\n效果为：<font color=\'blueviolet\'>测试</font>\n里面可以找找好看的颜色对应的标签名：[配色网](https://www.flatuicolorpicker.com/)\n常用的标签如下表格所示：\n\n| 英文代码 | 对应颜色 | ---- |  英文代码  |  对应颜色  |\n| :------: | :------: | :--: | :--------: | :--------: |\n|   red    |   红色   | ---- |   purple   |    紫色    |\n|  green   |   绿色   | ---- |  skyblue   |   天蓝色   |\n|   blue   |   蓝色   | ---- | lightgreen |   淡绿色   |\n|   Gold   |   金色   | ---- |    grey    |    灰色    |\n|  Orange  |   橙色   | ---- | blueviolet | 深紫罗兰色 |\n\n**说明**：标签首字母的大写可以不用大写，但是为了单词的可读性，建议首字母大写，如BlueViolet。\n\n\n## 13、分割线\n\n可以在一行中用三个以上的减号来建立一个分隔线，同时需要在分隔线的上面空一行。\n\n## 14、makedown在vuepress中的扩展语法--之容器\n\n::: info\n信息容器。\n:::\n\n::: note\n注释容器。\n:::\n\n::: tip\n提示容器\n:::\n\n::: warning\n警告容器\n:::\n\n::: danger\n危险容器\n:::\n\n::: details\n详情容器\n:::\n\n\n::: theorem 牛顿第一定律\n假若施加于某物体的外力为零，则该物体的运动速度不变。\n:::\n\n\n::: right\n来自 [维基百科](https://zh.wikipedia.org/wiki/%E7%89%9B%E9%A1%BF%E8%BF%90%E5%8A%A8%E5%AE%9A%E5%BE%8B)\n:::\n\n补充说明，对于badge标签，支持的类型有：类型: \"tip\" | \"warning\" | \"danger\" | \"info\" | \"note\"，默认值为info\n\n## 15、流程图\n\n下面这个流程图的代码为：\n\n```markdown\n[这里有三个反引号]flow\ncond=>condition: Process?\nprocess=>operation: Process\ne=>end: End\n\ncond(yes)->process->e\ncond(no)->e\n[这里有三个反引号]\n```\n\n效果为：\n\n```flow\ncond=>condition: Process?\nprocess=>operation: Process\ne=>end: End\n\ncond(yes)->process->e\ncond(no)->e\n```',1,0,0,0,1,'2023-06-07 17:02:26','2023-06-07 19:59:58');
INSERT INTO `t_article` VALUES (92,1,57,'https://upload.haoxx.site/article/2fcfdfae4d9133ae7d74c18af1dcf632.jpg','markdown之脚注设置','---\ntitle: markdown之frontmatter设置\ndate: 2021-2-15 20:00:01\ntag:\n - tag4\ncategory: \n - markdown基本规则\npublish: true\nfooter: <a href=\"https://beian.miit.gov.cn/#/Integrated/index\">渝ICP备2023001651号</a>\n\n---\n\n:::tip\n这篇文档主要是总结文章的前页（frontmatter）参数设置。参考了vuepress-theme-hope官网上的资料[点击查看](https://theme-hope.vuejs.press/zh/config/frontmatter/info.html)\n:::\n\n<!-- more -->\n\n## 注意！\n\n文章的前页使用yaml语言来设计的，其格式为`选项:[空格]选项值`。\n\n## 基本设置\n\n建议的选项有：\n\n- title：文章标题（当前页面内容标题，默认为 Markdown 文件中的第一个 h1 标签内容。）\n- description：当前页面内容描述，字符串类型\n  -icon：图标，字符串，[图标指南](https://theme-hope.vuejs.press/zh/guide/interface/icon.html) ，一共有三类图标，我们在主题配置文件中选择的是Iconfont，所以在[这个图标网站](https://www.iconfont.cn/)上去找我们需要的图标名。\n- author：作者，字符串类型\n- isOriginal：是否原创，布尔，默认为false\n- date：时间，注意格式为`YYYY-MM-DD` 或`YYYY-MM-DD hh:mm:ss`\n- category：分类，字符串或字符串数组\n- tag：标签，字符串或字符串数组\n- sticky：是否在列表中指定，类型为`boolean | number`，当填入数字时，取值越大排名越靠前，默认为false\n- star：是否收藏进博客的文章列表，类型为`boolean | number`，当填入数字时，取值越大排名越靠前，默认为false\n\n## 其他设置--信息类的frontmatter\n\n下面这些是扩展性设置\n\n- article：是否将该文章添加至文章列表中，布尔，默认为true\n- timeline：是否将该文章添加至时间线中。布尔，默认为true\n- image：设置预览图 (分享图)，请填入绝对路径，字符串\n- banner：设置横幅图片 (宽屏分享图)，请填入绝对路径，字符串\n\n## 其他设置--布局的frontmatter\n\n下面这些是扩展性设置\n\n- pageview：是否开启浏览量显示，布尔，默认为true\n- comment：是否开启评论显示，布尔，默认为true\n- breadcrumb：是否开启路径导航\n- breadcrumbIcon：是否开启路径导航图标\n- navbar：导航栏配置，填入 false 会禁用导航栏\n- sidebar：侧边栏配置选项。支持 \"heading\" 或 false\n- headerDepth：标题渲染深度，默认为2\n- index：是否在侧边栏中索引当前页面，布尔，默认为true\n- order：指定当前页面在侧边栏中的排序\n  - 当填写正数的时候，页面将排在靠前的位置，数字越小出现的位置越前。\n  - 当填写负数的时候，页面将排在靠后的位置，数字越大出现的位置越前（比如 -1 在 -2 之后）。\n- lastUpdated：是否显示最后更新时间，默认值: 主题选项中的值\n- editLink：是否显示编辑链接，布尔，默认值: 主题选项中的值\n- contributors：是否显示贡献者，布尔，默认值: 主题选项中的值\n- footer：设置页脚内容。\n  - 设置为 false 以禁用页脚\n  - 设置为 \"\" 以移除默认的页脚内容，\n  - 设置为 true 以使用默认页脚。\n\n更多详情请看 [页面 → 页脚支持](https://theme-hope.vuejs.press/zh/guide/layout/footer.html)\n\n- copyright：设置版权信息，更多详情请看[页面，页脚支持](https://theme-hope.vuejs.press/zh/guide/layout/footer.html)\n\n## 文档主页的frontmatter设置\n\n## 博客主页的frontmatter设置\n\n## 某些插件的frontmatter设置\n\n版权页copyroght2插件，feed2插件，sitmap2插件\n',1,0,0,0,1,'2023-06-07 17:03:20','2023-06-07 19:59:49');
INSERT INTO `t_article` VALUES (93,1,58,'https://upload.haoxx.site/article/716ceea8febe298c99a60b324b168a7e.jpg','部分有用的网站记录','# 网站导航记录\n\n来源于：CodeSheep的github：https://github.com/rd2coding/Road2Coding\n\n1、数据结构\n\nhttps://mp.weixin.qq.com/s/f9dfQQbpKjMopH6m2Gjiiw\n\n2、编程自学网站\n\nhttps://mp.weixin.qq.com/s/jFc-6QK2Mv1zHuhuFrqhog\n\n3、Linux系统性能监控小工具\n\ntop、htop、iftop等等\nhttps://mp.weixin.qq.com/s/zWIv5yBTD0Tvt8txb8znrA\n\n4、程序员命令行生产力！：终端和命令\n\nhttps://mp.weixin.qq.com/s/k19ZT_yH4lzNLUYkH2GUJA\n\nCLI指的是： command-line  interface\n\n5、git官方中文说明文档\n\nhttps://developers.weixin.qq.com/miniprogram/dev/framework/\n\n6、微信小程序官方开发文档\n\nhttps://developers.weixin.qq.com/miniprogram/dev/framework/\n\n\n\n\n\n',1,0,0,0,1,'2023-06-07 17:04:31','2023-06-07 19:59:31');
INSERT INTO `t_article` VALUES (94,1,59,'https://upload.haoxx.site/article/95bfa093fc995038d2b6e82aeab43625.jpg','微信公众号写文章工具墨滴','![](https://files.mdnice.com/logo.svg)\n\n请使用 **Chrome** 浏览器。\n\n请阅读下方文本熟悉工具使用方法，本文可直接拷贝到微信中预览。点击[墨滴官网](https://mdnice.com/)查看更多信息，注意：需要注册登录后才能看到编辑页面。其他微信公众号编辑工具（包含无需注册的）详见：[知乎文章](https://zhuanlan.zhihu.com/p/385098206)\n\n\n[TOC]\n\n\n## 1 Markdown Nice 简介\n\n- 支持自定义样式的 Markdown 编辑器\n- 支持微信公众号、知乎和稀土掘金\n- 欢迎扫码回复「排版」加入推文群\n\n![](https://files.mdnice.com/pic/cd3ca20c-896f-4cfc-9bdd-c4c58e69ba26.jpg)\n\n## 2 主题\n\n**https://product.mdnice.com/themes/**\n\n欢迎提交主题，提供更多文章示例~~\n\n## 3 通用语法\n\n### 3.1 标题\n\n在文字写书写不同数量的`#`可以完成不同的标题，如下：\n\n# 一级标题\n\n## 二级标题\n\n### 三级标题\n\n### 3.2 无序列表\n\n无序列表的使用，在符号`-`后加空格使用。如下：\n\n- 无序列表 1\n- 无序列表 2\n- 无序列表 3\n\n如果要控制列表的层级，则需要在符号`-`前使用空格。如下：\n\n- 无序列表 1\n- 无序列表 2\n  - 无序列表 2.1\n  - 无序列表 2.2\n\n**由于微信原因，最多支持到二级列表**。\n\n### 3.3 有序列表\n\n有序列表的使用，在数字及符号`.`后加空格后输入内容，如下：\n\n1. 有序列表 1\n2. 有序列表 2\n3. 有序列表 3\n\n### 3.4 粗体和斜体\n\n粗体的使用是在需要加粗的文字前后各加两个`*`。\n\n而斜体的使用则是在需要斜体的文字前后各加一个`*`。\n\n如果要使用粗体和斜体，那么就是在需要操作的文字前后加三个`*`。如下：\n\n**这个是粗体**\n\n_这个是斜体_\n\n**_这个是粗体加斜体_**\n\n### 3.5 链接\n\n微信公众号仅支持公众号文章链接，即域名为`https://mp.weixin.qq.com/`的合法链接。使用方法如下所示：\n\n对于该论述，欢迎读者查阅之前发过的文章，[你是《未来世界的幸存者》么？](https://mp.weixin.qq.com/s/s5IhxV2ooX3JN_X416nidA)\n\n### 3.6 引用\n\n引用的格式是在符号 `>` 后面书写文字，文字的内容可以包含标题、链接、图片、粗体和斜体等。\n\n一级引用如下：\n\n> ### 一级引用示例\n>\n> 读一本好书，就是在和高尚的人谈话。 **——歌德**\n>\n> [Markdown Nice最全功能介绍](https://mp.weixin.qq.com/s/lM808MxUu6tp8zU8SBu3sg)\n>\n> ![这里写图片描述](https://files.mdnice.com/pic/cd3ca20c-896f-4cfc-9bdd-c4c58e69ba26.jpg)\n\n当使用多个 `>` 符号时，就会变成多级引用\n\n二级引用如下：\n\n>> ### 二级引用示例\n>\n>> 读一本好书，就是在和高尚的人谈话。 **——歌德**\n>\n>> [Markdown Nice最全功能介绍](https://mp.weixin.qq.com/s/lM808MxUu6tp8zU8SBu3sg)\n>\n>> ![这里写图片描述](https://files.mdnice.com/pic/cd3ca20c-896f-4cfc-9bdd-c4c58e69ba26.jpg)\n\n三级引用如下：\n\n>>> ### 三级引用示例\n>\n>>> 读一本好书，就是在和高尚的人谈话。 **——歌德**\n>\n>>> [Markdown Nice最全功能介绍](https://mp.weixin.qq.com/s/lM808MxUu6tp8zU8SBu3sg)\n>\n>>> ![这里写图片描述](https://files.mdnice.com/pic/cd3ca20c-896f-4cfc-9bdd-c4c58e69ba26.jpg)\n\n### 3.7 分割线\n\n可以在一行中用三个以上的减号来建立一个分隔线，同时需要在分隔线的上面空一行。如下：\n\n---\n\n### 3.8 删除线\n\n删除线的使用，在需要删除的文字前后各使用两个`~`，如下：\n\n~~这是要被删除的内容。~~\n\n### 3.9 表格\n\n可以使用冒号来定义表格的对齐方式，如下：\n\n| 姓名       | 年龄 |         工作 |\n| :--------- | :--: | -----------: |\n| 小可爱     |  18  |     吃可爱多 |\n| 小小勇敢   |  20  |   爬棵勇敢树 |\n| 小小小机智 |  22  | 看一本机智书 |\n\n宽度过长的表格可以滚动，可在自定义主题中调节宽度：\n\n| 姓名       | 年龄 |         工作 |      邮箱       |    手机     |\n| :--------- | :--: | -----------: | :-------------: | :---------: |\n| 小可爱     |  18  |     吃可爱多 | lovely@test.com | 18812345678 |\n| 小小勇敢   |  20  |   爬棵勇敢树 | brave@test.com  | 17712345678 |\n| 小小小机智 |  22  | 看一本机智书 | smart@test.com  | 16612345678 |\n\n### 3.10 图片\n\n插入图片，如果是行内图片则无图例，否则有图例，格式如下：\n\n![这里写图片描述](https://files.mdnice.com/pic/cd3ca20c-896f-4cfc-9bdd-c4c58e69ba26.jpg)\n\n可以通过在图片尾部添加宽度和高度控制图片大小，用法如下：\n\n![同时设置宽度和高度](https://files.mdnice.com/logo.png =150x150)\n\n![只设置宽度，推荐使用百分比](https://files.mdnice.com/logo.png =40%x)\n\n该语法比较特殊，其他 Markdown 编辑器不完全通用。\n\n支持 jpg、png、gif、svg 等图片格式，**其中 svg 文件仅可在微信公众平台中使用**，svg 文件示例如下：\n\n![](https://files.mdnice.com/i-am-svg.svg)\n\n- 支持图片**拖拽和截图粘贴**到编辑器中上传，上传时使用当前选择的图床。\n- 可使用**格式->图片**上传本地图片，网站目前支持「图壳」图床，失败率低，但是只可保存一天用于排版\n\n**注：仅支持 https 的图片，图片粘贴到微信、知乎或掘金时会自动上传其服务器，不必担心使用上述图床会导致图片丢失**。\n\n图片还可以和链接嵌套使用，能够实现推荐卡片的效果，用法如下：\n\n[![Markdown Nice 最全功能介绍](https://files.mdnice.com/dance.gif)](https://mp.weixin.qq.com/s/lM808MxUu6tp8zU8SBu3sg)\n\n## 4. 特殊语法\n\n### 4.1 脚注\n\n> 支持平台：微信公众号、知乎。\n\n脚注与链接的区别如下所示：\n\n```markdown\n链接：[文字](链接)\n脚注：[文字](脚注解释 \"脚注名字\")\n```\n\n有人认为在[大前端时代](https://en.wikipedia.org/wiki/Front-end_web_development \"Front-end web development\")的背景下，移动端开发（Android、IOS）将逐步退出历史舞台。\n\n[全栈工程师](是指掌握多种技能，并能利用多种技能独立完成产品的人。 \"什么是全栈工程师\")在业务开发流程中起到了至关重要的作用。\n\n脚注内容请拉到最下面观看。\n\n### 4.2 代码块\n\n> 支持平台：微信公众号、知乎。\n\n如果在一个行内需要引用代码，只要用反引号引起来就好，如下：\n\nUse the `printf()` function.\n\n在需要高亮的代码块的前一行及后一行使用三个反引号，同时**第一行反引号后面表示代码块所使用的语言**，如下：\n\n```java\n// FileName: HelloWorld.java\npublic class HelloWorld {\n  // Java 入口程序，程序从此入口\n  public static void main(String[] args) {\n    System.out.println(\"Hello,World!\"); // 向控制台打印一条语句\n  }\n}\n```\n\n支持以下语言种类：\n\n```\nbash\nclojure，cpp，cs，css\ndart，dockerfile, diff\nerlang\ngo，gradle，groovy\nhaskell\njava，javascript，json，julia\nkotlin\nlisp，lua\nmakefile，markdown，matlab\nobjectivec\nperl，php，python\nr，ruby，rust\nscala，shell，sql，swift\ntex，typescript\nverilog，vhdl\nxml\nyaml\n```\n\n如果想要更换代码主题，可在上方挑选，不支持代码主题自定义。\n\n其中**微信代码主题与微信官方一致**，有以下注意事项：\n\n- 带行号且不换行，代码大小与官方一致\n- 需要在代码块处标志语言，否则无法高亮\n- 粘贴到公众号后，用鼠标点代码块内外一次，完成高亮\n\ndiff 不能同时和其他语言的高亮同时显示，且需要调整代码主题为微信代码主题以外的代码主题才能看到 diff 效果，使用效果如下:\n\n```diff\n+ 新增项\n- 删除项\n```\n\n**其他主题不带行号，可自定义是否换行，代码大小与当前编辑器一致**\n\n### 4.3 数学公式\n\n> 支持平台：微信公众号、知乎。\n\n行内公式使用方法，比如这个化学公式：$\\ce{Hg^2+ ->[I-] HgI2 ->[I-] [Hg^{II}I4]^2-}$\n\n块公式使用方法如下：\n\n$$H(D_2) = -\\left(\\frac{2}{4}\\log_2 \\frac{2}{4} + \\frac{2}{4}\\log_2 \\frac{2}{4}\\right) = 1$$\n\n矩阵：\n\n$$\n  \\begin{pmatrix}\n  1 & a_1 & a_1^2 & \\cdots & a_1^n \\\\\n  1 & a_2 & a_2^2 & \\cdots & a_2^n \\\\\n  \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\\n  1 & a_m & a_m^2 & \\cdots & a_m^n \\\\\n  \\end{pmatrix}\n$$\n\n公式由于微信不支持，目前的解决方案是转成 svg 放到微信中，无需调整，矢量不失真。\n\n目前测试如果公式量过大，在 Chrome 下会存在粘贴后无响应，但是在 Firefox 中始终能够成功。\n\n### 4.4 TOC\n\n> 支持平台：微信公众号、知乎。\n\nTOC 全称为 Table of Content，列出全部标题。由于示例标题过多，需要使用将下方代码段去除即可。\n\n```\n[TOC]\n```\n\n由于微信只支持到二级列表，本工具仅支持二级标题和三级标题的显示。\n\n### 4.5 注音符号\n\n> 支持平台：微信公众号。\n\n支持注音符号，用法如下：\n\nMarkdown Nice 这么好用，简直是{喜大普奔|hē hē hē hē}呀！\n\n### 4.6 横屏滑动幻灯片\n\n> 支持平台：微信公众号。\n\n通过`<![](url),![](url)>`这种语法设置横屏滑动滑动片，具体用法如下：\n\n<![蓝1](https://files.mdnice.com/blue.jpg),![绿2](https://files.mdnice.com/green.jpg),![红3](https://files.mdnice.com/red.jpg)>\n\n### 4.7 容器块\n\n> 支持平台：微信公众号。\n\n通过`::: block-1`开头，`:::`结尾，来设置容器块，容器块内可以使用任意 markdown 语法，容器块内显示样式可自定义，不会被外部干扰\n\n目前仅支持三种容器块，`block-1`、`block-2`和`block-3`\n\n::: block-1\n\n### 容器块 1 示例\n\n> 读一本好书，就是在和高尚的人谈话。 **——歌德**\n> :::\n\n::: block-2\n\n### 容器块 2 示例\n\n> 读一本好书，就是在和高尚的人谈话。 **——歌德**\n> :::\n\n::: block-3\n\n### 容器块 3 示例\n\n> 读一本好书，就是在和高尚的人谈话。 **——歌德**\n> :::\n\n### 4.8 分列\n\n> 支持平台：微信公众号。\n\n对于需要 2 列展示的内容，可以通过分列语法实现，可以设置左右比例，不设置时默认各为50%，示例如下：\n\n:::: column\n::: column-left\n\n**左边的内容**\n\n![左边的图片](https://files.mdnice.com/blue.jpg)\n\n:::\n::: column-right\n\n**右边的内容**\n\n![右边的图片](https://files.mdnice.com/green.jpg)\n\n:::\n::::\n\n设置百分比示例如下：\n\n:::: column\n::: column-left 30%\n\n**左边的内容**\n\n![左边的图片](https://files.mdnice.com/blue.jpg)\n\n:::\n::: column-right 70%\n\n**右边的内容**\n\n![右边的图片](https://files.mdnice.com/green.jpg)\n\n:::\n::::\n\n## 5 其他语法\n\n### 5.1 HTML\n\n支持原生 HTML 语法，请写内联样式，如下：\n\n<span style=\"display:block;text-align:right;color:orangered;\">橙色居右</span>\n<span style=\"display:block;text-align:center;color:orangered;\">橙色居中</span>\n\n### 5.2 UML\n\n不支持，推荐使用开源工具`https://draw.io/`制作后再导入图片\n\n### 5.3 更多文档\n\n更多文档请参考 [mdnice 产品主页](https://product.mdnice.com/articles/ \"更多文档\")',1,0,0,0,1,'2023-06-07 17:05:28','2023-06-07 19:59:21');
INSERT INTO `t_article` VALUES (95,1,60,'https://upload.haoxx.site/article/190eee4ddc61160d9293c95a65123531.jpg','docker使用记录','# docker记录\n\n## 安装\n\n镜像  容器  仓库\n略\n\n## 常用命令\n\ndocker rm container-id 删除指定 id 的容器\n\ndocker stop/start container-id 停止/启动指定 id 的容器\n\ndocker rmi image-id 删除指定 id 的镜像\n\ndocker volume ls 查看 volume 列表\n\ndocker network ls 查看网络列表\n\n镜像相关：\n\n导出镜像：docker iamge save centos:7.2.1511 > centos-7.2.1511.tgz\n\n导入镜像： docker image load -i centos-7.2.1511.tgz\n\n查看镜像详细信息：docker image inspect 镜像-ID\n\ndocker images 查看镜像列表\n\ndocker search XX 默认在本地，没有的话去docker hub上搜索\n\n容器相关：\ndocker ps 查看当前运行中的容器(-a查看所有容器记录，包括死了的)\n用镜像启动一个容器：docker run -d -p 80:80 nginx (-d表示后台运行，-p表示端口映射)\n查看容器信息：docker container inspect 容器ID\n进入容器空间1：docker run -it centos bash  （从镜像到容器）\n进入容器空间2：docker exec -it 容器ID bash （从终端进入到一个活着的容器，比如后台容器）\n\n\n容器端口映射：\n\n| 命令                              | 解释                              |\n| --------------------------------- | --------------------------------- |\n| -**p hostPort:containerPort**     | 端口映射-p 8080:80                |\n| **-p ip:hostPort:containerPort**  | 配置监听地址-p 10.0.0.100:8080:80 |\n| **p ip::containerPort**           | 随机分配端口 -p 10.0.0.100：：80  |\n| **-p hostPort:containerPort:udp** | 指定协议 -p 8080:80:tcp           |\n| **-p 81:80 -p 443:443**           | 指定多个                          |\n\n\n\n\n## 写自己的镜像 Dockerfile\n\n```Dockerfile\nFROM node:11\nMAINTAINER easydoc.net\n\n# 复制代码\nADD . /app\n\n# 设置容器启动后的默认运行目录\nWORKDIR /app\n\n# 运行命令，安装依赖\n# RUN 命令可以有多个，但是可以用 && 连接多个命令来减少层级。\n# 例如 RUN npm install && cd /app && mkdir logs\nRUN npm install --registry=https://registry.npm.taobao.org\n\n# CMD 指令只能一个，是容器启动后执行的命令，算是程序的入口。\n# 如果还需要运行其他命令可以用 && 连接，也可以写成一个shell脚本去执行。\n# 例如 CMD cd /app && ./start.sh\nCMD node app.js\n\n```\n\n说明：\nFROM 这个镜像的妈妈是谁？（指定基础镜像）\nMAINTAINER告诉别人，谁负责养他？（指定维护者信息，可以没有）\nRUN 你想让他干啥（在命令前加上RUN即可）\nADD 给他一点创业资金（copy文件，会自动解压）\nWORKDIR 我是cd，今天刚化了妆（设置当前工作目录）\nVILUME 给他一个存放行李的地方（设置卷，挂载主机目录）\nEXPOSE 他要打开的门是什么（指定对外的端口）\nCMD 奔跑吧，兄弟 （指定容器启动后要干的事情）\n**Docker的其他命令**：\n\n> CPOY 复制文件\n>\n> ENV 环境变量\n>\n> ENTRYPOINT 容器启动后执行的命令\n\n### Build为镜像（安装包）和运行\n\n编译 `docker build -t test:v1 .`\n\n> -t 设置镜像名字和版本号\n\n运行`docker run -p 8080:8080 --name test-hello test:v1`\n\n> -p 映射容器内端口到宿主机\n>\n> --name 容器名字\n>\n> -d 后台运行\n\n## 目录挂载\n\n现存问题：\n\n+ 使用 Docker 运行后，我们改了项目代码不会立刻生效，需要重新build和run，很是麻烦。\n+ 容器里面产生的数据，例如 log 文件，数据库备份文件，容器删除后就丢失了。\n\n**目录挂载**以解决上述问题\n\n几种挂载方式：\n\n+ bind mount 直接把宿主机目录映射到容器内，适合挂代码目录和配置文件。可挂到多个容器上\n+ volume 由容器创建和管理，创建在宿主机，所以删除容器不会丢失，官方推荐，更高效，Linux 文件系统，适合存储数据库数据。可挂到多个容器上\n+ tmpfs mount 适合存储临时文件，存宿主机内存中。不可多容器共享。\n\n### 挂载演示\n\n`bind mount` 方式用绝对路径 -v D:/code:/app\n\n`volume` 方式，只需要一个名字 -v db-data:/app\n\n\n## 2023/04/29 学习容器技术\n\n一种环境隔离的虚拟化技术，相比于传统的虚拟化技术，它拥有利用系统资源更高效、启动时间更快、持续交付和部署等特点。\n\n\n\n## 2023/06/06 使用\n\n在配置和使用[ttkican_Blog-master博客](https://github.com/ttkican/Blog)时的一些命令记录\n\n### 1、docker 与docker-compose的安装\n\n### 2、下载镜像\n\n```dockerfile\ndocker pull 镜像名:属性\ndocker pull canal/canal-server:latest\n```\n\n### 3、运行镜像\n\n```dockerfile\ndocker run --name canal -d canal/canal-server:latest\n```\n\n注意：镜像只有一个，下载的就是镜像。但是可以用该镜像运行若干个不同的容器\n\n### 4、docker容器的操作：\n\n```bash\n# 1) 查看正在运行的容器\ndocker ps \n# 1.2) 查看已经下载的镜像\ndocker images\n# 2）查看所有容器\ndocker ps -a\n# 3) 停止指定容器\ndocker stop 容器名或容器ID\n# 4）启动容器\ndocker start 容器名和容器ID\n# 5）进入容器终端，以mysql容器举例\ndocker exec -it mysql bash\n# 上述命令中 -it 表示以交互式的方式， bash 表示以bash终端的方式来交互\n# 6）容器与本地Linux之间的文件拷贝\ndocker cp /home/ubuntu/xxx.sql mysql:/\ndocker cp mysql:/xx.sql /home/ubuntu/\n# 7) 容器的删除和镜像的删除\ndocker rm 容器名或容器ID\ndocker rmi 镜像名或镜像ID\n# 8) 使用docker-compose和对应的docker-compose.yml来启动docker容器\ndocker-compose up -d --build  # 在有docker-compose.yml的同级目录下运行哦\n# 9) 查看docker网络\ndocker network ls\n# 查看上述命令的输出，例如我在docker-compose.yml中设置了网络名为：blog-net，然后就能在docker network ls下看到有个NAME为docker_blog-net的网络，然后其NETWORK_ID为d32231f3430c，在然后使用ifconfig命令查看docker虚拟网卡(是类似于br-xxx这种，这里是br-d32231f3430c，而不是下面的veth8fad9XX等)，就知道了该docker网络下的IP为172.20.0.1，后面其他同docker network下的容器想要和mysql容器和redis容器通信的话就填172.20.0.1。注意：docker容器下的127.0.0.1是容器内部自身的回环地址，其他容器肯定访问不到。\n```\n\ndocker-compose.yml文件示例：\n\n```dockerfile\nversion: \"3\"\nservices:\n  blog-service:\n    build: .\n    image: blog-springboot:latest\n    container_name: blog-springboot\n    restart: always\n    depends_on:\n      - mysql\n      - redis\n      - rabbitmq\n    volumes:\n      - \"/usr/local/upload:/usr/local/upload\"\n    ports:\n      - \"8080:8080\"\n    networks:\n      - blog-net\n  mysql:\n    image: mysql:${MYSQL_VERSION}\n    container_name: mysql\n    restart: always\n    environment:\n      MYSQL_ROOT_PASSWORD: ${MYSQL_ROOT_PASSWORD}\n      TZ: Asia/Shanghai\n    ports:\n      - \"3306:3306\"\n    networks:\n      - blog-net\n  redis:\n    image: redis:${REDIS_VERSION}\n    container_name: redis\n    restart: always\n    command: --requirepass \"${REDIS_PASSWORD}\"\n    ports:\n      - \"6379:6379\"\n    networks:\n      - blog-net\n  rabbitmq:\n    image: rabbitmq:${RABBITMQ_VERSION}\n    container_name: rabbitmq\n    restart: always\n    environment:\n      RABBITMQ_DEFAULT_USER: ${RABBITMQ_USER}\n      RABBITMQ_DEFAULT_PASS: ${RABBITMQ_PASSWORD}\n    ports:\n      - \"5672:5672\"\n      - \"15672:15672\"\n    networks:\n      - blog-net\n  elasticsearch:\n    image: elasticsearch:${ELASTICSEARCH_VERSION}\n    container_name: elasticsearch\n    restart: always\n    environment:\n      discovery.type: \"single-node\"\n      ES_JAVA_OPTS: \"-Xms64m -Xmx128m\"\n      http.cors.enabled: \"true\"\n      http.cors.allow-origin: \"*\"\n      xpack.security.enabled: \"true\"\n      ELASTIC_PASSWORD: \"${ELASTICSEARCH_PASSWORD}\"\n    ports:\n      - \"9200:9200\"\n      - \"9300:9300\"\n    networks:\n      - es-net\n      - blog-net\n  kibana:\n    image: kibana:${ELASTICSEARCH_VERSION}\n    container_name: kibana\n    volumes:\n      - \"/usr/local/kibana/kibana.yml:/usr/share/kibana/config/kibana.yml\"\n    depends_on:\n      - elasticsearch\n    ports:\n      - \"5601:5601\"\n    networks:\n      - es-net\n      - blog-net\n  canal_server:\n    image: canal/canal-server:${CANAL_VERSION}\n    container_name: canal\n    volumes:\n      - \"/usr/local/canal/instance.properties:/home/admin/canal-server/conf/example/instance.properties\"\n      - \"/usr/local/canal/canal.properties:/home/admin/canal-server/conf/canal.properties\"\n    ports:\n      - \"11111:11111\"\n    networks:\n      - blog-net\n  nginx:\n    image: nginx:${NGINX_VERSION}\n    container_name: nginx\n    restart: always\n    volumes:\n      - \"/usr/local/nginx/nginx.conf:/etc/nginx/nginx.conf\"\n      - \"/etc/ssl/certs:/etc/ssl/certs\"\n      - \"/usr/local/vue:/usr/local/vue\"\n      - \"/usr/local/upload:/usr/local/upload\"\n    privileged: true\n    ports:\n      - \"443:443\"\n      - \"80:80\"\n    networks:\n      - blog-net\nnetworks:\n  es-net:\n    driver: bridge\n  blog-net:\n    driver: bridge\n```\n\n对应的启动脚本：\n\n```bash\n#!/bin/bash\n# 文件名：blog-start.sh\n# 打包之后上传的jar包路径\nSOURCE_PATH=/usr/local/docker\n# docker的镜像和容器名称都命名为这个\nSERVER_NAME=blog-springboot\nTAG=latest\n# 容器id\nCID=$(docker ps | grep \"$SERVER_NAME\" | awk \'{print $1}\')\n# 镜像id\nIID=$(docker images | grep \"$SERVER_NAME\" | awk \'{print $3}\')\nif [ -n \"$CID\" ]; then\n  echo \"存在容器$SERVER_NAME, CID-$CID\"\n  docker stop $CID\n  docker rm $CID\nfi\n# 构建docker镜像\nif [ -n \"$IID\" ]; then\n  echo \"存在$SERVER_NAME:$TAG镜像，IID=$IID\"\n  docker rmi $IID\nfi\n# 重新构建镜像并运行\ndocker-compose up -d --build\n```\n\n\n\n\n\n\n\n',1,0,0,0,1,'2023-06-07 17:06:23','2023-06-07 19:59:11');
INSERT INTO `t_article` VALUES (96,1,51,'https://upload.haoxx.site/article/e40b334765dcebff6d4f4b60544bcc7b.jpg','GDB调试','# GDB调试手册\n\n前提：gcc在编译时需要加上-g参数\n\n总结：\n\n> 说明：gdb -c /tmp/core-tuxclocker-19395-1584497577 xx(可执行程序名)\n>\n> <font color=\'red\'>list</font>命令(简写为l)查看源码\n>\n> <font color=\'red\'>layout src</font>显示源代码窗口 （ctrl + x + a 以关闭源代码界面）\n>\n> 运行程序命令<font color=\'red\'>run</font>(简写为r)\n>\n> 设置断点命令<font color=\'red\'>break</font>(简写为b) +行号  或b 函数名\n>\n> 查看断点信息：<font color=\'red\'> info b </font>\n>\n> 清除断点<font color=\'red\'>clear</font>(简写为c) +行号\n>\n> 单步调试：继续执行到下一个断点<font color=\'red\'>continue</font>(简写为c)；单步执行，跳过子函数<font color=\'red\'>next</font>(简写为n)；单步执行，进入子函数<font color=\'red\'>strp</font>(简写为s)\n>\n> 查看变量<font color=\'red\'>print 变量名</font>\n>\n> 运行至函数结束<font color=\'red\'>finish</font>\n>\n> 退出<font color=\'red\'>quit</font>\n\n```c\n/*”核心文件已转储“的错误原因解析：\n\n原因一：内存访问越界\n\n  a) 使用错误的下标，导致数组访问越界；\n\n原因二：多线程程序使用了线程不安全的函数\n\n原因三：多线程读写的数据没有加锁保护；\n\n原因四：非法指针\n\n  a) 使用空指针，\n\n  b) 随意使用指针转换；\n\n原因五：堆栈溢出*/\n```\n\n```c\nlayout：用于分割窗口，可以一边查看代码，一边测试。主要有以下几种用法：\nlayout src：显示源代码窗口\nlayout asm：显示汇编窗口\nlayout regs：显示源代码/汇编和寄存器窗口\nlayout split：显示源代码和汇编窗口\nlayout next：显示下一个layout\nlayout prev：显示上一个layout\nCtrl + L：刷新窗口\nCtrl + x，再按1：单窗口模式，显示一个窗口\nCtrl + x，再按2：双窗口模式，显示两个窗口\n\nCtrl + x，再按a：回到传统模式，即退出layout，回到执行layout之前的调试窗口。\n\n```\n\n##  一、基础入门\n\n```sh\ngdb hello  #hello为程序名\n```\n\n1.1 参数-q，可以再启动时不打印gdb的默认参数\n\n2 参看源码\n\n命令list (简写l)可以查看源码，默认显示10行，通过回车键不断查看剩余代码\n\n3 运行程序\n\n命令run  (简写r)用于运行代码，在程序结束或者遇到断点处停下\n\n4 设置断点\n\n运行break (简写b)命令可以在指定行设置一个断点，断点调试是程序调试里面使用频率最高的技巧\n\n使用方法：“b”命令后面加上相应的行号\n\n设置好断点后，执行一下命令查看断点信息：info b\n![](https://s3.bmp.ovh/imgs/2022/11/12/9d9d4ba1565c9ad2.png)\n\n5 单步调试\n\n+ continue (简写c)：继续执行，到下一个断点处（或运行结束）。\n+ next (简写n)：单步执行，跳过子函数\n+ strp (简写s)：单步执行，进入子函数\n\n6 查看变量\n\n使用print (简写p)指令来查看变量的值，用法为\"print 变量名\"。\n\n7 清除断点\n\nclear + 行号以清除断点。\n\n8 运行至函数结束\n\n使用finish命令来运行程序至函数结束\n\n9 显示源代码窗口\n\n程序运行后，使用命令“layout src”可以显示源代码窗口，当前执行代码会高亮\n\n10 退出gdb\n\n执行quit (简写q)会退出gdb调试\n\n\n11 附加说明\n\ncgdb是gdb的终端界面增强版，它有上下两栏窗口，上栏的窗口支持vi编辑器的语法， 可以方便的使用它来进行字符串定位等功能。在gdb下使用“layout src”时，界面往往容易花屏， 而cgbd更加的稳定可靠。还有一点，cgdb会给不同符号的不同类型辅以不同的颜色。\n\n使用`sudo apt install cgdb`来安装该软件。\n\n## 二、 gdb调试之函数调用栈——backtrace\n\n在写代码的时候，我们会封装很多函数，而这些函数之中又会调用其他的函数，当程序每次调用函数的时候，就会跳转到函数的地方去执行，那么这期间就有很多信息产生了，比如：调用函数的地方，函数的参数，被调用函数的变量等，这些信息其实是存储在栈中的，其实更确切地说，这些信息是存储在函数调用信息帧中的，每个函数及其变量都被分配了一个帧（frame），这些函数信息帧就组成了函数调用栈。我们使用 gdb 调试工具就可以查看函数调用栈的内容信息，可以清晰地看到各个函数的调用顺序以及各函数的输入形参值，是分析程序的执行流程和输入依赖的重要手段。\n\ngdb提供了一些指令可以查看这些帧中的信息，当查询函数变量的信息时，gdb就是从这个被选中的帧内获取信息，但是查看被选中帧外的变量信息是非法的，当程序运行停止的时候，gdb会自动选择当前被调用的函数帧，并且打印简单帧信息。\n\n2、gdb中函数调用栈的指令\n\n+ 2.1 查看栈信息\n\n> <font color=\'red\'>bt</font>：bt是` backtrace` 指令的缩写，显示所有的函数调用栈的信息，栈中的每个函数都被分配了一个编号，最近被调用的函数在 0 号帧中（栈顶），并且每个帧占用一行。\n>\n> <font color=\'red\'>bt n</font>：显示函数调用栈从栈顶算起的n帧信息（n 表示一个正整数）。\n>\n> <font color=\'red\'>bt -n</font>：显示函数调用栈从栈底算起的n帧信息。\n>\n> <font color=\'red\'>bt full</font>：显示栈中所有信息如：函数参数，本地变量等。\n>\n> <font color=\'red\'>bt full n</font>：显示函数调用栈从栈顶算起的n帧的所有信息。\n>\n> <font color=\'red\'>bt full -n</font>：显示函数调用栈从栈底算起的n帧的所有信息。\n\n+ 2.2 查看帧信息\n\n上面的bt指令主要是查看栈的信息，而每一帧都会有详细的信息，这些函数调用信息帧包括：调用函数的地方，函数的参数等。如果想查看栈中某一帧的信息，首先要做的是切换当前栈。这时候需用用到 frame 指令（缩写形式为 f）。\n\n> <font color=\'red\'>f  n</font> ： 它的功能是切换到编号为 n 的栈帧（n 表示一个正整数），并显示相关信息。\n\n![](https://s3.bmp.ovh/imgs/2022/11/13/a89a6a826e86a4be.png)\n\n+ 2.3 up/down指令\n\n除了使用 frame 指令切换栈帧外，还可以使用 up 和 down 指令。\n\n> <font color=\'red\'>down n</font> ： 表示往栈顶方向下移 n 层（n 表示一个正整数，默认值为 1）。\n>\n> <font color=\'red\'>up  n</font> ： 表示往栈底方向上移 n 层。\n\n\n+ 2.4 查看更详细的帧信息\n\ninfo 指令是一个很强大的指令，使用它可以查看各种变量的值，如果我们希望看到详细的函数调用信息帧的信息，如：函数地址、调用函数的地址、被调用函数的地址、当前函数由哪种编程语言编写、函数参数地址及形参值、局部变量的地址、当前桢中存储的寄存器等，可以使用以下指令：\n\n> <font color=\'red\'>info frame</font> ：指令的缩写形式为 `i f` ，查看函数调用帧的所有信息。\n>\n> <font color=\'red\'>info args</font> ：查看函数变量的值。(与print args功能是一样的)\n>\n> <font color=\'red\'>info locals</font> ：查看函数变量的值。\n\n![](https://s3.bmp.ovh/imgs/2022/11/13/7c7dafcff67e8f53.png)\n\n这里面有很多信息：\n\n> + 当前桢的地址：0x7fffffffe030。\n>\n> + ip的值：0x400b58，此处引申介绍一下rip是什么：它是指令地址寄存器，用来存储 CPU 即将要执行的指令地址。每次 CPU 执行完相应的汇编指令之后，rip 寄存器的值就会自行累加，rip 无法直接赋值。\n>\n> + 当前桢函数：test1 (backtrace.c:9)。\n>\n> + 调用者的rip值：saved rip = 0x400bbe。\n>\n> + 调用者的帧地址：0x7fffffffe060。\n>\n> + 源代码所用的程序的语言: source language c。\n>\n> + 当前桢的参数的地址及值：Arglist at 0x7fffffffe020, args: arg=1。\n>\n> + 当前帧中局部变量的地址：Locals at 0x7fffffffe020, Previous frame’s sp is 0x7fffffffe030。\n>\n> + 当前桢中存储的寄存器：rbp at 0x7fffffffe020, rip at 0x7fffffffe028。\n\n除此之外 info 指令还可以查看当前寄存器的值：\n\n> <font color=\'red\'>info registers</font>：查看寄存器的情况（除了浮点寄存器）。\n>\n> <font color=\'red\'>info all-registers</font>：查看所有寄存器的情况（包括浮点寄存器）。\n\n### 2.2 gdb调试递归函数\n\n本小节的主题是教大家用gdb去调试递归函数，因为一步步去调试太麻烦了，也没法打断点，因为打断点每次递归时都会停下来，实在是难以调试，那么强大如gdb调试工具，对这种递归函数的调试也是轻而易举的。\n\n我们用递归算法计算斐波拉契数列，这是在大学C语言课本中的非常有名的递归算法——计算斐波拉契数列，我们回顾一下是什么是斐波拉契数列：斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。\n\n代码示例：\n\n```c\nint fibonacci(int n) {\n if (n == 1 || n == 2) {\n return 1;\n }\n return fibonacci(n - 1) + fibonacci(n - 2);\n}\nint main()\n{\n	int n = 10;\n	int ret = 0;\n	ret = fibonacci(n);\n	printf(\"fibonacci(%d)=%d\\n\", n, ret);\n	return 0;\n}\n```\n\n变异后用gdb调试：比如我想让递归调用，n=5时停下来，则有：\n\n```c\ngdb ./test\n(gdb) b fibonacci if n==5\n```\n\n## 三、跟踪系统调用——strace\n\n\n\n\n## GDB调试多线程',1,0,0,0,1,'2023-06-07 17:06:51','2023-06-07 19:58:25');
INSERT INTO `t_article` VALUES (97,1,60,'https://upload.haoxx.site/article/fccca1c9e6eaddff6e7aea054d820878.jpg',' git提交命令','# git提交命令\n\n[参考链接](https://blog.csdn.net/m0_46698504/article/details/129260726)\n\n\n\n## 1、设置用户名和邮箱\n\n```bash\ngit config --global user.name \"HaoY\"\ngit config --global user.email \"508506630@qq.com\"\n# 查看git的配置\ngit config --list\n# 使用代理\ngit clone https://github.com/twbs/bootstrap.git --config \"http.proxy=127.0.0.1:7890\"  \n# 查看clash日志，有github相关字样\n\n#ubuntu系统设置git的全局代理\n# 设置的是http的代理 fastgithub的端口是38457\ngit config --global http.proxy \"http://127.0.0.1:7890\"     # 设置的是http的代理\ngit config --global https.proxy \"http://127.0.0.1:7890\"    # 设置的是https的代理(clash和fastgithub不用设置这个)\n# 清除代理\ngit config --global --unset http.proxy\n```\n\n## 2、在gitee上创建并初始化一个仓库\n\n在网站上手动进行\n\n## 3、将该仓库拉取到本地\n\n```git\ngit clone https://xx.git\n//此时该目录下会生成一个.git隐藏目录\n//可以用vscode打开该目录，采用图形化界面来操作了\n```\n\n## 4、将工程文件或目录放置到上述目录下，并上传\n\n使用此命令随时查看工作状态：\n\n`git status`\n\n1）添加文件到缓冲区\n\n`git add *  //或者git add 文件名/目录名`\n\n2）上传到git的本地版本库中，并做记录\n\n`git commit -m \"第一次提交\"`\n\n3）先做分支初始化，再上传到远程服务器中\n\n`git init`\n\n`git push origin`\n\n## 5、补充说明\n\n要么当前.git目录下的config文件文件如下：\n\n![](https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlHCHfRyOUR24-TBS/root/content)\n\n否则，.config文件中没有说明url的话，你可以这样(直接通过git push -f 命令指定仓库也是可以的)，下面是deploy.sh文件的部分内容：\n\n```bash\ntimes=$(date \"+%Y-%m-%d__%H:%M:%S\")\ngit init\ngit add -A\ngit commit -m $times\ngit branch -M main\ngit push -f git@github.com:XiaoYuer2022/XiaoYuer2022.github.io.git main\n```\n\n## 6、git清空仓库\n\n```bash\ngit status\n# 创建一个新文件夹,或者手动删除本地所有文件在推送\ngit add .\ngit commit -m \"仓库已经清空\"\n\ngit push -f git@github.com:XiaoYuer2022/XiaoYuer2022.github.io.git main\n\n# 要么直接git push -f 或者下面两行\n\n#添加远程仓库(已添加可以跳过)\ngit remote add origin git@github.com:username/repositoryname\n#推送到远程仓库\ngit push -u origin master\n\n# 强制推送\ngit push --force origin main 或者 git push --force origin master\n\n# 从远端服务器拉取到本地\ngit pull origin master\n# 或者：\n1）git fetch origin    # 下载最新代码，origin是远端仓库地址\n2）git diff  HEAD origin/master # HEAD是本地分支，查看两者差异\n3）git pull  # 合并\n```\n\n手动删除文件的命令是：\n\n```bash\ngit rm -r *\n```\n\n恢复：\n\n```bash\n# 把删除的文件恢复到最新版本 \ngit checkout\n```\n\n## 7、初始创建一个仓库后\n\n```git\ngit init\ngit add README.md\ngit commit -m \"first commit\"\ngit branch -M main\ngit remote add origin git@github.com:XiaoYuer2022/chat.git\ngit push -u origin main\n```\n\n特别说明：除第一次上传外，后续都不需要`git remote add origin git@github.com:XiaoYuer2022/chat.git`命令了。\n\n## 8、使用代理\n\n```bash\n# 使用代理\ngit clone https://github.com/twbs/bootstrap.git --config \"http.proxy=127.0.0.1:7890\"  \n# 查看clash日志，有github相关字样\n```\n\n## 9、添加远端仓库\n\n```git\ngit remote add origin git@github.com:XiaoYuer2022/TinyWebServer2023.git\n## 如果重复的话,1)更改远端仓库：\ngit remote set-url origin git@github.com:XiaoYuer2022/TinyWebServer2023.git\n\n```\n\n## 10、从远端github仓库更新代码\n\n```git\ngit pull\n```',1,0,0,0,1,'2023-06-07 17:07:21','2023-06-07 19:58:58');
INSERT INTO `t_article` VALUES (98,1,60,'https://upload.haoxx.site/article/060c7716645312017b87f5a2b0495bec.jpg','关于cron和anacron的说明','---\ntitle: 关于cron和anacron的说明\ndate: 2023-4-12\ntags:\n - cron和anacron\ncategories:\n - 未分类\n\n---\n\n用户自己建立的cronttab文件在这个目录下：/var/spool/cron (要创建一份个人 crontab 文件，只要输入： crontab -e)\n\n比较这个目录/var/spool/anacron/下的cron.daily cron.weekly cron.monthly与当前系统的时间，来判断定时任务是否需要执行。\n\n1、关于run-parts命令\n\n对于ubuntu来说，run-parts是个二进制文件，位于/bin/run-parts;对于centos来说，他是一个脚本。它的后面接一个目录名，功能就是运行这个\n\n目录下的第一层目录中的所有脚本文件。 就是遍历目标文件夹，执行第一层目录下的可执行权限的文件。\n\n参数 --test : run-parts --test /目录名 //打印会被run-parts运行的脚本的名称，但不会实际的运行这些脚本。\n\n参数 --list : run-parts --list /目录名 //打印所有匹配的文件名，不局限于可执行，没有执行权限的文件也会打印，但不会实际的去执行。\n\n该选项不能与–test一起使用。\n\n参数 --report : run-parts --report /目录名 //类似于–verbose，但只打印会生成输出的脚本的名称。脚本的名称被打印到脚本首先产生输出的STDUT或STDRR中的任何一个\n\n其它参数，略\n\n2、关于test命令\n\n在脚本中常用test测试命令。其中在crontab中的test -x 文件名 是在测试该文件是否具有可执行权限。\n\n3、cron和anacron的说明 /etc/anacrontab 和 /etc/crontab\n\n我们用 cron.daily 工作来说明一下 /etc/anacrontab 的执行过程:\n\n读取 /var/spool/anacron/cron.daily 文件中 anacron 上一次执行的时间。\n\n和当前时间比较，如果两个时间的差值超过 1 天，就执行 cron.daily 工作。\n\n只能在 03：00-22：00 执行这个工作。\n\n执行工作时强制延迟时间为 5 分钟，再随机延迟 0～45 分钟。\n\n使用 nice 命令指定默认优先级，使用 run-parts 脚本执行 /etc/cron.daily 目录中所有的可执行文件。\n\n大家会发现，/etc/cron.{daily，weekly，monthly} 目录中的脚本在当前的 Linux 中是被 anacron 调用的，不再依靠 cron 服务。不过，anacron 不用设置多余的配置，我们只需要把需要定时执行的脚本放入 /etc/cron.{daily，weekly，monthly} 目录中，就会每天、每周或每月执行，而且也不再需要启动 anacron 服务了。如果需要进行修改，则只需修改 /etc/anacrontab 配置文件即可。\n\n// /etc/crontab\n\n11 17 \\* \\* \\* \\* root cd / && run-parts --report /etc/cron.hourly\n\n12 25 6 \\* \\* \\* root test -x /usr/sbin/anacron \\|\\| ( cd / && run-parts --report /etc/cron.daily )\n\n13 47 6 \\* \\* 7 root test -x /usr/sbin/anacron \\|\\| ( cd / && run-parts --report /etc/cron.weekly )\n\n14 52 6 1 \\* \\* root test -x /usr/sbin/anacron \\|\\| ( cd / && run-parts --report /etc/cron.monthly )\n\n// /etc/anacrontab\n\nperiod delay job-identifier command\n\n10 \\# These replace cron\'s entries\n\n11 1 5 cron.daily run-parts --report /etc/cron.daily \\#每天开机 5 分钟后就检查 /etc/cron.daily 目录内的文件是否被执行，如果今天没有被执行，那就执行\n\n12 7 10 cron.weekly run-parts --report /etc/cron.weekly \\#每隔 7 天开机后 25 分钟检查 /etc/cron.weekly 目录内的文件是否被执行，如果一周内没有被执行，就会执行\n\n13 @monthly 15 cron.monthly run-parts --report /etc/cron.monthly \\#每隔一个月开机后 45 分钟检查 /etc/cron.monthly 目录内的文件是否被执行，如果一个月内没有被执行，那就执行\n\n//注：把5/10/45全改为0,anacron或cron的定时任务就会按照你指定的准确时间运行，否则默认会有一定的延迟\n\n4、cron和anacron的比较\n\n下面是 cron 以及 anacron 的比较，帮助你理解何时用他们其中一个。\n\n| cron                           | anacron                                                      |\n| ------------------------------ | ------------------------------------------------------------ |\n| 它是守护进程                   | 它不是守护进程                                               |\n| 适合服务器                     | 适合桌面/笔记本电脑                                          |\n| 可以让你以分钟级运行计划任务   | 只能让你以天为基础来运行计划任务                             |\n| 关机时不会执行计划任务         | 如果计划任务到期，机器是关机的，那么它会在机器下次开机后执行计划任务 |\n| 普通用户和 root 用户都可以使用 | 只有 root 用户可以使用（使用特定的配置启动普通任务）         |',1,0,0,0,1,'2023-06-07 17:08:02','2023-06-07 19:58:33');
INSERT INTO `t_article` VALUES (99,1,60,'https://upload.haoxx.site/config/27c7f38a329c07159a80315712680ea5.jpg','clash使用指南','# clash使用指南\n\n在Linux终端运行好clash代理后，还需要这样做：\n\n## 1、用git工具\n\n```bash\ngit config --global user.name \"HaoY\"\ngit config --global user.email \"508506630@qq.com\"\n# 查看git的配置\ngit config --list\n# 使用代理\ngit clone https://github.com/twbs/bootstrap.git --config \"http.proxy=127.0.0.1:7890\"  \n# 查看clash日志，有github相关字样\n\n#ubuntu系统设置git的全局代理\n# 设置的是http的代理 fastgithub的端口是38457\ngit config --global http.proxy \"http://127.0.0.1:7890\"     # 设置的是http的代理\ngit config --global https.proxy \"http://127.0.0.1:7890\"    # 设置的是https的代理(clash和fastgithub不用设置这个)\n# 清除代理\ngit config --global --unset http.proxy\n```\n\n## 2、用npm\n\n```bash\n# 使用代理\nnpm config set proxy http://127.0.0.1:7890 \n# 下载模块\nnpm install pm2 -g \n# 取消代理\nnpm config delete proxy  #取消代理设置\n```\n\n## 3、设置shell的环境变量：例如APT/curl/wget\n\n```bash\n# 使用代理\nexport http_proxy=\"127.0.0.1:7890\"\n# 取消代理\nexport http_proxy=\"\"\n```\n\n## 4、SSH 通过代理连接服务器\n\n略',1,0,0,0,1,'2023-06-07 17:08:20',NULL);
INSERT INTO `t_article` VALUES (100,1,60,'https://upload.haoxx.site/article/979a9c0ee3f5bf324d916d6fac553317.jpg','MySql常用命令','# 常用命令\n\n参考：[CSDN网页](https://blog.csdn.net/weixin_46085718/article/details/127727204)\n\n1、ubuntu检查电脑上是否安装了mysql:\n`dpkg -l|grep mysql` 或`netstat -tap|grep mysql`或`systemctl status mysql.service`\n\n2、登录mysql (账号root，密码为1)\n`mysql -u root -p` 回车后，输入密码\n\n3、查看数据库命令(分号结尾)\n`show databases;`\n\n4、创建数据库，创建一个node的数据库\n`CREATE DATABASE IF NOT EXISTS node DEFAULT CHARSET utf8 COLLATE utf8_general_ci;`\n\n5、退出数据库\n`exit`\n\n6、数据库的初始化命令 （脱出mysql后使用）\n`mysql_secure_installation`\n\n7、配置mysql的远程访问\n\n1) 打开文件`vim /etc/mysql/mysql.conf.d/mysqld.cnf`，然后注释掉`#bind-address  = 127.0.0.1`\n\n2) 在[mysqld]条目下方，添加： \n\n```\n[mysqld]\nskip-grant-tables\n```\n\n3) 在windows上使用Navicat软件来远程管理数据库\n\n## 进阶命令\n\n通过mysql -h 或man mysql查询\n资料参考：[csdn](https://dablelv.blog.csdn.net/article/details/52106044?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2-52106044-blog-125246185.pc_relevant_multi_platform_whitelistv3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2-52106044-blog-125246185.pc_relevant_multi_platform_whitelistv3)\n\n这个连接里面的内容比较多，可以多看看\n\n\n## 创建新用户\n\n1、创建新用户，并允许远程访问：\n\n```bash\nCREATE USER \'<username>\'@\'%\' IDENTIFIED BY \'<password>\';\n```\n\n2、允许新用户访问所有数据库：\n\n```bash\nGRANT ALL PRIVILEGES ON *.* TO \'<username>\'@\'%\';\n```\n\n只允许新用户访问指定数据库：\n\n```bash\nGRANT ALL PRIVILEGES ON 指定数据库名.* TO \'<username>\'@\'%\';\n```\n\n3、刷新权限\n\n```bash\nFLUSH PRIVILEGES;\n```',1,0,0,0,1,'2023-06-07 17:08:52','2023-06-07 19:58:14');
INSERT INTO `t_article` VALUES (101,1,60,'https://upload.haoxx.site/article/aed9e7f618becc093ba89e9e48e300ed.jpg','Linux / Windows终端美化记录','# 终端美化记录\n\n## 一、ubuntu安装zsh、powerlevel10k\n\n参考[csdn的教程](https://blog.51cto.com/sddai/3030120)：\n\n[ohmyzsh的github](https://github.com/ohmyzsh/ohmyzsh)\n\n[powerlevel10k的github](https://github.com/romkatv/powerlevel10k)\n\npowerline这个不需要安装（powerlevel10k就是基于powerline的）：\n\n[powerline的github](https://github.com/powerline/powerline)\n\n1、安装zsh\n\n```bash\nsudo apt-get install zsh\n```\n\n2、安装oh-my-zsh\n\n```bash\n# 或者去仓库手动下载，然后运行install.sh\nsh -c \"$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\"\n```\n\n3、安装自动跳转插件和语法高亮插件、语法历史记录插件\n\n说明：zsh插件的位置在`/root/.oh-my-zsh//plugins`目录下。\n\n```bash\nsudo apt-get install autojump\n# 配置教程：cat /usr/share/doc/autojump/README.Debian\nvim .zshrc\n#在最后一行加入，注意点后面是一个空格\n. /usr/share/autojump/autojump.sh\nsource ~/.zshrc\n```\n\n语法高亮：\n\n```bash\n> git clone https://github.com/zsh-users/zsh-syntax-highlighting.git\n> echo \"source ${(q-)PWD}/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh\" >> ${ZDOTDIR:-$HOME}/.zshrc\n> source ~/.zshrc\n```\n\nzsh-autosuggestions语法历史记录插件：\n\n```bash\n> git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions\n> plugins=(zsh-autosuggestions)\n```\n\n4、安装powerlevel10k命令行显示主题：\n\n```bash\n# 1） 安装Meslo字体\n## 1.1）下载字体\nhttps://github.com/ryanoasis/nerd-fonts/tree/master/patched-fonts/Meslo/M/Regular\n## 1.2）安装字体\n# 将*.ttf字体文件放在/usr/share/fonts/custom目录下，该目录是自己新建的，然后\ncd /usr/share/fonts/agave\nsudo mkfontscale # 生成核心字体信息\nsudo mkfontdir # 生成字体文件夹\nsudo fc-cache -fv # 刷新系统字体缓存\n# 2）安装powerlevel10k\n## 2.1）下载\ngit clone --depth=1 https://gitee.com/romkatv/powerlevel10k.git ${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/themes/powerlevel10k\n## 2.2）安装\nSet ZSH_THEME=\"powerlevel10k/powerlevel10k\" in ~/.zshrc.\n## 说明：或者手动从github上下载powerlebel10k，然后放在/root/.oh-my-zsh/custom/themes目录下，最后在.zshrc中设置主题即可\n```\n\n### 1.1 powerlevel10k的配置\n\n见github仓库。  另外，您参考[CSDN的教程:powerlevel10k 颜色和图标的自定义设置](https://blog.csdn.net/qq_36835255/article/details/128101588)\n\n## 二、windows的powershell安装oh-my-posh\n\n1、查看官网：[oh-my-posh](https://ohmyposh.dev/)\n\n如果官网打不开的话就直接百度搜：oh my posh\n\n按照教程一步一步来：\n\n```powershell\n# 0、安装MesloLGMNerdFontXXX.ttf字体(三个字体)在windows设置中安装\nhttps://github.com/ryanoasis/nerd-fonts/tree/master/patched-fonts/Meslo/M/Regular\n# 1、安装oh-my-posh\nwinget install JanDeDobbeleer.OhMyPosh -s winget\n# 2、更新\nwinget upgrade JanDeDobbeleer.OhMyPosh -s winget\n# 3、查看当前终端名\noh-my-posh get shell\n# 4、打开配置文件\n## 4.1 查看配置文件是否存在：\nTest-Path $profile\n## 4.2 若不存在，就查看默认的配置文件路径：\necho $profile\n## 4.3 然后手动创建该路径和对应的配置文件\n# windowsPowerShell配置文件：C:\\Users\\50850\\Documents\\WindowsPowerShell\\Microsoft.PowerShell_profile.ps1\n# PowerShell配置文件：C:\\Users\\50850\\Documents\\PowerShell\\Microsoft.PowerShell_profile.ps1\n# 5、在配置文件中写入：\noh-my-posh init pwsh --config \"C:\\Users\\50850\\Documents\\WindowsPowerShell\\jandedobbeleer.omp.json\" | Invoke-Expression\n## 5.1 说明该json文件原路径是在：C:\\Users\\50850\\AppData\\Local\\Programs\\oh-my-posh\\themes\n## 5.2 请移动到自定义的位置，在更改\n# 6、重启powershell，配置完成\n# 7、补充，在vscode的powershell中的设置\n#参考：https://blog.csdn.net/dietime1943/article/details/122968934\n\n```\n\n### 2.1 oh-my-posh的配置\n\n参考文档：[CSDN的教程](https://blog.csdn.net/qq_36835255/article/details/128101588)\n\n\n2、自定义设置\n\n主要是对这个json文件进行修改，相关键名和参数值请参考官网。就当前配置而言，重点是更改blocks里面的东西。主要分为三块，由三个大括号包裹。type和alignment是配置提示符在终端的位置，newline选项相当于换行。\n\n然后的话，重点就在于segments数组的设置了：\n\n```markdown\n\"segments\": [\n        {\n          \"background\": \"#101010\",\n          \"foreground\": \"#ffffff\",\n          \"leading_diamond\": \"\\ue0b6\",\n          \"trailing_diamond\": \"\\ue0b4\",\n          \"style\": \"diamond\",\n          \"template\": \"\\uf007 {{ .UserName }}\",\n          \"type\": \"session\"\n        },\n        {\n        ...\n        }\n]\n```\n\n上述代码块是其中的一部分，他是设置了提示符中“用户名”相关的设置。1）前景颜色、背景颜色，当类型为`\"style\"=\"diamond\"`时，可以设置前后的字符，2）然后template键值里设置了用户名的值和表示形式。3）最后，有关字符的代码，可以查看网站：[nerdfonts](https://www.nerdfonts.com/cheat-sheet)。\n\n\n## 三、ubuntu安装lunar_vim插件管理器\n\n参考官网：[lunarvim](https://www.lunarvim.org/docs/installation) ，我感觉有点麻烦。\n\n\n\n\n## 四、vim插件安装和配置\n\n使用的是程序员卡尔的配置[程序员卡尔的github仓库](https://github.com/youngyangyang04/PowerVim)\n\n\n# 五、tmux的学习记录\n\n正在计划中...\n\n- [x] 完善tmux终端管理器的学习笔记',1,0,0,0,1,'2023-06-07 17:09:55','2023-06-07 19:58:02');
INSERT INTO `t_article` VALUES (102,1,51,'https://upload.haoxx.site/article/06d11f52c1fcd3abcda231e09209d1cd.jpg','C++STL常用容器知识点说明','---\ntitle: C++ STL常用容器知识点说明\ndate: 2023-4-12\ntags:\n - C++ STL\ncategories:\n - 未分类\n\n---\n\n# 0、总体概述\n\nSTL就是标准模板库，从广义上分为容器、算法和迭代器。当然，具体细分的话，STL大体分为六大组件，分别是:容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器。\n\n1.  容器：各种数据结构，如vector、list、deque、set、map等,用来存放数据。\n2.  算法：各种常用的算法，如sort、find、copy、for_each等\n3.  迭代器：扮演了容器与算法之间的胶合剂。\n4.  仿函数：行为类似函数，可作为算法的某种策略。\n5.  适配器：一种用来修饰容器或者仿函数或迭代器接口的东西。\n6.  空间配置器：负责空间的配置与管理。\n\n容器：就是将运用最广泛的一些数据结构实现出来，常用的数据结构：数组, 链表,树, 栈, 队列, 集合, 映射表等。这些容器分为序列式容器（值有顺序）和关联式容器（值之间有关联）。\n\n算法：有限的步骤，解决逻辑或数学上的问题，这一门学科我们叫做算法(Algorithms)。分为质变算法和非质变算法。质变算法：是指运算过程中会更改区间内的元素的内容。例如拷贝，替换，删除等等。非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等。\n\n# 0.1、迭代器\n\n迭代器：容器和算法的粘合剂。提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。迭代器使用非常类似于指针，初学阶段我们可以先理解迭代器为指针。\n\n![](media/589080628386800bbe32bb04420e0977.png)\n\n常用的容器中迭代器种类为双向迭代器，和随机访问迭代器。vector的begin和end是随机访问迭代器。\n\n![](media/105c3ca0ae4de6b12b6147b916a61af1.png)\n\n# 一、STL容器\n\n这是STL常用容器知识点总结。（1）是构造函数；（2）是赋值；（3）是（string）查找、大小/容量与交换；（4）插入与删除；（5）数据存取；第六部分，其它补充内容。容器最常用的是vector和list\n\n## 1、构造函数\n\n|        | （1）构造函数                                                |\n| ------ | ------------------------------------------------------------ |\n| string | 1、无参构造string(); 2、拷贝构造string(const string& str); 3、字符串构造string(const char\\* s)； 4、n个字符构造string(int n, char c); |\n| vector | 1、无参构造vector\\<T\\> v; 2、拷贝构造vector(const vector \\&vec); 3、（迭代器）区间拷贝构造vector(v.begin(), v.end()); 4、n个元素构造vector(n, elem); |\n| deque  | 1、无参构造deque\\<T\\> deq; 2、拷贝构造deque(const deque \\&deq); 3、（迭代器）区间拷贝构造deque(beg, end); 4、n个元素构造deque(n, elem); |\n| stack  | 1、无参构造stack\\<T\\> stk; 2、拷贝构造 stack(const stack \\&stk); |\n| queue  | 1、无参构造 queue\\<T\\> que; 2、拷贝构造 queue(const queue \\&que); |\n| List   | 1、无参构造list\\<T\\> lst; 2、拷贝构造 list(const list \\&lst); 3、（迭代器）区间拷贝构造 list(beg,end); 4、n个元素构造list(n, elem); |\n| set    | 1、无参构造 set\\<T\\> st; 2、拷贝构造 set(const set \\&st);    |\n| map    | 1、无参构造 map\\<T1,T2\\> mp; 2、拷贝构造 map(const map \\&mp); |\n\n## 2、赋值\n\n|        | （2）赋值                                                    |\n| ------ | ------------------------------------------------------------ |\n| string | - string& operator=(const char\\* s); //char\\*类型字符串 赋值给当前的字符串 - string& operator=(const string \\&s); //把字符串s赋给当前的字符串 - string& operator=(char c); //字符赋值给当前的字符串 - string& assign(const char \\*s); //把字符串s赋给当前的字符串 - string& assign(const char \\*s, int n); //把字符串s的前n个字符赋给当前的字符串 - string& assign(const string \\&s); //把字符串s赋给当前字符串 - string& assign(int n, char c); //用n个字符c赋给当前字符串 |\n| vector | - vector& operator=(const vector \\&vec);//重载等号操作符 - assign(beg, end); //将[beg, end)区间中的数据拷贝赋值给本身。 - assign(n, elem); //将n个elem拷贝赋值给本身。 |\n| deque  | - deque& operator=(const deque \\&deq); //重载等号操作符 - assign(beg, end); //将[beg, end)区间中的数据拷贝赋值给本身。 - assign(n, elem); //将n个elem拷贝赋值给本身。 |\n| stack  | stack& operator=(const stack \\&stk); //重载等号操作符        |\n| queue  | queue& operator=(const queue \\&que); //重载等号操作符        |\n| List   | - assign(beg, end); //将[beg, end)区间中的数据拷贝赋值给本身。 - assign(n, elem); //将n个elem拷贝赋值给本身。 - list& operator=(const list \\&lst); //重载等号操作符 |\n| set    | set& operator=(const set \\&st); //重载等号操作符             |\n| map    | map& operator=(const map \\&mp); //重载等号操作符             |\n\n## 3、(string)查找、大小/容量与交换\n\n|        | **（3）（string）查找、容量/大小与交换**                     |\n| ------ | ------------------------------------------------------------ |\n| string | --查找 - int find(const string& str, int pos = 0) const; //查找str第一次出现位置,从pos开始查找 - int find(const char\\* s, int pos = 0) const; //查找s第一次出现位置,从pos开始查找 - int find(const char\\* s, int pos, int n) const;//从pos位置查找s的前n个字符第一次位置 - int find(const char c, int pos = 0) const; //查找字符c第一次出现位置 -int rfind(const string& str, int pos = npos) const;//查找str最后一次位置,从pos开始查找 -int rfind(const char\\* s, int pos = npos) const;//查找s最后一次出现位置,从pos开始查找 - int rfind(const char\\* s, int pos, int n) const; //从pos查找s的前n个字符最后一次位置 - int rfind(const char c, int pos = 0) const; //查找字符c最后一次出现位置 --容量/大小 无 --交换 - string& replace(int pos, int n, const string& str); //替换从pos开始n个字符为字符串str - string& replace(int pos, int n,const char\\* s); //替换从pos开始的n个字符为字符串s |\n| vector | --查找 无 --容量/大小 - empty(); //判断容器是否为空 - capacity(); //容器的容量 - size(); //返回容器中元素的个数 - resize(int num); //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。//如果容器变短，则末尾超出容器长度的元素被删除。 -resize(int num, elem);//重新指定容器的长度为num，若容器变长，则以elem值填充新位置。//如果容器变短，则末尾超出容器长度的元素被删除 reserve(int len);//容器预留len个元素长度，预留位置不初始化，元素不可访问。自定义容器的容量 --交换 swap(vec); // 将vec与本身的元素互换 |\n| deque  | --查找 无 --容量/大小 - deque.empty(); //判断容器是否为空 - deque.size(); //返回容器中元素的个数 - deque.resize(num); //重新指定容器的长度为num,若容器变长，则以默认值填充新位置。//如果容器变短，则末尾超出容器长度的元素被删除。 - deque.resize(num, elem); //重新指定容器的长度为num,若容器变长，则以elem值填充新位置。//如果容器变短，则末尾超出容器长度的元素被删除。 --交换 无 |\n| stack  | --大小 - empty(); //判断堆栈是否为空 - size(); //返回栈的大小 |\n| queue  | --大小 - empty(); //判断堆栈是否为空 - size(); //返回栈的大小 |\n| List   | --大小 - size();//返回容器中元素的个数 - empty();//判断容器是否为空 - resize(num); //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。//如果容器变短，则末尾超出容器长度的元素被删除。 -resize(num, elem); //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。//如果容器变短，则末尾超出容器长度的元素被删除。 --交换 - swap(lst); //将lst与本身的元素互换。 |\n| set    | --大小 - size(); //返回容器中元素的数目 - empty(); //判断容器是否为空 --交换 - swap(st); //交换两个集合容器 |\n| map    | --大小 - size(); //返回容器中元素的数目 - empty(); //判断容器是否为空 --交换 - swap(st); //交换两个集合容器 |\n\n## 4、插入/删除\n\n|        | **（4）插入/删除**                                           |\n| ------ | ------------------------------------------------------------ |\n| string | - string& insert(int pos, const char\\* s); //插入字符串 - string& insert(int pos, const string& str); //插入字符串 - string& insert(int pos, int n, char c); //在指定位置插入n个字符c - string& erase(int pos, int n = npos); //删除从Pos开始的n个字符 |\n| vector | - push_back(ele); //尾部插入元素ele - pop_back(); //删除最后一个元素 - insert(const_iterator pos, ele); //迭代器指向位置pos插入元素ele - insert(const_iterator pos, int count,ele);//迭代器指向位置pos插入count个元素ele - erase(const_iterator pos); //删除迭代器指向的元素 - erase(const_iterator start, const_iterator end);//删除迭代器从start到end之间的元素 - clear(); //删除容器中所有元素 |\n| deque  | 两端插入操作： - push_back(elem); //在容器尾部添加一个数据 - push_front(elem); //在容器头部插入一个数据 - pop_back(); //删除容器最后一个数据 - pop_front(); //删除容器第一个数据 指定位置操作： - insert(pos,elem); //在pos位置插入一个elem元素的拷贝，返回新数据的位置。 - insert(pos,n,elem); //在pos位置插入n个elem数据，无返回值。 - insert(pos,beg,end); //在pos位置插入[beg,end)区间的数据，无返回值。 - clear(); //清空容器的所有数据 - erase(beg,end); //删除[beg,end)区间的数据，返回下一个数据的位置。 - erase(pos); //删除pos位置的数据，返回下一个数据的位置。 |\n| stack  | 无                                                           |\n| queue  | 无                                                           |\n| List   | - push_back(elem);//在容器尾部加入一个元素 - pop_back();//删除容器中最后一个元素 - push_front(elem);//在容器开头插入一个元素 - pop_front();//从容器开头移除第一个元素 - insert(pos,elem);//在pos位置插elem元素的拷贝，返回新数据的位置。 - insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值。 - insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值。 - clear();//移除容器的所有数据 - erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置。 - erase(pos);//删除pos位置的数据，返回下一个数据的位置。 - remove(elem);//删除容器中所有与elem值匹配的元素。 |\n| set    | - insert(elem); //在容器中插入元素。 - clear(); //清除所有元素 - erase(pos); //删除pos迭代器所指的元素，返回下一个元素的迭代器。 - erase(beg, end); //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。 - erase(elem); //删除容器中值为elem的元素。 |\n| map    | - insert(elem); //在容器中插入元素。 - clear(); //清除所有元素 - erase(pos); //删除pos迭代器所指的元素，返回下一个元素的迭代器。 - erase(beg, end); //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。 - erase(key); //删除容器中值为key的元素。 |\n\n## 5、数据存取\n\n|        | **（5）数据存取**                                            |\n| ------ | ------------------------------------------------------------ |\n| string | - char& operator[](int n); //通过[]方式取字符 - char& at(int n); //通过at方法获取字符 |\n| vector | - at(int idx); //返回索引idx所指的数据 - operator[]; //返回索引idx所指的数据 - front(); //返回容器中第一个数据元素 - back(); //返回容器中最后一个数据元素 |\n| deque  | - at(int idx); //返回索引idx所指的数据 - operator[]; //返回索引idx所指的数据 - front(); //返回容器中第一个数据元素 - back(); //返回容器中最后一个数据元素 |\n| stack  | - push(elem); //向栈顶添加元素 - pop(); //从栈顶移除第一个元素 - top(); //返回栈顶元素 |\n| queue  | - push(elem); //往队尾添加元素 - pop(); //从队头移除第一个元素 - back(); //返回最后一个元素 - front(); //返回第一个元素 |\n| List   | - front(); //返回第一个元素。 - back(); //返回最后一个元素。 |\n| set    | 无                                                           |\n| map    | 无                                                           |\n\n## 6、第六部分：补充内容\n\n注意：栈stack只有栈顶可以访问，所以不支持遍历行为；队列只有队头队尾才能被外界访问，因此队列也不支持遍历行为；\n\nvector很像数组，常称为单端数组，他和数组的最大区别是数组等长，而vector可以动态扩展长度。deque是双端数组，可以头/尾插入或删除，deque可以动态扩展长度。在头插入上，vector效率低，deque头插入效率高；另一方面，vector访问元素的速度要比deque快，这与vector/deque内部的实现有关。\n\nString、vector和deque的迭代器支持随机访问；stack/queue不提供迭代器，不支持随机访问；list容器的迭代器是双向迭代器，不支持随机访问\n\n注：随机访问迭代器 ：读写操作，可以以跳跃的方式访问任意数据，功能最强的迭代器\n\n**[string容器]**\n\n►string字符串的拼接\n\n\\- string& operator+=(const char\\* str); //重载+=操作符\n\n\\- string& operator+=(const char c); //重载+=操作符\n\n\\- string& operator+=(const string& str); //重载+=操作符\n\n\\- string& append(const char \\*s); //把字符串s连接到当前字符串结尾\n\n\\- string& append(const char \\*s, int n); //把字符串s的前n个字符连接到当前字符串结尾\n\n\\- string& append(const string \\&s); //同operator+=(const string& str)\n\n\\- string& append(const string \\&s, int pos, int n);//字符串s中从pos开始的n个字符连接到字符串结尾\n\n►string字符串的比较，按照字符的ASCII码值进行比较，相等返回0，大于返回1，小于返回-1\n\n\\- int compare(const string \\&s) const; //与字符串s比较\n\n\\- int compare(const char \\*s) const; //与字符串s比较\n\n►string字符串的子串\n\nstring substr(int pos = 0, int n = npos) const; //返回由pos开始的n个字符组成的字符串\n\n**[vector容器]**\n\n无\n\n**[deque容器]**\n\n**►deque排序**\n\nsort(iterator beg, iterator end) //对beg和end区间内元素进行排序\n\n[stack容器]\n\n无\n\n**[queue容器]**\n\n无\n\n**[list容器]**\n\n►list的翻转和排序\n\n\\- reverse(); //反转链表\n\n\\- sort(); //链表排序\n\n**[set容器]**\n\n►set的查找和统计\n\n\\- find(key); //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();\n\n\\- count(key); //统计key的元素个数\n\n►set的排序（默认为从小到大，可以使用仿函数来更改排序规则）\n\nclass MyCompare\n\n{\n\npublic:\n\nbool operator()(int v1, int v2) {\n\nreturn v1 \\> v2;\n\n}\n\n};\n\nset\\<int,MyCompare\\> s2; //自定义排序规则\n\n**[map容器]**\n\n►map的查找和统计\n\n\\- find(key); //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();\n\n\\- count(key); //统计key的元素个数\n\n►map的排序（使用自定义规则进行排序）\n\nclass MyCompare {\n\npublic:\n\nbool operator()(int v1, int v2) {\n\nreturn v1 \\> v2;\n\n}\n\n};\n\nmap\\<int, int, MyCompare\\> m; //自定义排序规则\n\n自定义函数用于排序的例子：\n\n**b**ool myCompare(int val1 , int val2)\n\n{\n\nreturn val1 \\> val2;\n\n}\n\n# 二、STL常用函数对象\n\n**1、函数对象**\n\n定义：重载函数调用操作符的类，其对象常称为函数对象。函数对象使用重载的（）号时，行为类似于函数调用，因此也称为仿函数。\n\n本质：函数对象（仿函数）是一个类，不是一个函数\n\n1.  函数对象的调用\n\n特点：\n\n函数对象在使用时，可以像普通函数那样调用，可以有参数，可以有返回值\n\n函数对象超出普通函数的概念，函数对象可以有自己的状态\n\n函数对象可以作为参数传递\n\n总结：仿函数写法非常灵活，可以作为参数进行传递。\n\n**2、谓语**\n\n返回值是bool类型的仿函数称为谓语，如果operator()接受一个参数，就是一元谓语；接受2个参数，就是二元谓语。\n\n**3、内建函数对象**\n\nSTL内建了一些函数对象，分为算术仿函数，关系仿函数，逻辑仿函数。\n\n这些仿函数所产生的对象，用法和普通函数一致，不过需要引入头文件\\<functional\\>\n\n3.1算术仿函数\n\n\\- template\\<class T\\> T plus\\<T\\> //加法仿函数\n\n\\- template\\<class T\\> T minus\\<T\\> //减法仿函数\n\n\\- template\\<class T\\> T multiplies\\<T\\> //乘法仿函数\n\n\\- template\\<class T\\> T divides\\<T\\> //除法仿函数\n\n\\- template\\<class T\\> T modulus\\<T\\> //取余仿函数%\n\n\\- template\\<class T\\> T negate\\<T\\> //取反仿函数\n\n3.2 关系仿函数 （谓语）\n\n\\- template\\<class T\\> bool equal_to\\<T\\> //等于\n\n\\- template\\<class T\\> bool not_equal_to\\<T\\> //不等于\n\n\\- template\\<class T\\> bool greater\\<T\\> //大于\n\n\\- template\\<class T\\> bool greater_equal\\<T\\> //大于等于\n\n\\- template\\<class T\\> bool less\\<T\\> //小于\n\n\\- template\\<class T\\> bool less_equal\\<T\\> //小于等于\n\n3.3 逻辑仿函数（应用较少） （谓语）\n\n\\- template\\<class T\\> bool logical_and\\<T\\> //逻辑与\n\n\\- template\\<class T\\> bool logical_or\\<T\\> //逻辑或\n\n\\- template\\<class T\\> bool logical_not\\<T\\> //逻辑非\n\n# 三、STL常用算法\n\n使用STL算法，需要包含头\\<algorithm\\>\n\n1、遍历算法\n\n**（1）for_each遍历容器**\n\n►for_each(iterator beg, iterator end, \\_func);\n\nfor_each是最常用的遍历算法，需要熟练掌握。功能函数有打印函数（自定义函数）、打印函数（类内函数，即仿函数）、算术操作函数或逻辑函数\n\n**（2）transform 搬运容器到另一个容器中**\n\n►transform(iterator beg1, iterator end1, iterator beg2, \\_func);\n\n源容器的起点，源容器的终点，目标容器的起点，功能函数同上。注意：搬运的目标函数必须提前开辟空间，否则不能正常搬运。\n\n2、查找算法\n\n►find(iterator beg, iterator end, value); //按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置，返回值类型是 ‘容器’\\<数据类型\\>::iterator it\n\n►find_if(iterator beg, iterator end, \\_Pred); //按条件查找元素(按值查找元素)，找到返回指定位置迭代器，找不到返回结束迭代器位置._Pred是函数或者谓词（谓词是返回bool类型的仿函数）\n\n► adjacent_find(iterator beg, iterator end); //查找相邻重复元素,返回相邻元素的第一个位置的迭代器\n\n► bool binary_search(iterator beg, iterator end, value); //二分查找法。查到返回true，否则返回false。注意在无序序列中不能用\n\n► count(iterator beg, iterator end, value); //统计指定元素出现的个数\n\n注意：统计自定义数据类型时，需要重载==\n\n► count_if(iterator beg, iterator end, \\_Pred); //按条件统计元素个数，_Pred是指返回值为bool类型的仿函数\n\n3、排序算法\n\n► sort(iterator beg, iterator end, \\_Pred); //对容器内元素进行排序\n\nsort属于开发中最常用的算法之一，需熟练掌握\n\n► random_shuffle(iterator beg, iterator end); //随机洗牌，指定范围内的元素随机调整次序\n\nrandom_shuffle洗牌算法比较实用，使用时记得加随机数种子\n\n► merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest); // 容器元素合并，并存储到另一容器中。Beg1/end1容器1的起止迭代器，beg2/end2容器2的起止迭代器，dest是目标容器的开始迭代器\n\n注意：两个容器必须是有序的，目标容器必须提前开辟空间\n\n► reverse(iterator beg, iterator end); // 反转指定范围的元素\n\n4、常用拷贝和替换算法\n\n► copy(iterator beg, iterator end, iterator dest); //容器内指定范围的元素拷贝到另一容器中\n\n► replace(iterator beg, iterator end, oldvalue, newvalue); //将容器内指定范围的旧元素修改为新元素\n\nreplace会替换区间内满足条件的元素\n\n► replace_if(iterator beg, iterator end, \\_pred, newvalue); // 容器内指定范围满足条件的元素替换为新元素\n\n按条件替换元素，满足条件的替换成指定元素。总结：replace_if按条件查找，可以利用仿函数灵活筛选满足的条件\n\n► swap(container c1, container c2); // 互换两个容器的元素\n\n总结：swap交换容器时，注意交换的容器要同种类型\n\n5、常用算术生成算法\n\n注意：算术生成算法属于小型算法，使用时包含的头文件为 \\#include \\<numeric\\>\n\n► accumulate(iterator beg, iterator end, value); // 计算容器元素累计总和，返回值为int\n\n► fill(iterator beg, iterator end, value); // 向容器中添加元素\n\n6、常用集合算法\n\n三个函数的返回值均是dest容器最后一个元素的迭代器iterator\n\n► set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest); // 求两个容器的交集\n\n注意:两个集合必须是有序序列。\n\n总结：-求交集的两个集合必须的有序序列\n\n\\- 目标容器开辟空间需要从两个容器中取小值\n\n\\- set_intersection返回值既是交集中最后一个元素的位置\n\n► set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest); //求两个容器的并集\n\n注意:两个集合必须是有序序列\n\n总结：- 求并集的两个集合必须的有序序列\n\n\\- 目标容器开辟空间需要两个容器相加\n\n\\- set_union返回值既是并集中最后一个元素的位置\n\n► set_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest); // 求两个容器的差集\n\n注意:两个集合必须是有序序列\n\n总结：- 求差集的两个集合必须的有序序列\n\n\\- 目标容器开辟空间需要从两个容器取较大值\n\n\\- set_difference返回值既是差集中最后一个元素的位置',1,0,0,0,1,'2023-06-07 17:10:32','2023-06-07 19:57:49');
INSERT INTO `t_article` VALUES (103,1,53,'https://upload.haoxx.site/article/9a42c06ea0f36c4eacc2fb9bfc59781d.jpg','进程与线程笔记','---\ntitle: 进程与线程笔记\ndate: 2023-4-12\ntags:\n - 进程与线程\ncategories:\n - 未分类\n---\n# 一、创建进程/线程：\n\n1、进程创建pid_t fork(void); 说明：fork - create a child process\n\n包含头：\\#include \\<unistd.h\\>\n\n返回值：创建成功，则在父进程中返回子进程的PID，在子进程中返回0。创建失败，在父进程中返回-1。\n\n2、进程创建pid_t vfork(void); 说明：vfork - create a child process and block parent\n\n包含头：\\#include \\<sys/types.h\\>\n\n\\#include \\<unistd.h\\>\n\n3、线程创建int pthread_create(pthread_t \\*thread, const pthread_attr_t \\*attr,\n\nvoid \\*(\\*start_routine) (void \\*), void \\*arg);\n\n包含头：\\#include \\<pthread.h\\>\n\n注意; Compile and link with -pthread.\n\n返回值：创建成功返回0，否则返回错误值。\n\n参数：\n\n1.  pthread_t \\*thread：传递一个 pthread_t 类型的指针变量，也可以直接传递某个 pthread_t 类型变量的地址。pthread_t 是一种用于表示线程的数据类型，每一个 pthread_t 类型的变量都可以表示一个线程。\n2.  const pthread_attr_t \\*attr：用于手动设置新建线程的属性，例如线程的调用策略、线程所能使用的栈内存的大小等。大部分场景中，我们都不需要手动修改线程的属性，将 attr 参数赋值为 NULL，pthread_create() 函数会采用系统默认的属性值创建线程。\n3.  void \\*(\\*start_routine) (void \\*)：以函数指针的方式指明新建线程需要执行的函数，该函数的参数最多有 1 个（可以省略不写），形参和返回值的类型都必须为 void\\* 类型。void\\* 类型又称空指针类型，表明指针所指数据的类型是未知的。使用此类型指针时，我们通常需要先对其进行强制类型转换，然后才能正常访问指针指向的数据。\n4.  void \\*arg：指定传递给 start_routine 函数的实参，当不需要传递任何数据时，将 arg 赋值为 NULL 即可。\n\n\\*\\*如果成功创建线程，pthread_create() 函数返回数字 0，反之返回非零值。各个非零值都对应着不同的宏，指明创建失败的原因，常见的宏有以下几种：\n\nEAGAIN：系统资源不足，无法提供创建线程所需的资源。\n\nEINVAL：传递给 pthread_create() 函数的 attr 参数无效。\n\nEPERM：传递给 pthread_create() 函数的 attr 参数中，某些属性的设置为非法操作，程序没有相关的设置权限。\n\n\\*\\*以上这些宏都声明在 \\<errno.h\\> 头文件中，如果程序中想使用这些宏，需提前引入此头文件。\n\n\\*\\*示例：\n\nvoid \\*receive(void \\*pth_arg) {}\n\npthread_t id;\n\npthread_create(&id,NULL,receive,(void\\*)cfd);\n\n# 二、创建和使用进程/线程时的一些问题：\n\n## 1、fork()和vfork()函数的区别：\n\n![](https://upload.haoxx.site/photo/d9b061df62171b02e7a445e1d176c593.png)\n\n为什么会有vfork，因为以前的fork 很傻， 它创建一个子进程时，将会创建一个新的地址\n\n空间，并且拷贝父进程的资源，而往往在子进程中会执行exec 调用，这样，前面的拷贝工\n\n作就是白费力气了，这种情况下，聪明的人就想出了vfork，它产生的子进程刚开始暂时与\n\n父进程共享地址空间（其实就是线程的概念了），因为这时候子进程在父进程的地址空间中\n\n运行，所以子进程不能进行写操作，并且在儿子 霸占着老子的房子时候，要委屈老子一\n\n下了，让他在外面歇着（阻塞），一旦儿子执行了exec 或者exit 后，相 于儿子买了自己的\n\n房子了，这时候就相于分家了。\n\n参考： <https://blog.csdn.net/jianchi88/article/details/6985326>\n\n在代码中获得当前进程pid的函数为：getpid()；\n\n在代码中获得当前进程父进程pid的函数为：getppid()。\n\n## 2、fork()功能简介：\n\n![](https://upload.haoxx.site/photo/d1f2e482b131c2aac315142934b97807.png)\n\n![](https://upload.haoxx.site/photo/dffc560d52616dd91c7a30860543c238.png)\n\n参考：https://blog.csdn.net/qq_38410730/article/details/81193118\n\n![](https://upload.haoxx.site/photo/a480238e9c3785af646f9d776e569797.png)\n\n![](https://upload.haoxx.site/photo/c2a7079ed0d2e0959a02775cfc93798f.png)\n\n这里需要注明一点：**父子进程的调度的顺序是由调度器决定的，与进程的创建顺序无关。**\n\n**\\*\\***还记得之前的图吗？子进程与父进程共享程序代码，而数据区、栈区、系统栈区相互独立。因此，父进程的代码实际上父、子进程要各执行一次。为了让父子进程执行不同的程序，有两种办法：1是在if(pid==0)中执行子程序特有的程序，2在子进程中调用execv()函数集。\n\n在实际应用中，通常调用execv()的都是子进程。人们之所以创建一个子进程，其目的就是执行一个与父进程代码不同的程序，而系统调用execv()就是子进程执行一个新程序的手段之一。子进程调用execv()之后，系统会立即为子进程加载可执行文件分配私有程序内存空间，从此子进程也成为一个真正的进程。\n\n如果说子进程是父进程的“儿子”，那么子进程在调用execv()之前，它所具有的单独用户堆栈和数据区也仅相当于它的私有“房间”；但因它还没有自己的“住房”，因此也只能寄住在“父亲”家，而不能“自立门户”，尽管它有自己的“户口”（进程控制块）。\n\n![](https://upload.haoxx.site/photo/c9dd37b5aeb33abe47b944c4fa8bed5f.png)\n\n![](https://upload.haoxx.site/photo/ebe07dbeff2c5d9943d4d094dca4ca93.png) \n\n![](https://upload.haoxx.site/photo/af808190d54947777f6c8ee2e8d91687.png)\n\n![](https://upload.haoxx.site/photo/36cf0a7153422dfaf17386b3796366c4.png)\n\n调用exec系列函数的前后，父子进程的关系变化如下图所示：\n\n![](https://upload.haoxx.site/photo/02a6d45da336592e5cb66280578c295e.png) \n\n![](https://upload.haoxx.site/photo/6d0a2a04a3119ad47edcabd7349d4673.png)\n\n为了避免子进程成为孤儿进程，父进程应该要等子进程结束并销毁子进程后才可以退出。因此，父进程中应设置系统调用wait()，子进程中应设置退出函数exit()。\n\n![](https://upload.haoxx.site/photo/f58553028c983dc7f5284ea0f6ff8f10.png)\n\n![](https://upload.haoxx.site/photo/5cb46546d42be10317ef6f30ce6d2fa3.png)\n\n![](https://upload.haoxx.site/photo/ef46427ce1d4b7268ae4baed43486364.png)\n\n![](https://upload.haoxx.site/photo/dcb7db7fed64b2b783a84f14c2324fc0.png)\n\n## 3、vfork()的进一步说明：\n\n![](https://upload.haoxx.site/photo/5529093d85e5635aa1effa437df22107.png)\n\n## 4、线程的基本使用：\n\n![](https://upload.haoxx.site/photo/5f24fbd285b131e20cf48c931def0d45.png)\n\n参考资料：https://blog.csdn.net/yi_chengyu/article/details/120412980\n\n![](https://upload.haoxx.site/photo/b329e9b72442e377d0ab3e954626d92a.png)\n\n## 5、线程与进程\n\n![](https://upload.haoxx.site/photo/eeec806437bfc7f6d52f615ef7078477.png)\n\n![](https://upload.haoxx.site/photo/6f23ed4e0dfc3ec691de15324db383a4.png)\n\n![](https://upload.haoxx.site/photo/ae2a762c612c3978c89eac5acbea13ad.png)\n\n## 6、fork与vfork\n\n![](https://upload.haoxx.site/photo/ae42db34e057eaba61295c7337e7c546.png)\n\n![](https://upload.haoxx.site/photo/5341a44ed914b07567b7dc18abdb8390.png)\n',1,0,0,0,1,'2023-06-07 18:18:00','2023-06-07 19:57:38');
INSERT INTO `t_article` VALUES (105,1,53,'https://upload.haoxx.site/article/17f10cd4cbe9e8cba44a22c4d0ee0381.jpg','进程和线程间通信学习内容','---\ntitle: 进程间通信学习内容\ndate: 2023-4-12\ntags:\n - 进程间通信\ncategories:\n - 未分类\n---\n\n![](https://upload.haoxx.site/photo/84e8bfe1bdfb66b1da75e06ca2c9fc33.png)\n\n![](https://upload.haoxx.site/photo/b7cc08bb88c6ef808f23b3202d5763eb.png)\n\n![](https://upload.haoxx.site/photo/20ec88f94bff808a8bcdbbd7e00c08cd.png)\n\n## 一、定义介绍\n\n1.  **管道：**管道是Linux 中进程间通信的一种方式，它把一个程序的输出直接连接到另一个程序的输入。Linux 的管道主要包括两种：无名管道和命名管道。\n    1.  **管道（无名管道）**\n\n        **（1）无名管道**\n\n无名管道有几个重要的限制：\n\n无名管道是半双工的，数据只能在一个方向上流动，A进程传给B进程，不能反向传递管道只能用于父子进程或兄弟进程之间的通信，即具有亲缘关系的进程。\n\n无名管道的特点：\n\n1）无名管道是半双工的\n\n2）无名管道没有名字：只能用于父子进程或者兄弟进程之间（具有亲缘关系的进程）。\n\n3）无名管道不是普通的文件，并且只存在与内存中。\n\n4）无名管道的缓冲区是有限的，该缓冲区的大小为4Kbyte。\n\n1.  **命名管道：**命名管道是一种特殊类型的文件，它在系统中以文件形式存在。这样克服了无名管道的弊端，他可以允许没有亲缘关系的进程间通信。\n\n命名管道特点：\n\n1）FIFO在文件系统中作为一个特殊的文件而存在。\n\n2）虽然FIFO文件存在于文件系统中，但FIFO中的内容却存放在内存中，在Linux中，该缓冲区的大小为4Kbyte。\n\n3）FIFO有名字，不同的进程可以通过该命名管道进行通信\n\n4）FIFO所传送的数据是无格式的。\n\n5）从FIFO读数据是一次性操作，数据一旦被读，它就从FIFO中被抛弃，释放空间以便写更多的数据。\n\n6）当共享FIFO的进程执行完所有的I/O操作以后，FIFO将继续保存在文件系统中以便以后使用。\n\n1.  **信号：**信号是软件层次上对中断机制的一种模拟，是一种异步通信方式，进程不必通过任何操作来等待信号的到达。信号可以在用户空间进程和内核之间直接交互，内核可以利用信号来通知用户空间的进程发生了哪些系统事件。\n\n信号的来源有两种：硬件来源（如键盘ctrl+c），软件来源（kill, raise, alarm和setitimer以及sigqueue函数，当然还包括一些非法操作）；\n\n操作系统对信号的处理方式：1）忽略；有两个信号是不能忽略的：SIGKLL和SIGSTOP；2）捕捉，执行对应的信号处理程序；3）缺省，执行默认操作。\n\n1.  **消息队列：**消息队列是内核地址空间中的内部链表，具有特定的格式,存放在内存中并由消息队列标识符标识，并且允许一个或多个进程向它写入与读取消息。消息队列通过Linux内核在各个进程直接传递内容，消息顺序地发送到消息队列中，并以几种不同的方式从队列中获得，每个消息队列可以用IPC标识符唯一地进行识别。\n\n消息队列克服了信号承载信息量少的问题，管道只能承载无格式字符流。\n\n1.  **信号量：**信号量实质上就是一个标识可用资源数量的计数器，它的值总是非负整数。它们常常被用作一个锁机制，在某个进程正在对特定的资源进行操作时，信号量可以防止另一个进程去访问它。\n\n信号量可细分为：二值信号量和计数信号量\n\n信号量是一种特殊的变量，它只取正整数值并且只允许对这个值进行两种操作：等待（wait）和信号（signal）。（P、V操作，P用于申请资源，V用于释放资源）。\n\n1.  **共享内存：**共享内存是在多个进程之间共享内存区域的一种进程间的通信方式，使得多个进程可以直接读写同一块内存空间，它是针对其他通信机制运行效率较低而设计的。共享内存由IPC为进程创建的一个特殊地址范围，为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间。进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率。\n\n需要注意的是：共享内存并未提供同步机制，在一个进程结束对共享内存的写操作之前，并无自动机制可以阻止另二个进程开始对它进行读取。所以，我们通常需要用其他的机制来同步对共享内存的访问。\n\n1.  **内存映射：**内存映射，是将一个文件映射到一块内存的方法。内存映射文件与虚拟内存有些类似，通过内存映射文件可以保留一个地址的区域，同时将物理存储器提交给此区域，内存文件映射的物理存储器来自一个已经存在于磁盘上的文件，而且在对该文件进行操作之前必须首先对文件进行映射。使用内存映射文件处理存储于磁盘上的文件时，将不必再对文件执行I/O操作。每一个使用该机制的进程通过把同一个共享的文件映射到自己的进程地址空间来实现多个进程间的通信（这里类似于共享内存，只要有一个进程对这块映射文件的内存进行操作，其他进程也能够马上看到）。\n2.  **套接字socket：**套接字是更为基础的进程间通信机制，与其他方式不同的是，套接字可用于不同机器之间的进程间通信。在Linux中，套接字是基于网络的，它也有自己的家族名字--AF_INET。\n\n## 二、详细函数接口说明\n\n参考资料：知识点讲解<https://blog.csdn.net/a987073381/article/details/52006729>\n\n代码示例：<https://blog.csdn.net/zqixiao_09/article/details/50485047> （上）\n\n（下，缺个消息队列）[https://blog.csdn.net/zqixiao_09/article/details/50498874?utm_medium=distribute.pc_relevant.none-task-blog-2\\~default\\~baidujs_title\\~default-0.no_search_link&spm=1001.2101.3001.4242.1](https://blog.csdn.net/zqixiao_09/article/details/50498874?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-0.no_search_link&spm=1001.2101.3001.4242.1)\n\n消息队列：<https://blog.csdn.net/qq_27664167/article/details/81712887>\n\n1、管道\n\n1.1无名管道\n\n![](https://upload.haoxx.site/photo/05438e1a57a775323713c45100ac9b5f.png)\n\n![](https://upload.haoxx.site/photo/630cb06c3086ffba6fb203a5a3ae317b.png)\n\n通过使用底层的read和write调用来访问数据。向file_descriptor[1]写数据，从file_descriptor[0]中读数据。写入与读取的顺序原则是先进先出。\n\n1.2 命名管道\n\n命名管道是一种特殊类型的文件，它在系统中以文件形式存在。这样克服了无名管道的弊端，他可以允许没有亲缘关系的进程间通信。\n\n![](https://upload.haoxx.site/photo/47fae86680ce79a7ed24d7237c1d16dc.png)\n\n编程示例：\n\n\\#include \\<sys/types.h\\>\n\n\\#include \\<sys/stat.h\\>\n\nint mkfifo(const char \\*filename,mode_t mode); //建立一个名字为filename的命名管道，参数mode为该文件的权限（mode%\\~umask），若成功则返回0，否则返回-1，错误原因存于errno中。\n\neg.mkfifo( \"/tmp/cmd_pipe\", S_IFIFO \\| 0666 );\n\n具体操作方法只要创建了一个命名管道然后就可以使用open、read、write等系统调用来操作。创建可以手工创建或者程序中创建。\n\nint mknod(const char \\*path, mode_t mode, dev_t dev); //第一个参数表示你要创建的文件的名称，第二个参数表示文件类型，第三个参数表示该文件对应的设备文件的设备号。只有当文件类型为 S_IFCHR 或 S_IFBLK 的时候该文件才有设备号，创建普通文件时传入0即可。\n\neg.mknod(FIFO_FILE,S_IFIFO\\|0666,0);\n\n![](https://upload.haoxx.site/photo/c0bdec69bc1cc87001a1903296feba86.png)\n\n2、信号\n\n信号机制是unix系统中最为古老的进程之间的通信机制，用于一个或几个进程之间传递异步信号。信号可以有各种异步事件产生，比如键盘中断等。shell也可以使用信号将作业控制命令传递给它的子进程。\n\n在此列出几个简单使用方法定义：\n\n![](https://upload.haoxx.site/photo/a55a1d964faddbc271c37e56f0588cde.png)\n\n3、消息队列\n\nMsgget() msgsnd() msgrcv() msgctl()\n\n4、信号量（Semaphore）\n\nSemget() semop() sembuf\n\n5、共享内存（Share Memory）\n\nShmget() shmat() shmdt()\n\n6、内存映射（Memory Map）\n\n\\*mmap() munmap() msync()\n\n7、套接字\n\n套接字的创建和使用与管道是有区别的，套接字 明确地将客户端与服务器 区分开来，可以实现多个客户端连到同一服务器。\n\n服务器套接字连接过程描述：\n\n首先，服务器应用程序用socket创建一个套接字，它是系统分配服务器进程的类似文件描述符的资源。 接着，服务器调用bind给套接字命名。这个名字是一个标示符，它允许linux将进入的针对特定端口的连接转到正确的服务器进程。 然后，系统调用listen函数开始接听，等待客户端连接。listen创建一个队列并将其用于存放来自客户端的进入连接。 当客户端调用connect请求连接时，服务器调用accept接受客户端连接，accept此时会创建一个新套接字，用于与这个客户端进行通信。\n\n客户端套接字连接过程描述：\n\n客户端首先调用socket创建一个未命名套接字，让后将服务器的命名套接字作为地址来调用connect与服务器建立连接。\n\n只要双方连接建立成功，我们就可以像操作底层文件一样来操作socket套接字实现通信。\n\n1.  管道\n\n管道实际是用于进程间通信的一段共享内存，创建管道的进程称为管道服务器，连接到一个管道的进程为管道客户机。一个进程在向管道写入数据后，另一进程就可以从管道的另一端将其读取出来。\n\n管道的特点：\n\n1)、管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道；\n\n2)、 只能用于父子进程或者兄弟进程之间（ 具有亲缘关系的进程）。 比如fork或exec创建的新进程， 在使用exec创建新进程时，需要将管道的文件描述符作为参数传递给exec创建的新进程。 当父进程与使用fork创建的子进程直接通信时，发送数据的进程关闭读端，接受数据的进程关闭写端。\n\n3)、单独构成一种独立的文件系统：管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在与内存中。\n\n4)、数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。\n\n通过使用底层的read和write调用来访问数据。 向 file_descriptor[1]写 数据，从 file_descriptor[0]中 读数据。写入与读取的顺序原则是 先进先出。\n\n![](https://upload.haoxx.site/photo/3a10aa097584f54f8b871ad0fc8668e6.png)\n\n1.  命名管道mkfifo\n2.  信号signal\n3.  消息队列 （本质是 链表）\n4.  信号量\n5.  共享内存：（需要信号量辅助读写的先后顺序）效率最高。\n\n采用共享内存通信的一个显而易见的好处就是**效率高**，因为进程可以直接读写内存，而**不需要任何数据的拷贝**。对于像管道和消息队列等通信方式，则需要在内核和用户控件进行四次数据的拷贝，而**共享内存只拷贝两次数据：一次从输入文件到共享区，另一次从共享内存区到输出文件**。实际上，进程之间在共享内存时，并不总是读写少量数据后就解除映射，有新的通信时，再重新建立共享内存区域。而是保持共享区域，知道通信完毕为止，这样，数据内同一直保存在共享内存中，并没有写回文件。共享内存中的内容往往是在接触映射时才写回文件的。因此，采用共享内存的通信方式效率是最高的。\n\n共享内存最大不足之处在意，由于多个进程对同一块内存区域具有访问的权限，**各个进程之间的同步问题显得尤为重要**。必须控制同一时刻只有一个进程对共享内存区域写入数据，否则会造成数据的混乱。同步控制问题可以由信号量来解决；\n',1,0,0,0,1,'2023-06-07 18:43:08','2023-06-07 19:57:26');
INSERT INTO `t_article` VALUES (106,1,53,'https://upload.haoxx.site/article/b9f3f2f6ed8b951e6e047298abf80a23.jpg','进程与线程笔记','---\ntitle: 进程与线程笔记\ndate: 2023-4-12\ntags:\n - 进程与线程\ncategories:\n - 未分类\n---\n# 一、创建进程/线程：\n\n1、进程创建pid_t fork(void); 说明：fork - create a child process\n\n包含头：\\#include \\<unistd.h\\>\n\n返回值：创建成功，则在父进程中返回子进程的PID，在子进程中返回0。创建失败，在父进程中返回-1。\n\n2、进程创建pid_t vfork(void); 说明：vfork - create a child process and block parent\n\n包含头：\\#include \\<sys/types.h\\>\n\n\\#include \\<unistd.h\\>\n\n3、线程创建int pthread_create(pthread_t \\*thread, const pthread_attr_t \\*attr,\n\nvoid \\*(\\*start_routine) (void \\*), void \\*arg);\n\n包含头：\\#include \\<pthread.h\\>\n\n注意; Compile and link with -pthread.\n\n返回值：创建成功返回0，否则返回错误值。\n\n参数：\n\n1.  pthread_t \\*thread：传递一个 pthread_t 类型的指针变量，也可以直接传递某个 pthread_t 类型变量的地址。pthread_t 是一种用于表示线程的数据类型，每一个 pthread_t 类型的变量都可以表示一个线程。\n2.  const pthread_attr_t \\*attr：用于手动设置新建线程的属性，例如线程的调用策略、线程所能使用的栈内存的大小等。大部分场景中，我们都不需要手动修改线程的属性，将 attr 参数赋值为 NULL，pthread_create() 函数会采用系统默认的属性值创建线程。\n3.  void \\*(\\*start_routine) (void \\*)：以函数指针的方式指明新建线程需要执行的函数，该函数的参数最多有 1 个（可以省略不写），形参和返回值的类型都必须为 void\\* 类型。void\\* 类型又称空指针类型，表明指针所指数据的类型是未知的。使用此类型指针时，我们通常需要先对其进行强制类型转换，然后才能正常访问指针指向的数据。\n4.  void \\*arg：指定传递给 start_routine 函数的实参，当不需要传递任何数据时，将 arg 赋值为 NULL 即可。\n\n\\*\\*如果成功创建线程，pthread_create() 函数返回数字 0，反之返回非零值。各个非零值都对应着不同的宏，指明创建失败的原因，常见的宏有以下几种：\n\nEAGAIN：系统资源不足，无法提供创建线程所需的资源。\n\nEINVAL：传递给 pthread_create() 函数的 attr 参数无效。\n\nEPERM：传递给 pthread_create() 函数的 attr 参数中，某些属性的设置为非法操作，程序没有相关的设置权限。\n\n\\*\\*以上这些宏都声明在 \\<errno.h\\> 头文件中，如果程序中想使用这些宏，需提前引入此头文件。\n\n\\*\\*示例：\n\nvoid \\*receive(void \\*pth_arg) {}\n\npthread_t id;\n\npthread_create(&id,NULL,receive,(void\\*)cfd);\n\n# 二、创建和使用进程/线程时的一些问题：\n\n## 1、fork()和vfork()函数的区别：\n\n![](https://upload.haoxx.site/photo/d9b061df62171b02e7a445e1d176c593.png)\n\n为什么会有vfork，因为以前的fork 很傻， 它创建一个子进程时，将会创建一个新的地址\n\n空间，并且拷贝父进程的资源，而往往在子进程中会执行exec 调用，这样，前面的拷贝工\n\n作就是白费力气了，这种情况下，聪明的人就想出了vfork，它产生的子进程刚开始暂时与\n\n父进程共享地址空间（其实就是线程的概念了），因为这时候子进程在父进程的地址空间中\n\n运行，所以子进程不能进行写操作，并且在儿子 霸占着老子的房子时候，要委屈老子一\n\n下了，让他在外面歇着（阻塞），一旦儿子执行了exec 或者exit 后，相 于儿子买了自己的\n\n房子了，这时候就相于分家了。\n\n参考： <https://blog.csdn.net/jianchi88/article/details/6985326>\n\n在代码中获得当前进程pid的函数为：getpid()；\n\n在代码中获得当前进程父进程pid的函数为：getppid()。\n\n## 2、fork()功能简介：\n\n![](https://upload.haoxx.site/photo/d1f2e482b131c2aac315142934b97807.png)\n\n![](https://upload.haoxx.site/photo/dffc560d52616dd91c7a30860543c238.png)\n\n参考：https://blog.csdn.net/qq_38410730/article/details/81193118\n\n![](https://upload.haoxx.site/photo/a480238e9c3785af646f9d776e569797.png)\n\n![](https://upload.haoxx.site/photo/c2a7079ed0d2e0959a02775cfc93798f.png)\n\n这里需要注明一点：**父子进程的调度的顺序是由调度器决定的，与进程的创建顺序无关。**\n\n**\\*\\***还记得之前的图吗？子进程与父进程共享程序代码，而数据区、栈区、系统栈区相互独立。因此，父进程的代码实际上父、子进程要各执行一次。为了让父子进程执行不同的程序，有两种办法：1是在if(pid==0)中执行子程序特有的程序，2在子进程中调用execv()函数集。\n\n在实际应用中，通常调用execv()的都是子进程。人们之所以创建一个子进程，其目的就是执行一个与父进程代码不同的程序，而系统调用execv()就是子进程执行一个新程序的手段之一。子进程调用execv()之后，系统会立即为子进程加载可执行文件分配私有程序内存空间，从此子进程也成为一个真正的进程。\n\n如果说子进程是父进程的“儿子”，那么子进程在调用execv()之前，它所具有的单独用户堆栈和数据区也仅相当于它的私有“房间”；但因它还没有自己的“住房”，因此也只能寄住在“父亲”家，而不能“自立门户”，尽管它有自己的“户口”（进程控制块）。\n\n![](https://upload.haoxx.site/photo/c9dd37b5aeb33abe47b944c4fa8bed5f.png)\n\n![](https://upload.haoxx.site/photo/ebe07dbeff2c5d9943d4d094dca4ca93.png) \n\n![](https://upload.haoxx.site/photo/af808190d54947777f6c8ee2e8d91687.png)\n\n![](https://upload.haoxx.site/photo/36cf0a7153422dfaf17386b3796366c4.png)\n\n调用exec系列函数的前后，父子进程的关系变化如下图所示：\n\n![](https://upload.haoxx.site/photo/02a6d45da336592e5cb66280578c295e.png) \n\n![](https://upload.haoxx.site/photo/6d0a2a04a3119ad47edcabd7349d4673.png)\n\n为了避免子进程成为孤儿进程，父进程应该要等子进程结束并销毁子进程后才可以退出。因此，父进程中应设置系统调用wait()，子进程中应设置退出函数exit()。\n\n![](https://upload.haoxx.site/photo/f58553028c983dc7f5284ea0f6ff8f10.png)\n\n![](https://upload.haoxx.site/photo/5cb46546d42be10317ef6f30ce6d2fa3.png)\n\n![](https://upload.haoxx.site/photo/ef46427ce1d4b7268ae4baed43486364.png)\n\n![](https://upload.haoxx.site/photo/dcb7db7fed64b2b783a84f14c2324fc0.png)\n\n## 3、vfork()的进一步说明：\n\n![](https://upload.haoxx.site/photo/5529093d85e5635aa1effa437df22107.png)\n\n## 4、线程的基本使用：\n\n![](https://upload.haoxx.site/photo/5f24fbd285b131e20cf48c931def0d45.png)\n\n参考资料：https://blog.csdn.net/yi_chengyu/article/details/120412980\n\n![](https://upload.haoxx.site/photo/b329e9b72442e377d0ab3e954626d92a.png)\n\n## 5、线程与进程\n\n![](https://upload.haoxx.site/photo/eeec806437bfc7f6d52f615ef7078477.png)\n\n![](https://upload.haoxx.site/photo/6f23ed4e0dfc3ec691de15324db383a4.png)\n\n![](https://upload.haoxx.site/photo/ae2a762c612c3978c89eac5acbea13ad.png)\n\n## 6、fork与vfork\n\n![](https://upload.haoxx.site/photo/ae42db34e057eaba61295c7337e7c546.png)\n\n![](https://upload.haoxx.site/photo/5341a44ed914b07567b7dc18abdb8390.png)\n',1,0,0,0,1,'2023-06-07 19:53:22','2023-06-07 19:57:16');
/*!40000 ALTER TABLE `t_article` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `t_article_tag`
--

DROP TABLE IF EXISTS `t_article_tag`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `t_article_tag` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键',
  `article_id` int NOT NULL COMMENT '文章id',
  `tag_id` int NOT NULL COMMENT '标签id',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=213 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_article_tag`
--

LOCK TABLES `t_article_tag` WRITE;
/*!40000 ALTER TABLE `t_article_tag` DISABLE KEYS */;
INSERT INTO `t_article_tag` VALUES (144,99,25);
INSERT INTO `t_article_tag` VALUES (168,71,16);
INSERT INTO `t_article_tag` VALUES (169,72,16);
INSERT INTO `t_article_tag` VALUES (170,73,16);
INSERT INTO `t_article_tag` VALUES (171,74,16);
INSERT INTO `t_article_tag` VALUES (172,75,16);
INSERT INTO `t_article_tag` VALUES (173,76,16);
INSERT INTO `t_article_tag` VALUES (174,84,16);
INSERT INTO `t_article_tag` VALUES (175,81,16);
INSERT INTO `t_article_tag` VALUES (176,106,30);
INSERT INTO `t_article_tag` VALUES (177,106,31);
INSERT INTO `t_article_tag` VALUES (178,105,30);
INSERT INTO `t_article_tag` VALUES (179,105,31);
INSERT INTO `t_article_tag` VALUES (180,103,30);
INSERT INTO `t_article_tag` VALUES (181,103,31);
INSERT INTO `t_article_tag` VALUES (182,102,16);
INSERT INTO `t_article_tag` VALUES (183,102,28);
INSERT INTO `t_article_tag` VALUES (184,101,25);
INSERT INTO `t_article_tag` VALUES (185,100,27);
INSERT INTO `t_article_tag` VALUES (186,96,16);
INSERT INTO `t_article_tag` VALUES (187,98,25);
INSERT INTO `t_article_tag` VALUES (188,97,25);
INSERT INTO `t_article_tag` VALUES (189,97,26);
INSERT INTO `t_article_tag` VALUES (190,95,24);
INSERT INTO `t_article_tag` VALUES (191,95,25);
INSERT INTO `t_article_tag` VALUES (192,95,29);
INSERT INTO `t_article_tag` VALUES (193,94,24);
INSERT INTO `t_article_tag` VALUES (194,93,16);
INSERT INTO `t_article_tag` VALUES (195,93,23);
INSERT INTO `t_article_tag` VALUES (196,92,21);
INSERT INTO `t_article_tag` VALUES (197,92,22);
INSERT INTO `t_article_tag` VALUES (198,91,21);
INSERT INTO `t_article_tag` VALUES (199,90,16);
INSERT INTO `t_article_tag` VALUES (200,90,20);
INSERT INTO `t_article_tag` VALUES (201,89,19);
INSERT INTO `t_article_tag` VALUES (202,88,19);
INSERT INTO `t_article_tag` VALUES (203,87,18);
INSERT INTO `t_article_tag` VALUES (204,86,16);
INSERT INTO `t_article_tag` VALUES (205,86,18);
INSERT INTO `t_article_tag` VALUES (206,85,16);
INSERT INTO `t_article_tag` VALUES (207,82,16);
INSERT INTO `t_article_tag` VALUES (208,83,16);
INSERT INTO `t_article_tag` VALUES (209,80,16);
INSERT INTO `t_article_tag` VALUES (210,78,16);
INSERT INTO `t_article_tag` VALUES (211,77,16);
INSERT INTO `t_article_tag` VALUES (212,79,17);
/*!40000 ALTER TABLE `t_article_tag` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `t_blog_file`
--

DROP TABLE IF EXISTS `t_blog_file`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `t_blog_file` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '文件id',
  `file_url` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT NULL COMMENT '文件url',
  `file_name` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '文件名',
  `file_size` int NOT NULL DEFAULT '0' COMMENT '文件大小',
  `extend_name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL DEFAULT '' COMMENT '文件类型',
  `file_path` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '文件路径',
  `is_dir` tinyint(1) NOT NULL DEFAULT '0' COMMENT '是否为目录 (0否 1是)',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=229 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_blog_file`
--

LOCK TABLES `t_blog_file` WRITE;
/*!40000 ALTER TABLE `t_blog_file` DISABLE KEYS */;
INSERT INTO `t_blog_file` VALUES (2,NULL,'talk',0,'','/',1,'2023-03-08 12:16:37',NULL);
INSERT INTO `t_blog_file` VALUES (3,NULL,'config',0,'','/',1,'2023-03-08 12:17:10',NULL);
INSERT INTO `t_blog_file` VALUES (106,NULL,'photo',0,'','/',1,'2023-03-10 22:33:29',NULL);
INSERT INTO `t_blog_file` VALUES (107,NULL,'article',0,'','/',1,'2023-03-10 22:33:33',NULL);
INSERT INTO `t_blog_file` VALUES (108,'https://upload.haoxx.site/article/27c7f38a329c07159a80315712680ea5.jpg','27c7f38a329c07159a80315712680ea5',203270,'jpg','/article',0,'2023-03-10 22:36:01',NULL);
INSERT INTO `t_blog_file` VALUES (109,'https://upload.haoxx.site/config/5c83bb7a0502fd77ba92c20087fcefde.jpg','5c83bb7a0502fd77ba92c20087fcefde',207664,'jpg','/photo',0,'2023-03-10 22:37:38',NULL);
INSERT INTO `t_blog_file` VALUES (110,'https://upload.haoxx.site/config/5bbb6dc8be42f3e96dbcc7d7529dc402.gif','5bbb6dc8be42f3e96dbcc7d7529dc402',94649,'gif','/config',0,'2023-03-10 22:48:26',NULL);
INSERT INTO `t_blog_file` VALUES (111,'https://upload.haoxx.site/config/d07b9fbf62f720a437ab20b307db428b.jpg','d07b9fbf62f720a437ab20b307db428b',1323,'jpg','/config',0,'2023-03-10 22:53:35',NULL);
INSERT INTO `t_blog_file` VALUES (114,'https://upload.haoxx.site/config/0b04691f25e400a708caba867be171d0.jpg','0b04691f25e400a708caba867be171d0',43466,'jpg','/config',0,'2023-03-10 22:57:18',NULL);
INSERT INTO `t_blog_file` VALUES (116,'https://upload.haoxx.site/config/f58a34eae84d48062c59a208c490381b.jpg','f58a34eae84d48062c59a208c490381b',43981,'jpg','/config',0,'2023-03-10 22:58:21',NULL);
INSERT INTO `t_blog_file` VALUES (117,'https://upload.haoxx.site/config/e94fc60e58a570ecc3e9ddcb334fdb2b.jpg','e94fc60e58a570ecc3e9ddcb334fdb2b',196780,'jpg','/config',0,'2023-03-10 22:58:53',NULL);
INSERT INTO `t_blog_file` VALUES (118,'https://upload.haoxx.site/config/27c7f38a329c07159a80315712680ea5.jpg','27c7f38a329c07159a80315712680ea5',203270,'jpg','/config',0,'2023-03-10 23:00:06',NULL);
INSERT INTO `t_blog_file` VALUES (128,'https://upload.haoxx.site/photo/24319fa48171a24c8adf1eb0c6680f17.jpg','24319fa48171a24c8adf1eb0c6680f17',45126,'jpg','/photo',0,'2023-06-07 19:14:22',NULL);
INSERT INTO `t_blog_file` VALUES (147,'https://upload.haoxx.site/photo/3a10aa097584f54f8b871ad0fc8668e6.png','3a10aa097584f54f8b871ad0fc8668e6',33790,'png','/photo',0,'2023-06-07 19:34:09',NULL);
INSERT INTO `t_blog_file` VALUES (148,'https://upload.haoxx.site/photo/20ec88f94bff808a8bcdbbd7e00c08cd.png','20ec88f94bff808a8bcdbbd7e00c08cd',144872,'png','/photo',0,'2023-06-07 19:34:14',NULL);
INSERT INTO `t_blog_file` VALUES (149,'https://upload.haoxx.site/photo/b7cc08bb88c6ef808f23b3202d5763eb.png','b7cc08bb88c6ef808f23b3202d5763eb',171855,'png','/photo',0,'2023-06-07 19:34:17',NULL);
INSERT INTO `t_blog_file` VALUES (150,'https://upload.haoxx.site/photo/47fae86680ce79a7ed24d7237c1d16dc.png','47fae86680ce79a7ed24d7237c1d16dc',21808,'png','/photo',0,'2023-06-07 19:34:21',NULL);
INSERT INTO `t_blog_file` VALUES (151,'https://upload.haoxx.site/photo/84e8bfe1bdfb66b1da75e06ca2c9fc33.png','84e8bfe1bdfb66b1da75e06ca2c9fc33',120165,'png','/photo',0,'2023-06-07 19:34:24',NULL);
INSERT INTO `t_blog_file` VALUES (152,'https://upload.haoxx.site/photo/630cb06c3086ffba6fb203a5a3ae317b.png','630cb06c3086ffba6fb203a5a3ae317b',19897,'png','/photo',0,'2023-06-07 19:34:30',NULL);
INSERT INTO `t_blog_file` VALUES (153,'https://upload.haoxx.site/photo/05438e1a57a775323713c45100ac9b5f.png','05438e1a57a775323713c45100ac9b5f',120185,'png','/photo',0,'2023-06-07 19:34:36',NULL);
INSERT INTO `t_blog_file` VALUES (154,'https://upload.haoxx.site/photo/a55a1d964faddbc271c37e56f0588cde.png','a55a1d964faddbc271c37e56f0588cde',64012,'png','/photo',0,'2023-06-07 19:34:40',NULL);
INSERT INTO `t_blog_file` VALUES (155,'https://upload.haoxx.site/photo/c0bdec69bc1cc87001a1903296feba86.png','c0bdec69bc1cc87001a1903296feba86',32765,'png','/photo',0,'2023-06-07 19:34:44',NULL);
INSERT INTO `t_blog_file` VALUES (158,'https://upload.haoxx.site/photo/5529093d85e5635aa1effa437df22107.png','5529093d85e5635aa1effa437df22107',115467,'png','/photo',0,'2023-06-07 19:41:17',NULL);
INSERT INTO `t_blog_file` VALUES (159,'https://upload.haoxx.site/photo/ae2a762c612c3978c89eac5acbea13ad.png','ae2a762c612c3978c89eac5acbea13ad',51392,'png','/photo',0,'2023-06-07 19:41:17',NULL);
INSERT INTO `t_blog_file` VALUES (160,'https://upload.haoxx.site/photo/d1f2e482b131c2aac315142934b97807.png','d1f2e482b131c2aac315142934b97807',163637,'png','/photo',0,'2023-06-07 19:41:17',NULL);
INSERT INTO `t_blog_file` VALUES (161,'https://upload.haoxx.site/photo/589080628386800bbe32bb04420e0977.png','589080628386800bbe32bb04420e0977',34521,'png','/photo',0,'2023-06-07 19:41:17',NULL);
INSERT INTO `t_blog_file` VALUES (162,'https://upload.haoxx.site/photo/b329e9b72442e377d0ab3e954626d92a.png','b329e9b72442e377d0ab3e954626d92a',57049,'png','/photo',0,'2023-06-07 19:41:17',NULL);
INSERT INTO `t_blog_file` VALUES (163,'https://upload.haoxx.site/photo/c2a7079ed0d2e0959a02775cfc93798f.png','c2a7079ed0d2e0959a02775cfc93798f',33561,'png','/photo',0,'2023-06-07 19:41:17',NULL);
INSERT INTO `t_blog_file` VALUES (164,'https://upload.haoxx.site/photo/c9dd37b5aeb33abe47b944c4fa8bed5f.png','c9dd37b5aeb33abe47b944c4fa8bed5f',76073,'png','/photo',0,'2023-06-07 19:41:17',NULL);
INSERT INTO `t_blog_file` VALUES (165,'https://upload.haoxx.site/photo/dcb7db7fed64b2b783a84f14c2324fc0.png','dcb7db7fed64b2b783a84f14c2324fc0',102867,'png','/photo',0,'2023-06-07 19:41:18',NULL);
INSERT INTO `t_blog_file` VALUES (166,'https://upload.haoxx.site/photo/ebe07dbeff2c5d9943d4d094dca4ca93.png','ebe07dbeff2c5d9943d4d094dca4ca93',6551,'png','/photo',0,'2023-06-07 19:41:18',NULL);
INSERT INTO `t_blog_file` VALUES (167,'https://upload.haoxx.site/photo/dffc560d52616dd91c7a30860543c238.png','dffc560d52616dd91c7a30860543c238',140334,'png','/photo',0,'2023-06-07 19:41:18',NULL);
INSERT INTO `t_blog_file` VALUES (168,'https://upload.haoxx.site/photo/a480238e9c3785af646f9d776e569797.png','a480238e9c3785af646f9d776e569797',146562,'png','/photo',0,'2023-06-07 19:41:19',NULL);
INSERT INTO `t_blog_file` VALUES (169,'https://upload.haoxx.site/photo/d9b061df62171b02e7a445e1d176c593.png','d9b061df62171b02e7a445e1d176c593',34349,'png','/photo',0,'2023-06-07 19:41:19',NULL);
INSERT INTO `t_blog_file` VALUES (170,'https://upload.haoxx.site/photo/eeec806437bfc7f6d52f615ef7078477.png','eeec806437bfc7f6d52f615ef7078477',46736,'png','/photo',0,'2023-06-07 19:41:20',NULL);
INSERT INTO `t_blog_file` VALUES (171,'https://upload.haoxx.site/photo/5cb46546d42be10317ef6f30ce6d2fa3.png','5cb46546d42be10317ef6f30ce6d2fa3',28135,'png','/photo',0,'2023-06-07 19:41:20',NULL);
INSERT INTO `t_blog_file` VALUES (172,'https://upload.haoxx.site/photo/ae42db34e057eaba61295c7337e7c546.png','ae42db34e057eaba61295c7337e7c546',103001,'png','/photo',0,'2023-06-07 19:41:20',NULL);
INSERT INTO `t_blog_file` VALUES (173,'https://upload.haoxx.site/photo/02a6d45da336592e5cb66280578c295e.png','02a6d45da336592e5cb66280578c295e',77194,'png','/photo',0,'2023-06-07 19:41:20',NULL);
INSERT INTO `t_blog_file` VALUES (174,'https://upload.haoxx.site/photo/f58553028c983dc7f5284ea0f6ff8f10.png','f58553028c983dc7f5284ea0f6ff8f10',35139,'png','/photo',0,'2023-06-07 19:41:20',NULL);
INSERT INTO `t_blog_file` VALUES (175,'https://upload.haoxx.site/photo/6f23ed4e0dfc3ec691de15324db383a4.png','6f23ed4e0dfc3ec691de15324db383a4',39524,'png','/photo',0,'2023-06-07 19:41:20',NULL);
INSERT INTO `t_blog_file` VALUES (176,'https://upload.haoxx.site/photo/ef46427ce1d4b7268ae4baed43486364.png','ef46427ce1d4b7268ae4baed43486364',41652,'png','/photo',0,'2023-06-07 19:41:20',NULL);
INSERT INTO `t_blog_file` VALUES (177,'https://upload.haoxx.site/photo/36cf0a7153422dfaf17386b3796366c4.png','36cf0a7153422dfaf17386b3796366c4',120479,'png','/photo',0,'2023-06-07 19:41:22',NULL);
INSERT INTO `t_blog_file` VALUES (178,'https://upload.haoxx.site/photo/6d0a2a04a3119ad47edcabd7349d4673.png','6d0a2a04a3119ad47edcabd7349d4673',89627,'png','/photo',0,'2023-06-07 19:41:22',NULL);
INSERT INTO `t_blog_file` VALUES (179,'https://upload.haoxx.site/photo/105c3ca0ae4de6b12b6147b916a61af1.png','105c3ca0ae4de6b12b6147b916a61af1',29197,'png','/photo',0,'2023-06-07 19:41:22',NULL);
INSERT INTO `t_blog_file` VALUES (180,'https://upload.haoxx.site/photo/af808190d54947777f6c8ee2e8d91687.png','af808190d54947777f6c8ee2e8d91687',122641,'png','/photo',0,'2023-06-07 19:41:22',NULL);
INSERT INTO `t_blog_file` VALUES (181,'https://upload.haoxx.site/photo/5341a44ed914b07567b7dc18abdb8390.png','5341a44ed914b07567b7dc18abdb8390',65131,'png','/photo',0,'2023-06-07 19:41:22',NULL);
INSERT INTO `t_blog_file` VALUES (182,'https://upload.haoxx.site/photo/5f24fbd285b131e20cf48c931def0d45.png','5f24fbd285b131e20cf48c931def0d45',42618,'png','/photo',0,'2023-06-07 19:41:24',NULL);
INSERT INTO `t_blog_file` VALUES (183,'https://upload.haoxx.site/article/b6877ebd88b9d69396333c5769e07c05.jpg','b6877ebd88b9d69396333c5769e07c05',205675,'jpg','/article',0,'2023-06-07 19:54:51',NULL);
INSERT INTO `t_blog_file` VALUES (184,'https://upload.haoxx.site/article/a48f6cb59c54e3e6f6397ee22eed38b2.jpg','a48f6cb59c54e3e6f6397ee22eed38b2',200723,'jpg','/article',0,'2023-06-07 19:55:16',NULL);
INSERT INTO `t_blog_file` VALUES (185,'https://upload.haoxx.site/article/8a9d452db38f480ff6fc43806fe4f0df.jpg','8a9d452db38f480ff6fc43806fe4f0df',200603,'jpg','/article',0,'2023-06-07 19:55:38',NULL);
INSERT INTO `t_blog_file` VALUES (186,'https://upload.haoxx.site/article/04e39dc69be59749653fec847b165ae6.jpg','04e39dc69be59749653fec847b165ae6',195669,'jpg','/article',0,'2023-06-07 19:55:50',NULL);
INSERT INTO `t_blog_file` VALUES (187,'https://upload.haoxx.site/article/2ec42f646cb85e6554ab21b4e9bc6c19.jpg','2ec42f646cb85e6554ab21b4e9bc6c19',209336,'jpg','/article',0,'2023-06-07 19:56:12',NULL);
INSERT INTO `t_blog_file` VALUES (188,'https://upload.haoxx.site/article/e16db2f6b4c568f36a1baa140b2e3b86.jpg','e16db2f6b4c568f36a1baa140b2e3b86',201407,'jpg','/article',0,'2023-06-07 19:56:35',NULL);
INSERT INTO `t_blog_file` VALUES (189,'https://upload.haoxx.site/article/27d6c34fad9892fa82032f4bfa681d4f.jpg','27d6c34fad9892fa82032f4bfa681d4f',197869,'jpg','/article',0,'2023-06-07 19:56:50',NULL);
INSERT INTO `t_blog_file` VALUES (190,'https://upload.haoxx.site/article/9a42c06ea0f36c4eacc2fb9bfc59781d.jpg','9a42c06ea0f36c4eacc2fb9bfc59781d',202925,'jpg','/article',0,'2023-06-07 19:57:02',NULL);
INSERT INTO `t_blog_file` VALUES (191,'https://upload.haoxx.site/article/b9f3f2f6ed8b951e6e047298abf80a23.jpg','b9f3f2f6ed8b951e6e047298abf80a23',201957,'jpg','/article',0,'2023-06-07 19:57:13',NULL);
INSERT INTO `t_blog_file` VALUES (192,'https://upload.haoxx.site/article/17f10cd4cbe9e8cba44a22c4d0ee0381.jpg','17f10cd4cbe9e8cba44a22c4d0ee0381',211018,'jpg','/article',0,'2023-06-07 19:57:25',NULL);
INSERT INTO `t_blog_file` VALUES (193,'https://upload.haoxx.site/article/06d11f52c1fcd3abcda231e09209d1cd.jpg','06d11f52c1fcd3abcda231e09209d1cd',195511,'jpg','/article',0,'2023-06-07 19:57:48',NULL);
INSERT INTO `t_blog_file` VALUES (194,'https://upload.haoxx.site/article/aed9e7f618becc093ba89e9e48e300ed.jpg','aed9e7f618becc093ba89e9e48e300ed',198919,'jpg','/article',0,'2023-06-07 19:58:00',NULL);
INSERT INTO `t_blog_file` VALUES (195,'https://upload.haoxx.site/article/979a9c0ee3f5bf324d916d6fac553317.jpg','979a9c0ee3f5bf324d916d6fac553317',197505,'jpg','/article',0,'2023-06-07 19:58:13',NULL);
INSERT INTO `t_blog_file` VALUES (196,'https://upload.haoxx.site/article/e40b334765dcebff6d4f4b60544bcc7b.jpg','e40b334765dcebff6d4f4b60544bcc7b',206452,'jpg','/article',0,'2023-06-07 19:58:21',NULL);
INSERT INTO `t_blog_file` VALUES (197,'https://upload.haoxx.site/article/060c7716645312017b87f5a2b0495bec.jpg','060c7716645312017b87f5a2b0495bec',196165,'jpg','/article',0,'2023-06-07 19:58:31',NULL);
INSERT INTO `t_blog_file` VALUES (198,'https://upload.haoxx.site/article/fccca1c9e6eaddff6e7aea054d820878.jpg','fccca1c9e6eaddff6e7aea054d820878',203709,'jpg','/article',0,'2023-06-07 19:58:55',NULL);
INSERT INTO `t_blog_file` VALUES (199,'https://upload.haoxx.site/article/190eee4ddc61160d9293c95a65123531.jpg','190eee4ddc61160d9293c95a65123531',201565,'jpg','/article',0,'2023-06-07 19:59:08',NULL);
INSERT INTO `t_blog_file` VALUES (200,'https://upload.haoxx.site/article/95bfa093fc995038d2b6e82aeab43625.jpg','95bfa093fc995038d2b6e82aeab43625',205053,'jpg','/article',0,'2023-06-07 19:59:19',NULL);
INSERT INTO `t_blog_file` VALUES (201,'https://upload.haoxx.site/article/716ceea8febe298c99a60b324b168a7e.jpg','716ceea8febe298c99a60b324b168a7e',201388,'jpg','/article',0,'2023-06-07 19:59:30',NULL);
INSERT INTO `t_blog_file` VALUES (202,'https://upload.haoxx.site/article/2fcfdfae4d9133ae7d74c18af1dcf632.jpg','2fcfdfae4d9133ae7d74c18af1dcf632',200545,'jpg','/article',0,'2023-06-07 19:59:48',NULL);
INSERT INTO `t_blog_file` VALUES (203,'https://upload.haoxx.site/article/93c917e6b636c7a56c9473e6c29a3081.jpg','93c917e6b636c7a56c9473e6c29a3081',208962,'jpg','/article',0,'2023-06-07 19:59:56',NULL);
INSERT INTO `t_blog_file` VALUES (204,'https://upload.haoxx.site/article/da9646e2e30563537d21e5a36a4ac461.jpg','da9646e2e30563537d21e5a36a4ac461',181723,'jpg','/article',0,'2023-06-07 20:00:06',NULL);
INSERT INTO `t_blog_file` VALUES (205,'https://upload.haoxx.site/article/0ee03ae43908303571e0982183382565.jpg','0ee03ae43908303571e0982183382565',203202,'jpg','/article',0,'2023-06-07 20:00:31',NULL);
INSERT INTO `t_blog_file` VALUES (206,'https://upload.haoxx.site/article/370336be7166eb151f9877379c989b33.jpg','370336be7166eb151f9877379c989b33',202758,'jpg','/article',0,'2023-06-07 20:00:41',NULL);
INSERT INTO `t_blog_file` VALUES (207,'https://upload.haoxx.site/article/9c533384183255ee7a33c3f702e1a718.jpg','9c533384183255ee7a33c3f702e1a718',207955,'jpg','/article',0,'2023-06-07 20:00:56',NULL);
INSERT INTO `t_blog_file` VALUES (208,'https://upload.haoxx.site/article/916b2acdd31a579849fb9f1e706fd1ac.jpg','916b2acdd31a579849fb9f1e706fd1ac',192270,'jpg','/article',0,'2023-06-07 20:01:04',NULL);
INSERT INTO `t_blog_file` VALUES (209,'https://upload.haoxx.site/article/a9ac1c3c7feb616dd40892fdb8fdf1ec.jpg','a9ac1c3c7feb616dd40892fdb8fdf1ec',213478,'jpg','/article',0,'2023-06-07 20:01:24',NULL);
INSERT INTO `t_blog_file` VALUES (210,'https://upload.haoxx.site/article/ca35f9ff3043e951a604aeee51064499.jpg','ca35f9ff3043e951a604aeee51064499',203133,'jpg','/article',0,'2023-06-07 20:01:35',NULL);
INSERT INTO `t_blog_file` VALUES (211,'https://upload.haoxx.site/article/ef2a97cea70aa44f3e7e7e4ac7c0a1ce.jpg','ef2a97cea70aa44f3e7e7e4ac7c0a1ce',210287,'jpg','/article',0,'2023-06-07 20:02:14',NULL);
INSERT INTO `t_blog_file` VALUES (212,'https://upload.haoxx.site/article/015acc505d3ef69b0d459b85d2b4f990.jpg','015acc505d3ef69b0d459b85d2b4f990',209676,'jpg','/article',0,'2023-06-07 20:02:35',NULL);
INSERT INTO `t_blog_file` VALUES (213,'https://upload.haoxx.site/article/79db75241acafdd2e58deb66960c3e25.jpg','79db75241acafdd2e58deb66960c3e25',209822,'jpg','/article',0,'2023-06-07 20:02:58',NULL);
INSERT INTO `t_blog_file` VALUES (214,'https://upload.haoxx.site//config/9d1f91355bfe35dd0ecd5f472ca8a22b.jpg','9d1f91355bfe35dd0ecd5f472ca8a22b',209772,'jpg','/config',0,'2023-06-07 20:09:35',NULL);
INSERT INTO `t_blog_file` VALUES (215,'https://upload.haoxx.site//config/1df2188b6f498106917eebb283983cb4.jpg','1df2188b6f498106917eebb283983cb4',177049,'jpg','/config',0,'2023-06-07 20:11:52',NULL);
INSERT INTO `t_blog_file` VALUES (216,'https://upload.haoxx.site//config/bc0549eae956ba0d385eb98e35d0f315.jpg','bc0549eae956ba0d385eb98e35d0f315',93065,'jpg','/config',0,'2023-06-07 20:13:01',NULL);
INSERT INTO `t_blog_file` VALUES (222,NULL,'indexlist',0,'','/config',1,'2023-06-07 20:18:13',NULL);
INSERT INTO `t_blog_file` VALUES (223,'https://upload.haoxx.site//config/indexlist/f2bc6e65688efd7a64b7758b0b552f31.jpg','f2bc6e65688efd7a64b7758b0b552f31',213544,'jpg','/config/indexlist',0,'2023-06-07 20:18:20',NULL);
INSERT INTO `t_blog_file` VALUES (224,'https://upload.haoxx.site//config/indexlist/5f84a39f58e3ae27bcfd78f85d65fe21.jpg','5f84a39f58e3ae27bcfd78f85d65fe21',208860,'jpg','/config/indexlist',0,'2023-06-07 20:18:20',NULL);
INSERT INTO `t_blog_file` VALUES (225,'https://upload.haoxx.site//config/indexlist/1fbbb3ac1012beaf4ff8385566fabfb8.jpg','1fbbb3ac1012beaf4ff8385566fabfb8',212351,'jpg','/config/indexlist',0,'2023-06-07 20:18:21',NULL);
INSERT INTO `t_blog_file` VALUES (226,'https://upload.haoxx.site//config/indexlist/164be34c3e9c40294890a65190e0761b.jpg','164be34c3e9c40294890a65190e0761b',211581,'jpg','/config/indexlist',0,'2023-06-07 20:18:21',NULL);
INSERT INTO `t_blog_file` VALUES (227,'https://upload.haoxx.site//config/indexlist/379ce4b2ddf4b087441c196fbffa2f3b.jpg','379ce4b2ddf4b087441c196fbffa2f3b',116647,'jpg','/config/indexlist',0,'2023-06-07 20:19:55',NULL);
INSERT INTO `t_blog_file` VALUES (228,'https://upload.haoxx.site//config/0928490660c39486a9fd434948633355.jpg','0928490660c39486a9fd434948633355',212955,'jpg','/config',0,'2023-06-07 20:29:23',NULL);
/*!40000 ALTER TABLE `t_blog_file` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `t_category`
--

DROP TABLE IF EXISTS `t_category`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `t_category` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '分类id',
  `category_name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '分类名',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=62 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_category`
--

LOCK TABLES `t_category` WRITE;
/*!40000 ALTER TABLE `t_category` DISABLE KEYS */;
INSERT INTO `t_category` VALUES (51,'编程语言基础','2023-06-07 16:32:56',NULL);
INSERT INTO `t_category` VALUES (52,'数据结构与算法','2023-06-07 16:41:44',NULL);
INSERT INTO `t_category` VALUES (53,'操作系统与计算机组成原理','2023-06-07 16:59:04',NULL);
INSERT INTO `t_category` VALUES (54,'计算机网络','2023-06-07 16:59:38',NULL);
INSERT INTO `t_category` VALUES (55,'设计模式','2023-06-07 17:00:36',NULL);
INSERT INTO `t_category` VALUES (56,'找工作','2023-06-07 17:01:45',NULL);
INSERT INTO `t_category` VALUES (57,'markdown','2023-06-07 17:02:26',NULL);
INSERT INTO `t_category` VALUES (58,'其他','2023-06-07 17:04:31',NULL);
INSERT INTO `t_category` VALUES (59,'博客相关','2023-06-07 17:05:28',NULL);
INSERT INTO `t_category` VALUES (60,'Linux运维','2023-06-07 17:06:23',NULL);
INSERT INTO `t_category` VALUES (61,'未分类','2023-06-07 18:18:00',NULL);
/*!40000 ALTER TABLE `t_category` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `t_comment`
--

DROP TABLE IF EXISTS `t_comment`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `t_comment` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '评论id',
  `comment_type` tinyint(1) NOT NULL COMMENT '类型 (1文章 2友链 3说说)',
  `type_id` int DEFAULT NULL COMMENT '类型id (类型为友链则没有值)',
  `parent_id` int DEFAULT NULL COMMENT '父评论id',
  `reply_id` int DEFAULT NULL COMMENT '回复评论id',
  `comment_content` text CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '评论内容',
  `from_uid` int NOT NULL COMMENT '评论用户id',
  `to_uid` int DEFAULT NULL COMMENT '回复用户id',
  `is_check` tinyint(1) NOT NULL DEFAULT '1' COMMENT '是否通过 (0否 1是)',
  `create_time` datetime NOT NULL COMMENT '评论时间',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_comment`
--

LOCK TABLES `t_comment` WRITE;
/*!40000 ALTER TABLE `t_comment` DISABLE KEYS */;
INSERT INTO `t_comment` VALUES (1,2,NULL,NULL,NULL,'<img src= \'https://static.ttkwsd.top/emoji/doge.png\' width=\'21\' height=\'21\' style=\'margin: 0 1px;vertical-align: text-bottom\'/>',1,NULL,1,'2023-06-05 12:49:45',NULL);
/*!40000 ALTER TABLE `t_comment` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `t_exception_log`
--

DROP TABLE IF EXISTS `t_exception_log`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `t_exception_log` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '异常id',
  `module` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '异常模块',
  `uri` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '异常uri',
  `name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '异常名称',
  `description` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '操作描述',
  `error_method` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '异常方法',
  `message` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '异常信息',
  `params` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '请求参数',
  `request_method` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '请求方式',
  `ip_address` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '操作ip',
  `ip_source` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '操作地址',
  `os` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '操作系统',
  `browser` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '浏览器',
  `create_time` datetime NOT NULL COMMENT '操作时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=258 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_exception_log`
--

LOCK TABLES `t_exception_log` WRITE;
/*!40000 ALTER TABLE `t_exception_log` DISABLE KEYS */;
INSERT INTO `t_exception_log` VALUES (248,'网站配置模块','/admin/site/update','org.springframework.dao.DataIntegrityViolationException','更新网站配置','com.ican.controller.SiteConfigController.updateSiteConfig','org.springframework.dao.DataIntegrityViolationException:\n### Error updating database.  Cause: com.mysql.cj.jdbc.exceptions.MysqlDataTruncation: Data truncation: Data too long for column \'bilibili\' at row 1\n### The error may exist in com/ican/mapper/SiteConfigMapper.java (best guess)\n### The error may involve com.ican.mapper.SiteConfigMapper.updateById-Inline\n### The error occurred while setting parameters\n### SQL: UPDATE t_site_config  SET user_avatar=?, tourist_avatar=?, site_name=?, site_address=?, site_intro=?, site_notice=?, create_site_time=?, record_number=?, author_avatar=?, site_author=?, article_cover=?, about_me=?, github=?, gitee=?, bilibili=?, qq=?, comment_check=?, message_check=?, is_reward=?, wei_xin_code=?, ali_code=?, email_notice=?, social_list=?, login_list=?, is_music=?, music_id=?,  update_time=?  WHERE id=?\n### Cause: com.mysql.cj.jdbc.exceptions.MysqlDataTruncation: Data truncation: Data too long for column \'bilibili\' at row 1\n; Data truncation: Data too long for column \'bilibili\' at row 1; nested exception is com.mysql.cj.jdbc.exceptions.MysqlDataTruncation: Data truncation: Data too long for column \'bilibili\' at row 1\norg.springframework.jdbc.support.SQLStateSQLExceptionTranslator.doTranslate(SQLStateSQLExceptionTranslator.java:104)\norg.springframework.jdbc.support.AbstractFallbackSQLExceptionTranslator.translate(AbstractFallbackSQLExceptionTranslator.java:70)\norg.springframework.jdbc.support.AbstractFallbackSQLExceptionTranslator.translate(AbstractFallbackSQLExceptionTranslator.java:79)\norg.springframework.jdbc.support.AbstractFallbackSQLExceptionTranslator.translate(AbstractFallbackSQLExceptionTranslator.java:79)\norg.mybatis.spring.MyBatisExceptionTranslator.translateExceptionIfPossible(MyBatisExceptionTranslator.java:91)\norg.mybatis.spring.SqlSessionTemplate$SqlSessionInterceptor.invoke(SqlSessionTemplate.java:441)\ncom.sun.proxy.$Proxy124.update(Unknown Source)\norg.mybatis.spring.SqlSessionTemplate.update(SqlSessionTemplate.java:288)\ncom.baomidou.mybatisplus.core.override.MybatisMapperMethod.execute(MybatisMapperMethod.java:64)\ncom.baomidou.mybatisplus.core.override.MybatisMapperProxy$PlainMethodInvoker.invoke(MybatisMapperProxy.java:148)\ncom.baomidou.mybatisplus.core.override.MybatisMapperProxy.invoke(MybatisMapperProxy.java:89)\ncom.sun.proxy.$Proxy150.updateById(Unknown Source)\njava.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\njava.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\njava.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\njava.base/java.lang.reflect.Method.invoke(Method.java:566)\norg.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:344)\norg.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:198)\norg.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163)\norg.springframework.dao.support.PersistenceExceptionTranslationInterceptor.invoke(PersistenceExceptionTranslationInterceptor.java:137)\norg.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)\norg.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:215)\ncom.sun.proxy.$Proxy151.updateById(Unknown Source)\ncom.ican.service.impl.SiteConfigServiceImpl.updateSiteConfig(SiteConfigServiceImpl.java:58)\ncom.ican.service.impl.SiteConfigServiceImpl$$FastClassBySpringCGLIB$$49d1efd1.invoke(<generated>)\norg.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218)\norg.springframework.aop.framework.CglibAopProxy.invokeMethod(CglibAopProxy.java:386)\norg.springframework.aop.framework.CglibAopProxy.access$000(CglibAopProxy.java:85)\norg.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:704)\ncom.ican.service.impl.SiteConfigServiceImpl$$EnhancerBySpringCGLIB$$56ef49f4.updateSiteConfig(<generated>)\ncom.ican.controller.SiteConfigController.updateSiteConfig(SiteConfigController.java:53)\ncom.ican.controller.SiteConfigController$$FastClassBySpringCGLIB$$2c5f3a3d.invoke(<generated>)\norg.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218)\norg.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:793)\norg.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163)\norg.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:763)\norg.springframework.aop.framework.adapter.AfterReturningAdviceInterceptor.invoke(AfterReturningAdviceInterceptor.java:57)\norg.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:175)\norg.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:763)\norg.springframework.aop.framework.adapter.MethodBeforeAdviceInterceptor.invoke(MethodBeforeAdviceInterceptor.java:58)\norg.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:175)\norg.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:763)\norg.springframework.aop.aspectj.AspectJAfterThrowingAdvice.invoke(AspectJAfterThrowingAdvice.java:64)\norg.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)\norg.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:763)\norg.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:97)\norg.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)\norg.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:763)\norg.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:708)\ncom.ican.controller.SiteConfigController$$EnhancerBySpringCGLIB$$b45464e8.updateSiteConfig(<generated>)\njava.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\njava.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\njava.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\njava.base/java.lang.reflect.Method.invoke(Method.java:566)\norg.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:205)\norg.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:150)\norg.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:117)\norg.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:895)\norg.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:808)\norg.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)\norg.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1071)\norg.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:964)\norg.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006)\norg.springframework.web.servlet.FrameworkServlet.doPut(FrameworkServlet.java:920)\njavax.servlet.http.HttpServlet.service(HttpServlet.java:699)\norg.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883)\njavax.servlet.http.HttpServlet.service(HttpServlet.java:779)\norg.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:227)\norg.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\norg.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53)\norg.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)\norg.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\ncn.dev33.satoken.filter.SaServletFilter.doFilter(SaServletFilter.java:179)\norg.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)\norg.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\norg.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)\norg.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117)\norg.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)\norg.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\norg.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)\norg.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117)\norg.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)\norg.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\norg.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)\norg.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117)\norg.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)\norg.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\norg.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:177)\norg.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:97)\norg.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:541)\norg.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:135)\norg.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92)\norg.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:78)\norg.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:360)\norg.apache.coyote.http11.Http11Processor.service(Http11Processor.java:399)\norg.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65)\norg.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:891)\norg.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1784)\norg.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)\norg.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1191)\norg.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659)\norg.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)\njava.base/java.lang.Thread.run(Thread.java:829)\n','[{\"aboutMe\":\"🍀个人简介\\n\\n普通人\",\"aliCode\":\"https://upload.haoxx.site/cloud/images/image_2.jpg\",\"articleCover\":\"https://upload.haoxx.site/config/27c7f38a329c07159a80315712680ea5.jpg\",\"authorAvatar\":\"https://upload.haoxx.site/config/5bbb6dc8be42f3e96dbcc7d7529dc402.gif\",\"bilibili\":\"https://space.bilibili.com/263844591?spm_id_from=333.999.0.0\",\"commentCheck\":0,\"createSiteTime\":\"2023-06-06\",\"emailNotice\":1,\"gitee\":\"https://gitee.com/wu_shengdong\",\"github\":\"https://github.com/XiaoYuer2022\",\"id\":1,\"isMusic\":0,\"isReward\":0,\"loginList\":\",gitee\",\"messageCheck\":0,\"musicId\":\"7611185981\",\"qq\":\"508506630\",\"recordNumber\":\"渝ICP备2023001651号-2\",\"siteAddress\":\"https://www.haoxx.site\",\"siteAuthor\":\"小鱼\",\"siteIntro\":\"网站介绍\",\"siteName\":\"HaoXX`s Blog\",\"siteNotice\":\"个人学习资料记录\",\"socialList\":\"gitee,bilibili,github,qq\",\"touristAvatar\":\"https://upload.haoxx.site/config/0b04691f25e400a708caba867be171d0.jpg\",\"userAvatar\":\"https://upload.haoxx.site/config/e94fc60e58a570ecc3e9ddcb334fdb2b.jpg\",\"weiXinCode\":\"https://upload.haoxx.site/cloud/images/image_1.jpg\"}]','PUT','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-07 17:14:08');
INSERT INTO `t_exception_log` VALUES (249,'网站配置模块','/admin/site/update','org.springframework.dao.DataIntegrityViolationException','更新网站配置','com.ican.controller.SiteConfigController.updateSiteConfig','org.springframework.dao.DataIntegrityViolationException:\n### Error updating database.  Cause: com.mysql.cj.jdbc.exceptions.MysqlDataTruncation: Data truncation: Data too long for column \'bilibili\' at row 1\n### The error may exist in com/ican/mapper/SiteConfigMapper.java (best guess)\n### The error may involve com.ican.mapper.SiteConfigMapper.updateById-Inline\n### The error occurred while setting parameters\n### SQL: UPDATE t_site_config  SET user_avatar=?, tourist_avatar=?, site_name=?, site_address=?, site_intro=?, site_notice=?, create_site_time=?, record_number=?, author_avatar=?, site_author=?, article_cover=?, about_me=?, github=?, gitee=?, bilibili=?, qq=?, comment_check=?, message_check=?, is_reward=?, wei_xin_code=?, ali_code=?, email_notice=?, social_list=?, login_list=?, is_music=?, music_id=?,  update_time=?  WHERE id=?\n### Cause: com.mysql.cj.jdbc.exceptions.MysqlDataTruncation: Data truncation: Data too long for column \'bilibili\' at row 1\n; Data truncation: Data too long for column \'bilibili\' at row 1; nested exception is com.mysql.cj.jdbc.exceptions.MysqlDataTruncation: Data truncation: Data too long for column \'bilibili\' at row 1\norg.springframework.jdbc.support.SQLStateSQLExceptionTranslator.doTranslate(SQLStateSQLExceptionTranslator.java:104)\norg.springframework.jdbc.support.AbstractFallbackSQLExceptionTranslator.translate(AbstractFallbackSQLExceptionTranslator.java:70)\norg.springframework.jdbc.support.AbstractFallbackSQLExceptionTranslator.translate(AbstractFallbackSQLExceptionTranslator.java:79)\norg.springframework.jdbc.support.AbstractFallbackSQLExceptionTranslator.translate(AbstractFallbackSQLExceptionTranslator.java:79)\norg.mybatis.spring.MyBatisExceptionTranslator.translateExceptionIfPossible(MyBatisExceptionTranslator.java:91)\norg.mybatis.spring.SqlSessionTemplate$SqlSessionInterceptor.invoke(SqlSessionTemplate.java:441)\ncom.sun.proxy.$Proxy124.update(Unknown Source)\norg.mybatis.spring.SqlSessionTemplate.update(SqlSessionTemplate.java:288)\ncom.baomidou.mybatisplus.core.override.MybatisMapperMethod.execute(MybatisMapperMethod.java:64)\ncom.baomidou.mybatisplus.core.override.MybatisMapperProxy$PlainMethodInvoker.invoke(MybatisMapperProxy.java:148)\ncom.baomidou.mybatisplus.core.override.MybatisMapperProxy.invoke(MybatisMapperProxy.java:89)\ncom.sun.proxy.$Proxy150.updateById(Unknown Source)\njava.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\njava.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\njava.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\njava.base/java.lang.reflect.Method.invoke(Method.java:566)\norg.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:344)\norg.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:198)\norg.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163)\norg.springframework.dao.support.PersistenceExceptionTranslationInterceptor.invoke(PersistenceExceptionTranslationInterceptor.java:137)\norg.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)\norg.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:215)\ncom.sun.proxy.$Proxy151.updateById(Unknown Source)\ncom.ican.service.impl.SiteConfigServiceImpl.updateSiteConfig(SiteConfigServiceImpl.java:58)\ncom.ican.service.impl.SiteConfigServiceImpl$$FastClassBySpringCGLIB$$49d1efd1.invoke(<generated>)\norg.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218)\norg.springframework.aop.framework.CglibAopProxy.invokeMethod(CglibAopProxy.java:386)\norg.springframework.aop.framework.CglibAopProxy.access$000(CglibAopProxy.java:85)\norg.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:704)\ncom.ican.service.impl.SiteConfigServiceImpl$$EnhancerBySpringCGLIB$$56ef49f4.updateSiteConfig(<generated>)\ncom.ican.controller.SiteConfigController.updateSiteConfig(SiteConfigController.java:53)\ncom.ican.controller.SiteConfigController$$FastClassBySpringCGLIB$$2c5f3a3d.invoke(<generated>)\norg.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218)\norg.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:793)\norg.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163)\norg.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:763)\norg.springframework.aop.framework.adapter.AfterReturningAdviceInterceptor.invoke(AfterReturningAdviceInterceptor.java:57)\norg.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:175)\norg.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:763)\norg.springframework.aop.framework.adapter.MethodBeforeAdviceInterceptor.invoke(MethodBeforeAdviceInterceptor.java:58)\norg.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:175)\norg.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:763)\norg.springframework.aop.aspectj.AspectJAfterThrowingAdvice.invoke(AspectJAfterThrowingAdvice.java:64)\norg.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)\norg.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:763)\norg.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:97)\norg.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)\norg.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:763)\norg.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:708)\ncom.ican.controller.SiteConfigController$$EnhancerBySpringCGLIB$$b45464e8.updateSiteConfig(<generated>)\njava.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\njava.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\njava.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\njava.base/java.lang.reflect.Method.invoke(Method.java:566)\norg.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:205)\norg.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:150)\norg.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:117)\norg.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:895)\norg.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:808)\norg.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)\norg.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1071)\norg.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:964)\norg.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006)\norg.springframework.web.servlet.FrameworkServlet.doPut(FrameworkServlet.java:920)\njavax.servlet.http.HttpServlet.service(HttpServlet.java:699)\norg.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883)\njavax.servlet.http.HttpServlet.service(HttpServlet.java:779)\norg.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:227)\norg.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\norg.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53)\norg.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)\norg.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\ncn.dev33.satoken.filter.SaServletFilter.doFilter(SaServletFilter.java:179)\norg.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)\norg.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\norg.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)\norg.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117)\norg.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)\norg.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\norg.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)\norg.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117)\norg.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)\norg.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\norg.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)\norg.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117)\norg.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)\norg.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\norg.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:177)\norg.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:97)\norg.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:541)\norg.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:135)\norg.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92)\norg.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:78)\norg.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:360)\norg.apache.coyote.http11.Http11Processor.service(Http11Processor.java:399)\norg.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65)\norg.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:891)\norg.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1784)\norg.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)\norg.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1191)\norg.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659)\norg.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)\njava.base/java.lang.Thread.run(Thread.java:829)\n','[{\"aboutMe\":\"🍀个人简介\\n\\n普通人\",\"aliCode\":\"https://upload.haoxx.site/cloud/images/image_2.jpg\",\"articleCover\":\"https://upload.haoxx.site/config/27c7f38a329c07159a80315712680ea5.jpg\",\"authorAvatar\":\"https://upload.haoxx.site/config/5bbb6dc8be42f3e96dbcc7d7529dc402.gif\",\"bilibili\":\"https://space.bilibili.com/263844591?spm_id_from=333.999.0.0\",\"commentCheck\":0,\"createSiteTime\":\"2023-06-06\",\"emailNotice\":1,\"gitee\":\"https://gitee.com/haoxxown\",\"github\":\"https://github.com/XiaoYuer2022\",\"id\":1,\"isMusic\":0,\"isReward\":0,\"loginList\":\",gitee\",\"messageCheck\":0,\"musicId\":\"7611185981\",\"qq\":\"508506630\",\"recordNumber\":\"渝ICP备2023001651号-2\",\"siteAddress\":\"https://www.haoxx.site\",\"siteAuthor\":\"小鱼\",\"siteIntro\":\"网站介绍\",\"siteName\":\"HaoXX`s Blog\",\"siteNotice\":\"个人学习资料记录\",\"socialList\":\"gitee,bilibili,github,qq\",\"touristAvatar\":\"https://upload.haoxx.site/config/0b04691f25e400a708caba867be171d0.jpg\",\"userAvatar\":\"https://upload.haoxx.site/config/e94fc60e58a570ecc3e9ddcb334fdb2b.jpg\",\"weiXinCode\":\"https://upload.haoxx.site/cloud/images/image_1.jpg\"}]','PUT','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-07 17:14:25');
INSERT INTO `t_exception_log` VALUES (250,'网站配置模块','/admin/site/update','org.springframework.dao.DataIntegrityViolationException','更新网站配置','com.ican.controller.SiteConfigController.updateSiteConfig','org.springframework.dao.DataIntegrityViolationException:\n### Error updating database.  Cause: com.mysql.cj.jdbc.exceptions.MysqlDataTruncation: Data truncation: Data too long for column \'bilibili\' at row 1\n### The error may exist in com/ican/mapper/SiteConfigMapper.java (best guess)\n### The error may involve com.ican.mapper.SiteConfigMapper.updateById-Inline\n### The error occurred while setting parameters\n### SQL: UPDATE t_site_config  SET user_avatar=?, tourist_avatar=?, site_name=?, site_address=?, site_intro=?, site_notice=?, create_site_time=?, record_number=?, author_avatar=?, site_author=?, article_cover=?, about_me=?, github=?, gitee=?, bilibili=?, qq=?, comment_check=?, message_check=?, is_reward=?, wei_xin_code=?, ali_code=?, email_notice=?, social_list=?, login_list=?, is_music=?, music_id=?,  update_time=?  WHERE id=?\n### Cause: com.mysql.cj.jdbc.exceptions.MysqlDataTruncation: Data truncation: Data too long for column \'bilibili\' at row 1\n; Data truncation: Data too long for column \'bilibili\' at row 1; nested exception is com.mysql.cj.jdbc.exceptions.MysqlDataTruncation: Data truncation: Data too long for column \'bilibili\' at row 1\norg.springframework.jdbc.support.SQLStateSQLExceptionTranslator.doTranslate(SQLStateSQLExceptionTranslator.java:104)\norg.springframework.jdbc.support.AbstractFallbackSQLExceptionTranslator.translate(AbstractFallbackSQLExceptionTranslator.java:70)\norg.springframework.jdbc.support.AbstractFallbackSQLExceptionTranslator.translate(AbstractFallbackSQLExceptionTranslator.java:79)\norg.springframework.jdbc.support.AbstractFallbackSQLExceptionTranslator.translate(AbstractFallbackSQLExceptionTranslator.java:79)\norg.mybatis.spring.MyBatisExceptionTranslator.translateExceptionIfPossible(MyBatisExceptionTranslator.java:91)\norg.mybatis.spring.SqlSessionTemplate$SqlSessionInterceptor.invoke(SqlSessionTemplate.java:441)\ncom.sun.proxy.$Proxy124.update(Unknown Source)\norg.mybatis.spring.SqlSessionTemplate.update(SqlSessionTemplate.java:288)\ncom.baomidou.mybatisplus.core.override.MybatisMapperMethod.execute(MybatisMapperMethod.java:64)\ncom.baomidou.mybatisplus.core.override.MybatisMapperProxy$PlainMethodInvoker.invoke(MybatisMapperProxy.java:148)\ncom.baomidou.mybatisplus.core.override.MybatisMapperProxy.invoke(MybatisMapperProxy.java:89)\ncom.sun.proxy.$Proxy150.updateById(Unknown Source)\njava.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\njava.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\njava.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\njava.base/java.lang.reflect.Method.invoke(Method.java:566)\norg.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:344)\norg.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:198)\norg.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163)\norg.springframework.dao.support.PersistenceExceptionTranslationInterceptor.invoke(PersistenceExceptionTranslationInterceptor.java:137)\norg.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)\norg.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:215)\ncom.sun.proxy.$Proxy151.updateById(Unknown Source)\ncom.ican.service.impl.SiteConfigServiceImpl.updateSiteConfig(SiteConfigServiceImpl.java:58)\ncom.ican.service.impl.SiteConfigServiceImpl$$FastClassBySpringCGLIB$$49d1efd1.invoke(<generated>)\norg.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218)\norg.springframework.aop.framework.CglibAopProxy.invokeMethod(CglibAopProxy.java:386)\norg.springframework.aop.framework.CglibAopProxy.access$000(CglibAopProxy.java:85)\norg.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:704)\ncom.ican.service.impl.SiteConfigServiceImpl$$EnhancerBySpringCGLIB$$56ef49f4.updateSiteConfig(<generated>)\ncom.ican.controller.SiteConfigController.updateSiteConfig(SiteConfigController.java:53)\ncom.ican.controller.SiteConfigController$$FastClassBySpringCGLIB$$2c5f3a3d.invoke(<generated>)\norg.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218)\norg.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:793)\norg.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163)\norg.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:763)\norg.springframework.aop.framework.adapter.AfterReturningAdviceInterceptor.invoke(AfterReturningAdviceInterceptor.java:57)\norg.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:175)\norg.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:763)\norg.springframework.aop.framework.adapter.MethodBeforeAdviceInterceptor.invoke(MethodBeforeAdviceInterceptor.java:58)\norg.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:175)\norg.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:763)\norg.springframework.aop.aspectj.AspectJAfterThrowingAdvice.invoke(AspectJAfterThrowingAdvice.java:64)\norg.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)\norg.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:763)\norg.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:97)\norg.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)\norg.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:763)\norg.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:708)\ncom.ican.controller.SiteConfigController$$EnhancerBySpringCGLIB$$b45464e8.updateSiteConfig(<generated>)\njava.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\njava.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\njava.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\njava.base/java.lang.reflect.Method.invoke(Method.java:566)\norg.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:205)\norg.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:150)\norg.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:117)\norg.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:895)\norg.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:808)\norg.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)\norg.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1071)\norg.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:964)\norg.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006)\norg.springframework.web.servlet.FrameworkServlet.doPut(FrameworkServlet.java:920)\njavax.servlet.http.HttpServlet.service(HttpServlet.java:699)\norg.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883)\njavax.servlet.http.HttpServlet.service(HttpServlet.java:779)\norg.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:227)\norg.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\norg.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53)\norg.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)\norg.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\ncn.dev33.satoken.filter.SaServletFilter.doFilter(SaServletFilter.java:179)\norg.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)\norg.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\norg.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)\norg.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117)\norg.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)\norg.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\norg.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)\norg.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117)\norg.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)\norg.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\norg.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)\norg.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117)\norg.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)\norg.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\norg.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:177)\norg.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:97)\norg.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:541)\norg.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:135)\norg.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92)\norg.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:78)\norg.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:360)\norg.apache.coyote.http11.Http11Processor.service(Http11Processor.java:399)\norg.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65)\norg.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:891)\norg.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1784)\norg.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)\norg.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1191)\norg.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659)\norg.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)\njava.base/java.lang.Thread.run(Thread.java:829)\n','[{\"aboutMe\":\"🍀个人简介\\n\\n普通人\",\"aliCode\":\"https://upload.haoxx.site/cloud/images/image_2.jpg\",\"articleCover\":\"https://upload.haoxx.site/config/27c7f38a329c07159a80315712680ea5.jpg\",\"authorAvatar\":\"https://upload.haoxx.site/config/5bbb6dc8be42f3e96dbcc7d7529dc402.gif\",\"bilibili\":\"https://space.bilibili.com/263844591?spm_id_from=333.999.0.0\",\"commentCheck\":0,\"createSiteTime\":\"2023-06-06\",\"emailNotice\":1,\"gitee\":\"https://gitee.com/haoxxown\",\"github\":\"https://github.com/XiaoYuer2022\",\"id\":1,\"isMusic\":1,\"isReward\":0,\"loginList\":\",gitee\",\"messageCheck\":0,\"musicId\":\"7611185981\",\"qq\":\"508506630\",\"recordNumber\":\"渝ICP备2023001651号-2\",\"siteAddress\":\"https://www.haoxx.site\",\"siteAuthor\":\"小鱼\",\"siteIntro\":\"网站介绍\",\"siteName\":\"HaoXX`s Blog\",\"siteNotice\":\"个人学习资料记录\",\"socialList\":\"gitee,bilibili,github,qq\",\"touristAvatar\":\"https://upload.haoxx.site/config/0b04691f25e400a708caba867be171d0.jpg\",\"userAvatar\":\"https://upload.haoxx.site/config/e94fc60e58a570ecc3e9ddcb334fdb2b.jpg\",\"weiXinCode\":\"https://upload.haoxx.site/cloud/images/image_1.jpg\"}]','PUT','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-07 17:14:31');
INSERT INTO `t_exception_log` VALUES (251,'文件模块','/admin/file/upload','java.lang.IllegalArgumentException','上传文件','com.ican.controller.BlogFileController.uploadFile','java.lang.IllegalArgumentException:文件已存在\ncn.hutool.core.lang.Assert.lambda$isNull$2(Assert.java:158)\ncn.hutool.core.lang.Assert.isNull(Assert.java:141)\ncn.hutool.core.lang.Assert.isNull(Assert.java:158)\ncom.ican.service.impl.BlogFileServiceImpl.uploadFile(BlogFileServiceImpl.java:91)\ncom.ican.service.impl.BlogFileServiceImpl$$FastClassBySpringCGLIB$$8334ab1c.invoke(<generated>)\norg.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218)\norg.springframework.aop.framework.CglibAopProxy.invokeMethod(CglibAopProxy.java:386)\norg.springframework.aop.framework.CglibAopProxy.access$000(CglibAopProxy.java:85)\norg.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:704)\ncom.ican.service.impl.BlogFileServiceImpl$$EnhancerBySpringCGLIB$$4bb562b5.uploadFile(<generated>)\ncom.ican.controller.BlogFileController.uploadFile(BlogFileController.java:61)\ncom.ican.controller.BlogFileController$$FastClassBySpringCGLIB$$8df024d2.invoke(<generated>)\norg.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218)\norg.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:793)\norg.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163)\norg.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:763)\norg.springframework.aop.framework.adapter.AfterReturningAdviceInterceptor.invoke(AfterReturningAdviceInterceptor.java:57)\norg.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:175)\norg.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:763)\norg.springframework.aop.framework.adapter.MethodBeforeAdviceInterceptor.invoke(MethodBeforeAdviceInterceptor.java:58)\norg.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:175)\norg.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:763)\norg.springframework.aop.aspectj.AspectJAfterThrowingAdvice.invoke(AspectJAfterThrowingAdvice.java:64)\norg.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)\norg.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:763)\norg.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:97)\norg.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)\norg.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:763)\norg.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:708)\ncom.ican.controller.BlogFileController$$EnhancerBySpringCGLIB$$e76fe9c7.uploadFile(<generated>)\njava.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\njava.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\njava.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\njava.base/java.lang.reflect.Method.invoke(Method.java:566)\norg.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:205)\norg.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:150)\norg.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:117)\norg.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:895)\norg.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:808)\norg.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)\norg.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1071)\norg.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:964)\norg.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006)\norg.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:909)\njavax.servlet.http.HttpServlet.service(HttpServlet.java:696)\norg.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883)\njavax.servlet.http.HttpServlet.service(HttpServlet.java:779)\norg.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:227)\norg.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\norg.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53)\norg.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)\norg.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\ncn.dev33.satoken.filter.SaServletFilter.doFilter(SaServletFilter.java:179)\norg.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)\norg.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\norg.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)\norg.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117)\norg.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)\norg.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\norg.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)\norg.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117)\norg.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)\norg.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\norg.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)\norg.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117)\norg.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)\norg.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\norg.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:177)\norg.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:97)\norg.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:541)\norg.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:135)\norg.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92)\norg.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:78)\norg.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:360)\norg.apache.coyote.http11.Http11Processor.service(Http11Processor.java:399)\norg.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65)\norg.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:891)\norg.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1784)\norg.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)\norg.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1191)\norg.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659)\norg.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)\njava.base/java.lang.Thread.run(Thread.java:829)\n','c0bdec69bc1cc87001a1903296feba86.png','POST','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-07 19:38:04');
INSERT INTO `t_exception_log` VALUES (252,'网站配置模块','/admin/site/update','org.springframework.dao.DataIntegrityViolationException','更新网站配置','com.ican.controller.SiteConfigController.updateSiteConfig','org.springframework.dao.DataIntegrityViolationException:\n### Error updating database.  Cause: com.mysql.cj.jdbc.exceptions.MysqlDataTruncation: Data truncation: Data too long for column \'bilibili\' at row 1\n### The error may exist in com/ican/mapper/SiteConfigMapper.java (best guess)\n### The error may involve com.ican.mapper.SiteConfigMapper.updateById-Inline\n### The error occurred while setting parameters\n### SQL: UPDATE t_site_config  SET user_avatar=?, tourist_avatar=?, site_name=?, site_address=?, site_intro=?, site_notice=?, create_site_time=?, record_number=?, author_avatar=?, site_author=?, article_cover=?, about_me=?, github=?, gitee=?, bilibili=?, qq=?, comment_check=?, message_check=?, is_reward=?, wei_xin_code=?, ali_code=?, email_notice=?, social_list=?, login_list=?, is_music=?, music_id=?,  update_time=?  WHERE id=?\n### Cause: com.mysql.cj.jdbc.exceptions.MysqlDataTruncation: Data truncation: Data too long for column \'bilibili\' at row 1\n; Data truncation: Data too long for column \'bilibili\' at row 1; nested exception is com.mysql.cj.jdbc.exceptions.MysqlDataTruncation: Data truncation: Data too long for column \'bilibili\' at row 1\norg.springframework.jdbc.support.SQLStateSQLExceptionTranslator.doTranslate(SQLStateSQLExceptionTranslator.java:104)\norg.springframework.jdbc.support.AbstractFallbackSQLExceptionTranslator.translate(AbstractFallbackSQLExceptionTranslator.java:70)\norg.springframework.jdbc.support.AbstractFallbackSQLExceptionTranslator.translate(AbstractFallbackSQLExceptionTranslator.java:79)\norg.springframework.jdbc.support.AbstractFallbackSQLExceptionTranslator.translate(AbstractFallbackSQLExceptionTranslator.java:79)\norg.mybatis.spring.MyBatisExceptionTranslator.translateExceptionIfPossible(MyBatisExceptionTranslator.java:91)\norg.mybatis.spring.SqlSessionTemplate$SqlSessionInterceptor.invoke(SqlSessionTemplate.java:441)\ncom.sun.proxy.$Proxy124.update(Unknown Source)\norg.mybatis.spring.SqlSessionTemplate.update(SqlSessionTemplate.java:288)\ncom.baomidou.mybatisplus.core.override.MybatisMapperMethod.execute(MybatisMapperMethod.java:64)\ncom.baomidou.mybatisplus.core.override.MybatisMapperProxy$PlainMethodInvoker.invoke(MybatisMapperProxy.java:148)\ncom.baomidou.mybatisplus.core.override.MybatisMapperProxy.invoke(MybatisMapperProxy.java:89)\ncom.sun.proxy.$Proxy150.updateById(Unknown Source)\njava.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\njava.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\njava.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\njava.base/java.lang.reflect.Method.invoke(Method.java:566)\norg.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:344)\norg.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:198)\norg.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163)\norg.springframework.dao.support.PersistenceExceptionTranslationInterceptor.invoke(PersistenceExceptionTranslationInterceptor.java:137)\norg.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)\norg.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:215)\ncom.sun.proxy.$Proxy151.updateById(Unknown Source)\ncom.ican.service.impl.SiteConfigServiceImpl.updateSiteConfig(SiteConfigServiceImpl.java:58)\ncom.ican.service.impl.SiteConfigServiceImpl$$FastClassBySpringCGLIB$$49d1efd1.invoke(<generated>)\norg.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218)\norg.springframework.aop.framework.CglibAopProxy.invokeMethod(CglibAopProxy.java:386)\norg.springframework.aop.framework.CglibAopProxy.access$000(CglibAopProxy.java:85)\norg.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:704)\ncom.ican.service.impl.SiteConfigServiceImpl$$EnhancerBySpringCGLIB$$904f3eec.updateSiteConfig(<generated>)\ncom.ican.controller.SiteConfigController.updateSiteConfig(SiteConfigController.java:53)\ncom.ican.controller.SiteConfigController$$FastClassBySpringCGLIB$$2c5f3a3d.invoke(<generated>)\norg.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218)\norg.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:793)\norg.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163)\norg.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:763)\norg.springframework.aop.framework.adapter.AfterReturningAdviceInterceptor.invoke(AfterReturningAdviceInterceptor.java:57)\norg.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:175)\norg.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:763)\norg.springframework.aop.framework.adapter.MethodBeforeAdviceInterceptor.invoke(MethodBeforeAdviceInterceptor.java:58)\norg.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:175)\norg.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:763)\norg.springframework.aop.aspectj.AspectJAfterThrowingAdvice.invoke(AspectJAfterThrowingAdvice.java:64)\norg.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)\norg.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:763)\norg.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:97)\norg.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)\norg.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:763)\norg.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:708)\ncom.ican.controller.SiteConfigController$$EnhancerBySpringCGLIB$$133734b8.updateSiteConfig(<generated>)\njava.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\njava.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\njava.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\njava.base/java.lang.reflect.Method.invoke(Method.java:566)\norg.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:205)\norg.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:150)\norg.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:117)\norg.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:895)\norg.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:808)\norg.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)\norg.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1071)\norg.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:964)\norg.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006)\norg.springframework.web.servlet.FrameworkServlet.doPut(FrameworkServlet.java:920)\njavax.servlet.http.HttpServlet.service(HttpServlet.java:699)\norg.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883)\njavax.servlet.http.HttpServlet.service(HttpServlet.java:779)\norg.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:227)\norg.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\norg.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53)\norg.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)\norg.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\ncn.dev33.satoken.filter.SaServletFilter.doFilter(SaServletFilter.java:179)\norg.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)\norg.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\norg.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)\norg.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117)\norg.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)\norg.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\norg.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)\norg.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117)\norg.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)\norg.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\norg.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)\norg.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117)\norg.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)\norg.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\norg.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:177)\norg.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:97)\norg.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:541)\norg.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:135)\norg.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92)\norg.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:78)\norg.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:360)\norg.apache.coyote.http11.Http11Processor.service(Http11Processor.java:399)\norg.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65)\norg.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:891)\norg.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1784)\norg.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)\norg.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1191)\norg.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659)\norg.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)\njava.base/java.lang.Thread.run(Thread.java:829)\n','[{\"aboutMe\":\"🍀个人简介\\n\\n普通人\",\"aliCode\":\"https://upload.haoxx.site/cloud/images/image_2.jpg\",\"articleCover\":\"https://upload.haoxx.site/config/27c7f38a329c07159a80315712680ea5.jpg\",\"authorAvatar\":\"https://upload.haoxx.site/config/5bbb6dc8be42f3e96dbcc7d7529dc402.gif\",\"bilibili\":\"https://space.bilibili.com/263844591?spm_id_from=333.1007.0.0\",\"commentCheck\":0,\"createSiteTime\":\"2023-06-06\",\"emailNotice\":1,\"gitee\":\"https://gitee.com/wu_shengdong\",\"github\":\"https://github.com/XiaoYuer2022\",\"id\":1,\"isMusic\":1,\"isReward\":0,\"loginList\":\",gitee,qq\",\"messageCheck\":0,\"musicId\":\"7611185981\",\"qq\":\"508506630\",\"recordNumber\":\"渝ICP备2023001651号-2\",\"siteAddress\":\"https://www.haoxx.site\",\"siteAuthor\":\"小鱼\",\"siteIntro\":\"网站介绍\",\"siteName\":\"HaoXX`s Blog\",\"siteNotice\":\"个人学习资料记录\",\"socialList\":\"gitee,bilibili,github,qq\",\"touristAvatar\":\"https://upload.haoxx.site/config/0b04691f25e400a708caba867be171d0.jpg\",\"userAvatar\":\"https://upload.haoxx.site/config/e94fc60e58a570ecc3e9ddcb334fdb2b.jpg\",\"weiXinCode\":\"https://upload.haoxx.site/cloud/images/image_1.jpg\"}]','PUT','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-08 16:18:59');
INSERT INTO `t_exception_log` VALUES (253,'网站配置模块','/admin/site/update','org.springframework.dao.DataIntegrityViolationException','更新网站配置','com.ican.controller.SiteConfigController.updateSiteConfig','org.springframework.dao.DataIntegrityViolationException:\n### Error updating database.  Cause: com.mysql.cj.jdbc.exceptions.MysqlDataTruncation: Data truncation: Data too long for column \'bilibili\' at row 1\n### The error may exist in com/ican/mapper/SiteConfigMapper.java (best guess)\n### The error may involve com.ican.mapper.SiteConfigMapper.updateById-Inline\n### The error occurred while setting parameters\n### SQL: UPDATE t_site_config  SET user_avatar=?, tourist_avatar=?, site_name=?, site_address=?, site_intro=?, site_notice=?, create_site_time=?, record_number=?, author_avatar=?, site_author=?, article_cover=?, about_me=?, github=?, gitee=?, bilibili=?, qq=?, comment_check=?, message_check=?, is_reward=?, wei_xin_code=?, ali_code=?, email_notice=?, social_list=?, login_list=?, is_music=?, music_id=?,  update_time=?  WHERE id=?\n### Cause: com.mysql.cj.jdbc.exceptions.MysqlDataTruncation: Data truncation: Data too long for column \'bilibili\' at row 1\n; Data truncation: Data too long for column \'bilibili\' at row 1; nested exception is com.mysql.cj.jdbc.exceptions.MysqlDataTruncation: Data truncation: Data too long for column \'bilibili\' at row 1\norg.springframework.jdbc.support.SQLStateSQLExceptionTranslator.doTranslate(SQLStateSQLExceptionTranslator.java:104)\norg.springframework.jdbc.support.AbstractFallbackSQLExceptionTranslator.translate(AbstractFallbackSQLExceptionTranslator.java:70)\norg.springframework.jdbc.support.AbstractFallbackSQLExceptionTranslator.translate(AbstractFallbackSQLExceptionTranslator.java:79)\norg.springframework.jdbc.support.AbstractFallbackSQLExceptionTranslator.translate(AbstractFallbackSQLExceptionTranslator.java:79)\norg.mybatis.spring.MyBatisExceptionTranslator.translateExceptionIfPossible(MyBatisExceptionTranslator.java:91)\norg.mybatis.spring.SqlSessionTemplate$SqlSessionInterceptor.invoke(SqlSessionTemplate.java:441)\ncom.sun.proxy.$Proxy124.update(Unknown Source)\norg.mybatis.spring.SqlSessionTemplate.update(SqlSessionTemplate.java:288)\ncom.baomidou.mybatisplus.core.override.MybatisMapperMethod.execute(MybatisMapperMethod.java:64)\ncom.baomidou.mybatisplus.core.override.MybatisMapperProxy$PlainMethodInvoker.invoke(MybatisMapperProxy.java:148)\ncom.baomidou.mybatisplus.core.override.MybatisMapperProxy.invoke(MybatisMapperProxy.java:89)\ncom.sun.proxy.$Proxy150.updateById(Unknown Source)\njava.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\njava.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\njava.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\njava.base/java.lang.reflect.Method.invoke(Method.java:566)\norg.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:344)\norg.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:198)\norg.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163)\norg.springframework.dao.support.PersistenceExceptionTranslationInterceptor.invoke(PersistenceExceptionTranslationInterceptor.java:137)\norg.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)\norg.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:215)\ncom.sun.proxy.$Proxy151.updateById(Unknown Source)\ncom.ican.service.impl.SiteConfigServiceImpl.updateSiteConfig(SiteConfigServiceImpl.java:58)\ncom.ican.service.impl.SiteConfigServiceImpl$$FastClassBySpringCGLIB$$49d1efd1.invoke(<generated>)\norg.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218)\norg.springframework.aop.framework.CglibAopProxy.invokeMethod(CglibAopProxy.java:386)\norg.springframework.aop.framework.CglibAopProxy.access$000(CglibAopProxy.java:85)\norg.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:704)\ncom.ican.service.impl.SiteConfigServiceImpl$$EnhancerBySpringCGLIB$$904f3eec.updateSiteConfig(<generated>)\ncom.ican.controller.SiteConfigController.updateSiteConfig(SiteConfigController.java:53)\ncom.ican.controller.SiteConfigController$$FastClassBySpringCGLIB$$2c5f3a3d.invoke(<generated>)\norg.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218)\norg.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:793)\norg.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163)\norg.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:763)\norg.springframework.aop.framework.adapter.AfterReturningAdviceInterceptor.invoke(AfterReturningAdviceInterceptor.java:57)\norg.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:175)\norg.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:763)\norg.springframework.aop.framework.adapter.MethodBeforeAdviceInterceptor.invoke(MethodBeforeAdviceInterceptor.java:58)\norg.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:175)\norg.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:763)\norg.springframework.aop.aspectj.AspectJAfterThrowingAdvice.invoke(AspectJAfterThrowingAdvice.java:64)\norg.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)\norg.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:763)\norg.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:97)\norg.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)\norg.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:763)\norg.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:708)\ncom.ican.controller.SiteConfigController$$EnhancerBySpringCGLIB$$133734b8.updateSiteConfig(<generated>)\njava.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\njava.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\njava.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\njava.base/java.lang.reflect.Method.invoke(Method.java:566)\norg.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:205)\norg.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:150)\norg.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:117)\norg.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:895)\norg.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:808)\norg.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)\norg.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1071)\norg.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:964)\norg.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006)\norg.springframework.web.servlet.FrameworkServlet.doPut(FrameworkServlet.java:920)\njavax.servlet.http.HttpServlet.service(HttpServlet.java:699)\norg.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883)\njavax.servlet.http.HttpServlet.service(HttpServlet.java:779)\norg.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:227)\norg.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\norg.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53)\norg.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)\norg.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\ncn.dev33.satoken.filter.SaServletFilter.doFilter(SaServletFilter.java:179)\norg.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)\norg.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\norg.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)\norg.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117)\norg.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)\norg.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\norg.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)\norg.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117)\norg.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)\norg.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\norg.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)\norg.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117)\norg.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)\norg.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\norg.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:177)\norg.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:97)\norg.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:541)\norg.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:135)\norg.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92)\norg.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:78)\norg.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:360)\norg.apache.coyote.http11.Http11Processor.service(Http11Processor.java:399)\norg.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65)\norg.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:891)\norg.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1784)\norg.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)\norg.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1191)\norg.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659)\norg.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)\njava.base/java.lang.Thread.run(Thread.java:829)\n','[{\"aboutMe\":\"🍀个人简介\\n\\n普通人\",\"aliCode\":\"https://upload.haoxx.site/cloud/images/image_2.jpg\",\"articleCover\":\"https://upload.haoxx.site/config/27c7f38a329c07159a80315712680ea5.jpg\",\"authorAvatar\":\"https://upload.haoxx.site/config/5bbb6dc8be42f3e96dbcc7d7529dc402.gif\",\"bilibili\":\"https://space.bilibili.com/263844591?spm_id_from=333.1007.0.0\",\"commentCheck\":0,\"createSiteTime\":\"2023-06-06\",\"emailNotice\":1,\"gitee\":\"https://gitee.com/wu_shengdong\",\"github\":\"https://github.com/XiaoYuer2022\",\"id\":1,\"isMusic\":1,\"isReward\":0,\"loginList\":\",gitee,qq\",\"messageCheck\":0,\"musicId\":\"7611185981\",\"qq\":\"508506630\",\"recordNumber\":\"渝ICP备2023001651号-2\",\"siteAddress\":\"https://www.haoxx.site\",\"siteAuthor\":\"小鱼\",\"siteIntro\":\"网站介绍\",\"siteName\":\"HaoXX`s Blog\",\"siteNotice\":\"个人学习资料记录\",\"socialList\":\"gitee,bilibili,github,qq\",\"touristAvatar\":\"https://upload.haoxx.site/config/0b04691f25e400a708caba867be171d0.jpg\",\"userAvatar\":\"https://upload.haoxx.site/config/e94fc60e58a570ecc3e9ddcb334fdb2b.jpg\",\"weiXinCode\":\"https://upload.haoxx.site/cloud/images/image_1.jpg\"}]','PUT','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-08 16:19:00');
INSERT INTO `t_exception_log` VALUES (254,'网站配置模块','/admin/site/update','org.springframework.dao.DataIntegrityViolationException','更新网站配置','com.ican.controller.SiteConfigController.updateSiteConfig','org.springframework.dao.DataIntegrityViolationException:\n### Error updating database.  Cause: com.mysql.cj.jdbc.exceptions.MysqlDataTruncation: Data truncation: Data too long for column \'bilibili\' at row 1\n### The error may exist in com/ican/mapper/SiteConfigMapper.java (best guess)\n### The error may involve com.ican.mapper.SiteConfigMapper.updateById-Inline\n### The error occurred while setting parameters\n### SQL: UPDATE t_site_config  SET user_avatar=?, tourist_avatar=?, site_name=?, site_address=?, site_intro=?, site_notice=?, create_site_time=?, record_number=?, author_avatar=?, site_author=?, article_cover=?, about_me=?, github=?, gitee=?, bilibili=?, qq=?, comment_check=?, message_check=?, is_reward=?, wei_xin_code=?, ali_code=?, email_notice=?, social_list=?, login_list=?, is_music=?, music_id=?,  update_time=?  WHERE id=?\n### Cause: com.mysql.cj.jdbc.exceptions.MysqlDataTruncation: Data truncation: Data too long for column \'bilibili\' at row 1\n; Data truncation: Data too long for column \'bilibili\' at row 1; nested exception is com.mysql.cj.jdbc.exceptions.MysqlDataTruncation: Data truncation: Data too long for column \'bilibili\' at row 1\norg.springframework.jdbc.support.SQLStateSQLExceptionTranslator.doTranslate(SQLStateSQLExceptionTranslator.java:104)\norg.springframework.jdbc.support.AbstractFallbackSQLExceptionTranslator.translate(AbstractFallbackSQLExceptionTranslator.java:70)\norg.springframework.jdbc.support.AbstractFallbackSQLExceptionTranslator.translate(AbstractFallbackSQLExceptionTranslator.java:79)\norg.springframework.jdbc.support.AbstractFallbackSQLExceptionTranslator.translate(AbstractFallbackSQLExceptionTranslator.java:79)\norg.mybatis.spring.MyBatisExceptionTranslator.translateExceptionIfPossible(MyBatisExceptionTranslator.java:91)\norg.mybatis.spring.SqlSessionTemplate$SqlSessionInterceptor.invoke(SqlSessionTemplate.java:441)\ncom.sun.proxy.$Proxy124.update(Unknown Source)\norg.mybatis.spring.SqlSessionTemplate.update(SqlSessionTemplate.java:288)\ncom.baomidou.mybatisplus.core.override.MybatisMapperMethod.execute(MybatisMapperMethod.java:64)\ncom.baomidou.mybatisplus.core.override.MybatisMapperProxy$PlainMethodInvoker.invoke(MybatisMapperProxy.java:148)\ncom.baomidou.mybatisplus.core.override.MybatisMapperProxy.invoke(MybatisMapperProxy.java:89)\ncom.sun.proxy.$Proxy150.updateById(Unknown Source)\njava.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\njava.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\njava.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\njava.base/java.lang.reflect.Method.invoke(Method.java:566)\norg.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:344)\norg.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:198)\norg.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163)\norg.springframework.dao.support.PersistenceExceptionTranslationInterceptor.invoke(PersistenceExceptionTranslationInterceptor.java:137)\norg.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)\norg.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:215)\ncom.sun.proxy.$Proxy151.updateById(Unknown Source)\ncom.ican.service.impl.SiteConfigServiceImpl.updateSiteConfig(SiteConfigServiceImpl.java:58)\ncom.ican.service.impl.SiteConfigServiceImpl$$FastClassBySpringCGLIB$$49d1efd1.invoke(<generated>)\norg.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218)\norg.springframework.aop.framework.CglibAopProxy.invokeMethod(CglibAopProxy.java:386)\norg.springframework.aop.framework.CglibAopProxy.access$000(CglibAopProxy.java:85)\norg.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:704)\ncom.ican.service.impl.SiteConfigServiceImpl$$EnhancerBySpringCGLIB$$904f3eec.updateSiteConfig(<generated>)\ncom.ican.controller.SiteConfigController.updateSiteConfig(SiteConfigController.java:53)\ncom.ican.controller.SiteConfigController$$FastClassBySpringCGLIB$$2c5f3a3d.invoke(<generated>)\norg.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218)\norg.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:793)\norg.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163)\norg.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:763)\norg.springframework.aop.framework.adapter.AfterReturningAdviceInterceptor.invoke(AfterReturningAdviceInterceptor.java:57)\norg.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:175)\norg.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:763)\norg.springframework.aop.framework.adapter.MethodBeforeAdviceInterceptor.invoke(MethodBeforeAdviceInterceptor.java:58)\norg.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:175)\norg.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:763)\norg.springframework.aop.aspectj.AspectJAfterThrowingAdvice.invoke(AspectJAfterThrowingAdvice.java:64)\norg.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)\norg.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:763)\norg.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:97)\norg.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)\norg.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:763)\norg.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:708)\ncom.ican.controller.SiteConfigController$$EnhancerBySpringCGLIB$$133734b8.updateSiteConfig(<generated>)\njava.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\njava.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\njava.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\njava.base/java.lang.reflect.Method.invoke(Method.java:566)\norg.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:205)\norg.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:150)\norg.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:117)\norg.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:895)\norg.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:808)\norg.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)\norg.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1071)\norg.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:964)\norg.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006)\norg.springframework.web.servlet.FrameworkServlet.doPut(FrameworkServlet.java:920)\njavax.servlet.http.HttpServlet.service(HttpServlet.java:699)\norg.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883)\njavax.servlet.http.HttpServlet.service(HttpServlet.java:779)\norg.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:227)\norg.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\norg.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53)\norg.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)\norg.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\ncn.dev33.satoken.filter.SaServletFilter.doFilter(SaServletFilter.java:179)\norg.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)\norg.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\norg.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)\norg.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117)\norg.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)\norg.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\norg.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)\norg.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117)\norg.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)\norg.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\norg.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)\norg.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117)\norg.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)\norg.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\norg.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:177)\norg.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:97)\norg.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:541)\norg.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:135)\norg.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92)\norg.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:78)\norg.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:360)\norg.apache.coyote.http11.Http11Processor.service(Http11Processor.java:399)\norg.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65)\norg.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:891)\norg.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1784)\norg.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)\norg.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1191)\norg.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659)\norg.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)\njava.base/java.lang.Thread.run(Thread.java:829)\n','[{\"aboutMe\":\"🍀个人简介\\n\\n普通人\",\"aliCode\":\"https://upload.haoxx.site/cloud/images/image_2.jpg\",\"articleCover\":\"https://upload.haoxx.site/config/27c7f38a329c07159a80315712680ea5.jpg\",\"authorAvatar\":\"https://upload.haoxx.site/config/5bbb6dc8be42f3e96dbcc7d7529dc402.gif\",\"bilibili\":\"https://space.bilibili.com/263844591?spm_id_from=333.1007.0.0\",\"commentCheck\":0,\"createSiteTime\":\"2023-06-06\",\"emailNotice\":1,\"gitee\":\"https://gitee.com/wu_shengdong\",\"github\":\"https://github.com/XiaoYuer2022\",\"id\":1,\"isMusic\":1,\"isReward\":0,\"loginList\":\",gitee,qq\",\"messageCheck\":0,\"musicId\":\"7611185981\",\"qq\":\"508506630\",\"recordNumber\":\"渝ICP备2023001651号-2\",\"siteAddress\":\"https://www.haoxx.site\",\"siteAuthor\":\"小鱼\",\"siteIntro\":\"网站介绍\",\"siteName\":\"HaoXX`s Blog\",\"siteNotice\":\"个人学习资料记录\",\"socialList\":\"gitee,bilibili,github,qq\",\"touristAvatar\":\"https://upload.haoxx.site/config/0b04691f25e400a708caba867be171d0.jpg\",\"userAvatar\":\"https://upload.haoxx.site/config/e94fc60e58a570ecc3e9ddcb334fdb2b.jpg\",\"weiXinCode\":\"https://upload.haoxx.site/cloud/images/image_1.jpg\"}]','PUT','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-08 16:19:02');
INSERT INTO `t_exception_log` VALUES (255,'网站配置模块','/admin/site/update','org.springframework.dao.DataIntegrityViolationException','更新网站配置','com.ican.controller.SiteConfigController.updateSiteConfig','org.springframework.dao.DataIntegrityViolationException:\n### Error updating database.  Cause: com.mysql.cj.jdbc.exceptions.MysqlDataTruncation: Data truncation: Data too long for column \'bilibili\' at row 1\n### The error may exist in com/ican/mapper/SiteConfigMapper.java (best guess)\n### The error may involve com.ican.mapper.SiteConfigMapper.updateById-Inline\n### The error occurred while setting parameters\n### SQL: UPDATE t_site_config  SET user_avatar=?, tourist_avatar=?, site_name=?, site_address=?, site_intro=?, site_notice=?, create_site_time=?, record_number=?, author_avatar=?, site_author=?, article_cover=?, about_me=?, github=?, gitee=?, bilibili=?, qq=?, comment_check=?, message_check=?, is_reward=?, wei_xin_code=?, ali_code=?, email_notice=?, social_list=?, login_list=?, is_music=?, music_id=?,  update_time=?  WHERE id=?\n### Cause: com.mysql.cj.jdbc.exceptions.MysqlDataTruncation: Data truncation: Data too long for column \'bilibili\' at row 1\n; Data truncation: Data too long for column \'bilibili\' at row 1; nested exception is com.mysql.cj.jdbc.exceptions.MysqlDataTruncation: Data truncation: Data too long for column \'bilibili\' at row 1\norg.springframework.jdbc.support.SQLStateSQLExceptionTranslator.doTranslate(SQLStateSQLExceptionTranslator.java:104)\norg.springframework.jdbc.support.AbstractFallbackSQLExceptionTranslator.translate(AbstractFallbackSQLExceptionTranslator.java:70)\norg.springframework.jdbc.support.AbstractFallbackSQLExceptionTranslator.translate(AbstractFallbackSQLExceptionTranslator.java:79)\norg.springframework.jdbc.support.AbstractFallbackSQLExceptionTranslator.translate(AbstractFallbackSQLExceptionTranslator.java:79)\norg.mybatis.spring.MyBatisExceptionTranslator.translateExceptionIfPossible(MyBatisExceptionTranslator.java:91)\norg.mybatis.spring.SqlSessionTemplate$SqlSessionInterceptor.invoke(SqlSessionTemplate.java:441)\ncom.sun.proxy.$Proxy124.update(Unknown Source)\norg.mybatis.spring.SqlSessionTemplate.update(SqlSessionTemplate.java:288)\ncom.baomidou.mybatisplus.core.override.MybatisMapperMethod.execute(MybatisMapperMethod.java:64)\ncom.baomidou.mybatisplus.core.override.MybatisMapperProxy$PlainMethodInvoker.invoke(MybatisMapperProxy.java:148)\ncom.baomidou.mybatisplus.core.override.MybatisMapperProxy.invoke(MybatisMapperProxy.java:89)\ncom.sun.proxy.$Proxy150.updateById(Unknown Source)\njava.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\njava.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\njava.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\njava.base/java.lang.reflect.Method.invoke(Method.java:566)\norg.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:344)\norg.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:198)\norg.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163)\norg.springframework.dao.support.PersistenceExceptionTranslationInterceptor.invoke(PersistenceExceptionTranslationInterceptor.java:137)\norg.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)\norg.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:215)\ncom.sun.proxy.$Proxy151.updateById(Unknown Source)\ncom.ican.service.impl.SiteConfigServiceImpl.updateSiteConfig(SiteConfigServiceImpl.java:58)\ncom.ican.service.impl.SiteConfigServiceImpl$$FastClassBySpringCGLIB$$49d1efd1.invoke(<generated>)\norg.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218)\norg.springframework.aop.framework.CglibAopProxy.invokeMethod(CglibAopProxy.java:386)\norg.springframework.aop.framework.CglibAopProxy.access$000(CglibAopProxy.java:85)\norg.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:704)\ncom.ican.service.impl.SiteConfigServiceImpl$$EnhancerBySpringCGLIB$$904f3eec.updateSiteConfig(<generated>)\ncom.ican.controller.SiteConfigController.updateSiteConfig(SiteConfigController.java:53)\ncom.ican.controller.SiteConfigController$$FastClassBySpringCGLIB$$2c5f3a3d.invoke(<generated>)\norg.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218)\norg.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:793)\norg.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163)\norg.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:763)\norg.springframework.aop.framework.adapter.AfterReturningAdviceInterceptor.invoke(AfterReturningAdviceInterceptor.java:57)\norg.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:175)\norg.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:763)\norg.springframework.aop.framework.adapter.MethodBeforeAdviceInterceptor.invoke(MethodBeforeAdviceInterceptor.java:58)\norg.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:175)\norg.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:763)\norg.springframework.aop.aspectj.AspectJAfterThrowingAdvice.invoke(AspectJAfterThrowingAdvice.java:64)\norg.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)\norg.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:763)\norg.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:97)\norg.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)\norg.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:763)\norg.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:708)\ncom.ican.controller.SiteConfigController$$EnhancerBySpringCGLIB$$133734b8.updateSiteConfig(<generated>)\njava.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\njava.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\njava.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\njava.base/java.lang.reflect.Method.invoke(Method.java:566)\norg.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:205)\norg.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:150)\norg.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:117)\norg.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:895)\norg.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:808)\norg.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)\norg.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1071)\norg.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:964)\norg.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006)\norg.springframework.web.servlet.FrameworkServlet.doPut(FrameworkServlet.java:920)\njavax.servlet.http.HttpServlet.service(HttpServlet.java:699)\norg.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883)\njavax.servlet.http.HttpServlet.service(HttpServlet.java:779)\norg.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:227)\norg.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\norg.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53)\norg.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)\norg.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\ncn.dev33.satoken.filter.SaServletFilter.doFilter(SaServletFilter.java:179)\norg.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)\norg.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\norg.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)\norg.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117)\norg.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)\norg.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\norg.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)\norg.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117)\norg.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)\norg.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\norg.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)\norg.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117)\norg.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)\norg.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\norg.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:177)\norg.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:97)\norg.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:541)\norg.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:135)\norg.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92)\norg.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:78)\norg.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:360)\norg.apache.coyote.http11.Http11Processor.service(Http11Processor.java:399)\norg.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65)\norg.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:891)\norg.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1784)\norg.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)\norg.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1191)\norg.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659)\norg.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)\njava.base/java.lang.Thread.run(Thread.java:829)\n','[{\"aboutMe\":\"🍀个人简介\\n\\n普通人\",\"aliCode\":\"https://upload.haoxx.site/cloud/images/image_2.jpg\",\"articleCover\":\"https://upload.haoxx.site/config/27c7f38a329c07159a80315712680ea5.jpg\",\"authorAvatar\":\"https://upload.haoxx.site/config/5bbb6dc8be42f3e96dbcc7d7529dc402.gif\",\"bilibili\":\"https://space.bilibili.com/263844591?spm_id_from=333.1007.0.0\",\"commentCheck\":0,\"createSiteTime\":\"2023-06-06\",\"emailNotice\":1,\"gitee\":\"https://gitee.com/wu_shengdong\",\"github\":\"https://github.com/XiaoYuer2022\",\"id\":1,\"isMusic\":1,\"isReward\":0,\"loginList\":\",gitee,qq\",\"messageCheck\":0,\"musicId\":\"7611185981\",\"qq\":\"508506630\",\"recordNumber\":\"渝ICP备2023001651号-2\",\"siteAddress\":\"https://www.haoxx.site\",\"siteAuthor\":\"小鱼\",\"siteIntro\":\"网站介绍\",\"siteName\":\"HaoXX`s Blog\",\"siteNotice\":\"个人学习资料记录\",\"socialList\":\"gitee,bilibili,github,qq\",\"touristAvatar\":\"https://upload.haoxx.site/config/0b04691f25e400a708caba867be171d0.jpg\",\"userAvatar\":\"https://upload.haoxx.site/config/e94fc60e58a570ecc3e9ddcb334fdb2b.jpg\",\"weiXinCode\":\"https://upload.haoxx.site/cloud/images/image_1.jpg\"}]','PUT','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-08 16:19:39');
INSERT INTO `t_exception_log` VALUES (256,'登录模块','/login','java.lang.IllegalArgumentException','用户登录','com.ican.controller.LoginController.login','java.lang.IllegalArgumentException:用户不存在或密码错误\ncn.hutool.core.lang.Assert.lambda$notNull$3(Assert.java:217)\ncn.hutool.core.lang.Assert.notNull(Assert.java:197)\ncn.hutool.core.lang.Assert.notNull(Assert.java:217)\ncom.ican.service.impl.LoginServiceImpl.login(LoginServiceImpl.java:65)\ncom.ican.service.impl.LoginServiceImpl$$FastClassBySpringCGLIB$$b577d1a7.invoke(<generated>)\norg.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218)\norg.springframework.aop.framework.CglibAopProxy.invokeMethod(CglibAopProxy.java:386)\norg.springframework.aop.framework.CglibAopProxy.access$000(CglibAopProxy.java:85)\norg.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:704)\ncom.ican.service.impl.LoginServiceImpl$$EnhancerBySpringCGLIB$$d979ba2e.login(<generated>)\ncom.ican.controller.LoginController.login(LoginController.java:42)\ncom.ican.controller.LoginController$$FastClassBySpringCGLIB$$b48ffc8d.invoke(<generated>)\norg.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218)\norg.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:793)\norg.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163)\norg.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:763)\norg.springframework.aop.aspectj.AspectJAfterThrowingAdvice.invoke(AspectJAfterThrowingAdvice.java:64)\norg.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)\norg.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:763)\norg.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:97)\norg.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)\norg.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:763)\norg.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:708)\ncom.ican.controller.LoginController$$EnhancerBySpringCGLIB$$da8fcccf.login(<generated>)\njava.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\njava.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\njava.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\njava.base/java.lang.reflect.Method.invoke(Method.java:566)\norg.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:205)\norg.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:150)\norg.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:117)\norg.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:895)\norg.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:808)\norg.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)\norg.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1071)\norg.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:964)\norg.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006)\norg.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:909)\njavax.servlet.http.HttpServlet.service(HttpServlet.java:696)\norg.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883)\njavax.servlet.http.HttpServlet.service(HttpServlet.java:779)\norg.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:227)\norg.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\norg.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53)\norg.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)\norg.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\ncn.dev33.satoken.filter.SaServletFilter.doFilter(SaServletFilter.java:179)\norg.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)\norg.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\norg.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)\norg.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117)\norg.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)\norg.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\norg.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)\norg.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117)\norg.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)\norg.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\norg.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)\norg.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117)\norg.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)\norg.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\norg.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:177)\norg.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:97)\norg.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:541)\norg.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:135)\norg.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92)\norg.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:78)\norg.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:360)\norg.apache.coyote.http11.Http11Processor.service(Http11Processor.java:399)\norg.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65)\norg.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:891)\norg.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1784)\norg.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)\norg.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1191)\norg.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659)\norg.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)\njava.base/java.lang.Thread.run(Thread.java:829)\n','[{\"password\":\"508506630.yh\",\"username\":\"1875023344@qq.com\"}]','POST','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-08 16:47:03');
INSERT INTO `t_exception_log` VALUES (257,'登录模块','/login','java.lang.IllegalArgumentException','用户登录','com.ican.controller.LoginController.login','java.lang.IllegalArgumentException:用户不存在或密码错误\ncn.hutool.core.lang.Assert.lambda$notNull$3(Assert.java:217)\ncn.hutool.core.lang.Assert.notNull(Assert.java:197)\ncn.hutool.core.lang.Assert.notNull(Assert.java:217)\ncom.ican.service.impl.LoginServiceImpl.login(LoginServiceImpl.java:65)\ncom.ican.service.impl.LoginServiceImpl$$FastClassBySpringCGLIB$$b577d1a7.invoke(<generated>)\norg.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218)\norg.springframework.aop.framework.CglibAopProxy.invokeMethod(CglibAopProxy.java:386)\norg.springframework.aop.framework.CglibAopProxy.access$000(CglibAopProxy.java:85)\norg.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:704)\ncom.ican.service.impl.LoginServiceImpl$$EnhancerBySpringCGLIB$$718b027f.login(<generated>)\ncom.ican.controller.LoginController.login(LoginController.java:42)\ncom.ican.controller.LoginController$$FastClassBySpringCGLIB$$b48ffc8d.invoke(<generated>)\norg.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218)\norg.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:793)\norg.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163)\norg.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:763)\norg.springframework.aop.aspectj.AspectJAfterThrowingAdvice.invoke(AspectJAfterThrowingAdvice.java:64)\norg.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)\norg.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:763)\norg.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:97)\norg.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)\norg.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:763)\norg.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:708)\ncom.ican.controller.LoginController$$EnhancerBySpringCGLIB$$9736c138.login(<generated>)\njava.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\njava.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\njava.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\njava.base/java.lang.reflect.Method.invoke(Method.java:566)\norg.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:205)\norg.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:150)\norg.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:117)\norg.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:895)\norg.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:808)\norg.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)\norg.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1071)\norg.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:964)\norg.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006)\norg.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:909)\njavax.servlet.http.HttpServlet.service(HttpServlet.java:696)\norg.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883)\njavax.servlet.http.HttpServlet.service(HttpServlet.java:779)\norg.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:227)\norg.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\norg.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53)\norg.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)\norg.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\ncn.dev33.satoken.filter.SaServletFilter.doFilter(SaServletFilter.java:179)\norg.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)\norg.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\norg.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)\norg.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117)\norg.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)\norg.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\norg.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)\norg.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117)\norg.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)\norg.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\norg.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)\norg.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117)\norg.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)\norg.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\norg.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:177)\norg.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:97)\norg.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:541)\norg.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:135)\norg.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92)\norg.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:78)\norg.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:360)\norg.apache.coyote.http11.Http11Processor.service(Http11Processor.java:399)\norg.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65)\norg.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:891)\norg.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1784)\norg.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)\norg.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1191)\norg.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659)\norg.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)\njava.base/java.lang.Thread.run(Thread.java:829)\n','[{\"password\":\"508506630.yh\",\"username\":\"1875023344@qq.com\"}]','POST','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-08 18:58:31');
/*!40000 ALTER TABLE `t_exception_log` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `t_friend`
--

DROP TABLE IF EXISTS `t_friend`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `t_friend` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '友链id',
  `name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '友链名称',
  `color` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '友链颜色',
  `avatar` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '友链头像',
  `url` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '友链地址',
  `introduction` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '友链介绍',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE,
  KEY `friend_user` (`name`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_friend`
--

LOCK TABLES `t_friend` WRITE;
/*!40000 ALTER TABLE `t_friend` DISABLE KEYS */;
/*!40000 ALTER TABLE `t_friend` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `t_menu`
--

DROP TABLE IF EXISTS `t_menu`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `t_menu` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键',
  `parent_id` int NOT NULL DEFAULT '0' COMMENT '父菜单id (paren_id为0且type为M则是一级菜单)',
  `menu_type` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '权限类型 (M目录 C菜单 B按钮)',
  `menu_name` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '名称',
  `path` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT NULL COMMENT '路由地址',
  `icon` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT NULL COMMENT '菜单图标',
  `component` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT NULL COMMENT '菜单组件',
  `perms` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT '' COMMENT '权限标识',
  `is_hidden` tinyint(1) NOT NULL DEFAULT '0' COMMENT '是否隐藏 (0否 1是)',
  `is_disable` tinyint(1) NOT NULL DEFAULT '0' COMMENT '是否禁用 (0否 1是)',
  `order_num` int NOT NULL DEFAULT '1' COMMENT '排序',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=127 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_menu`
--

LOCK TABLES `t_menu` WRITE;
/*!40000 ALTER TABLE `t_menu` DISABLE KEYS */;
INSERT INTO `t_menu` VALUES (1,0,'M','文章管理','article','archives','','',0,0,1,'2022-12-04 09:13:31','2023-02-21 15:36:45');
INSERT INTO `t_menu` VALUES (3,1,'C','分类管理','category','category','/blog/category/index','blog:category:list',0,0,3,'2022-12-04 09:22:20','2023-02-21 15:21:19');
INSERT INTO `t_menu` VALUES (4,1,'C','标签管理','tag','tag','/blog/tag/index','blog:tag:list',0,0,4,'2022-12-04 09:23:01','2023-02-21 15:21:23');
INSERT INTO `t_menu` VALUES (5,3,'B','添加分类',NULL,NULL,NULL,'blog:category:add',0,0,1,'2022-12-04 09:30:55',NULL);
INSERT INTO `t_menu` VALUES (6,3,'B','删除分类',NULL,NULL,NULL,'blog:category:delete',0,0,2,'2022-12-04 09:32:15','2022-12-26 15:39:20');
INSERT INTO `t_menu` VALUES (7,3,'B','修改分类',NULL,NULL,NULL,'blog:category:update',0,0,3,'2022-12-04 09:33:52',NULL);
INSERT INTO `t_menu` VALUES (8,4,'B','添加标签',NULL,NULL,'','blog:tag:add',0,0,1,'2022-12-04 10:19:51',NULL);
INSERT INTO `t_menu` VALUES (9,4,'B','删除标签',NULL,NULL,NULL,'blog:tag:delete',0,0,2,'2022-12-04 10:20:41',NULL);
INSERT INTO `t_menu` VALUES (10,4,'B','修改标签',NULL,NULL,NULL,'blog:tag:update',0,0,3,'2022-12-04 10:21:32',NULL);
INSERT INTO `t_menu` VALUES (11,0,'M','系统管理','system','system','','',0,0,3,'2022-12-06 10:58:50','2023-01-03 18:47:19');
INSERT INTO `t_menu` VALUES (12,11,'C','菜单管理','menu','tree-table','/system/menu/index','system:menu:list',0,0,1,'2022-12-06 16:33:56',NULL);
INSERT INTO `t_menu` VALUES (13,11,'C','角色管理','role','peoples','/system/role/index','system:role:list',0,0,2,'2022-12-06 17:09:55',NULL);
INSERT INTO `t_menu` VALUES (14,11,'C','用户管理','user','user','/system/user/index','system:user:list',0,0,3,'2022-12-06 17:10:28',NULL);
INSERT INTO `t_menu` VALUES (15,12,'B','添加菜单',NULL,'',NULL,'system:menu:add',0,0,1,'2022-12-07 10:50:22',NULL);
INSERT INTO `t_menu` VALUES (16,12,'B','删除菜单',NULL,'',NULL,'system:menu:delete',0,0,2,'2022-12-07 10:50:54',NULL);
INSERT INTO `t_menu` VALUES (17,12,'B','修改菜单',NULL,'',NULL,'system:menu:update',0,0,3,'2022-12-07 10:55:21',NULL);
INSERT INTO `t_menu` VALUES (18,13,'B','添加角色',NULL,NULL,NULL,'system:role:add',0,0,1,'2022-12-07 10:56:24',NULL);
INSERT INTO `t_menu` VALUES (19,13,'B','删除角色',NULL,NULL,NULL,'system:role:delete',0,0,2,'2022-12-07 10:56:50',NULL);
INSERT INTO `t_menu` VALUES (20,13,'B','修改角色',NULL,NULL,NULL,'system:role:update',0,0,3,'2022-12-07 10:57:15',NULL);
INSERT INTO `t_menu` VALUES (21,0,'M','日志管理','log','log','','',0,0,4,'2022-12-21 17:36:39','2023-02-21 15:20:13');
INSERT INTO `t_menu` VALUES (22,21,'C','操作日志','operation','form','/system/log/operation','log:operation:list',0,0,1,'2022-12-21 20:14:01',NULL);
INSERT INTO `t_menu` VALUES (23,21,'C','异常日志','exception','bug','/system/log/exception','log:exception:list',0,0,2,'2022-12-21 20:48:25',NULL);
INSERT INTO `t_menu` VALUES (24,22,'B','删除操作日志',NULL,NULL,NULL,'log:operation:delete',0,0,1,'2022-12-26 16:43:00',NULL);
INSERT INTO `t_menu` VALUES (25,23,'B','删除异常日志',NULL,NULL,NULL,'log:exception:delete',0,0,1,'2022-12-27 13:21:50',NULL);
INSERT INTO `t_menu` VALUES (26,0,'M','系统监控','monitor','monitor',NULL,'',0,0,5,'2022-12-27 13:23:29','2023-01-03 18:47:27');
INSERT INTO `t_menu` VALUES (27,26,'C','定时任务','task','job','/monitor/task/index','monitor:task:list',0,0,2,'2022-12-27 13:26:29','2023-01-01 21:08:35');
INSERT INTO `t_menu` VALUES (28,27,'B','添加任务',NULL,NULL,NULL,'monitor:task:add',0,0,1,'2022-12-27 13:32:42',NULL);
INSERT INTO `t_menu` VALUES (29,27,'B','修改任务',NULL,NULL,NULL,'monitor:task:update',0,0,2,'2022-12-27 13:33:45',NULL);
INSERT INTO `t_menu` VALUES (30,27,'B','删除任务',NULL,NULL,NULL,'monitor:task:delete',0,0,3,'2022-12-27 13:34:29',NULL);
INSERT INTO `t_menu` VALUES (31,27,'B','修改任务状态',NULL,NULL,NULL,'monitor:task:status',0,0,4,'2022-12-27 13:43:24',NULL);
INSERT INTO `t_menu` VALUES (32,27,'B','运行任务',NULL,NULL,NULL,'monitor:task:run',0,0,5,'2022-12-27 13:45:34',NULL);
INSERT INTO `t_menu` VALUES (33,13,'B','修改角色状态',NULL,NULL,NULL,'system:role:status',0,0,4,'2022-12-27 13:46:39',NULL);
INSERT INTO `t_menu` VALUES (34,0,'M','网站管理','web','international',NULL,'',0,0,6,'2022-12-30 17:22:33','2023-02-14 09:46:29');
INSERT INTO `t_menu` VALUES (35,34,'C','友链管理','friend','friend','/web/friend/index','web:friend:list',0,0,1,'2022-12-30 17:33:15',NULL);
INSERT INTO `t_menu` VALUES (36,0,'M','消息管理','news','email',NULL,'',0,0,2,'2022-12-30 17:50:06','2022-12-30 18:02:12');
INSERT INTO `t_menu` VALUES (37,36,'C','留言管理','message','form','/news/message/index','news:message:list',0,0,2,'2022-12-30 17:58:25','2022-12-30 18:01:47');
INSERT INTO `t_menu` VALUES (38,36,'C','评论管理','comment','comment','/news/comment/index','news:comment:list',0,0,1,'2022-12-30 17:59:37','2022-12-30 18:03:35');
INSERT INTO `t_menu` VALUES (39,35,'B','添加友链',NULL,NULL,NULL,'web:friend:add',0,0,1,'2022-12-30 18:56:22',NULL);
INSERT INTO `t_menu` VALUES (40,35,'B','删除友链',NULL,NULL,NULL,'web:friend:delete',0,0,2,'2022-12-30 18:56:42',NULL);
INSERT INTO `t_menu` VALUES (41,35,'B','修改友链',NULL,NULL,NULL,'web:friend:update',0,0,3,'2022-12-30 18:57:08',NULL);
INSERT INTO `t_menu` VALUES (42,37,'B','删除留言',NULL,NULL,NULL,'news:message:delete',0,0,1,'2022-12-30 22:05:53',NULL);
INSERT INTO `t_menu` VALUES (45,37,'B','审核留言',NULL,NULL,NULL,'news:message:pass',0,0,2,'2022-12-30 22:29:24',NULL);
INSERT INTO `t_menu` VALUES (46,34,'C','网站配置','site','example','/web/site/index','web:site:list',0,0,5,'2022-12-31 11:50:45','2023-01-03 18:49:17');
INSERT INTO `t_menu` VALUES (51,34,'C','相册管理','album','album','/web/album/index','web:album:list',0,0,3,'2023-01-01 18:16:40','2023-01-03 18:49:06');
INSERT INTO `t_menu` VALUES (52,34,'C','照片管理','photo/:albumId','photo','/web/photo/index','web:photo:list',1,0,4,'2023-01-01 18:18:11','2023-01-01 18:39:22');
INSERT INTO `t_menu` VALUES (53,26,'C','在线用户','online','online','/monitor/online/index','monitor:online:list',0,0,1,'2023-01-01 21:07:48','2023-01-01 21:08:29');
INSERT INTO `t_menu` VALUES (54,51,'B','添加相册',NULL,NULL,NULL,'web:album:add',0,0,1,'2023-01-02 19:01:33',NULL);
INSERT INTO `t_menu` VALUES (55,51,'B','删除相册',NULL,NULL,NULL,'web:album:delete',0,0,2,'2023-01-02 19:02:03',NULL);
INSERT INTO `t_menu` VALUES (56,51,'B','修改相册',NULL,NULL,NULL,'web:album:update',0,0,3,'2023-01-02 19:02:50',NULL);
INSERT INTO `t_menu` VALUES (57,51,'B','编辑相册',NULL,NULL,NULL,'web:album:edit',0,0,4,'2023-01-02 19:03:40',NULL);
INSERT INTO `t_menu` VALUES (58,51,'B','上传相册封面',NULL,NULL,NULL,'web:album:upload',0,0,5,'2023-01-02 19:04:38',NULL);
INSERT INTO `t_menu` VALUES (60,12,'B','编辑菜单',NULL,NULL,NULL,'system:menu:edit',0,0,4,'2023-01-03 18:29:57',NULL);
INSERT INTO `t_menu` VALUES (61,34,'C','说说管理','talk','talk','/web/talk/index','web:talk:list',0,0,2,'2023-01-03 18:48:28','2023-01-03 18:48:41');
INSERT INTO `t_menu` VALUES (62,61,'B','添加说说',NULL,NULL,NULL,'web:talk:add',0,0,1,'2023-01-05 19:16:42',NULL);
INSERT INTO `t_menu` VALUES (63,61,'B','删除说说',NULL,NULL,NULL,'web:talk:delete',0,0,2,'2023-01-05 19:17:07',NULL);
INSERT INTO `t_menu` VALUES (64,61,'B','修改说说',NULL,NULL,NULL,'web:talk:update',0,0,3,'2023-01-05 19:17:36',NULL);
INSERT INTO `t_menu` VALUES (65,61,'B','编辑说说',NULL,NULL,NULL,'web:talk:edit',0,0,4,'2023-01-05 19:18:27',NULL);
INSERT INTO `t_menu` VALUES (66,61,'B','上传说说图片',NULL,NULL,NULL,'web:talk:upload',0,0,5,'2023-01-05 19:18:52',NULL);
INSERT INTO `t_menu` VALUES (67,46,'B','修改网站配置',NULL,NULL,NULL,'web:site:update',0,0,1,'2023-01-08 09:15:56',NULL);
INSERT INTO `t_menu` VALUES (68,46,'B','上传网站配置图片',NULL,NULL,NULL,'web:site:upload',0,0,2,'2023-01-08 14:53:16',NULL);
INSERT INTO `t_menu` VALUES (69,14,'B','修改用户',NULL,NULL,NULL,'system:user:update',0,0,1,'2023-01-09 17:03:18',NULL);
INSERT INTO `t_menu` VALUES (70,14,'B','修改用户状态',NULL,NULL,NULL,'system:user:status',0,0,2,'2023-01-09 17:03:51',NULL);
INSERT INTO `t_menu` VALUES (71,53,'B','下线用户',NULL,NULL,NULL,'monitor:online:kick',0,0,1,'2023-01-09 19:18:33',NULL);
INSERT INTO `t_menu` VALUES (73,1,'C','文章列表','list','chart','/blog/article/list','blog:article:list',0,0,2,'2023-01-10 17:37:29','2023-02-21 15:36:09');
INSERT INTO `t_menu` VALUES (76,52,'B','添加照片',NULL,NULL,NULL,'web:photo:add',0,0,1,'2023-01-11 18:45:28',NULL);
INSERT INTO `t_menu` VALUES (77,52,'B','删除照片',NULL,NULL,NULL,'web:photo:delete',0,0,2,'2023-01-11 18:45:51',NULL);
INSERT INTO `t_menu` VALUES (78,52,'B','修改照片',NULL,NULL,NULL,'web:photo:update',0,0,3,'2023-01-11 18:46:12',NULL);
INSERT INTO `t_menu` VALUES (79,52,'B','上传照片',NULL,NULL,NULL,'web:photo:upload',0,0,3,'2023-01-11 18:46:48',NULL);
INSERT INTO `t_menu` VALUES (80,73,'B','添加文章',NULL,NULL,NULL,'blog:article:add',0,0,1,'2023-01-14 15:25:29',NULL);
INSERT INTO `t_menu` VALUES (81,73,'B','物理删除文章',NULL,NULL,NULL,'blog:article:delete',0,0,2,'2023-01-14 15:26:44',NULL);
INSERT INTO `t_menu` VALUES (82,73,'B','逻辑删除文章',NULL,NULL,NULL,'blog:article:recycle',0,0,3,'2023-01-14 15:28:32',NULL);
INSERT INTO `t_menu` VALUES (83,73,'B','更新文章',NULL,NULL,NULL,'blog:article:update',0,0,4,'2023-01-14 15:30:11',NULL);
INSERT INTO `t_menu` VALUES (84,73,'B','编辑文章',NULL,NULL,NULL,'blog:article:edit',0,0,5,'2023-01-14 15:32:34','2023-01-14 15:32:54');
INSERT INTO `t_menu` VALUES (85,73,'B','上传文章图片',NULL,NULL,NULL,'blog:article:upload',0,0,6,'2023-01-14 15:34:05','2023-01-15 11:19:13');
INSERT INTO `t_menu` VALUES (86,73,'B','置顶文章',NULL,NULL,NULL,'blog:article:top',0,0,7,'2023-01-14 15:35:33',NULL);
INSERT INTO `t_menu` VALUES (87,73,'B','推荐文章',NULL,NULL,NULL,'blog:article:recommend',0,0,8,'2023-01-14 15:36:08',NULL);
INSERT INTO `t_menu` VALUES (88,73,'B','点赞文章',NULL,NULL,NULL,'blog:article:like',0,0,9,'2023-01-14 15:36:39',NULL);
INSERT INTO `t_menu` VALUES (93,21,'C','访问日志','visit','logininfor','/system/log/visit','log:visit:list',0,0,3,'2023-01-28 19:04:09','2023-01-28 19:06:52');
INSERT INTO `t_menu` VALUES (94,93,'B','删除访问日志',NULL,NULL,NULL,'log:visit:delete',0,0,1,'2023-01-28 19:05:31',NULL);
INSERT INTO `t_menu` VALUES (95,14,'B','修改用户邮箱',NULL,NULL,NULL,'user:email:update',0,0,3,'2023-01-31 09:26:22',NULL);
INSERT INTO `t_menu` VALUES (96,14,'B','修改用户头像',NULL,NULL,NULL,'user:avatar:update',0,0,4,'2023-01-31 09:27:03',NULL);
INSERT INTO `t_menu` VALUES (97,14,'B','修改用户信息',NULL,NULL,NULL,'user:info:update',0,0,5,'2023-01-31 09:27:37',NULL);
INSERT INTO `t_menu` VALUES (98,14,'B','修改用户密码',NULL,NULL,NULL,'user:password:update',0,0,6,'2023-01-31 09:28:10',NULL);
INSERT INTO `t_menu` VALUES (99,38,'B','添加评论',NULL,NULL,NULL,'news:comment:add',0,0,1,'2023-02-08 19:09:25',NULL);
INSERT INTO `t_menu` VALUES (100,38,'B','删除评论',NULL,NULL,NULL,'news:comment:delete',0,0,2,'2023-02-08 19:09:57',NULL);
INSERT INTO `t_menu` VALUES (101,38,'B','审核评论',NULL,NULL,NULL,'news:comment:pass',0,0,3,'2023-02-08 19:10:26',NULL);
INSERT INTO `t_menu` VALUES (102,38,'B','点赞评论',NULL,NULL,NULL,'news:comment:like',0,0,4,'2023-02-08 19:10:45',NULL);
INSERT INTO `t_menu` VALUES (103,61,'B','点赞说说',NULL,NULL,NULL,'web:talk:like',0,0,6,'2023-02-10 11:16:23',NULL);
INSERT INTO `t_menu` VALUES (104,21,'C','任务日志','task','job','/system/log/task','log:task:list',0,0,3,'2023-02-14 10:28:28','2023-02-14 10:28:41');
INSERT INTO `t_menu` VALUES (105,104,'B','删除任务日志',NULL,NULL,NULL,'log:task:delete',0,0,1,'2023-02-14 11:21:06',NULL);
INSERT INTO `t_menu` VALUES (106,104,'B','清空任务日志',NULL,NULL,NULL,'log:task:clear',0,0,2,'2023-02-14 11:21:28',NULL);
INSERT INTO `t_menu` VALUES (108,1,'C','发布文章','write','edit','/blog/article/write','blog:article:list',0,0,1,'2023-02-21 13:32:22','2023-02-21 15:36:04');
INSERT INTO `t_menu` VALUES (111,1,'C','修改文章','write/:articleId','edit','/blog/article/write','blog:article:list',1,0,5,'2023-02-21 15:40:11','2023-02-21 15:41:07');
INSERT INTO `t_menu` VALUES (123,11,'C','文件管理','file','file','/system/file/index','system:file:list',0,0,4,'2023-03-09 10:57:29',NULL);
INSERT INTO `t_menu` VALUES (124,123,'B','上传文件',NULL,NULL,NULL,'system:file:upload',0,0,1,'2023-03-10 23:11:33',NULL);
INSERT INTO `t_menu` VALUES (125,123,'B','新建文件夹',NULL,NULL,NULL,'system:file:createFolder',0,0,2,'2023-03-10 23:12:11',NULL);
INSERT INTO `t_menu` VALUES (126,123,'B','删除文件',NULL,NULL,NULL,'system:file:delete',0,0,3,'2023-03-10 23:12:45',NULL);
/*!40000 ALTER TABLE `t_menu` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `t_message`
--

DROP TABLE IF EXISTS `t_message`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `t_message` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '留言id',
  `nickname` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '昵称',
  `avatar` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '头像',
  `message_content` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '留言内容',
  `ip_address` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '用户ip',
  `ip_source` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '用户地址',
  `is_check` tinyint(1) NOT NULL DEFAULT '1' COMMENT '是否通过 (0否 1是)',
  `create_time` datetime NOT NULL COMMENT '留言时间',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=88 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_message`
--

LOCK TABLES `t_message` WRITE;
/*!40000 ALTER TABLE `t_message` DISABLE KEYS */;
/*!40000 ALTER TABLE `t_message` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `t_operation_log`
--

DROP TABLE IF EXISTS `t_operation_log`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `t_operation_log` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '操作id',
  `module` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '操作模块',
  `type` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '操作类型',
  `uri` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '操作uri',
  `name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '方法名称',
  `description` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '操作描述',
  `params` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '请求参数',
  `method` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '请求方式',
  `data` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '返回数据',
  `user_id` int NOT NULL COMMENT '用户id',
  `nickname` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '用户昵称',
  `ip_address` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '操作ip',
  `ip_source` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '操作地址',
  `times` int NOT NULL COMMENT '操作耗时 (毫秒)',
  `create_time` datetime NOT NULL COMMENT '操作时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=1438 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_operation_log`
--

LOCK TABLES `t_operation_log` WRITE;
/*!40000 ALTER TABLE `t_operation_log` DISABLE KEYS */;
INSERT INTO `t_operation_log` VALUES (1151,'文件模块','上传','/admin/file/upload','com.ican.controller.BlogFileController.uploadFile','上传文件','amili.gif','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','192.168.23.1','内网IP|内网IP',216,'2023-03-10 23:27:15');
INSERT INTO `t_operation_log` VALUES (1152,'网站配置模块','修改','/admin/site/update','com.ican.controller.SiteConfigController.updateSiteConfig','更新网站配置','[{\"aboutMe\":\"🍀个人简介\\n\\n想进大厂的小白\\n\\n感谢大佬们的开源精神💖\",\"aliCode\":\"https://upload.haoxx.site/cloud/images/image_2.jpg\",\"articleCover\":\"https://upload.haoxx.site/config/27c7f38a329c07159a80315712680ea5.jpg\",\"authorAvatar\":\"https://upload.haoxx.site/config/5bbb6dc8be42f3e96dbcc7d7529dc402.gif\",\"bilibili\":\"https://space.bilibili.com/505715511\",\"commentCheck\":0,\"createSiteTime\":\"2022-08-25\",\"emailNotice\":1,\"gitee\":\"https://gitee.com/wu_shengdong\",\"github\":\"https://github.com/ICAN1999\",\"id\":1,\"isMusic\":1,\"isReward\":0,\"loginList\":\",gitee,github\",\"messageCheck\":0,\"musicId\":\"7611185981\",\"qq\":\"1632167813\",\"recordNumber\":\"赣ICP备2022007910号\",\"siteAddress\":\"https://www.haoxx.site\",\"siteAuthor\":\"阿冬\",\"siteIntro\":\"网站介绍\",\"siteName\":\"Hello World\",\"siteNotice\":\"后端基于SpringBoot开发，前端基于Vue3 Ts Navie UI开发，<a href=\\\"https://gitee.com/wu_shengdong/blog\\\" style=\\\"color: #49b1f5;\\\">网站源码</a>\",\"socialList\":\"gitee,bilibili,github,qq\",\"touristAvatar\":\"https://upload.haoxx.site/config/819148114874887d5da6579fa0277f69.jpg\",\"userAvatar\":\"https://upload.haoxx.site/config/9efe3748595986f6bd82058336443bbe.jpg\",\"weiXinCode\":\"https://upload.haoxx.site/cloud/images/image_1.jpg\"}]','PUT','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.228.187.36','中国|重庆|重庆市|移动',400,'2023-06-05 12:47:38');
INSERT INTO `t_operation_log` VALUES (1153,'网站配置模块','修改','/admin/site/update','com.ican.controller.SiteConfigController.updateSiteConfig','更新网站配置','[{\"aboutMe\":\"🍀个人简介\\n\\n想进大厂的小白\\n\\n感谢大佬们的开源精神💖\",\"aliCode\":\"https://upload.haoxx.site/cloud/images/image_2.jpg\",\"articleCover\":\"https://upload.haoxx.site/config/27c7f38a329c07159a80315712680ea5.jpg\",\"authorAvatar\":\"https://upload.haoxx.site/config/5bbb6dc8be42f3e96dbcc7d7529dc402.gif\",\"bilibili\":\"https://space.bilibili.com/505715511\",\"commentCheck\":0,\"createSiteTime\":\"2022-08-25\",\"emailNotice\":1,\"gitee\":\"https://gitee.com/wu_shengdong\",\"github\":\"https://github.com/ICAN1999\",\"id\":1,\"isMusic\":0,\"isReward\":0,\"loginList\":\"\",\"messageCheck\":0,\"musicId\":\"7611185981\",\"qq\":\"1632167813\",\"recordNumber\":\"赣ICP备2022007910号\",\"siteAddress\":\"https://www.haoxx.site\",\"siteAuthor\":\"阿冬\",\"siteIntro\":\"网站介绍\",\"siteName\":\"Hello World\",\"siteNotice\":\"后端基于SpringBoot开发，前端基于Vue3 Ts Navie UI开发，<a href=\\\"https://gitee.com/wu_shengdong/blog\\\" style=\\\"color: #49b1f5;\\\">网站源码</a>\",\"socialList\":\"gitee,bilibili,github,qq\",\"touristAvatar\":\"https://upload.haoxx.site/config/819148114874887d5da6579fa0277f69.jpg\",\"userAvatar\":\"https://upload.haoxx.site/config/9efe3748595986f6bd82058336443bbe.jpg\",\"weiXinCode\":\"https://upload.haoxx.site/cloud/images/image_1.jpg\"}]','PUT','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.228.187.36','中国|重庆|重庆市|移动',16,'2023-06-05 12:47:50');
INSERT INTO `t_operation_log` VALUES (1154,'网站配置模块','修改','/admin/site/update','com.ican.controller.SiteConfigController.updateSiteConfig','更新网站配置','[{\"aboutMe\":\"🍀个人简介\\n\\n想进大厂的小白\\n\\n感谢大佬们的开源精神💖\",\"aliCode\":\"https://upload.haoxx.site/cloud/images/image_2.jpg\",\"articleCover\":\"https://upload.haoxx.site/config/27c7f38a329c07159a80315712680ea5.jpg\",\"authorAvatar\":\"https://upload.haoxx.site/config/5bbb6dc8be42f3e96dbcc7d7529dc402.gif\",\"bilibili\":\"https://space.bilibili.com/505715511\",\"commentCheck\":0,\"createSiteTime\":\"2022-08-25\",\"emailNotice\":1,\"gitee\":\"https://gitee.com/wu_shengdong\",\"github\":\"https://github.com/ICAN1999\",\"id\":1,\"isMusic\":0,\"isReward\":0,\"loginList\":\"\",\"messageCheck\":0,\"musicId\":\"7611185981\",\"qq\":\"1632167813\",\"recordNumber\":\"渝ICP备2023001651号-2\",\"siteAddress\":\"https://www.haoxx.site\",\"siteAuthor\":\"阿冬\",\"siteIntro\":\"网站介绍\",\"siteName\":\"Hello World\",\"siteNotice\":\"后端基于SpringBoot开发，前端基于Vue3 Ts Navie UI开发，<a href=\\\"https://gitee.com/wu_shengdong/blog\\\" style=\\\"color: #49b1f5;\\\">网站源码</a>\",\"socialList\":\"gitee,bilibili,github,qq\",\"touristAvatar\":\"https://upload.haoxx.site/config/819148114874887d5da6579fa0277f69.jpg\",\"userAvatar\":\"https://upload.haoxx.site/config/9efe3748595986f6bd82058336443bbe.jpg\",\"weiXinCode\":\"https://upload.haoxx.site/cloud/images/image_1.jpg\"}]','PUT','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',15,'2023-06-05 14:40:57');
INSERT INTO `t_operation_log` VALUES (1155,'网站配置模块','修改','/admin/site/update','com.ican.controller.SiteConfigController.updateSiteConfig','更新网站配置','[{\"aboutMe\":\"🍀个人简介\\n\\n想进大厂的小白\\n\\n感谢大佬们的开源精神💖\",\"aliCode\":\"https://upload.haoxx.site/cloud/images/image_2.jpg\",\"articleCover\":\"https://upload.haoxx.site/config/27c7f38a329c07159a80315712680ea5.jpg\",\"authorAvatar\":\"https://upload.haoxx.site/config/5bbb6dc8be42f3e96dbcc7d7529dc402.gif\",\"bilibili\":\"https://space.bilibili.com/505715511\",\"commentCheck\":0,\"createSiteTime\":\"2022-08-25\",\"emailNotice\":1,\"gitee\":\"https://gitee.com/wu_shengdong\",\"github\":\"https://github.com/ICAN1999\",\"id\":1,\"isMusic\":0,\"isReward\":0,\"loginList\":\"\",\"messageCheck\":0,\"musicId\":\"7611185981\",\"qq\":\"1632167813\",\"recordNumber\":\"渝ICP备2023001651号-2\",\"siteAddress\":\"https://www.haoxx.site\",\"siteAuthor\":\"小鱼\",\"siteIntro\":\"网站介绍\",\"siteName\":\"Hello World\",\"siteNotice\":\"后端基于SpringBoot开发，前端基于Vue3 Ts Navie UI开发，<a href=\\\"https://gitee.com/wu_shengdong/blog\\\" style=\\\"color: #49b1f5;\\\">网站源码</a>\",\"socialList\":\"gitee,bilibili,github,qq\",\"touristAvatar\":\"https://upload.haoxx.site/config/819148114874887d5da6579fa0277f69.jpg\",\"userAvatar\":\"https://upload.haoxx.site/config/9efe3748595986f6bd82058336443bbe.jpg\",\"weiXinCode\":\"https://upload.haoxx.site/cloud/images/image_1.jpg\"}]','PUT','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',13,'2023-06-05 14:45:37');
INSERT INTO `t_operation_log` VALUES (1156,'网站配置模块','修改','/admin/site/update','com.ican.controller.SiteConfigController.updateSiteConfig','更新网站配置','[{\"aboutMe\":\"🍀个人简介\\n\\nXX\",\"aliCode\":\"https://upload.haoxx.site/cloud/images/image_2.jpg\",\"articleCover\":\"https://upload.haoxx.site/config/27c7f38a329c07159a80315712680ea5.jpg\",\"authorAvatar\":\"https://upload.haoxx.site/config/5bbb6dc8be42f3e96dbcc7d7529dc402.gif\",\"bilibili\":\"https://space.bilibili.com/505715511\",\"commentCheck\":0,\"createSiteTime\":\"2022-08-25\",\"emailNotice\":1,\"gitee\":\"https://gitee.com/wu_shengdong\",\"github\":\"https://github.com/ICAN1999\",\"id\":1,\"isMusic\":0,\"isReward\":0,\"loginList\":\"\",\"messageCheck\":0,\"musicId\":\"7611185981\",\"qq\":\"1632167813\",\"recordNumber\":\"渝ICP备2023001651号-2\",\"siteAddress\":\"https://www.haoxx.site\",\"siteAuthor\":\"小鱼\",\"siteIntro\":\"网站介绍\",\"siteName\":\"Hello World\",\"siteNotice\":\"后端基于SpringBoot开发，前端基于Vue3 Ts Navie UI开发，<a href=\\\"https://gitee.com/wu_shengdong/blog\\\" style=\\\"color: #49b1f5;\\\">网站源码</a>\",\"socialList\":\"gitee,bilibili,github,qq\",\"touristAvatar\":\"https://upload.haoxx.site/config/819148114874887d5da6579fa0277f69.jpg\",\"userAvatar\":\"https://upload.haoxx.site/config/9efe3748595986f6bd82058336443bbe.jpg\",\"weiXinCode\":\"https://upload.haoxx.site/cloud/images/image_1.jpg\"}]','PUT','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',16,'2023-06-05 14:45:41');
INSERT INTO `t_operation_log` VALUES (1157,'网站配置模块','上传','/admin/site/upload','com.ican.controller.SiteConfigController.uploadSiteImg','上传网站配置图片','image_21.jpg','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/config/c9afbcf4258bfeb9f5f257ebd471d1a7.jpg\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',99,'2023-06-05 22:04:31');
INSERT INTO `t_operation_log` VALUES (1158,'网站配置模块','上传','/admin/site/upload','com.ican.controller.SiteConfigController.uploadSiteImg','上传网站配置图片','image_27.jpg','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/config/b9f3f2f6ed8b951e6e047298abf80a23.jpg\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',22,'2023-06-05 22:04:40');
INSERT INTO `t_operation_log` VALUES (1159,'网站配置模块','修改','/admin/site/update','com.ican.controller.SiteConfigController.updateSiteConfig','更新网站配置','[{\"aboutMe\":\"🍀个人简介\\n\\nXX\",\"aliCode\":\"https://upload.haoxx.site/cloud/images/image_2.jpg\",\"articleCover\":\"https://upload.haoxx.site/config/27c7f38a329c07159a80315712680ea5.jpg\",\"authorAvatar\":\"https://upload.haoxx.site/config/5bbb6dc8be42f3e96dbcc7d7529dc402.gif\",\"bilibili\":\"https://space.bilibili.com/505715511\",\"commentCheck\":0,\"createSiteTime\":\"2022-08-25\",\"emailNotice\":1,\"gitee\":\"https://gitee.com/wu_shengdong\",\"github\":\"https://github.com/ICAN1999\",\"id\":1,\"isMusic\":0,\"isReward\":0,\"loginList\":\"\",\"messageCheck\":0,\"musicId\":\"7611185981\",\"qq\":\"1632167813\",\"recordNumber\":\"渝ICP备2023001651号-2\",\"siteAddress\":\"https://www.haoxx.site\",\"siteAuthor\":\"小鱼\",\"siteIntro\":\"网站介绍\",\"siteName\":\"Hello World\",\"siteNotice\":\"后端基于SpringBoot开发，前端基于Vue3 Ts Navie UI开发，<a href=\\\"https://gitee.com/wu_shengdong/blog\\\" style=\\\"color: #49b1f5;\\\">网站源码</a>\",\"socialList\":\"gitee,bilibili,github,qq\",\"touristAvatar\":\"https://upload.haoxx.site/config/b9f3f2f6ed8b951e6e047298abf80a23.jpg\",\"userAvatar\":\"https://upload.haoxx.site/config/c9afbcf4258bfeb9f5f257ebd471d1a7.jpg\",\"weiXinCode\":\"https://upload.haoxx.site/cloud/images/image_1.jpg\"}]','PUT','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',13,'2023-06-05 22:04:44');
INSERT INTO `t_operation_log` VALUES (1160,'文件模块','删除','/admin/file/delete','com.ican.controller.BlogFileController.deleteFile','删除文件','[[125]]','DELETE','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',51,'2023-06-05 22:05:45');
INSERT INTO `t_operation_log` VALUES (1161,'文件模块','删除','/admin/file/delete','com.ican.controller.BlogFileController.deleteFile','删除文件','[[126]]','DELETE','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',20,'2023-06-05 22:05:47');
INSERT INTO `t_operation_log` VALUES (1162,'角色模块','修改','/admin/role/changeStatus','com.ican.controller.RoleController.updateRoleStatus','修改角色状态','[{\"id\":\"3\",\"isDisable\":1}]','PUT','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',18,'2023-06-05 22:06:05');
INSERT INTO `t_operation_log` VALUES (1163,'角色模块','修改','/admin/role/changeStatus','com.ican.controller.RoleController.updateRoleStatus','修改角色状态','[{\"id\":\"2\",\"isDisable\":1}]','PUT','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',12,'2023-06-05 22:06:07');
INSERT INTO `t_operation_log` VALUES (1164,'角色模块','修改','/admin/role/changeStatus','com.ican.controller.RoleController.updateRoleStatus','修改角色状态','[{\"id\":\"2\",\"isDisable\":0}]','PUT','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',11,'2023-06-05 22:06:09');
INSERT INTO `t_operation_log` VALUES (1165,'角色模块','修改','/admin/role/changeStatus','com.ican.controller.RoleController.updateRoleStatus','修改角色状态','[{\"id\":\"3\",\"isDisable\":0}]','PUT','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',11,'2023-06-05 22:06:11');
INSERT INTO `t_operation_log` VALUES (1166,'照片模块','删除','/admin/photo/delete','com.ican.controller.PhotoController.deletePhoto','删除照片','[[1,3]]','DELETE','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',12,'2023-06-05 22:06:36');
INSERT INTO `t_operation_log` VALUES (1167,'文件模块','上传','/admin/file/upload','com.ican.controller.BlogFileController.uploadFile','上传文件','avatar.jpg','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',402,'2023-06-05 22:26:15');
INSERT INTO `t_operation_log` VALUES (1168,'文件模块','删除','/admin/file/delete','com.ican.controller.BlogFileController.deleteFile','删除文件','[[127]]','DELETE','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',199,'2023-06-05 22:27:18');
INSERT INTO `t_operation_log` VALUES (1169,'网站配置模块','修改','/admin/site/update','com.ican.controller.SiteConfigController.updateSiteConfig','更新网站配置','[{\"aboutMe\":\"🍀个人简介\\n\\nXX\",\"aliCode\":\"https://upload.haoxx.site/cloud/images/image_2.jpg\",\"articleCover\":\"https://upload.haoxx.site/config/27c7f38a329c07159a80315712680ea5.jpg\",\"authorAvatar\":\"https://upload.haoxx.site/config/5bbb6dc8be42f3e96dbcc7d7529dc402.gif\",\"bilibili\":\"https://space.bilibili.com/505715511\",\"commentCheck\":0,\"createSiteTime\":\"2023-06-06\",\"emailNotice\":1,\"gitee\":\"https://gitee.com/wu_shengdong\",\"github\":\"https://github.com/ICAN1999\",\"id\":1,\"isMusic\":0,\"isReward\":0,\"loginList\":\",gitee\",\"messageCheck\":0,\"musicId\":\"7611185981\",\"qq\":\"1632167813\",\"recordNumber\":\"渝ICP备2023001651号-2\",\"siteAddress\":\"https://www.haoxx.site\",\"siteAuthor\":\"小鱼\",\"siteIntro\":\"网站介绍\",\"siteName\":\"Hello World\",\"siteNotice\":\"后端基于SpringBoot开发，前端基于Vue3 Ts Navie UI开发，<a href=\\\"https://gitee.com/wu_shengdong/blog\\\" style=\\\"color: #49b1f5;\\\">网站源码</a>\",\"socialList\":\"gitee,bilibili,github,qq\",\"touristAvatar\":\"https://upload.haoxx.site/config/0b04691f25e400a708caba867be171d0.jpg\",\"userAvatar\":\"https://upload.haoxx.site/config/e94fc60e58a570ecc3e9ddcb334fdb2b.jpg\",\"weiXinCode\":\"https://upload.haoxx.site/cloud/images/image_1.jpg\"}]','PUT','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',346,'2023-06-06 20:20:35');
INSERT INTO `t_operation_log` VALUES (1170,'文章模块','删除','/admin/article/delete','com.ican.controller.ArticleController.deleteArticle','删除文章','[[61]]','DELETE','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',51,'2023-06-07 16:31:20');
INSERT INTO `t_operation_log` VALUES (1171,'文章模块','添加','/admin/article/add','com.ican.controller.ArticleController.addArticle','添加文章','[{\"articleContent\":\"---\\ntitle: 全面内容综述\\ndate: 2022-10-30\\ncategory:\\n - 1编程语言基础\\n\\nfooter: <a href=\\\"https://beian.miit.gov.cn/#/Integrated/index\\\">渝ICP备2023001651号</a>\\n\\n---\\n\\n:::tip\\n全面内容综述\\n:::\\n\\n<!-- more -->\\n\\n\\n第一部分是C++基础，第二部分是C/C++内存问题，第三部分是C++面向对象，第四部分是C++标准模板库STL，第五部分是C++新特性，第六部分是C++操作系统内容，第七部分是C++计算机网络，第八部分提到了部分常用的设计模式，第九部分举了一些常见的编程题。\\n\\n内容参考自[牛客](https://www.nowcoder.com/issue/tutorial?zhuanlanId=Gj56lM&uuid=0d542159b96c424f8b35bd6f9a278609)\\n\\n## 1、C++基础\\n\\n\\n\\n### 1.1 简述C++语言的特点\\n\\n1. C++在C语言基础上引入了**面向对象**的机制，同时也**兼容C语言**。\\n2. C++有三大特性：封装、继承、多态\\n3. C++语言编写出的程序结构清晰、易于扩充，程序可读性好\\n4. C++生成的代码质量高，运行效率高，仅比汇编语言慢10%～20%\\n5. C++更加安全，增加了const常量、引用、四类cast转换（static_cast、dynamic_cast、const_cast、reinterpret_cast）、智能指针、try—catch等等\\n6. C++可复用性高，C++引入了模板的概念，后面在此基础上，实现了方便开发的标准模板库STL（Standard Template Library）\\n7. 同时，C++是**不断在发展**的语言。C++后续版本更是发展了不少新特性，如C++11中引入了nullptr、auto变量、Lambda匿名函数、右值引用、智能指针。\\n\\n### 1.2 说说C语言与C++语言的区别\\n\\n1. C语言是C++的子集，C++可以很好兼容C语言。但是C++又有很多**新特性**，如引用、智能指针、auto变量等。\\n2. C++是**面对对象**的编程语言；C语言是面对过程的编程语言\\n3. C语言有一些不安全的语言特性，如指针使用的潜在危险、强制转换的不确定性、内存泄露等。而C++对此增加了不少新特性来**改善安全性**，如const常量、引用、cast转换、智能指针、try—catch等等\\n4. C++**可复用性高**，C++引入了**模板**的概念，后面在此基础上，实现了方便开发的标准模板库STL。C++的STL库相对于C语言的函数库**更灵活、更通用**\\n\\n### 1.3 说说C++中struct和class的区别\\n\\n1. struct一般用于描述一个数据结构集合，而class是对一个对象数据的封装；\\n2. struct的默认访问权限是public，而class默认权限是private；\\n\\n```cpp\\nstruct A{\\n\\tint iNum;  //默认访问控制权限是public\\n};\\nclass B{\\n\\tint iNum;  //默认访问控制权限是private\\n};\\n```\\n\\n3. 在继承关系上，struct是public继承，而class是private继承；\\n4. class关键字可以用于定义模板参数，就像typename，而struct不能用于定义模板参数。\\n\\n### 1.4 说说C中结构体和C++中结构体的区别\\n\\n1. C的结构体内不允许有函数存在，C++允许有内部成员函数，且允许该函数是虚函数\\n2. C的结构体对内部成员变量的访问权限只能是public，而C++允许public,protected,private三种\\n3. C语言的结构体是不可以继承的，C++的结构体是可以从其他的结构体或者类继承过来的\\n4. C 中使用结构体需要加上 struct 关键字，或者对结构体使用 typedef 取别名，而 C++ 中可以省略 struct 关键字直接使用\\n\\n小总结一波：①C与C++在声明时的区别在于：\\n\\n|          |           C            |           C++            |\\n| :------: | :--------------------: | :----------------------: |\\n| 成员函数 |         不能有         |           可以           |\\n| 静态成员 |         不能有         |           可以           |\\n| 访问控制 |  默认public，不可修改  | public/private/protected |\\n| 继承关系 |       不可以继承       |  可从类或其他结构体继承  |\\n|  初始化  | 不能直接初始化数据成员 |           可以           |\\n\\n②使用时的区别：\\n\\nC 中使用结构体需要加上 struct 关键字，或者对结构体使用 typedef 取别名，而 C++ 中可以省略 struct 关键字直接使用，例如：\\n\\n```cpp\\nstruct Student{\\n\\tint iAge;\\n\\tstring strName;\\n};\\ntypedef struct Student Student2; //C中给结构体取别名\\n\\nstuct Student stu1;   //C中正常使用\\nStudent2 stu2;      //C中通过取别名来使用\\nStudent stu3;      // C++中使用结构体可以省略关键字struct\\n```\\n\\n### 1.5 说说include头文件的顺序以及双引号“”和尖括号<>的区别\\n\\n1. 区别\\n   （1）尖括号的头文件是系统文件，双引号的文件是自定义文件；\\n   （2）编译器预处理阶段查找头文件的路径不一样\\n2. 查找路径\\n   （1）使用尖括号<>的头文件的查找路径：编译器设置的头文件路径-->系统变量\\n   （2）使用双引号“”的头文件的查找路径：当前头文件目录-->编译器设置的头文件路径-->系统变量\\n\\n### 1.6 导入C函数的关键字是什么，C++编译的时候与C有什么区别\\n\\n1. **关键字**：在C++中，导入C函数的关键字是extern，表达形式为extern “C”， extern \\\"C\\\"的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern \\\"C\\\"后，会指示编译器这部分代码按C语言的进行编译，而不是C++的。\\n2. **编译区别**：由于C++支持函数重载，因此编译器编译函数的过程中会将函数的**参数类型**也加到编译后的代码中，而不仅仅是**函数名**；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括**函数名**。\\n   程序示例：\\n\\n```cpp\\n//extern示例\\n//在C++程序里边声明该函数，会指示编译器这部分代码按C语言的进行编译\\nextern \\\"C\\\" int strcmp(const char *s1, const char *s2);\\n\\n//在C++程序里边声明该函数\\nextern \\\"C\\\"{\\n    #include <string.h>//string.h里边包含了要调用的C函数的声明\\n}\\n\\n//两种不同的语言，有着不同的编译规则，比如一个函数fun，可能C语言编译的时候为_fun，而C++则是__fun__\\n```\\n\\n### 1.7 简述C++从代码到可执行二进制文件的过程\\n\\nC++和C语言类似，一个C++程序从源码到执行文件，有四个过程，**预处理、编译、汇编、链接**。\\n\\n1. 预处理：这个过程主要的处理操作如下：\\n   （1） 将所有的#define删除，并且展开所有的宏定义\\n   （2） 处理所有的条件预编译指令，如#if、#ifdef\\n   （3） 处理#include预编译指令，将被包含的文件插入到该预编译指令的位置。\\n   （4） 过滤所有的注释\\n   （5） 添加行号和文件名标识。\\n2. 编译：这个过程主要的处理操作如下：\\n   （1） 词法分析：将源代码的字符序列分割成一系列的记号。\\n   （2） 语法分析：对记号进行语法分析，产生语法树。\\n   （3） 语义分析：判断表达式是否有意义。\\n   （4） 代码优化：\\n   （5） 目标代码生成：生成汇编代码。\\n   （6） 目标代码优化：\\n3. 汇编：这个过程主要是将汇编代码转变成机器可以执行的指令。\\n4. 链接：将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。\\n\\n链接分为静态链接和动态链接。\\n\\n静态链接，是在链接的时候就已经把要调用的函数或者过程链接到了生成的可执行文件中，就算你在去把静态库删除也不会影响可执行程序的执行；生成的静态链接库，Windows下以.lib为后缀，Linux下以.a为后缀。\\n\\n而动态链接，是在链接的时候没有把调用的函数代码链接进去，而是在执行的过程中，再去找要链接的函数，生成的可执行文件中没有函数代码，只包含函数的重定位信息，所以当你删除动态库时，可执行程序就不能运行。生成的动态链接库，Windows下以.dll为后缀，Linux下以.so为后缀。\\n\\n### 1.8 说说 static关键字的作用\\n\\n**static关键字的作用**：一方面她延长了函数和变量的作用时间；另一方面，它也限制了函数和变量的作用范围。\\n\\n1. **定义全局静态变量和局部静态变量**：在变量前面加上static关键字。初始化的静态变量会在数据段（.data）分配内存，未初始化的静态变量会在BSS段（.bss）分配内存。直到程序结束，静态变量始终会维持前值。只不过全局静态变量和局部静态变量的作用域不一样；\\n2. **定义静态函数**：在函数返回类型前加上static关键字，函数即被定义为静态函数。静态函数只能在本源文件中使用；\\n3. 在变量类型前加上static关键字，变量即被定义为静态变量。静态变量只能在本源文件中使用；\\n4. 在C++中，static关键字可以用于定义类中的静态成员变量：使用静态数据成员，它既可以被当成全局变量那样去存储，但又被隐藏在类的内部。类中的static静态数据成员拥有一块单独的存储区，而不管创建了多少个该类的对象。所有这些对象的静态数据成员都共享这一块静态存储空间；\\n5. 在C++中，static关键字可以用于定义类中的静态成员函数：与静态成员变量类似，类里面同样可以定义静态成员函数。只需要在函数前加上关键字static即可。如静态成员函数也是类的一部分，而不是对象的一部分。所有这些对象的静态数据成员都共享这一块静态存储空间。\\n\\n**关于第五点的补充说明**：当调用一个对象的非静态成员函数时，系统会把该对象的起始地址赋给成员函数的this指针。而静态成员函数不属于任何一个对象，因此C++规定静态成员函数没有this指针（划重点，面试题常考）。既然它没有指向某一对象，也就无法对一个对象中的非静态成员进行访问。\\n\\n### 1.9 说说数组和指针的区别\\n\\n1、概念：\\n    （1）数组：数组是用于储存多个相同类型数据的集合。数组名是首元素的地址\\n    （2）指针：指针相当于一个变量，但是它和不同变量不一样，它存放的是其它变量在**内存中的地址**。指针名指向了内存的首地址\\n\\n2. 区别：\\n   （1）**赋值**：同类型指针变量可以相互赋值；数组不行，只能一个一个元素的赋值或拷贝\\n   （2）**存储方式**：\\n\\n数组：数组在内存中是连续存放的，开辟一块连续的内存空间。数组是根据数组的下标进行访问的，数组的存储空间，不是在静态区就是在栈上。\\n\\n指针：指针很灵活，它可以指向任意类型的数据。指针的类型说明了它所指向地址空间的内存。由于指针本身就是一个变量，再加上它所存放的也是变量，所以指针的存储空间不能确定。\\n（3）**求sizeof**：\\n\\n数组所占存储空间的内存大小是sizeof(数组)，计算数组中元素个数：sizeof（数组名）/sizeof（数据类型）\\n\\n在32位平台下，无论指针的类型是什么，sizeof（指针名）都是4，在64位平台下，无论指针的类型是什么，sizeof（指针名）都是8。\\n（4）**初始化**：\\n\\n```cpp\\n// 数组\\nint a[5] = { 0 };\\nchar b[] = \\\"Hello\\\";    // 按字符串初始化，大小为6\\nchar c[] = { \'H\',\'e\',\'l\',\'l\',\'o\',\'\\\\0\' };    // 按字符初始化\\nint* arr = new int[10];    // 动态创建一维数组\\n\\n// 指针\\n// 指向对象的指针\\nint* p = new int(0);\\ndelete p;\\n// 指向数组的指针\\nint* p1 = new int[10];\\ndelete[] p1;\\n// 指向类的指针：\\nstring* p2 = new string;\\ndelete p2;\\n// 指向指针的指针（二级指针）\\nint** pp = &p;\\n**pp = 10;\\n```\\n\\n（5）**指针操作**：\\n\\n数组名的指针操作：\\n\\n`int (*p)[4]`定义了一个数组指针，该指针指向一个包含4个元素的数组。\\n\\n```cpp\\nint a[3][4];  \\nint (*p)[4];  //该语句是定义一个数组指针，指向含4个元素的一维数组\\np = a;        //将该二维数组的首地址赋给p，也就是a[0]或&a[0][0]\\np++;          //该语句执行过后，也就是p=p+1；p跨过行a[0][]指向了行a[1][]\\n              //所以数组指针也称指向一维数组的指针，亦称行指针。\\n//访问数组中第i行j列的一个元素，有几种操作方式：\\n//*(p[i]+j)、*(*(p+i)+j)、(*(p+i))[j]、p[i][j]。其中，优先级：()>[]>*。\\n//这几种操作方式都是合法的。\\n```\\n\\n指针变量的数据操作：\\n\\n```cpp\\nchar *str = \\\"hello,douya!\\\";\\nstr[2] = \'a\';\\n*(str+2) = \'b\';\\n//这两种操作方式都是合法的。\\n```\\n\\n补充：int \\\\*p[4]和int (*p)[4]的区别和区分：因为[]的优先级要比\\\\*高，所以前者是p先和[ ]结合，表示一个数组，然后再与*结合，表示int指针类型的数组。（本质上是数组，不过是int指针类型的数组）这数组里每个元素都是int类型的指针，储存的是int类型变量的地址。\\n\\n而int(\\\\*p)[4]，p先和\\\\*结合，表示p是一个指针，int ［4］就是他的类型，表示这是一个数组类型的指针，即p是一个指向一个长度为4数组的指针，它的本质是一个指针，这个指针的类型是int类型长度为4的数组。表示，这个指针存的是int类型长度为4的数组的地址。（不是其中某个元素的地址）\\n\\n### 1.10 说说什么是函数指针，如何定义函数指针，有什么使用场景\\n\\n1. **概念**：函数指针就是指向函数的指针变量。每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址\\n2. **定义**形式如下：\\n\\n```cpp\\nint func(int a);  \\nint (*f)(int a);  \\nf = &func;  \\n```\\n\\n3. 函数指针的**应用场景**：**回调**(callback)。我们调用别人提供的 API函数(Application Programming Interface,应用程序编程接口)，称为Call；如果别人的库里面调用我们的函数，就叫回调Callback。\\n\\n  我们用系统的API叫调用，系统用我们的API叫回调。\\n\\n  程序示例：\\n\\n```cpp\\n//以库函数qsort排序函数为例，它的原型如下：\\nvoid qsort(void *base,//void*类型，代表原始数组\\n           size_t nmemb, //第二个是size_t类型，代表数据数量\\n           size_t size, //第三个是size_t类型，代表单个数据占用空间大小\\n           int(*compar)(const void *,const void *)//第四个参数是函数指针\\n          );\\n//第四个参数告诉qsort，应该使用哪个函数来比较元素，即只要我们告诉qsort比较大小的规则，它就可以帮我们对任意数据类型的数组进行排序。在库函数qsort调用我们自定义的比较函数，这就是回调的应用。\\n\\n//示例\\nint num[100];\\nint cmp_int(const void* _a , const void* _b){//参数格式固定\\n    int* a = (int*)_a;    //强制类型转换\\n    int* b = (int*)_b;\\n    return *a - *b;　　\\n}\\nqsort(num,100,sizeof(num[0]),cmp_int); //回调\\n```\\n\\n### 1.11 说说静态变量什么时候初始化\\n\\n<font color=\'red\'>对于C语言的全局和静态变量，初始化发生在任何代码执行之前，属于编译期初始化。</font>\\n\\n<font color=\'red\'>而C++标准规定：全局或静态对象当且仅当对象首次用到时才进行构造。</font>\\n\\n1. **作用域**：C++里作用域可分为6种：全局，局部，类，语句，命名空间和文件作用域\\n\\n  全局变量：全局作用域+文件作用域，可以通过extern作用于其他非定义的源文件。\\n  静态全局变量 ：全局作用域，所以无法在其他文件中使用。\\n  静态局部变量 ：局部作用域，只被初始化一次，直到程序结束。\\n  类静态成员变量：类作用域。\\n\\n2. **所在空间**：都在静态存储区。因为静态变量都在静态存储区，所以下次调用函数的时候还是能取到原来的值\\n\\n3. **生命周期**：静态全局变量、静态局部变量都在静态存储区，直到程序结束才会回收内存。类静态成员变量在静态存储区，当超出类作用域时回收内存\\n\\n### 1.12 nullptr可以调用成员函数吗，为什么？\\n\\n答案：能。\\n原因：因为在编译时对象就绑定了函数地址，和指针空不空没关系。\\n\\n因为在编译时对象就绑定了函数地址，和指针空不空没关系。pAn->breathe();编译的时候，函数的地址就和指针pAn绑定了；调用breath(\\\\*this), this就等于pAn。由于函数中没有需要解引用this的地方，所以函数运行不会出错，但是若用到this，因为this=nullptr，运行出错。\\n\\n```cpp\\n//给出实例\\nclass animal{\\npublic:\\n    void sleep(){ cout << \\\"animal sleep\\\" << endl; }\\n    void breathe(){ cout << \\\"animal breathe haha\\\" << endl; }\\n};\\nclass fish :public animal{\\npublic:\\n    void breathe(){ cout << \\\"fish bubble\\\" << endl; }\\n};\\nint main(){\\n    animal *pAn=nullptr;\\n    pAn->breathe();   // 输出：animal breathe haha\\n    fish *pFish = nullptr;\\n    pFish->breathe(); // 输出：fish bubble\\n    return 0;\\n}  \\n```\\n\\n### 1.13 什么是野指针，怎么产生的，如何避免？\\n\\n1. **概念**：野指针就是指针指向的位置是不可知的（随机的、不正确的、没有明确限制的）\\n2. **产生原因**：释放内存后指针不及时置空（野指针），依然指向了该内存，那么可能出现非法访问的错误。这些我们都要注意避免，如：\\n\\n```cpp\\nchar *p = (char *)malloc(sizeof(char)*100);  \\nstrcpy(p, \\\"Douya\\\");  \\nfree(p);//p所指向的内存被释放，但是p所指的地址仍然不变  \\n...  \\nif (p != NULL){//没有起到防错作用  \\n    strcpy(p, \\\"hello, Douya!\\\");//出错  \\n}  \\n```\\n\\n3. 避免办法：\\n   （1）初始化置为NULL\\n   （2）申请内存后判空\\n   （3）指针释放后置NULL\\n   （4）使用智能指针\\n\\n```cpp\\nint *p = NULL; //初始化置NULL\\np = (int *)malloc(sizeof(int)*n); //申请n个int内存空间  \\nassert(p != NULL); //判空，防错设计\\n//C 库函数 void *realloc(void *ptr, size_t size) 尝试重新调整之前调用 malloc 或 calloc 所分配的 ptr 所指向的内存块的大小。\\n//注意：如果大小为 0，且 ptr 指向一个已存在的内存块，则 ptr 所指向的内存块会被释放，并返回一个空指针。\\np = (int *) realloc(p, 25);//重新分配内存, p 所指向的内存块会被释放并分配一个新的内存地址\\nfree(p);  \\np = NULL; //释放后置空\\n\\nint *p1 = NULL; //初始化置NULL\\ncalloc默认设置分配的内存数据为0\\np1 = (int *)calloc(n, sizeof(int)); //申请n个int内存空间同时初始化为0 \\nassert(p1 != NULL); //判空，防错设计\\nfree(p1);  \\np1 = NULL; //释放后置空\\n\\nint *p2 = NULL; //初始化置NULL\\np2 = new int[n]; //申请n个int内存空间  \\nassert(p2 != NULL); //判空，防错设计\\ndelete []p2;  \\np2 = nullptr; //释放后置空  \\n```\\n\\n### 1.14 说说静态局部变量，全局变量，局部变量的特点，以及使用场景\\n\\n1. **首先从作用域考虑**：C++里作用域可分为6种：全局，局部，类，语句，命名空间和文件作用域。\\n   全局变量：全局作用域+文件作用域，可以通过extern作用于其他非定义的源文件。\\n   静态全局变量 ：全局作用域，所以无法在其他文件中使用。\\n   局部变量：局部作用域，比如函数的参数，函数内的局部变量等等。\\n   静态局部变量 ：局部作用域，只被初始化一次，直到程序结束。\\n2. **从所在空间考虑**：除了局部变量在栈上外，其他都在静态存储区。因为静态变量都在静态存储区，所以下次调用函数的时候还是能取到原来的值。\\n3. **生命周期**： 局部变量在栈上，出了作用域就回收内存；而全局变量、静态全局变量、静态局部变量都在静态存储区，直到程序结束才会回收内存。\\n4. **使用场景**：从它们各自特点就可以看出各自的应用场景，不再赘述。\\n\\n### 1.15 说说内联函数和宏函数的区别\\n\\n区别：\\n\\n1. **宏定义不是函数**，但是使用起来像函数。预处理器用复制宏代码的方式代替函数的调用，省去了函数压栈退栈过程，提高了效率；而**内联函数本质上是一个函数**，内联函数一般用于函数体的代码比较简单的函数，不能包含复杂的控制语句，while、switch，并且内联函数本身不能直接调用自身(内联函数不能用于迭代)。\\n\\n2. **宏定义**是在预编译的时候把所有的宏名用宏体来替换，简单的说就是字符串替换 ；而**内联函数**则是在编译的时候进行代码插入，编译器会在每处调用内联函数的地方直接把内联函数的内容展开，这样可以省去函数的调用的开销，提高效率\\n\\n3. **宏定义**是没有类型检查的，无论对还是错都是直接替换；而**内联函数**在编译的时候会进行类型的检查，内联函数满足函数的性质，比如有返回值、参数列表等\\n\\n  **说人话**：相同点是，宏定义和内联函数，相比于函数体内代码较短，逻辑简单的普通函数而言，避免了出栈入栈的开销，提高了运行效率。不同的在于，宏定义本质不是函数。只是简单的字符替换，而且不会进行检查；内联函数本质是函数，是进行代码插入，有检错（宏定义不会对传入的参数进行检查），有形参，有返回值。\\n\\n  代码示例如下：\\n\\n```cpp\\n//宏定义示例\\n#define MAX(a，b) ((a)>(b)?(a):(b))\\nMAX(a,\\\"Hello\\\")； //错误地比较int和字符串，没有参数类型检查\\n\\n//内联函数示例\\n#include <stdio.h>\\ninline int add(int a, int b){\\n    return (a + b);\\n}\\nint main(void){\\n    int a;\\n    a = add(1, 2);\\n    printf(\\\"a+b=%d\\\\n\\\", a);\\n    return 0;\\n}\\n//以上a = add(1, 2);处在编译时将被展开为：a = (a + b);\\n```\\n\\n1、使用时的一些注意事项：\\n\\n+ 使用宏定义一定要注意错误情况的出现，比如宏定义函数没有类型检查，可能传进来任意类型，从而带来错误，如举例。还有就是括号的使用，宏在定义时要小心处理宏参数，一般用括号括起来，否则容易出现二义性\\n\\n+ inline函数一般用于比较小的，频繁调用的函数，这样可以减少函数调用带来的开销。只需要在函数返回类型前加上关键字inline，即可将函数指定为inline函数。\\n\\n+ 同其它函数不同的是，最好将inline函数定义在头文件，而不仅仅是声明，因为编译器在处理inline函数时，需要在调用点内联展开该函数，所以仅需要函数声明是不够的。\\n\\n2、内联函数使用的条件：\\n\\n+ 内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。以下情况不宜使用内联：\\n\\n+ （1）如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。\\n+ （2）如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。\\n+ 内联不是什么时候都能展开的，一个好的编译器将会根据函数的定义体，自动地取消不符合要求的内联。\\n\\n### 1.16 说说运算符i++和++i的区别\\n\\n先看代码示例：\\n\\n```cpp\\n#include <stdio.h>\\nint main(){\\n    int i = 2;\\n    int j = 2;\\n    j += i++; //先赋值后加\\n    printf(\\\"i= %d, j= %d\\\\n\\\",i, j); //i= 3, j= 4\\n    i = 2;\\n    j = 2;\\n    j += ++i; //先加后赋值\\n    printf(\\\"i= %d, j= %d\\\",i, j); //i= 3, j= 5\\n}\\n```\\n\\n区别：\\n\\n1. 赋值顺序不同：++ i 是先加后赋值；i ++ 是先赋值后加；++i和i++都是分两步完成的。\\n2. 效率不同：<font color=\'red\'>后置++执行速度比前置的慢</font>。\\n3. i++ 不能作为左值，而++i 可以：\\n\\n```cpp\\nint i = 0;\\nint *p1 = &（++i）；//正确\\nint *p2 = &（i++）；//错误\\n++i = 1；//正确\\ni++ = 1；//错误\\n```\\n\\n4. 两者都不是原子操作\\n\\n### 1.17 说说new和malloc的区别，各自底层实现原理\\n\\n1. new是操作符，而malloc是函数。\\n2. new在调用的时候先分配内存，在调用构造函数，释放的时候调用析构函数；而malloc没有构造函数和析构函数。\\n3. malloc需要给定申请内存的大小，返回的指针需要强转；new会调用构造函数，不用指定内存的大小，返回指针不用强转。\\n4. new可以被重载；malloc不行\\n5. new分配内存更直接和安全。\\n6. new发生错误抛出异常，malloc返回null\\n\\n答案解析：\\n\\n**malloc底层实现**：当开辟的空间小于 128K 时，调用 brk（）函数；当开辟的空间大于 128K 时，调用mmap（）。malloc采用的是内存池的管理方式，以减少内存碎片。先申请大块内存作为堆区，然后将堆区分为多个内存块。当用户申请内存时，直接从堆区分配一块合适的空闲快。采用隐式链表将所有空闲块，每一个空闲块记录了一个未分配的、连续的内存地址。\\n\\n**new底层实现**：关键字new在调用构造函数的时候实际上进行了如下的几个步骤：\\n\\n1. 创建一个新的对象\\n2. 将构造函数的作用域赋值给这个新的对象（因此this指向了这个新的对象）\\n3. 执行构造函数中的代码（为这个新对象添加属性）\\n4. 返回新对象\\n\\n### 1.18 说说const和define的区别\\n\\nconst用于定义常量；而define用于定义宏，而宏也可以用于定义常量。都用于常量定义时，它们的\\n区别有：\\n\\n1. const生效于编译的阶段；define生效于预处理阶段。\\n2. const定义的常量，在C语言中是存储在内存中、需要额外的内存空间的；define定义的常量，运行时是直接的操作数，并不会存放在内存中。\\n3. const定义的常量是带类型的；define定义的常量不带类型。因此define定义的常量不利于类型检查。\\n\\n### 1.19 说说C++中函数指针和指针函数的区别\\n\\n1. 定义不同\\n   指针函数本质是一个函数，其返回值为指针。\\n   函数指针本质是一个指针，其指向一个函数。\\n\\n2. 写法不同\\n\\n>指针函数：int \\\\*fun(int x,int y);\\n>\\t   函数指针：int (\\\\*fun)(int x,int y);\\n\\n3. 用法不同\\n\\n用法参考以下代码示例：\\n\\n```cpp\\n//指针函数示例\\ntypedef struct _Data{\\n    int a;\\n    int b;\\n}Data;\\n//指针函数\\nData* f(int a,int b){\\n    Data * data = new Data;\\n    //...\\n    return data;\\n}\\nint main(){\\n    //调用指针函数\\n    Data * myData = f(4,5);\\n    //Data * myData = static_cast<Data*>(f(4,5));\\n   //...\\n}\\n\\n//函数指针示例\\nint add(int x,int y){\\n    return x+y;\\n}\\n//函数指针\\nint (*fun)(int x,int y);\\n//赋值\\nfun = add;\\n//调用\\ncout << \\\"(*fun)(1,2) = \\\" << (*fun)(1,2) ;\\n//输出结果\\n//(*fun)(1,2) =  3\\n```\\n\\n### 1.20 说说const int *a, int const *a, const int a, int *const a, const int *const a分别是什么，有什么特点。\\n\\n参考答案：\\n\\n```cpp\\n1. const int a;     //指的是a是一个常量，不允许修改。\\n2. const int *a;    //a指针所指向的内存里的值不变，即（*a）不变\\n3. int const *a;    //同const int *a;\\n4. int *const a;    //a指针所指向的内存地址不变，即a不变\\n5. const int *const a;   //都不变，即（*a）不变，a也不变\\n```\\n\\n### 1.21 说说使用指针需要注意什么？\\n\\n1. 定义指针时，先初始化为NULL。\\n2. 用malloc或new申请内存之后，应该立即检查指针值是否为NULL。防止使用指针值为NULL的内存。\\n3. 不要忘记为数组和动态内存赋初值。防止将未被初始化的内存作为右值使用。\\n4. 避免数字或指针的下标越界，特别要当心发生“多1”或者“少1”操作\\n5. 动态内存的申请与释放必须配对，防止内存泄漏\\n6. 用free或delete释放了内存之后，立即将指针设置为NULL，防止“野指针”\\n\\n示例代码：\\n\\n```cpp\\n//（1）初始化置NULL\\n//（2）申请内存后判空\\n//（3）指针释放后置NULL\\nint *p = NULL; //初始化置NULL\\np = (int *)malloc(sizeof(int)*n); //申请n个int内存空间  \\nassert(p != NULL); //判空，防错设计\\np = (int *) realloc(p, 25);//重新分配内存, p 所指向的内存块会被释放并分配一个新的内存地址\\nfree(p);  \\np = NULL; //释放后置空\\n\\nint *p1 = NULL; //初始化置NULL\\np1 = (int *)calloc(n, sizeof(int)); //申请n个int内存空间同时初始化为0 \\nassert(p1 != NULL); //判空，防错设计\\nfree(p1);  \\np1 = NULL; //释放后置空\\n\\nint *p2 = NULL; //初始化置NULL\\np2 = new int[n]; //申请n个int内存空间  \\nassert(p2 != NULL); //判空，防错设计\\ndelete []p2;  \\np2 = nullptr; //释放后置空  \\n```\\n\\n### 1.22 说说内联函数和函数的区别，内联函数的作用\\n\\n1. 内联函数比普通函数多了关键字inline\\n2. 内联函数避免了函数调用的开销；普通函数有调用的开销\\n3. 普通函数在被调用的时候，需要寻址（函数入口地址）；内联函数不需要寻址。\\n4. 内联函数有一定的限制，内联函数体要求代码简单，不能包含复杂的结构控制语句；普通函数没有这个要求。\\n\\n**内联函数的作用**：内联函数在调用时，是将调用表达式用内联函数体来替换。避免函数调用的开销。\\n\\n在使用内联函数时，应注意如下几点：　\\n\\n1. 在内联函数内不允许用循环语句和开关语句。　\\n\\n如果内联函数有这些语句，则编译将该函数视同普通函数那样产生函数调用代码,递归函数是不能被用来做内联函数的。内联函数只适合于只有1～5行的小函数。对一个含有许多语句的大函数，函数调用和返回的开销相对来说微不足道，所以也没有必要用内联函数实现。　\\n\\n2. 内联函数的定义必须出现在内联函数第一次被调用之前。\\n\\n### 1.23 简述C++有几种传值方式，之间的区别是什么？\\n\\n传参方式有这三种：**值传递**、**引用传递**、**指针传递**\\n\\n1. 值传递：形参即使在函数体内值发生变化，也不会影响实参的值；\\n2. 引用传递：形参在函数体内值发生变化，会影响实参的值；\\n3. 指针传递：在指针指向没有发生改变的前提下，形参在函数体内值发生变化，会影响实参的值；\\n\\n值传递用于对象时，整个对象会拷贝一个副本，这样效率低；而引用传递用于对象时，不发生拷贝行为，只是绑定对象，更高效；指针传递同理，但不如引用传递安全。\\n\\n```cpp\\n//代码示例\\n#include <iostream>\\nusing namespace std;\\n\\nvoid testfunc(int a, int *b, int &c){//形参a值发生了改变，但是没有影响实参i的值；但形参*b、c的值发生了改变，影响到了实参*j、k的值\\n    a += 1;\\n    (*b) += 1;\\n    c += 1;\\n    printf(\\\"a= %d, b= %d, c= %d\\\\n\\\",a,*b,c);//a= 2, b= 2, c= 2\\n}\\nint main(){\\n       int i = 1;\\n    int a = 1;\\n    int *j = &a;\\n    int k = 1;\\n    testfunc(i, j, k);\\n    printf(\\\"i= %d, j= %d, k= %d\\\\n\\\",i,*j,k);//i= 1, j= 2, k= 2\\n    return 0;\\n}\\n```\\n\\n### 1.24 简述const（星号）和（星号）const的区别\\n\\n代码示例：\\n\\n```cpp\\n//const* 是常量指针，*const 是指针常量\\n\\nint const *a;    //a指针所指向的内存里的值不变，即（*a）不变\\nint *const a;    //a指针所指向的内存地址不变，即a不变\\n```\\n\\n\\n\\n\\n\\n\\n## 2、C/C++内存问题\\n\\n### 2.1 简述一下堆和栈的区别\\n\\n1. **堆栈空间分配不同**。栈由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等；堆一般由程序员分配释放。\\n2. **堆栈缓存方式不同**。栈使用的是一级缓存， 它们通常都是被调用时处于存储空间中，调用完毕立即释放；堆则是存放在二级缓存中，速度要慢些。\\n3. **堆栈数据结构不同**。堆类似数组结构；栈类似栈结构，先进后出。\\n\\n### 2.2 简述C++的内存管理\\n\\n1. 内存分配方式\\n   在C++中，内存分成5个区，他们分别是堆、栈、自由存储区、全局/静态存储区和常量存储区。\\n\\n><font color=\'red\'>栈</font>，在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。\\n>\\n><font color=\'red\'>堆</font>，就是那些由malloc/realloc/calloc分配的内存块，一般一个malloc就要对应一个free。\\n>\\n><font color=\'red\'>自由存储区</font>，就是那些由new分配的内存块，和堆是十分相似的，不过是用delete来结束自己的生命。 【补充说明】\\n>\\n><font color=\'red\'>全局/静态存储区</font>，全局变量和静态变量被分配到同一块内存中\\n>\\n><font color=\'red\'>常量存储区</font>，这是一块比较特殊的存储区，里面存放的是常量，不允许修改。\\n\\n【**补充说明**】：\\n\\n如果我接着问你自由存储区与堆有什么区别，你或许这样回答：“malloc在堆上分配的内存块，使用free释放内存，而new所申请的内存则是在自由存储区上，使用delete来释放。”\\n\\n这样听起来似乎也没错，但如果我接着问：\\n\\n自由存储区与堆是两块不同的内存区域吗？它们有可能相同吗？\\n\\n你可能就懵了。\\n\\n**尽管C++标准没有要求，但很多编译器的new/delete都是以malloc/free为基础来实现的。那么请问：借以malloc实现的new，所申请的内存是在堆上还是在自由存储区上？ 明显，此时的堆与自由存储区所代表的空间是相同的。**\\n\\n如果，你重载了new运算符，使其不在堆上开辟空间，那么对于自动存储区的概念就完全不相同了。\\n\\n从技术上来说，堆（heap）是C语言和操作系统的术语。堆是操作系统所维护的一块特殊内存，它提供了动态分配的功能，当运行程序调用malloc()时就会从中分配，稍后调用free可把内存交还。而自由存储是C++中通过new和delete动态分配和释放对象的抽象概念，通过new来申请的内存区域可称为自由存储区。基本上，所有的C++编译器默认使用堆来实现自由存储，也即是缺省的全局运算符new和delete也许会按照malloc和free的方式来被实现，这时藉由new运算符分配的对象，说它在堆上也对，说它在自由存储区上也正确。但程序员也可以通过重载操作符，改用其他内存来实现自由存储，例如全局变量做的对象池，这时自由存储区就区别于堆了。我们所需要记住的就是：\\n\\n><font color=\'red\'>堆是操作系统维护的一块内存，而自由存储是C++中通过new与delete动态分配和释放对象的抽象概念。堆与自由存储区并不等价。</font>\\n\\n【**补充说明结束**】\\n\\n2. 常见的内存错误和对策\\n\\n（1）内存分配未成功，却使用了它。\\n\\n（2）内存分配虽然成功，但是尚未初始化就引用它。\\n\\n（3）内存分配成功并且已经初始化，但操作越过了内存的边界。\\n\\n（4）忘记了释放内存，造成内存泄露。\\n\\n（5）释放了内存却继续使用它。\\n\\n对策：\\n\\n（1）定义指针时，先初始化为NULL。\\n\\n（2）用malloc或new申请内存之后，应该立即检查指针值是否为NULL。防止使用指针值为NULL的内存。\\n\\n（3）不要忘记为数组和动态内存赋初值。防止将未被初始化的内存作为右值使用。\\n\\n（4）避免数字或指针的下标越界，特别要当心发生“多1”或者“少1”操作\\n\\n（5）动态内存的申请与释放必须配对，防止内存泄漏\\n\\n（6）用free或delete释放了内存之后，立即将指针设置为NULL，防止“野指针”\\n\\n（7）使用智能指针。\\n\\n3. 内存泄漏及解决办法\\n\\n**什么是内存泄露？**\\n\\n简单地说就是申请了一块内存空间，使用完毕后没有释放掉。（1）new和malloc申请资源使用后，没有用delete和free释放；（2）子类继承父类时，父类析构函数不是虚函数。（3）Windows句柄资源使用后没有释放。\\n\\n**怎么检测？**\\n\\n第一：良好的编码习惯，使用了内存分配的函数，一旦使用完毕,要记得使用其相应的函数释放掉。\\n\\n第二：将分配的内存的指针以链表的形式自行管理，使用完毕之后从链表中删除，程序结束时可检查改链表。\\n\\n第三：使用智能指针。\\n\\n第四：一些常见的工具插件，如ccmalloc、Dmalloc、Leaky、Valgrind等等。\\n\\n### 2.3 malloc和局部变量分配在堆还是栈？\\n\\n malloc是在堆上分配内存，需要程序员自己回收内存；局部变量是在栈中分配内存，超过作用域就自动回收。\\n\\n### 2.4 程序有哪些section，分别的作用？程序启动的过程？怎么判断数据分配在栈上还是堆上？\\n\\n![图1](https://s3.bmp.ovh/imgs/2022/08/29/91e07f9f6bdac247.png)\\n\\n**一个程序有哪些section**：\\n\\n如上图，从低地址到高地址，一个程序由**代码段、数据段、 BSS 段**组成。\\n\\n【1】、**数据段**：存放程序中已初始化的全局变量和静态变量的一块内存区域。\\n\\n【2】、**代码段**：存放程序执行代码的一块内存区域。只读，代码段的头部还会包含一些<font color=\'blue\'>只读的**常数变量**</font>。(全局常量和字符串常量位于全局区/静态区还是代码区，还有待商榷)\\n\\n【3】、**BSS 段**：存放程序中未初始化的全局变量和静态变量的一块内存区域。\\n\\n【4】、可执行程序在运行时又会多出两个区域：堆区和栈区。\\n\\n**堆区**：动态申请内存用。堆从低地址向高地址增长。\\n\\n**栈区**：存储局部变量、函数参数值。栈从高地址向低地址增长。是一块连续的空间。\\n\\n【5】、最后还有一个**文件映射区**，位于堆和栈之间。\\n\\n<font color=\'red\'>【警告】：在网上查阅的资料显示，字符串常量存放在全局/静态区，而不是代码区。普通常量也是位于全局/静态区。</font>根据观察和代码验证，字符串数组是变量，存放在栈区；字符串指针是常量，存放在全局/静态区。还有一点，全局/静态区是低地址，栈是高地址。\\n\\n```cpp\\n#include <stdio.h>\\n\\nvoid test01()\\n{\\nchar str1[] = \\\"abcd\\\";\\nchar str2[] = \\\"abcd\\\";\\n \\nconst char str3[] = \\\"abcd\\\";\\nconst char str4[] = \\\"abcd\\\";\\n \\nconst char *str5 = \\\"abcd\\\";\\nconst char *str6 = \\\"abcd\\\";\\n \\nchar *str7 = \\\"abcd\\\";\\nchar *str8 = \\\"abcd\\\";\\n\\nprintf(\\\"str1: %p\\\\n\\\",str1);\\nprintf(\\\"str2: %p\\\\n\\\",str2);\\nprintf(\\\"str3: %p\\\\n\\\",str3);\\nprintf(\\\"str4: %p\\\\n\\\",str4);\\n\\nprintf(\\\"str5: %p\\\\n\\\",str5);\\nprintf(\\\"str6: %p\\\\n\\\",str6);\\nprintf(\\\"str7: %p\\\\n\\\",str7);\\nprintf(\\\"str8: %p\\\\n\\\",str8);\\n}\\n\\nvoid test02()\\n{\\n    char p[]=\\\"hello world!\\\";\\n    printf(\\\"test02 p[] is %p\\\\n\\\",p);\\n\\n    char *p1=\\\"hello world!\\\";\\n    printf(\\\"test02 *p is %p\\\\n\\\",p1);\\n}\\n\\nint main()\\n{\\n    test01();\\n    test02();\\n    return 0;\\n}\\n//输出结果为:\\nstr1: 0061FEEB //栈 char str1[] = \\\"abcd\\\";\\nstr2: 0061FEE6 //栈 char str2[] = \\\"abcd\\\";\\nstr3: 0061FEE1 //栈 const char str3[] = \\\"abcd\\\";\\nstr4: 0061FEDC //栈 const char str4[] = \\\"abcd\\\";\\nstr5: 00405094 //全局/静态区 const char str3[] = \\\"abcd\\\";\\nstr6: 00405094 //全局/静态区 const char *str6 = \\\"abcd\\\";\\nstr7: 00405094 //全局/静态区 char *str7 = \\\"abcd\\\";\\nstr8: 00405094 //全局/静态区 char *str8 = \\\"abcd\\\";\\ntest02 p[] is 0061FEEF //栈 char p[]=\\\"hello world!\\\";\\ntest02 *p is 00405064 //全局/静态区 char *p1=\\\"hello world!\\\";\\n```\\n\\n<font color=\'red\'>注意！</font>字符串指针所表示的是字符串常量，并且全局常量和字符串常量都是位于全局/静态变量区，但是，局部常量位于栈区。演示代码如下所示：\\n\\n```cpp\\n#include <stdio.h>\\n\\n//已初始化的全局变量 --全局区的.data区\\nint g_a=10;\\nint g_b=12;\\n\\n//已初始化的全局静态变量   --全局区的.data区 \\nstatic int s_g_a=10;\\nstatic int s_g_b=10;\\n\\n//全局常量 全局区\\nconst int g_c_a=10;\\nconst int g_c_b=11;\\n\\nvoid test01()\\n{\\n    //静态局部变量  全局区\\n    static int s_a=10;\\n    static int s_b=11;\\n\\n    //局部常量  位于栈区\\n    const int l_g_c_a=10;\\n    const int l_g_c_b=11;\\n\\n    printf(\\\"全局变量g_a的地址是：%p\\\\n\\\",&g_a);\\n    printf(\\\"全局变量g_b的地址是：%p\\\\n\\\",&g_b);\\n\\n    printf(\\\"全局静态变量s_g_a的地址是：%p\\\\n\\\",&s_g_a);\\n    printf(\\\"全局静态变量s_g_b的地址是：%p\\\\n\\\",&s_g_b);\\n\\n    printf(\\\"静态局部变量s_a的地址是：%p\\\\n\\\",&s_a);\\n    printf(\\\"静态局部变量s_b的地址是：%p\\\\n\\\",&s_b);\\n\\n    printf(\\\"全局常量g_a的地址是：%p\\\\n\\\",&g_c_a);\\n    printf(\\\"全局常量g_b的地址是：%p\\\\n\\\",&g_c_b);\\n\\n    printf(\\\"局部常量g_a的地址是：%p\\\\n\\\",&l_g_c_a);\\n    printf(\\\"局部常量g_b的地址是：%p\\\\n\\\",&l_g_c_b);\\n\\n    //字符串常量 全局区\\n    printf(\\\"字符串常量的地址是：%p\\\\n\\\",&\\\"Hello1\\\");\\n    printf(\\\"字符串常量的地址是：%p\\\\n\\\",&\\\"Hello2\\\");\\n}\\n\\nint main()\\n{\\n    test01();\\n    return 0;\\n}\\n//测试结果为：\\n全局变量g_a的地址是：00404004\\n全局变量g_b的地址是：00404008\\n全局静态变量s_g_a的地址是：0040400C\\n全局静态变量s_g_b的地址是：00404010\\n静态局部变量s_a的地址是：00404014\\n静态局部变量s_b的地址是：00404018\\n全局常量g_a的地址是：00405064\\n全局常量g_b的地址是：00405068\\n局部常量g_a的地址是：0061FF0C\\n局部常量g_b的地址是：0061FF08\\n字符串常量的地址是：0040517D\\n字符串常量的地址是：0040519C\\n```\\n\\n<font color=\'red\'>有一种说法</font>：程序只分text区、data区、bss区，当程序运行时才会增加堆区和栈区。（linux下查看代码二进制的elf格式)\\n**程序启动的过程**：\\n1、操作系统首先创建相应的进程并分配私有的进程空间，然后操作系统的加载器负责把可执行文件的数据段和代码段映射到进程的虚拟内存空间中。\\n2、加载器读入可执行程序的导入符号表，根据这些符号表可以查找出该可执行程序的所有依赖的动态链接库。\\n3、加载器针对该程序的每一个动态链接库调用LoadLibrary\\n\\t（1）查找对应的动态库文件，加载器为该动态链接库确定一个合适的基地址。\\n\\t（2）加载器读取该动态链接库的导入符号表和导出符号表，比较应用程序要求的导入符号是否匹配该库的导出符号。\\n\\t（3）针对该库的导入符号表，查找对应的依赖的动态链接库，如有跳转，则跳到3\\n\\t（4）调用该动态链接库的初始化函数\\n4、初始化应用程序的全局变量，对于全局对象自动调用构造函数。\\n5、进入应用程序入口点函数开始执行。\\n**怎么判断数据分配在栈上还是堆上**：首先局部变量分配在栈上；而通过malloc和new申请的空间是在堆上。\\n\\n### 2.5 初始化为0的全局变量在bss还是data\\n\\n答：全局变量和静态变量，初始化了的存入data段，未初始化的存入bss段。\\n\\n### 2.6 请简述一下atomoic内存顺序\\n\\n有六个内存顺序选项可应用于对原子类型的操作：\\n\\nmemory_order_relaxed：在原子类型上的操作以自由序列执行，没有任何同步关系，仅对此操作要求原子性。\\n\\nmemory_order_consume：memory_order_consume只会对其标识的对象保证该对象存储先行于那些需要加载该对象的操作。\\n\\nmemory_order_acquire：使用memory_order_acquire的原子操作，当前线程的读写操作都不能重排到此操作之前。\\n\\nmemory_order_release：使用memory_order_release的原子操作，当前线程的读写操作都不能重排到此操作之后。\\n\\nmemory_order_acq_rel：memory_order_acq_rel在此内存顺序的读-改-写操作既是获得加载又是释放操作。没有操作能够从此操作之后被重排到此操作之前，也没有操作能够从此操作之前被重排到此操作之后。\\n\\nmemory_order_seq_cst：memory_order_seq_cst比std::memory_order_acq_rel更为严格。memory_order_seq_cst不仅是一个\\\"获取释放\\\"内存顺序，它还会对所有拥有此标签的内存操作建立一个单独全序。\\n\\n除非你为特定的操作指定一个顺序选项，否则内存顺序选项对于所有原子类型默认都是memory_order_seq_cst。\\n\\n## 2.7 简述C++中内存对齐的使用场景\\n\\n内存对齐应用于三种数据类型中：struct/class/union\\n\\nstruct/class/union内存对齐原则有四个：\\n\\n>1. 数据成员对齐规则：结构(struct)或联合(union)的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小或者成员的子成员大小的整数倍开始。\\n\\n>2. 结构体作为成员:如果一个结构里有某些结构体成员,则结构体成员要从其内部\\\"最宽基本类型成员\\\"的整数倍地址开始存储。(struct a里存有struct b,b里有char,int ,double等元素,那b应该从8的整数倍开始存储)。\\n\\n>3. 收尾工作:结构体的总大小，也就是sizeof的结果，必须是其内部最大成员的\\\"最宽基本类型成员\\\"的整数倍。不足的要补齐。(基本类型不包括struct/class/uinon)。\\n\\n>4. sizeof(union)，以结构里面size最大元素为union的size，因为在某一时刻，union只有一个成员真正存储于该地址。\\n\\n补充说明：\\n\\n1. **什么是字节对齐**\\n\\n那么什么是字节对齐？在C语言中，结构体是一种复合数据类型，其构成元素既可以是基本数据类型（如int、long、float等）的变量，也可以是一些复合数据类型（如数组、结构体、联合体等）的数据单元。在结构体中，编译器为结构体的每个成员按其自然边界（alignment）分配空间。各个成员按照它们被声明的顺序在内存中顺序存储，第一个成员的地址和整个结构体的地址相同。\\n\\n为了使CPU能够对变量进行快速的访问，变量的起始地址应该具有某些特性，即所谓的“对齐”，比如4字节的int型，其起始地址应该位于4字节的边界上，即起始地址能够被4整除，也即“对齐”跟数据在内存中的位置有关。如果一个变量的内存地址正好位于它长度的整数倍，他就被称做自然对齐。\\n\\n比如在32位cpu下，假设一个整型变量的地址为0x00000004(为4的倍数)，那它就是自然对齐的，而如果其地址为0x00000002（非4的倍数）则是非对齐的。现代计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。\\n\\n2. **为什么要字节对齐**\\n\\n需要字节对齐的根本原因在于CPU访问数据的效率问题。假设上面整型变量的地址不是自然对齐，比如为0x00000002，则CPU如果取它的值的话需要访问两次内存，第一次取从0x00000002-0x00000003的一个short，第二次取从0x00000004-0x00000005的一个short然后组合得到所要的数据，如果变量在0x00000003地址上的话则要访问三次内存，第一次为char，第二次为short，第三次为char，然后组合得到整型数据。\\n\\n而如果变量在自然对齐位置上，则只要一次就可以取出数据。一些系统对对齐要求非常严格，比如sparc系统，如果取未对齐的数据会发生错误，而在x86上就不会出现错误，只是效率下降。\\n\\n各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。比如有些平台每次读都是从偶地址开始，如果一个int型（假设为32位系统）如果存放在偶地址开始的地方，那么一个读周期就可以读出这32bit，而如果存放在奇地址开始的地方，就需要2个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该32bit数据。显然在读取效率上下降很多。\\n\\n3. **字节对齐实例**：\\n\\n```cpp\\nunion example {  \\n    int a[5];  \\n    char b;  \\n    double c;  \\n};  \\nint result = sizeof(example);  \\n/*\\n联合体只取最长的，int a[5]，长度为20，字节对齐为24\\n*/\\n\\nstruct example {  \\n    int a[5];  \\n    char b;  \\n    double c;  \\n}test_struct;\\nint result = sizeof(test_struct);  \\n/*\\nstruct总和 int 20 分为 8 8 4 char 1 double 8 最大对齐8 char补充到int的4 所以为 8+8+8（4+1）+8（double），总计32\\n*/\\n\\nstruct example {  \\n    char b;  \\n    double c;  \\n    int a;  \\n}test_struct;  \\nint result = sizeof(test_struct);  \\n/*\\n字节对齐除了内存起始地址要是数据类型的整数倍以外，还要满足一个条件，那就是占用的内存空间大小需要是结构体中占用最大内存空间的类型的整数倍，所以20不是double（8Byte）的整数倍，我们还要扩充四个字节，最后的结果是result=24\\n*/\\n```\\n\\n## 3、C++面向对象\\n\\n### 3.1 简述一下什么是面向对象\\n\\n1. 面向对象是一种编程思想，把一切东西看成是一个个对象，比如人、耳机、鼠标、水杯等，他们各自都有属性，比如：耳机是白色的，鼠标是黑色的，水杯是圆柱形的等等，把这些对象拥有的属性变量和操作这些属性变量的函数打包成一个类来表示\\n\\n2. 面向过程和面向对象的区别\\n\\n面向过程：根据业务逻辑从上到下写代码\\n\\n面向对象：将数据与函数绑定到一起，进行封装，这样能够更快速的开发程序，减少了重复代码的重写过程\\n\\n### 3.2 简述一下面向对象的三大特征\\n\\n封装、继承、多态\\n\\n1. 封装：将数据和操作数据的方法进行有机结合，隐藏对象的属性和实现细节，仅对外公开接口来和对象进行 交互。封装本质上是一种管理：我们如何管理兵马俑呢？比如如果什么都不管，兵马俑就被随意破坏了。那么我们首先建了一座房子把兵马俑给封装起来。但是我们目的全封装起来，不让别人看。所以我们开放了售票通道，可以买票突破封装在合理的监管机制下进去参观。类也是一样，不想给别人看到的，我们使用protected/private把成员封装起来。开放一些公有的成员函数对成员合理的访问。所以封装本质是一种管理。\\n\\n2. 继承：可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。\\n   三种继承关系：\\n\\n| 继承方式            | private继承     | protected继承     | public继承        |\\n| ------------------- | --------------- | ----------------- | ----------------- |\\n| 基类的private成员   | 不可见          | 不可见            | 不可见            |\\n| 基类的protected成员 | 变为private成员 | 仍为protected成员 | 仍为protected成员 |\\n| 基类的public成员    | 变为private成员 | 变为protected成员 | 仍为protected成员 |\\n\\n3. 多态：用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。实现多态，有二种方式，重写，重载。（虚函数/纯虚函数、函数重载）\\n\\n### 3.3 简述一下C++的重写与重载，以及他们之间的区别\\n\\n1、重写\\n\\n是指派生类中存在重新定义的函数。其函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致。只有函数体不同（花括号内），派生类对象调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有virtual修饰。（虚函数/纯虚函数）\\n\\n```cpp\\n#include<bits/stdC++.h>\\n\\nusing namespace std;\\n\\nclass A\\n{\\npublic:\\n    virtual    void fun()\\n    {\\n        cout << \\\"A\\\";\\n    }\\n};\\nclass B :public A\\n{\\npublic:\\n    virtual void fun()\\n    {\\n        cout << \\\"B\\\";\\n    }\\n};\\nint main(void)\\n{\\n    A* a = new B();\\n    a->fun();//输出B，A类中的fun在B类中重写\\n}\\n```\\n\\n2、重载\\n\\n我们在平时写代码中会用到几个函数但是他们的实现功能相同，但是有些细节却不同。例如：交换两个数的值其中包括（int, float,char,double)这些个类型。在C语言中我们是利用不同的函数名来加以区分。这样的代码不美观而且给程序猿也带来了很多的不便。于是在C++中人们提出了用一个函数名定义多个函数，也就是所谓的函数重载。函数重载是指同一可访问区内被声明的几个具有不同参数列（**参数的类型，个数，顺序不同**）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型。\\n\\n```cpp\\n#include<bits/stdC++.h>\\n\\nusing namespace std;\\n\\nclass A\\n{\\n    void fun() {};\\n    void fun(int i) {};\\n    void fun(int i, int j) {};\\n    void fun1(int i,int j){};\\n};\\n```\\n\\n### 3.4 C++如何实现重写与重载的？在C语言中怎么实现函数重载？\\n\\n答1：重写：在基类的函数前加上virual关键字，就可以在派生类中重写该函数，运行时将会根据对象的实际类型来调用对应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数。\\n\\n>i. 用virtual关键字申明的函数叫做虚函数，虚函数肯定是类的成员函数\\n>ii. 存在虚函数的类都有一个一维的虚函数表叫做虚表，类的对象有一个指向虚表开始的虚指针。虚表是和类对应的，虚表指针是和对象对应的\\n>iii. 多态性是一个接口多种实现，是面向对象的核心，分为类的多态性和函数的多态性\\n>iv. 重写用虚函数来实现，结合动态绑定\\n>v. 纯虚函数是虚函数再加上 = 0\\n>vi. 抽象类是指包括至少一个纯虚函数的类\\n\\n纯虚函数：virtual void fun()=0。即抽象类必须在子类实现这个函数，即先有名称，没有内容，在派生类实现内容。而虚函数可以再子类中不实现。还有，仅含有虚函数的类，并不是抽象类。\\n\\n答2：重载：C++通过命名倾轧（name mangling）技术来改名函数名，区分参数不同的同名函数，命名倾轧是在编译阶段完成的。\\n\\n题外话：C++在编译阶段通过函数名+形参列表的方式来区分函数，所以可以实现函数重载。而C语言在编译时是以函数名来区分函数的，所以C与C++混编的时候会出现错误。可以在++代码中使用extern{}关键字来保证正确编译。\\n\\n答3：c语言中不允许有同名函数，因为编译时函数命名是一样的，不像C++会添加参数类型和返回类型作为函数编译后的名称，进而实现重载。如果要用c语言显现函数重载，可通过以下方式来实现：\\n\\n>1. 使用函数指针来实现，重载的函数不能使用同名称，只是类似的实现了函数重载功能\\n>2. 重载函数使用可变参数，方式如打开文件open函数\\n>3. gcc有内置函数，程序使用编译函数可以实现函数重载\\n\\n一般方式1比较常用，示例代码：\\n\\n```cpp\\n#include<stdio.h>\\n\\nvoid func_int(void * a)\\n{\\n    printf(\\\"%d\\\\n\\\",*(int*)a);  //输出int类型，注意 void * 转化为int\\n}\\n\\nvoid func_double(void * b)\\n{\\n    printf(\\\"%.2f\\\\n\\\",*(double*)b);\\n}\\n\\ntypedef void (*ptr)(void *);  //typedef申明一个函数指针\\n\\nvoid c_func(ptr p,void *param)\\n{\\n     p(param);                //调用对应函数\\n}\\n\\nint main()\\n{\\n    int a = 23;\\n    double b = 23.23;\\n    c_func(func_int,&a);\\n    c_func(func_double,&b);\\n    return 0;\\n}\\n```\\n\\n关于typedef和函数指针的恩怨纠葛，在补充代码如下：\\n\\n```cpp\\n//形式1：返回类型(*函数名)(参数列表)\\n#include <iostream>\\nusing namespace std;\\n//定义一个函数指针pFUN，它指向一个返回类型为char，有一个整型的参数的函数\\nchar (*pFun)(int);\\n//定义一个返回类型为char，参数为int的函数\\n//从指针层面上理解该函数，即函数的函数名实际上是一个指针，\\n//该指针指向函数在内存中的首地址\\nchar glFun(int a)\\n{\\n    cout << a;\\n    //return a;\\n}\\nint main()\\n{\\n//将函数glFun的地址赋值给变量pFun\\n    pFun = glFun;\\n//*pFun”显然是取pFun所指向地址的内容，当然也就是取出了函数glFun()的内容，然后给定参数为2。\\n    (*pFun)(2);\\n    return 0;\\n}\\n\\n//形式2 typedef  返回类型(*新类型)(参数表)\\n// typedef可以让函数指针更直观方便 ,typedef是新定义了一种类型\\ntypedef char (*PTRFUN)(int); \\nPTRFUN pFun; \\nchar glFun(int a){ return;} \\nvoid main() \\n{ \\n    pFun = glFun; \\n    (*pFun)(2); \\n}\\n```\\n\\n对于typedef void(\\\\*T)(void \\\\*)，我们进行一层层的剖析\\n\\n1、首先写成 void(\\\\*T)() 可以看出 T是一个指针，是一个指向返回值为void ，参数为空的类型的函数指针\\n\\n2、在加上(void \\\\*)  为 void(\\\\*T)(void \\\\*)  就变成了一个指向 返回值为void，参数为void \\\\*类型的指针\\n\\n3、在加上上typedef ，加上后，T就不再是一个函数指针了，它代表着一种类型，这种类型可以定义一个 指向 返回值为void，参数为void \\\\*类型的指针 \\n\\n4、``比如 T t;``\\n\\n``void func(void \\\\*)；``\\n\\n``t=func ``\\n\\n### 3.5 构造函数分为哪几种？\\n\\n默认无参构造函数、拷贝构造函数、有参构造函数（初始化列表或函数体内赋值）、<font color=\'red\'>移动构造函数</font>\\n\\n需要注意：有参构造中，可细分为初始化列表he函数体内赋值。初始化列表就是在定义变量的同时就给值，函数体内赋值相当于先定义变量，再给值。当类中有成员变量为常量时，必须使用初始化列表。\\n\\n下面以代码举例，说明拷贝构造函数和移动构造函数：\\n\\n```cpp\\n//拷贝构造函数\\nTest(const Test& t)\\n    {\\n        this->i = t.i;\\n        this->p = new int(*t.p);\\n    }\\n    \\n//移动构造函数\\nclass Example{\\nprivate:\\n\\tstring *ptr;\\npublic:\\n\\t //移动构造函数\\n\\t Example (Example&& x) : ptr(x.ptr) \\n    {\\n        x.ptr = nullptr;\\n    }\\n    //拷贝构造函数 深拷贝  区别在于不会处理形参元素x\\n    Example (Example& x)\\n    {\\n    \\tdelete ptr;\\n    \\tptr=new string(x.ptr);\\n    }\\n    //有参构造函数\\n    Example (const string& str) : ptr(new string(str)) {}\\n    //重载赋值运算符\\n    Example& operator= (Example6&& x) \\n    {\\n        delete ptr; \\n        ptr = x.ptr;\\n        x.ptr=nullptr;\\n        return *this;\\n    }\\n    //打印字符串\\n    const string& content() const {return *ptr;}\\n    //重载加号运算符：\\n    Example operator+(const Example& rhs) \\n    {\\n        return Example(content()+rhs.content());\\n    }\\n}；\\n```\\n\\n### 3.6 只定义析构函数，会自动生成哪些构造函数\\n\\n只定义了析构函数，编译器将自动为我们生成拷贝构造函数和默认构造函数。\\n\\n注意：有了有参的构造了，编译器就不提供默认的构造函数。\\n\\n### 3.7 说说一个类，默认会生成哪些函数\\n\\n定义了一个空类，默认为生成以下几个函数：\\n1、无参构造函数\\n2、拷贝构造函数（默认的为浅拷贝）\\n3、重载赋值运算符\\n4、析构函数（非虚）\\n\\n### 3.8 说说 C++ 类对象的初始化顺序，有多重继承情况下的顺序\\n\\n1. 创建派生类的对象，基类的构造函数优先被调用（也优先于派生类里的成员类）；\\n\\n2. 如果类里面有成员类，成员类的构造函数优先被调用；(也优先于该类本身的构造函数）\\n\\n3. 基类构造函数如果有多个基类，则<font color=\'red\'>构造函数的调用顺序是某类在类派生表中出现的顺序</font>而不是它们在成员初始化表中的顺序；；（即：class 类名：public 基类1，public 基类2）\\n\\n4. 成员类对象构造函数如果有多个成员类对象，则<font color=\'red\'>构造函数的调用顺序是对象在类中被声明的顺序</font>而不是它们出现在成员初始化表中的顺序；（即：类内变量：类名 变量1；类名 变量2）\\n\\n5. 派生类构造函数，作为一般规则派生类构造函数应该不能直接向一个基类数据成员赋值而是把值传递给适当的基类构造函数,否则两个类的实现变成紧耦合的（tightly coupled）将更加难于正确地修改或扩展基类的实现。（基类设计者的责任是提供一组适当的基类构造函数）\\n\\n综上可以得出，初始化顺序：\\n\\n> 父类构造函数–>成员类对象构造函数–>自身构造函数\\n>\\n> 其中成员变量的初始化与声明顺序有关，构造函数的调用顺序是类派生列表中的顺序。\\n>\\n> 析构顺序和构造顺序相反。\\n\\n代码示例：\\n\\n```cpp\\n#include <iostream>\\nusing namespace std;\\nclass Base1 {\\npublic:\\n\\tBase1(int i)\\n\\t{\\n\\t\\tcout << \\\"construting Base1——\\\" << i << endl;\\n\\t}\\n\\tBase1(Base1& b1)\\n\\t{\\n\\t\\tcout << \\\"Base1 Copy constructor\\\" << endl;\\n\\t}\\n\\t~Base1()\\n\\t{\\n\\t\\tcout << \\\"~Base1\\\" << endl;\\n\\t}\\n};\\nclass Base2\\n{\\npublic:\\n\\tBase2(int j)\\n\\t{\\n\\t\\tcout << \\\"constructing Base2——\\\" << j << endl;\\n\\t}\\n\\tBase2(Base2& b2)\\n\\t{\\n\\t\\tcout << \\\"Base2 Copy constructor\\\" << endl;\\n\\t}\\n\\t~Base2()\\n\\t{\\n\\t\\tcout << \\\"~Base2\\\" << endl;\\n\\t}\\n};\\nclass Derived :public Base1, public Base2\\n{\\npublic:\\n\\t//Derived(int a, int b, int c, int d) :Base1(b), member2(c), Base2(a), member1(d)\\n\\tDerived(int a, int b, int c, int d) :Base1(a), member2(b), Base2(c), member1(d)\\n\\t{\\n\\t\\tcout << \\\"constructing Derived\\\" << endl;\\n\\t}\\n\\tDerived(Derived& d) :Base1(d), member2(d), Base2(d), member1(d)\\n\\t{\\n\\t\\tcout << \\\"Derived Copy constructor \\\" << endl;\\n\\t}\\n\\t~Derived()\\n\\t{\\n\\t\\tcout << \\\"~Derived\\\" << endl;\\n\\t}\\nprivate:\\n\\tBase2 member2; \\n\\tBase1 member1;\\n};\\n//在派生类中的，基类构造函数的调用顺序是，先看权限继承方式上的顺序：public Base1, public Base2；\\n//再看成员变量定义的顺序：Base2 member2; Base1 member1;\\nint test()\\n{\\n\\tDerived d1(1, 2, 3, 4);\\n\\tDerived d2(d1);\\n\\treturn 0;\\n}\\nint main()\\n{\\n\\ttest();\\n\\tsystem(\\\"pause\\\");\\n\\treturn 0;\\n}\\n//输出结果为：\\nconstruting Base1——1\\nconstructing Base2——3\\nconstructing Base2——2\\nconstruting Base1——4\\nconstructing Derived\\nBase1 Copy constructor\\nBase2 Copy constructor\\nBase2 Copy constructor\\nBase1 Copy constructor\\nDerived Copy constructor\\n~Derived\\n~Base1\\n~Base2\\n~Base2\\n~Base1\\n~Derived\\n~Base1\\n~Base2\\n~Base2\\n~Base1\\n```\\n\\n### 3.9 简述下向上转型和向下转型\\n\\n1. 子类转换为父类：向上转型，使用dynamic_cast(expression)，这种转换相对来说比较安全不会有数据的丢失；\\n\\n2. 父类转换为子类：向下转型，可以使用强制转换，这种转换时不安全的，会导致数据的丢失，原因是父类的指针或者引用的内存中可能不包含子类的成员的内存。\\n\\n### 3.10 简述下深拷贝和浅拷贝，如何实现深拷贝\\n\\n1. 浅拷贝：又称值拷贝，将源对象的值拷贝到目标对象中去，本质上来说源对象和目标对象共用一份实体，只是所引用的变量名不同，地址其实还是相同的。举个简单的例子，你的小名叫西西，大名叫冬冬，当别人叫你西西或者冬冬的时候你都会答应，这两个名字虽然不相同，但是都指的是你。\\n\\n2. 深拷贝，拷贝的时候先开辟出和源对象大小一样的空间，然后将源对象里的内容拷贝到目标对象中去，这样两个指针就指向了不同的内存位置。并且里面的内容是一样的，这样不但达到了我们想要的目的，还不会出现问题，两个指针先后去调用析构函数，分别释放自己所指向的位置。即为每次增加一个指针，便申请一块新的内存，并让这个指针指向新的内存，深拷贝情况下，不会出现重复释放同一块内存的错误。\\n\\n### 3.11 简述一下C++中的多态\\n\\n由于派生类重写基类方法，然后用基类引用指向派生类对象，调用方法时候会进行动态绑定，这就是多态。 多态分为静态多态和动态多态：\\n\\n1. 静态多态：编译器在编译期间完成的，编译器会根据实参类型来推断该调用哪个函数，如果有对应的函数，就调用，没有则在编译时报错。例如：\\n\\n```cpp\\ninclude<iostream>\\nusing namespace std;\\n\\nint Add(int a,int b)//1\\n{\\n    return a+b;\\n}\\n\\nchar Add(char a,char b)//2\\n{\\n    return a+b;\\n}\\n\\nint main()\\n{\\n    cout<<Add(666,888)<<endl;//1\\n    cout<<Add(\'1\',\'2\');//2\\n    return 0;\\n}\\n```\\n\\n静态多态，就是在编译阶段就实现的多态。\\n\\n2. 动态多态：其实要实现动态多态，需要几个条件----即动态绑定条件：\\n\\n> 虚函数，基类必须含有虚函数，派生类必须重写虚函数；\\n> 通过基类指针或引用来调用虚函数\\n\\n### 3.12 为什么要虚析构，为什么不能虚构造？\\n\\n1. 为什么要虚析构：将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。如果基类的析构函数不是虚函数，在特定情况下会导致派生类无法被析构。\\n\\n> i. 用派生类类型指针绑定派生类实例，析构的时候，不管基类析构函数是不是虚函数，都会正常析构\\n>\\n> ii. 用基类类型指针绑定派生类实例，析构的时候，如果基类析构函数不是虚函数，则只会析构基类，不会析构派生类对象，从而造成内存泄漏。为什么会出现这种现象呢，个人认为析构的时候如果没有虚函数的动态绑定功能，就只根据指针的类型来进行的，而不是根据指针绑定的对象来进行，所以只是调用了基类的析构函数；如果基类的析构函数是虚函数，则析构的时候就要根据指针绑定的对象来调用对应的析构函数了。\\n\\nC++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。\\n\\n2. 为什么不能虚构造？\\n\\ni. 从存储空间角度：虚函数对应一个vtable,这个表的地址是存储在对象的内存空间的。如果将构造函数设置为虚函数，就需要到vtable 中调用，可是对象还没有实例化，没有内存空间分配，如何调用。（悖论）\\n\\nii. 从使用角度：虚函数主要用于在信息不全的情况下，能使重载的函数得到对应的调用。构造函数本身就是要初始化实例，那使用虚函数也没有实际意义呀。所以构造函数没有必要是虚函数。虚函数的作用在于通过父类的指针或者引用来调用它的时候能够变成调用子类的那个成员函数。而构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数。\\n\\niii. 从实现上看，vtable 在构造函数调用后才建立，因而构造函数不可能成为虚函数。从实际含义上看，在调用构造函数时还不能确定对象的真实类型（因为子类会调父类的构造函数）；而且构造函数的作用是提供初始化，在对象生命期只执行一次，不是对象的动态行为，也没有太大的必要成为虚函数。\\n\\n### 3.13 说说模板类是在什么时候实现的\\n\\n1. 模板实例化：模板的实例化分为显式实例化和隐式实例化，前者是研发人员明确的告诉模板应该使用什么样的类型去生成具体的类或函数，后者是在编译的过程中由编译器来决定使用什么类型来实例化一个模板。不管是显式实例化或隐式实例化，最终生成的类或函数完全是按照模板的定义来实现的\\n\\n2. 模板具体化：当模板使用某种类型实例化后生成的类或函数不能满足需要时，可以考虑对模板进行具体化。具体化时可以修改原模板的定义，当使用该类型时，按照具体化后的定义实现，具体化相当于对某种类型进行特殊处理。<font color=\'blue\'>模板的具体化，就是重写模板</font>>\\n\\n代码示例：\\n\\n```cpp\\n#include <iostream>\\nusing namespace std;\\n\\n// #1 模板定义\\ntemplate<class T>\\nstruct TemplateStruct\\n{\\n    TemplateStruct()\\n    {\\n        cout << sizeof(T) << endl;\\n    }\\n};\\n\\n// #2 模板显示实例化\\ntemplate struct TemplateStruct<int>;\\n\\n// #3 模板具体化\\ntemplate<> struct TemplateStruct<double>\\n{\\n    TemplateStruct() {\\n        cout << \\\"--8--\\\" << endl;\\n    }\\n};\\n\\nint main()\\n{\\n    TemplateStruct<int> intStruct;\\n    TemplateStruct<double> doubleStruct;\\n\\n    // #4 模板隐式实例化\\n    TemplateStruct<char> llStruct;\\n}\\n//输出结果为：\\n4\\n--8--\\n1\\n```\\n\\n### 3.14 说说类继承时，派生类对不同关键字修饰的基类方法的访问权限\\n\\n类中的成员可以分为三种类型，分别为public成员、protected成员、public成员。类中可以直接访问自己类的public、protected、private成员，但类对象只能访问自己类的public成员。\\n\\n1. public继承：派生类可以访问基类的public、protected成员，不可以访问基类的private成员；\\n   派生类对象可以访问基类的public成员，不可以访问基类的protected、private成员。\\n\\n2. protected继承：派生类可以访问基类的public、protected成员，不可以访问基类的private成员；\\n   派生类对象不可以访问基类的public、protected、private成员。\\n\\n3. private继承：派生类可以访问基类的public、protected成员，不可以访问基类的private成员；\\n   派生类对象不可以访问基类的public、protected、private成员。\\n\\n### 3.15 简述一下移动构造函数，什么库用到了这个函数？\\n\\nC++11中新增了移动构造函数。与拷贝类似，移动也使用一个对象的值设置另一个对象的值。但是，又与拷贝不同的是，移动实现的是对象值真实的转移（源对象到目的对象）：源对象将丢失其内容，其内容将被目的对象占有。移动操作的发生的时候，是当移动值的对象是未命名的对象的时候。这里未命名的对象就是那些临时变量，甚至都不会有名称。典型的未命名对象就是函数的返回值或者类型转换的对象。使用临时对象的值初始化另一个对象值，不会要求对对象的复制：因为临时对象不会有其它使用，因而，它的值可以被移动到目的对象。做到这些，就要使用移动构造函数和移动赋值：当使用一个临时变量对对象进行构造初始化的时候，调用移动构造函数。类似的，使用未命名的变量的值赋给一个对象时，调用移动赋值操作。\\n\\n移动操作的概念对对象管理它们使用的存储空间很有用的，诸如对象使用new和delete分配内存的时候。在这类对象中，拷贝和移动是不同的操作：从A拷贝到B意味着，B分配了新内存，A的整个内容被拷贝到为B分配的新内存上。\\n\\n而从A移动到B意味着分配给A的内存转移给了B，没有分配新的内存，它仅仅包含简单地拷贝指针。\\n\\n看下面的例子：\\n\\n```cpp\\n// 移动构造函数和赋值\\n#include <iostream>\\n#include <string>\\nusing namespace std;\\n\\nclass Example6 {\\nprivate:\\n    string* ptr;\\npublic:\\n    Example6 (const string& str) : ptr(new string(str)) {}\\n    ~Example6 () {delete ptr;}\\n    // 移动构造函数，参数x不能是const Pointer&& x，\\n    // 因为要改变x的成员数据的值；\\n    // C++98不支持，C++0x（C++11）支持\\n    Example6 (Example6&& x) : ptr(x.ptr) \\n    {\\n        x.ptr = nullptr;\\n    }\\n    // move assignment\\n    Example6& operator= (Example6&& x) \\n    {\\n        delete ptr; \\n        ptr = x.ptr;\\n        x.ptr=nullptr;\\n        return *this;\\n    }\\n    // access content:\\n    const string& content() const {return *ptr;}\\n    // addition:\\n    Example6 operator+(const Example6& rhs) \\n    {\\n        return Example6(content()+rhs.content());\\n    }\\n};\\nint main () {\\n    Example6 foo(\\\"Exam\\\");           // 构造函数\\n    Example6 bar(move(foo));     // 移动构造函数\\n                                // 调用move之后，foo变为一个右值引用变量，\\n                                // 此时，foo所指向的字符串已经被\\\"掏空\\\"，\\n                                // 所以此时不能再调用foo\\n\\tExample6 bar2 = Example6(\\\"ple\\\"); // 拷贝构造函数\\n    bar = bar+ bar2;             // 移动赋值，在这儿\\\"=\\\"号右边的加法操作，\\n                                // 产生一个临时值，即一个右值\\n                                 // 所以此时调用移动赋值语句\\n    cout << \\\"bar\'s content: \\\" << bar.content() << \'\\\\n\';\\n    return 0;\\n}\\n//说明：std::move()函数时C++11新增的，用于将一个左值引用转换为右值引用。\\n//输出结果为：bar`s content: Example\\n//附加说明：本例中，如何调用重载赋值运算符：Example6 str2=move(bar);此时，bar字符串被删除内存，str2=Example\\n```\\n\\n### 3.16 请你回答一下 C++ 类内可以定义引用数据成员吗？\\n\\nC++类内可以定义引用成员变量，但要遵循以下三个规则：\\n\\n1. 不能用默认构造函数初始化，必须提供构造函数，用初始化列表的方式来初始化引用成员变量。否则会造成引用未初始化错误。\\n\\n2. 构造函数的形参也必须是引用类型。\\n\\n3. 不能在构造函数里初始化，必须在初始化列表中进行初始化。\\n\\n### 3.17 简述一下什么是常函数，有什么作用\\n\\n类的成员函数后面加 const，表明这个函数不会对这个类对象的数据成员（准确地说是非静态数据成员）作任何改变。在设计类的时候，一个原则就是对于不改变数据成员的成员函数都要在后面加const，而对于改变数据成员的成员函数不能加 const。所以 const 关键字对成员函数的行为作了更明确的限定：有 const 修饰的成员函数（指 const 放在函数参数表的后面，而不是在函数前面或者参数表内），只能读取数据成员，不能改变数据成员；没有 const 修饰的成员函数，对数据成员则是可读可写的。除此之外，在类的成员函数后面加 const 还有什么好处呢？那就是**常量（即 const）对象可以调用 const 成员函数，而不能调用非const修饰的函数**。正如非const类型的数据可以给const类型的变量赋值一样，反之则不成立。\\n\\n```cpp\\n#include<iostream>\\nusing namespace std;\\n\\nclass CStu\\n{\\npublic:\\n    int a;\\n    CStu()\\n    {\\n        a = 12;\\n    }\\n\\n    void Show() const\\n    {\\n        //a = 13; //常函数不能修改数据成员\\n        cout <<a << \\\"I am show()\\\" << endl;\\n    }\\n};\\n\\nint main()\\n{\\n    CStu st;\\n    st.Show();\\n    system(\\\"pause\\\");\\n    return 0;\\n}\\n```\\n\\n### 3.18 说说什么是虚继承，解决什么问题，如何实现？\\n\\n虚继承是解决C++多重继承问题的一种手段，从不同途径继承来的同一基类，会在子类中存在多份拷贝。这将存在两个问题：其一，浪费存储空间；第二，存在二义性问题，通常可以将派生类对象的地址赋值给基类对象，实现的具体方式是，将基类指针指向继承类（继承类有基类的拷贝）中的基类对象的地址，但是多重继承可能存在一个基类的多份拷贝，这就出现了二义性。虚继承可以解决多种继承前面提到的两个问题（即菱形继承问题）\\n\\n```cpp\\n#include<iostream>\\nusing namespace std;\\nclass A{\\npublic:\\n    int _a;\\n};\\nclass B :virtual public A\\n{\\npublic:\\n    int _b;\\n};\\nclass C :virtual public A\\n{\\npublic:\\n    int _c;\\n};\\nclass D :public B, public C\\n{\\npublic:\\n    int _d;\\n};\\n//菱形继承和菱形虚继承的对象模型\\nint main()\\n{\\n    D d;\\n    d.B::_a = 1;\\n    d.C::_a = 2;\\n    d._b = 3;\\n    d._c = 4;\\n    d._d = 5;\\n    cout << sizeof(D) << endl;\\n    return 0;\\n}\\n```\\n\\n分别从菱形继承和虚继承来分析：\\n\\n>菱形继承中A在B,C,D,中各有一份，虚继承中，A共享。\\n>\\n>上面的虚继承表实际上是一个指针数组。B、C实际上是虚基表指针，指向虚基表。\\n>\\n>虚基表：存放相对偏移量，用来找虚基类\\n\\n### 3.19 简述一下虚函数和纯虚函数，以及实现原理\\n\\n1. C++中的虚函数的作用主要是实现了多态的机制。关于多态，简而言之就是用父类型的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。这种技术可以让父类的指针有“多种形态”，这是一种泛型技术。**如果调用非虚函数，则无论实际对象是什么类型，都执行基类类型所定义的函数**。非虚函数总是在编译时根据调用该函数的对象，引用或指针的类型而确定。如果调用虚函数，则直到运行时才能确定调用哪个函数，运行的虚函数是引用所绑定或指针所指向的对象所属类型定义的版本。虚函数必须是基类的非静态成员函数。虚函数的作用是实现动态联编，也就是在程序的运行阶段动态地选择合适的成员函数，在定义了虚函数后，可以在基类的派生类中对虚函数重新定义，在派生类中重新定义的函数应与虚函数具有相同的形参个数和形参类型。以实现统一的接口，不同定义过程。如果在派生类中没有对虚函数重新定义，则它继承其基类的虚函数。\\n\\n\\n```cpp\\nclass Person{\\n    public:\\n        //虚函数\\n        virtual void GetName(){\\n            cout<<\\\"PersonName:xiaosi\\\"<<endl;\\n        };\\n};\\nclass Student:public Person{\\n    public:\\n        void GetName(){\\n            cout<<\\\"StudentName:xiaosi\\\"<<endl;\\n        };\\n};\\nint main(){\\n    //指针\\n    Person *person = new Student();\\n    //基类调用子类的函数\\n    person->GetName();//StudentName:xiaosi\\n}\\n```\\n\\n虚函数（Virtual Function）是通过一张虚函数表（Virtual Table）来实现的。简称为V-Table。在这个表中，主是要一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，保证其真实反应实际的函数。这样，在有虚函数的类的实例中这个表被分配在了这个实例的内存中，所以，当我们用父类的指针来操作一个子类的时候，这张虚函数表就显得尤为重要了，它就像一个地图一样，指明了实际所应该调用的函数。\\n\\n\\n2. 纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加“=0” virtualvoid GetName() =0。在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。为了解决上述问题，将函数定义为纯虚函数，则编译器要求在派生类中必须予以重写以实现多态性。同时含有纯虚拟函数的类称为抽象类，它不能生成对象。这样就很好地解决了上述两个问题。将函数定义为纯虚函数能够说明，该函数为后代类型提供了可以覆盖的接口，但是这个类中的函数绝不会调用。声明了纯虚函数的类是一个抽象类。所以，用户不能创建类的实例，只能创建它的派生类的实例。必须在继承类中重新声明函数（不要后面的＝0）否则该派生类也不能实例化，而且它们在抽象类中往往没有定义。定义纯虚函数的目的在于，使派生类仅仅只是继承函数的接口。纯虚函数的意义，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但类无法为纯虚函数提供一个合理的缺省实现。所以类纯虚函数的声明就是在告诉子类的设计者，“你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它”。\\n\\n```cpp\\n//抽象类\\nclass Person{\\n    public:\\n        //纯虚函数\\n        virtual void GetName()=0;\\n};\\nclass Student:public Person{\\n    public:\\n        Student(){\\n        };\\n        void GetName(){\\n            cout<<\\\"StudentName:xiaosi\\\"<<endl;\\n        };\\n};\\nint main(){\\n    Student student;\\n}\\n```\\n\\n### 3.20 说说纯虚函数能实例化吗，为什么？派生类要实现吗，为什么？\\n\\n1. 纯虚函数不可以实例化，但是可以用其派生类实例化，示例如下：\\n\\n```cpp\\nclass Base\\n{\\npublic:\\n    virtual void func() = 0;\\n};\\n```\\n\\n```cpp\\n #include<iostream>\\n\\n using namespace std;\\n\\n class Base\\n {\\n public:\\n     virtual void func() = 0;\\n };\\n\\n class Derived :public Base\\n {\\n public:\\n     void func() override\\n     {\\n         cout << \\\"哈哈\\\" << endl;\\n     }\\n };\\n\\n int main()\\n {\\n     Base *b = new Derived();\\n     b->func();\\n\\n     return 0;\\n }\\n\\n```\\n\\n2. 虚函数的原理采用 vtable。类中含有纯虚函数时，其vtable 不完全，有个空位。\\n   即“纯虚函数在类的vtable表中对应的表项被赋值为0。也就是指向一个不存在的函数。由于编译器绝对不允许有调用一个不存在的函数的可能，所以该类不能生成对象。在它的派生类中，除非重写此函数，否则也不能生成对象。”\\n\\n   所以纯虚函数不能实例化。\\n\\n3. 纯虚函数是在基类中声明的虚函数，它要求任何派生类都要定义自己的实现方法，以实现多态性。\\n\\n4. 定义纯虚函数是为了实现一个接口，用来规范派生类的行为，也即规范继承这个类的程序员必须实现这个函数。派生类仅仅只是继承函数的接口。纯虚函数的意义在于，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但基类无法为纯虚函数提供一个合理的缺省实现。所以类纯虚函数的声明就是在告诉子类的设计者，“你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它”。\\n\\n### 3.21 说说C++中虚函数与纯虚函数的区别\\n\\n答：\\n\\n1. 虚函数和纯虚函数可以定义在同一个类中，含有纯虚函数的类被称为抽象类，而只含有虚函数的类不能被称为抽象类。\\n\\n2. 虚函数可以被直接使用，也可以被子类重载以后，以多态的形式调用，而纯虚函数必须在子类中实现该函数才可以使用，因为纯虚函数在基类有声明而没有定义。\\n\\n3. 虚函数和纯虚函数都可以在子类中被重载，以多态的形式被调用。\\n\\n4. 虚函数和纯虚函数通常存在于抽象基类之中，被继承的子类重载，目的是提供一个统一的接口。\\n\\n5. 虚函数的定义形式：`virtual{}`;纯虚函数的定义形式：`virtual {} = 0`;在虚函数和纯虚函数的定义中不能有static标识符，原因很简单，被static修饰的函数在编译时要求前期绑定,然而虚函数却是动态绑定，而且被两者修饰的函数生命周期也不一样。\\n\\n举个虚函数的例子：\\n\\n```cpp\\nclass A\\n{\\npublic:\\n    virtual void foo()\\n    {\\n        cout<<\\\"A::foo() is called\\\"<<endl;\\n    }\\n};\\nclass B:public A\\n{\\npublic:\\n    void foo()\\n    {\\n        cout<<\\\"B::foo() is called\\\"<<endl;\\n    }\\n};\\nint main(void)\\n{\\n    A *a = new B();\\n    a->foo();   // 在这里，a虽然是指向A的指针，但是被调用的函数(foo)却是B的!\\n    return 0;\\n}\\n```\\n\\n这个例子是虚函数的一个典型应用，通过这个例子，也许你就对虚函数有了一些概念。它虚就虚在所谓“推迟联编”或者“动态联编”上，一个类函数的调用并不是在编译时刻被确定的，而是在运行时刻被确定的。由于编写代码的时候并不能确定被调用的是基类的函数还是哪个派生类的函数，所以被成为“虚”函数。\\n\\n虚函数只能借助于指针或者引用来达到多态的效果。\\n\\n\\n2. 纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加“=0” 。形如`virtual void funtion1()=0`\\n\\n为了方便使用多态特性，我们常常需要在基类中定义虚拟函数。\\n\\n在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。\\n\\n为了解决上述问题，引入了纯虚函数的概念，将函数定义为纯虚函数（方法：virtual ReturnType Function()= 0;），则编译器要求在派生类中必须予以重写以实现多态性。同时含有纯虚拟函数的类称为抽象类，它不能生成对象。这样就很好地解决了上述两个问题。\\n声明了纯虚函数的类是一个抽象类。所以，用户不能创建类的实例，只能创建它的派生类的实例。\\n\\n纯虚函数最显著的特征是：它们必须在继承类中重新声明函数（不要后面的＝0，否则该派生类也不能实例化），而且它们在抽象类中往往没有定义。\\n\\n定义纯虚函数的目的在于，使派生类仅仅只是继承函数的接口。\\n\\n纯虚函数的意义，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但类无法为纯虚函数提供一个合理的缺省实现。所以类纯虚函数的声明就是在告诉子类的设计者，“你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它”。\\n\\n### 3.22 说说 C++ 中什么是菱形继承问题，如何解决\\n\\n使用虚继承来解决该问题\\n\\n```cpp\\nclass Tiger : virtual public Animal { /* ... */ };\\nclass Lion : virtual public Animal { /* ... */ }\\n```\\n\\n### 3.23 请问构造函数中的能不能调用虚方法\\n\\n不要在构造函数中调用虚方法，从语法上讲，调用完全没有问题，但是从效果上看，往往不能达到需要的目的。\\n\\n派生类对象构造期间进入基类的构造函数时，对象类型变成了基类类型，而不是派生类类型。\\n\\n同样，进入基类析构函数时，对象也是基类类型。\\n\\n所以，虚函数始终仅仅调用基类的虚函数（如果是基类调用虚函数），不能达到多态的效果，所以放在构造函数中是没有意义的，而且往往不能达到本来想要的效果。\\n\\n### 3.24 请问拷贝构造函数的参数是什么传递方式，为什么\\n\\n1. 拷贝构造函数的参数必须使用引用传递\\n\\n2. 如果拷贝构造函数中的参数不是一个引用，即形如CClass(const CClass c_class)，那么就相当于采用了传值的方式(pass-by-value)，而传值的方式会调用该类的拷贝构造函数，从而造成无穷递归地调用拷贝构造函数。因此拷贝构造函数的参数必须是一个引用。\\n\\n需要澄清的是，传指针其实也是传值，如果上面的拷贝构造函数写成CClass(const CClass\\\\* c_class)，也是不行的。事实上，只有传引用不是传值外，其他所有的传递方式都是传值。\\n\\n### 3.25 如何理解抽象类？\\n\\n1. 抽象类的定义如下：\\n\\n纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加“=0”，有虚函数的类就叫做抽象类。\\n\\n2. 抽象类有如下几个特点：\\n\\n1）抽象类只能用作其他类的基类，不能建立抽象类对象。\\n\\n2）抽象类不能用作参数类型、函数返回类型或显式转换的类型。\\n\\n3）可以定义指向抽象类的指针和引用，此指针可以指向它的派生类，进而实现多态性。\\n\\n### 3.26 什么是多态？除了虚函数，还有什么方式能实现多态？\\n\\n1. 多态是面向对象的重要特性之一，它是一种行为的封装，就是不同对象对同一行为会有不同的状态。(举例 : 学生和成人都去买票时,学生会打折,成人不会)\\n\\n2. 多态是以封装和继承为基础的。在C++中多态分为静态多态（早绑定）和动态多态（晚绑定）两种，其中动态多态是通过虚函数实现，静态多态通过函数重载实现，代码如下：\\n\\n```cpp\\nclass A\\n{\\npublic:    \\n    void do(int a);    \\n    void do(int a, int b);\\n};\\n```\\n\\n### 3.27 简述一下虚析构函数，什么作用\\n\\n1. 虚析构函数，是将基类的析构函数声明为virtual，举例如下：\\n\\n```cpp\\nclass TimeKeeper\\n{\\npublic:    \\n    TimeKeeper() {}        \\n    virtual ~TimeKeeper() {}    \\n};\\n```\\n\\n2. 虚析构函数的主要作用是防止内存泄露。\\n\\n定义一个基类的指针p，在delete p时，如果基类的析构函数是虚函数，这时只会看p所赋值的对象，如果p赋值的对象是派生类的对象，就会调用派生类的析构函数（毫无疑问，在这之前也会先调用基类的构造函数，在调用派生类的构造函数，然后调用派生类的析构函数，基类的析构函数，所谓先构造的后释放）；如果p赋值的对象是基类的对象，就会调用基类的析构函数，这样就不会造成内存泄露。\\n\\n如果基类的析构函数不是虚函数，在delete p时，调用析构函数时，只会看指针的数据类型，而不会去看赋值的对象，这样就会造成内存泄露。\\n\\n说明：\\n我们创建一个TimeKeeper基类和一些及其它的派生类作为不同的计时方法：\\n\\n```cpp\\nclass TimeKeeper\\n{\\npublic:\\n    TimeKeeper() {}\\n    ~TimeKeeper() {}  //非virtual的\\n};\\n\\n//都继承与TimeKeeper\\nclass AtomicClock :public TimeKeeper{};\\nclass WaterClock :public TimeKeeper {};\\nclass WristWatch :public TimeKeeper {};\\n```\\n\\n如果客户想要在程序中使用时间，不想操作时间如何计算等细节，这时候我们可以设计factory（工厂）函数，让函数返回指针指向一个计时对象。该函数返回一个基类指针，这个基类指针是指向于派生类对象的\\n\\n```cpp\\nTimeKeeper* getTimeKeeper()\\n{\\n    //返回一个指针，指向一个TimeKeeper派生类的动态分配对象\\n}\\n```\\n\\n因为函数返回的对象存在于堆中，因此为了在不使用时我们需要使用释放该对象（delete）\\n\\n```cpp\\nTimeKeeper* ptk = getTimeKeeper();\\ndelete ptk;\\n```\\n\\n**此处基类的析构函数是非virtual的，因此通过一个基类指针删除派生类对象是错误的**\\n\\n<font color=\'red\'>解决办法</font>： 将基类的析构函数改为virtual就正确了\\n\\n```cpp\\nclass TimeKeeper\\n{\\npublic:\\n    TimeKeeper() {}\\n    virtual ~TimeKeeper() {}\\n};\\n```\\n\\n声明为virtual之后，通过基类指针删除派生类对象就会释放整个对象（基类+派生类）\\n\\n### 3.28 说说什么是虚基类，可否被实例化？\\n\\n1. 在被继承的类前面加上virtual关键字，这时被继承的类称为虚基类，代码如下：\\n\\n```cpp\\nclass A\\nclass B1:public virtual A;\\nclass B2:public virtual A;\\nclass D:public B1,public B2;\\n```\\n\\n2. 虚继承的类可以被实例化，举例如下：\\n\\n```cpp\\nclass Animal {/* ... */ };\\nclass Tiger : virtual public Animal { /* ... */ };\\nclass Lion : virtual public Animal { /* ... */ }\\n```\\n\\n```cpp\\nint main( )\\n{\\nLiger lg ;\\n/*既然我们已经在Tiger和Lion类的定义中声明了\\\"virtual\\\"关键字，于是下面的代码编译OK */\\nint weight = lg.getWeight();\\n}\\n```\\n\\n### 3.29  简述一下拷贝赋值和移动赋值？\\n\\n1. 拷贝赋值是通过拷贝构造函数来赋值，在创建对象时，使用同一类中之前创建的对象来初始化新创建的对象。\\n\\n2. 移动赋值是通过移动构造函数来赋值，二者的主要区别在于\\n\\n1）拷贝构造函数的形参是一个左值引用，而移动构造函数的形参是一个右值引用；\\n\\n2）拷贝构造函数完成的是整个对象或变量的拷贝，而移动构造函数是生成一个指针指向源对象或变量的地址，接管源对象的内存，相对于大量数据的拷贝**节省时间和内存空间**。\\n\\n### 3.30 仿函数了解吗？有什么作用\\n\\n1. 仿函数（functor）又称为函数对象（function object）**是一个能行使函数功能的类**。仿函数的语法几乎和我们普通的函数调用一样，不过作为仿函数的类，都<font color=\'red\'>必须重载operator()运算符</font>，举个例子：\\n\\n ```cpp\\n class Func{\\n     public:\\n         void operator() (const string& str) const {\\n             cout<<str<<endl;\\n         }\\n };\\n Func myFunc;\\n myFunc(\\\"helloworld!\\\");\\n//输出：\\nhelloworld!\\n ```\\n\\n2. 仿函数既能想普通函数一样传入给定数量的参数，还能存储或者处理更多我们需要的有用信息。我们可以举个例子：\\n\\n假设有一个`vector<string>`，你的任务是统计长度小于5的string的个数，如果使用count_if函数的话，你的代码可能长成这样：\\n\\n```cpp\\n  bool LengthIsLessThanFive(const string& str) {\\n       return str.length()<5;   \\n  }\\nint res=count_if(vec.begin(), vec.end(), LengthIsLessThanFive);\\n其中count_if函数的第三个参数是一个函数指针，返回一个bool类型的值。一般的，如果需要将特定的阈值长度也传入的话，我们可能将函数写成这样：\\n```cpp\\n bool LenthIsLessThan(const string& str, int len) {\\n      return str.length()<len;\\n  }\\n```\\n\\n这个函数看起来比前面一个版本更具有一般性，但是他不能满足count_if函数的参数要求：count_if要求的是unary function（仅带有一个参数）作为它的最后一个参数。如果我们使用仿函数，是不是就豁然开朗了呢：\\n\\n```cpp\\n  class ShorterThan {\\n      public:\\n          explicit ShorterThan(int maxLength) : length(maxLength) {}\\n          bool operator() (const string& str) const {\\n              return str.length() < length;\\n          }\\n      private:\\n          const int length;\\n  };\\n```\\n\\n### 3.31 C++ 中哪些函数不能被声明为虚函数？\\n\\n常见的不不能声明为虚函数的有：**普通函数（非成员函数），静态成员函数，内联成员函数，构造函数，友元函数**。\\n\\n1. 为什么C++不支持普通函数为虚函数？\\n\\n普通函数（非成员函数）只能被overload(重载)，不能被override(重写)，声明为虚函数也没有什么意思，因此编译器会在编译时绑定函数。\\n\\n2. 为什么C++不支持构造函数为虚函数？\\n\\n这个原因很简单，主要是从语义上考虑，所以不支持。因为构造函数本来就是为了明确初始化对象成员才产生的，然而virtual function主要是为了再不完全了解细节的情况下也能正确处理对象。另外，virtual函数是在不同类型的对象产生不同的动作，现在对象还没有产生，如何使用virtual函数来完成你想完成的动作。（这不就是典型的悖论）\\n\\n构造函数用来创建一个新的对象,而虚函数的运行是建立在对象的基础上,在构造函数执行时,对象尚未形成,所以不能将构造函数定义为虚函数\\n\\n3. 为什么C++不支持内联成员函数为虚函数？\\n\\n内联函数就是为了在代码中直接展开，减少函数调用花费的代价，而虚函数是为了在继承后对象能够准确的执行自己的动作，这是不可能统一的。（再说了，inline函数在编译时被展开，虚函数在运行时才能动态的绑定函数）\\n\\n内联函数是在编译时期展开,而虚函数的特性是运行时才动态联编,所以两者矛盾,不能定义内联函数为虚函数\\n\\n4. 为什么C++不支持静态成员函数为虚函数？\\n\\n这也很简单，静态成员函数对于每个类来说只有一份代码，所有的对象都共享这一份代码，他也没有要动态绑定的必要性。\\n\\n静态成员函数属于一个类而非某一对象,没有this指针,它无法进行对象的判别\\n\\n5. 为什么C++不支持友元函数为虚函数？\\n\\n因为C++不支持友元函数的继承，对于没有继承特性的函数没有虚函数的说法。\\n\\n### 3.32 解释下 C++ 中类模板和模板类的区别\\n\\n1. 类模板是模板的定义，不是一个实实在在的类，定义中用到通用类型参数\\n\\n2. 模板类是实实在在的类定义，是类模板的实例化。类定义中参数被实际类型所代替。\\n\\n答案解析\\n\\n1. 类模板的类型参数可以有一个或多个，每个类型前面都必须加class或typename，如template <class T1,class T2>class someclass{…};在定义对象时分别代入实际的类型名，如 someclass<int,double> obj;\\n\\n2. 和使用类一样，使用类模板时要注意其作用域，只能在其有效作用域内用它定义对象。\\n\\n3. 模板可以有层次，一个类模板可以作为基类，派生出派生模板类。\\n\\n### 3.33 虚函数表里存放的内容是什么时候写进去的？\\n\\n1. 虚函数表是一个存储虚函数地址的数组,以NULL结尾。虚表（vtable）在**编译阶段生成**，对象内存空间开辟以后，写入对象中的 v_ptr，然后调用构造函数。即：虚表在构造函数之前写入。\\n\\n2. 除了在构造函数之前写入之外，我们还需要考虑到虚表的二次写入机制，通过此机制让每个对象的虚表指针都能准确的指向到自己类的虚表，为实现动多态提供支持。\\n\\n## 4、标准模板库STL\\n\\n\\n\\n\\n## 5、C++新特性\\n\\n### 5.1 C++新特性\\n\\n内容参考于[csdn](https://blog.csdn.net/dnty00/article/details/126171485)\\n一、C++新特性\\nC++新特性主要包括包含语法改进和标准库扩充两个方面，主要包括以下11点\\n1、语法的改进\\n1）统一的初始化方法\\n在 C++11 中，可以直接在变量名后面跟上初始化列表，来进行对象的初始化\\n2）成员变量默认初始化\\n3）auto关键字用于定义变量，编译器可以自动判断的类型（前提：定义一个变量时对其进行初始化）\\n4）decltype 求表达式的类型\\n5）智能指针 shared_ptr\\n\\n和 unique_ptr、weak_ptr 不同之处在于，多个 shared_ptr 智能指针可以共同使用同一块堆内存。并且，由于该类型智能指针在实现上采用的是引用计数机制，即便有一个 shared_ptr 指针放弃了堆内存的“使用权”（引用计数减 1），也不会影响其他指向同一堆内存的 shared_ptr 指针（只有引用计数为 0 时，堆内存才会被自动释放）\\n6）空指针 nullptr（原来NULL）\\n7）基于范围的for循环\\n8）右值引用和move语义\\n\\n+ 右值引用\\n\\n```cpp\\n//左值引用\\nint num = 10;\\nint &b = num;  //正确\\nint &c = 10;   //错误，在C++98/03标准中，无法为右值添加引用\\n```\\n\\n实际开发中可能需要对右值进行修改（实现移动语义时就需要），显然左值引用的方式是行不通的。为此，C++11 标准新引入了另一种引用方式，称为右值引用，用 “&&” 表示。\\n\\n```cpp\\nint num = 10;\\n//int && a = num;  //右值引用不能初始化为左值\\nint && a = 10;\\n```\\n\\n+ move语义\\n\\n在C++11中，标准库在中提供了一个有用的函数std::move，std::move()函数并不能移动任何东西，它唯一的功能是将一个左值引用强制转化为右值引用，继而可以通过右值引用使用该值，以用于移动语义。从实现上讲，std::move基本等同于一个类型转换：static_cast<T&&>(lvalue);\\n\\n```cpp\\nmove( arg ) //其中，arg 表示指定的左值对象。该函数会返回 arg 对象的右值形式。\\n```\\n\\n2、标准模板库的扩充（往STL里面添加了一些模板类，比较好用）\\n9）无序容器（哈希表）\\n用法和功能同map一模一样，区别在于哈希表的效率更高\\n10）正则表达式\\n可以认为正则表达式实质上是一个字符串，该字符串描述了一种特定模式的字符串\\n11）Lambda表达式（匿名函数）\\nlambda表达式是一个匿名函数，用于定义并创建匿名的函数对象，以简化编程工作。举个例子：\\n\\n```cpp\\n vector<int> vec;\\n sort(vec.begin(), vec.end(), cmp); // 旧式\\n sort(vec.begin(), vec.end(), [](int a, int b) -> bool { return a < b; });   // Lambda表达式\\n```\\n\\n声明lambda表达式：\\n\\n```cpp\\n[capture list] (params list) mutable exception-> return type { function body }\\n```\\n\\n+ capture list：捕获外部变量列表\\n+ params list：形参列表\\n+ mutable指示符：用来说用是否可以修改捕获的变量\\n+ exception：异常设定\\n+ return type：返回类型\\n+ function body：函数体\\n\\n详细说明：\\n\\n1. 统一的初始化方法\\n   C++98/03 可以使用初始化列表（initializer list）进行初始化：\\n\\n```cpp\\nint i_arr[3] = { 1, 2, 3 };\\nlong l_arr[] = { 1, 3, 2, 4 };\\nstruct A\\n{\\n    int x;\\n    int y;\\n} a = { 1, 2 };\\n```\\n\\n但是这种初始化方式的适用性非常狭窄，只有上面提到的这两种数据类型可以使用初始化列表。在 C++11 中，初始化列表的适用性被大大增加了。它现在可以用于任何类型对象的初始化，实例如下：\\n\\n```cpp\\nclass Foo\\n{\\npublic:\\n    Foo(int) {}\\nprivate:\\n    Foo(const Foo &);\\n};\\nint main(void)\\n{\\n    Foo a1(123);\\n    Foo a2 = 123;  //error: \'Foo::Foo(const Foo &)\' is private\\n    Foo a3 = { 123 };\\n    Foo a4 { 123 };\\n    int a5 = { 3 };\\n    int a6 { 3 };\\n    return 0;\\n}\\n```\\n\\n在上例中，a3、a4 使用了新的初始化方式来初始化对象，效果如同 a1 的直接初始化。a5、a6 则是基本数据类型的列表初始化方式。可以看到，它们的形式都是统一的。这里需要注意的是，a3 虽然使用了等于号，但它仍然是列表初始化，因此，私有的拷贝构造并不会影响到它。a4 和 a6 的写法，是 C++98/03 所不具备的。在 C++11 中，可以直接在变量名后面跟上初始化列表，来进行对象的初始化。\\n\\n2. 成员变量默认初始化\\n   好处：构建一个类的对象不需要用构造函数初始化成员变量。\\n\\n```cpp\\n//程序实例\\n#include<iostream>\\nusing namespace std;\\nclass B\\n{\\npublic:\\n    int m = 1234; //成员变量有一个初始值\\n    int n;\\n};\\nint main()\\n{\\n    B b;\\n    cout << b.m << endl;\\n    return 0;\\n}\\n```\\n\\n3. auto关键字\\n   用于定义变量，编译器可以自动判断的类型（前提：定义一个变量时对其进行初始化）。\\n\\n```cpp\\n//程序实例\\n#include <vector>\\nusing namespace std;\\nint main(){\\n    vector< vector<int> > v;\\n    vector< vector<int> >::iterator i = v.begin();\\n    return 0;\\n}\\n```\\n\\n可以看出来，定义迭代器 i 的时候，类型书写比较冗长，容易出错。然而有了 auto 类型推导，我们大可不必这样，只写一个 auto 即可。\\n\\n4. decltype 求表达式的类型\\n\\ndecltype 是 C++11 新增的一个关键字，它和 auto 的功能一样，都用来在编译时期进行自动类型推导。\\n\\n(1)为什么要有decltype\\n\\n因为 auto 并不适用于所有的自动类型推导场景，在某些特殊情况下 auto 用起来非常不方便，甚至压根无法使用，所以 decltype 关键字也被引入到 C++11 中。\\n\\nauto 和 decltype 关键字都可以自动推导出变量的类型，但它们的用法是有区别的：\\n\\n```cpp\\nauto varname = value;\\ndecltype(exp) varname = value;\\n```\\n\\n其中，varname 表示变量名，value 表示赋给变量的值，exp 表示一个表达式。\\n\\nauto 根据\\\"=\\\"右边的初始值 value 推导出变量的类型，而 decltype 根据 exp 表达式推导出变量的类型，跟\\\"=\\\"右边的 value 没有关系。\\n\\n另外，auto 要求变量必须初始化，而 decltype 不要求。这很容易理解，auto 是根据变量的初始值来推导出变量类型的，如果不初始化，变量的类型也就无法推导了。decltype 可以写成下面的形式：\\n\\n>decltype(exp) varname;\\n\\n(2)代码示例\\n\\n```cpp\\n// decltype 用法举例\\nnt a = 0;\\ndecltype(a) b = 1;  //b 被推导成了 int\\ndecltype(10.8) x = 5.5;  //x 被推导成了 double\\ndecltype(x + 100) y;  //y 被推导成了 double\\n```\\n\\n5. 智能指针 shared_ptr\\n\\n和 unique_ptr、weak_ptr 不同之处在于，多个 shared_ptr 智能指针可以共同使用同一块堆内存。并且，由于该类型智能指针在实现上采用的是引用计数机制，即便有一个 shared_ptr 指针放弃了堆内存的“使用权”（引用计数减 1），也不会影响其他指向同一堆内存的 shared_ptr 指针（只有引用计数为 0 时，堆内存才会被自动释放）。\\n\\n```cpp\\n#include <iostream>\\n#include <memory>\\nusing namespace std;\\nint main()\\n{\\n    //构建 2 个智能指针\\n    std::shared_ptr<int> p1(new int(10));\\n    std::shared_ptr<int> p2(p1);\\n    //输出 p2 指向的数据\\n    cout << *p2 << endl;\\n    p1.reset();//引用计数减 1,p1为空指针\\n    if (p1) {\\n        cout << \\\"p1 不为空\\\" << endl;\\n    }\\n    else {\\n        cout << \\\"p1 为空\\\" << endl;\\n    }\\n    //以上操作，并不会影响 p2\\n    cout << *p2 << endl;\\n    //判断当前和 p2 同指向的智能指针有多少个\\n    cout << p2.use_count() << endl;\\n    return 0;\\n}\\n\\n/*    程序运行结果：        \\n            10\\n            p1 为空\\n            10\\n            1    \\n*/   \\n```\\n\\n6. 空指针 nullptr（原来NULL）\\n\\n nullptr 是 nullptr_t 类型的右值常量，专用于初始化空类型指针。nullptr_t 是 C++11 新增加的数据类型，可称为“指针空值类型”。也就是说，nullpter 仅是该类型的一个实例对象（已经定义好，可以直接使用），如果需要我们完全定义出多个同 nullptr 完全一样的实例对象。值得一提的是，nullptr 可以被隐式转换成任意的指针类型。例如：\\n\\n```cpp\\nint * a1 = nullptr;\\nchar * a2 = nullptr;\\ndouble * a3 = nullptr;\\n```\\n\\n 显然，不同类型的指针变量都可以使用 nullptr 来初始化，编译器分别将 nullptr 隐式转换成 int、char 以及 double\\\\* 指针类型。另外，通过将指针初始化为 nullptr，可以很好地解决 NULL 遗留的问题，比如：\\n\\n```cpp\\n#include <iostream>\\nusing namespace std;\\nvoid isnull(void *c){\\n    cout << \\\"void*c\\\" << endl;\\n}\\nvoid isnull(int n){\\n    cout << \\\"int n\\\" << endl;\\n}\\nint main() {\\n    isnull(NULL);\\n    isnull(nullptr);\\n    return 0;\\n}\\n\\n/*    程序运行结果：        \\n        int n\\n        void*c\\n*/         \\n```\\n\\n7. 基于范围的for循环\\n   如果要用 for 循环语句遍历一个数组或者容器，只能套用如下结构：\\n\\n```cpp\\nfor(表达式 1; 表达式 2; 表达式 3){\\n    //循环体\\n}\\n```\\n\\n```cpp\\n//程序实例\\n#include <iostream>\\n#include <vector>\\n#include <string.h>\\nusing namespace std;\\nint main() {\\n    char arc[] = \\\"www.123.com\\\";\\n    int i;\\n    //for循环遍历普通数组\\n    for (i = 0; i < strlen(arc); i++) {\\n        cout << arc[i];\\n    }\\n    cout << endl;\\n    vector<char>myvector(arc,arc+3);\\n    vector<char>::iterator iter;\\n    //for循环遍历 vector 容器\\n    for (iter = myvector.begin(); iter != myvector.end(); ++iter) {\\n        cout << *iter;\\n    }\\n    return 0;\\n}\\n/*    程序运行结果：        \\n        www.123.com\\n        www\\n*/      \\n```\\n\\n8. 右值引用和move语义\\n   i. 右值引用\\n\\n C++98/03 标准中就有引用，使用 \\\"&\\\" 表示。但此种引用方式有一个缺陷，即正常情况下只能操作 C++ 中的左值，无法对右值添加引用。举个例子：\\n\\n```cpp\\nint num = 10;\\nint &b = num; //正确\\nint &c = 10; //错误\\n```\\n\\n 如上所示，编译器允许我们为 num 左值建立一个引用，但不可以为 10 这个右值建立引用。因此，C++98/03 标准中的引用又称为左值引用。\\n\\n注意，虽然 C++98/03 标准不支持为右值建立非常量左值引用，但允许使用常量左值引用操作右值。也就是说，常量左值引用既可以操作左值，也可以操作右值，例如：\\n\\n```cpp\\nint num = 10;\\nconst int &b = num;\\nconst int &c = 10;\\n```\\n\\n我们知道，右值往往是没有名称的，因此要使用它只能借助引用的方式。这就产生一个问题，实际开发中我们可能需要对右值进行修改（实现移动语义时就需要），显然左值引用的方式是行不通的。\\n\\n 为此，C++11 标准新引入了另一种引用方式，称为右值引用，用 \\\"&&\\\" 表示。\\n\\n 需要注意的，和声明左值引用一样，右值引用也必须立即进行初始化操作，且只能使用右值进行初始化，比如：\\n\\n```cpp\\nint num = 10;\\n//int && a = num;  //右值引用不能初始化为左值\\nint && a = 10;\\n​ 和常量左值引用不同的是，右值引用还可以对右值进行修改。例如：\\n\\nint && a = 10;\\na = 100;\\ncout << a << endl;\\n/*    程序运行结果：        \\n        100    \\n*/          \\n​ 另外值得一提的是，C++ 语法上是支持定义常量右值引用的，例如:\\nconst int&& a = 10;//编译器不会报错\\n```\\n\\n 但这种定义出来的右值引用并无实际用处。一方面，右值引用主要用于移动语义和完美转发，其中前者需要有修改右值的权限；其次，常量右值引用的作用就是引用一个不可修改的右值，这项工作完全可以交给常量左值引用完成。\\n\\nii. move语义\\n\\n move 本意为 \\\"移动\\\"，但该函数并不能移动任何数据，它的功能很简单，就是将某个左值强制转化为右值。基于 move() 函数特殊的功能，其常用于实现移动语义。move() 函数的用法也很简单，其语法格式如下：\\n\\n> move( arg ) //其中，arg 表示指定的左值对象。该函数会返回 arg 对象的右值形式。\\n\\n```cpp\\n//程序实例\\n#include <iostream>\\nusing namespace std;\\nclass first {\\npublic:\\n    first() :num(new int(0)) {\\n        cout << \\\"construct!\\\" << endl;\\n    }\\n    //移动构造函数\\n    first(first &&d) :num(d.num) {\\n        d.num = NULL;\\n        cout << \\\"first move construct!\\\" << endl;\\n    }\\npublic:    //这里应该是 private，使用 public 是为了更方便说明问题\\n    int *num;\\n};\\nclass second {\\npublic:\\n    second() :fir() {}\\n    //用 first 类的移动构造函数初始化 fir\\n    second(second && sec) :fir(move(sec.fir)) {\\n        cout << \\\"second move construct\\\" << endl;\\n    }\\npublic:    //这里也应该是 private，使用 public 是为了更方便说明问题\\n    first fir;\\n};\\nint main() {\\n    second oth;\\n    second oth2 = move(oth);\\n    //cout << *oth.fir.num << endl;   //程序报运行时错误\\n    return 0;\\n}\\n\\n/*    程序运行结果：\\n          construct!\\n        first move construct!\\n        second move construct\\n*/            \\n```\\n\\n9. 无序容器（哈希表）\\n\\n用法和功能同map一模一样，区别在于哈希表的效率更高。\\n\\n(1) 无序容器具有以下 2 个特点：\\n\\n a. 无序容器内部存储的键值对是无序的，各键值对的存储位置取决于该键值对中的键，\\n\\n b. 和关联式容器相比，无序容器擅长通过指定键查找对应的值（平均时间复杂度为 O(1)）；但对于使用迭代器遍历容器中存储的元素，无序容器的执行效率则不如关联式容器。\\n\\n(2) 和关联式容器一样，无序容器只是一类容器的统称，其包含有 4 个具体容器，分别为 unordered_map、unordered_multimap、unordered_set 以及 unordered_multiset。功能如下表：\\n\\n| 无序容器           | 功能                                                         |\\n| ------------------ | ------------------------------------------------------------ |\\n| unordered_map      | 存储键值对 <key, value> 类型的元素，其中各个键值对键的值不允许重复，且该容器中存储的键值对是无序的。 |\\n| unordered_multimap | 和 unordered_map 唯一的区别在于，该容器允许存储多个键相同的键值对。 |\\n| unordered_set      | 不再以键值对的形式存储数据，而是直接存储数据元素本身（当然也可以理解为，该容器存储的全部都是键 key 和值 value 相等的键值对，正因为它们相等，因此只存储 value 即可）。另外，该容器存储的元素不能重复，且容器内部存储的元素也是无序的。 |\\n| unordered_multiset | 和 unordered_set 唯一的区别在于，该容器允许存储值相同的元素。 |\\n\\n 程序实例（以 unordered_map 容器为例）\\n\\n```cpp\\n#include <iostream>\\n#include <string>\\n#include <unordered_map>\\nusing namespace std;\\nint main()\\n{\\n    //创建并初始化一个 unordered_map 容器，其存储的 <string,string> 类型的键值对\\n    std::unordered_map<std::string, std::string> my_uMap{\\n        {\\\"教程1\\\",\\\"www.123.com\\\"},\\n        {\\\"教程2\\\",\\\"www.234.com\\\"},\\n        {\\\"教程3\\\",\\\"www.345.com\\\"} };\\n    //查找指定键对应的值，效率比关联式容器高\\n    string str = my_uMap.at(\\\"C语言教程\\\");\\n    cout << \\\"str = \\\" << str << endl;\\n    //使用迭代器遍历哈希容器，效率不如关联式容器\\n    for (auto iter = my_uMap.begin(); iter != my_uMap.end(); ++iter)\\n    {\\n        //pair 类型键值对分为 2 部分\\n        cout << iter->first << \\\" \\\" << iter->second << endl;\\n    }\\n    return 0;\\n}\\n\\n/*    程序运行结果：\\n          教程1 www.123.com\\n          教程2 www.234.com\\n          教程3 www.345.com\\n*/  \\n```\\n\\n10. 正则表达式\\n\\n可以认为正则表达式实质上是一个字符串，该字符串描述了一种特定模式的字符串。常用符号的意义如下：\\n\\n11. Lambda匿名函数\\n    所谓匿名函数，简单地理解就是没有名称的函数，又常被称为 lambda 函数或者 lambda 表达式。\\n\\n（1）定义\\n\\n lambda 匿名函数很简单，可以套用如下的语法格式：\\n\\n [外部变量访问方式说明符] (参数) mutable noexcept/throw() -> 返回值类型\\n​ {\\n​ 函数体;\\n​ };\\n\\n其中各部分的含义分别为：\\n\\na. [外部变量方位方式说明符]\\n\\n> [ ] 方括号用于向编译器表明当前是一个 lambda 表达式，其不能被省略。在方括号内部，可以注明当前 lambda 函数的函数体中可以使用哪些“外部变量”。\\n\\n所谓外部变量，指的是和当前 lambda 表达式位于同一作用域内的所有局部变量。\\nb. (参数)\\n\\n>和普通函数的定义一样，lambda 匿名函数也可以接收外部传递的多个参数。和普通函数不同的是，如果不需要传递参数，可以连同 () 小括号一起省略；\\n\\nc. mutable\\n\\n>此关键字可以省略，如果使用则之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，对于以值传递方式引入的外部变量，不允许在 lambda 表达式内部修改它们的值（可以理解为这部分变量都是 const 常量）。而如果想修改它们，就必须使用 mutable 关键字。\\n\\n 注意:对于以值传递方式引入的外部变量，lambda 表达式修改的是拷贝的那一份，并不会修改真正的外部变量；\\n\\nd. noexcept/throw()\\n\\n>可以省略，如果使用，在之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，lambda 函数的函数体中可以抛出任何类型的异常。而标注 noexcept 关键字，则表示函数体内不会抛出任何异常；使用 throw() 可以指定 lambda 函数内部可以抛出的异常类型。\\n\\ne. -> 返回值类型\\n\\n>指明 lambda 匿名函数的返回值类型。值得一提的是，如果 lambda 函数体内只有一个 return 语句，或者该函数返回 void，则编译器可以自行推断出返回值类型，此情况下可以直接省略\\\"-> 返回值类型\\\"。\\n\\nf. 函数体\\n\\n>和普通函数一样，lambda 匿名函数包含的内部代码都放置在函数体中。该函数体内除了可以使用指定传递进来的参数之外，还可以使用指定的外部变量以及全局范围内的所有全局变量。\\n\\n（2）程序实例\\n\\n```cpp\\n#include <iostream>\\n#include <algorithm>\\nusing namespace std;\\nint main()\\n{\\n    int num[4] = {4, 2, 3, 1};\\n    //对 a 数组中的元素进行排序\\n    sort(num, num+4, [=](int x, int y) -> bool{ return x < y; } );\\n    for(int n : num){\\n        cout << n << \\\" \\\";\\n    }\\n    return 0;\\n}\\n\\n/*    程序运行结果：\\n          1 2 3 4\\n*/ \\n```\\n\\n### 5.2 说说 C++ 中智能指针和指针的区别是什么？\\n\\n1. 智能指针\\n\\n 如果在程序中使用new从堆（自由存储区）分配内存，等到不需要时，应使用delete将其释放。C++引用了智能指针auto_ptr，以帮助自动完成这个过程。随后的编程体验（尤其是使用STL）表明，需要有更精致的机制。基于程序员的编程体验和BOOST库提供的解决方案，C++11摒弃了auto_ptr，并新增了三种智能指针：unique_ptr、shared_ptr和weak_ptr。所有新增的智能指针都能与STL容器和移动语义协同工作。\\n\\n2. 指针\\n\\n C 语言规定所有变量在使用前必须先定义，指定其类型，并按此分配内存单元。指针变量不同于整型变量和其他类型的变量，它是专门用来存放地址的，所以必须将它定义为“指针类型”。\\n\\n智能指针和普通指针的区别\\n\\n 智能指针和普通指针的区别在于智能指针实际上是对普通指针加了一层封装机制，区别是它负责自动释放所指的对象，这样的一层封装机制的目的是为了使得智能指针可以方便的管理一个对象的生命期。\\n\\n### 5.3 \\n\\n\\n## 6、C++操作系统（Linux相关）\\n\\n\\n\\n\\n## 7、计算机网络\\n\\n\\n\\n\\n\\n## 8、设计模式（摘选）\\n\\n\\n\\n\\n\\n## 9、常见编程大题\\n\\n\\n\\n\",\"articleCover\":\"\",\"articleTitle\":\"2022-10-30\",\"articleType\":1,\"categoryName\":\"编程语言基础\",\"isRecommend\":0,\"isTop\":0,\"status\":1,\"tagNameList\":[\"C++\"]}]','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',166,'2023-06-07 16:32:57');
INSERT INTO `t_operation_log` VALUES (1172,'文章模块','修改','/admin/article/update','com.ican.controller.ArticleController.updateArticle','修改文章','[{\"articleContent\":\"\\n第一部分是C++基础，第二部分是C/C++内存问题，第三部分是C++面向对象，第四部分是C++标准模板库STL，第五部分是C++新特性，第六部分是C++操作系统内容，第七部分是C++计算机网络，第八部分提到了部分常用的设计模式，第九部分举了一些常见的编程题。\\n\\n内容参考自[牛客](https://www.nowcoder.com/issue/tutorial?zhuanlanId=Gj56lM&uuid=0d542159b96c424f8b35bd6f9a278609)\\n\\n## 1、C++基础\\n\\n\\n\\n### 1.1 简述C++语言的特点\\n\\n1. C++在C语言基础上引入了**面向对象**的机制，同时也**兼容C语言**。\\n2. C++有三大特性：封装、继承、多态\\n3. C++语言编写出的程序结构清晰、易于扩充，程序可读性好\\n4. C++生成的代码质量高，运行效率高，仅比汇编语言慢10%～20%\\n5. C++更加安全，增加了const常量、引用、四类cast转换（static_cast、dynamic_cast、const_cast、reinterpret_cast）、智能指针、try—catch等等\\n6. C++可复用性高，C++引入了模板的概念，后面在此基础上，实现了方便开发的标准模板库STL（Standard Template Library）\\n7. 同时，C++是**不断在发展**的语言。C++后续版本更是发展了不少新特性，如C++11中引入了nullptr、auto变量、Lambda匿名函数、右值引用、智能指针。\\n\\n### 1.2 说说C语言与C++语言的区别\\n\\n1. C语言是C++的子集，C++可以很好兼容C语言。但是C++又有很多**新特性**，如引用、智能指针、auto变量等。\\n2. C++是**面对对象**的编程语言；C语言是面对过程的编程语言\\n3. C语言有一些不安全的语言特性，如指针使用的潜在危险、强制转换的不确定性、内存泄露等。而C++对此增加了不少新特性来**改善安全性**，如const常量、引用、cast转换、智能指针、try—catch等等\\n4. C++**可复用性高**，C++引入了**模板**的概念，后面在此基础上，实现了方便开发的标准模板库STL。C++的STL库相对于C语言的函数库**更灵活、更通用**\\n\\n### 1.3 说说C++中struct和class的区别\\n\\n1. struct一般用于描述一个数据结构集合，而class是对一个对象数据的封装；\\n2. struct的默认访问权限是public，而class默认权限是private；\\n\\n```cpp\\nstruct A{\\n\\tint iNum;  //默认访问控制权限是public\\n};\\nclass B{\\n\\tint iNum;  //默认访问控制权限是private\\n};\\n```\\n\\n3. 在继承关系上，struct是public继承，而class是private继承；\\n4. class关键字可以用于定义模板参数，就像typename，而struct不能用于定义模板参数。\\n\\n### 1.4 说说C中结构体和C++中结构体的区别\\n\\n1. C的结构体内不允许有函数存在，C++允许有内部成员函数，且允许该函数是虚函数\\n2. C的结构体对内部成员变量的访问权限只能是public，而C++允许public,protected,private三种\\n3. C语言的结构体是不可以继承的，C++的结构体是可以从其他的结构体或者类继承过来的\\n4. C 中使用结构体需要加上 struct 关键字，或者对结构体使用 typedef 取别名，而 C++ 中可以省略 struct 关键字直接使用\\n\\n小总结一波：①C与C++在声明时的区别在于：\\n\\n|          |           C            |           C++            |\\n| :------: | :--------------------: | :----------------------: |\\n| 成员函数 |         不能有         |           可以           |\\n| 静态成员 |         不能有         |           可以           |\\n| 访问控制 |  默认public，不可修改  | public/private/protected |\\n| 继承关系 |       不可以继承       |  可从类或其他结构体继承  |\\n|  初始化  | 不能直接初始化数据成员 |           可以           |\\n\\n②使用时的区别：\\n\\nC 中使用结构体需要加上 struct 关键字，或者对结构体使用 typedef 取别名，而 C++ 中可以省略 struct 关键字直接使用，例如：\\n\\n```cpp\\nstruct Student{\\n\\tint iAge;\\n\\tstring strName;\\n};\\ntypedef struct Student Student2; //C中给结构体取别名\\n\\nstuct Student stu1;   //C中正常使用\\nStudent2 stu2;      //C中通过取别名来使用\\nStudent stu3;      // C++中使用结构体可以省略关键字struct\\n```\\n\\n### 1.5 说说include头文件的顺序以及双引号“”和尖括号<>的区别\\n\\n1. 区别\\n   （1）尖括号的头文件是系统文件，双引号的文件是自定义文件；\\n   （2）编译器预处理阶段查找头文件的路径不一样\\n2. 查找路径\\n   （1）使用尖括号<>的头文件的查找路径：编译器设置的头文件路径-->系统变量\\n   （2）使用双引号“”的头文件的查找路径：当前头文件目录-->编译器设置的头文件路径-->系统变量\\n\\n### 1.6 导入C函数的关键字是什么，C++编译的时候与C有什么区别\\n\\n1. **关键字**：在C++中，导入C函数的关键字是extern，表达形式为extern “C”， extern \\\"C\\\"的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern \\\"C\\\"后，会指示编译器这部分代码按C语言的进行编译，而不是C++的。\\n2. **编译区别**：由于C++支持函数重载，因此编译器编译函数的过程中会将函数的**参数类型**也加到编译后的代码中，而不仅仅是**函数名**；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括**函数名**。\\n   程序示例：\\n\\n```cpp\\n//extern示例\\n//在C++程序里边声明该函数，会指示编译器这部分代码按C语言的进行编译\\nextern \\\"C\\\" int strcmp(const char *s1, const char *s2);\\n\\n//在C++程序里边声明该函数\\nextern \\\"C\\\"{\\n    #include <string.h>//string.h里边包含了要调用的C函数的声明\\n}\\n\\n//两种不同的语言，有着不同的编译规则，比如一个函数fun，可能C语言编译的时候为_fun，而C++则是__fun__\\n```\\n\\n### 1.7 简述C++从代码到可执行二进制文件的过程\\n\\nC++和C语言类似，一个C++程序从源码到执行文件，有四个过程，**预处理、编译、汇编、链接**。\\n\\n1. 预处理：这个过程主要的处理操作如下：\\n   （1） 将所有的#define删除，并且展开所有的宏定义\\n   （2） 处理所有的条件预编译指令，如#if、#ifdef\\n   （3） 处理#include预编译指令，将被包含的文件插入到该预编译指令的位置。\\n   （4） 过滤所有的注释\\n   （5） 添加行号和文件名标识。\\n2. 编译：这个过程主要的处理操作如下：\\n   （1） 词法分析：将源代码的字符序列分割成一系列的记号。\\n   （2） 语法分析：对记号进行语法分析，产生语法树。\\n   （3） 语义分析：判断表达式是否有意义。\\n   （4） 代码优化：\\n   （5） 目标代码生成：生成汇编代码。\\n   （6） 目标代码优化：\\n3. 汇编：这个过程主要是将汇编代码转变成机器可以执行的指令。\\n4. 链接：将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。\\n\\n链接分为静态链接和动态链接。\\n\\n静态链接，是在链接的时候就已经把要调用的函数或者过程链接到了生成的可执行文件中，就算你在去把静态库删除也不会影响可执行程序的执行；生成的静态链接库，Windows下以.lib为后缀，Linux下以.a为后缀。\\n\\n而动态链接，是在链接的时候没有把调用的函数代码链接进去，而是在执行的过程中，再去找要链接的函数，生成的可执行文件中没有函数代码，只包含函数的重定位信息，所以当你删除动态库时，可执行程序就不能运行。生成的动态链接库，Windows下以.dll为后缀，Linux下以.so为后缀。\\n\\n### 1.8 说说 static关键字的作用\\n\\n**static关键字的作用**：一方面她延长了函数和变量的作用时间；另一方面，它也限制了函数和变量的作用范围。\\n\\n1. **定义全局静态变量和局部静态变量**：在变量前面加上static关键字。初始化的静态变量会在数据段（.data）分配内存，未初始化的静态变量会在BSS段（.bss）分配内存。直到程序结束，静态变量始终会维持前值。只不过全局静态变量和局部静态变量的作用域不一样；\\n2. **定义静态函数**：在函数返回类型前加上static关键字，函数即被定义为静态函数。静态函数只能在本源文件中使用；\\n3. 在变量类型前加上static关键字，变量即被定义为静态变量。静态变量只能在本源文件中使用；\\n4. 在C++中，static关键字可以用于定义类中的静态成员变量：使用静态数据成员，它既可以被当成全局变量那样去存储，但又被隐藏在类的内部。类中的static静态数据成员拥有一块单独的存储区，而不管创建了多少个该类的对象。所有这些对象的静态数据成员都共享这一块静态存储空间；\\n5. 在C++中，static关键字可以用于定义类中的静态成员函数：与静态成员变量类似，类里面同样可以定义静态成员函数。只需要在函数前加上关键字static即可。如静态成员函数也是类的一部分，而不是对象的一部分。所有这些对象的静态数据成员都共享这一块静态存储空间。\\n\\n**关于第五点的补充说明**：当调用一个对象的非静态成员函数时，系统会把该对象的起始地址赋给成员函数的this指针。而静态成员函数不属于任何一个对象，因此C++规定静态成员函数没有this指针（划重点，面试题常考）。既然它没有指向某一对象，也就无法对一个对象中的非静态成员进行访问。\\n\\n### 1.9 说说数组和指针的区别\\n\\n1、概念：\\n    （1）数组：数组是用于储存多个相同类型数据的集合。数组名是首元素的地址\\n    （2）指针：指针相当于一个变量，但是它和不同变量不一样，它存放的是其它变量在**内存中的地址**。指针名指向了内存的首地址\\n\\n2. 区别：\\n   （1）**赋值**：同类型指针变量可以相互赋值；数组不行，只能一个一个元素的赋值或拷贝\\n   （2）**存储方式**：\\n\\n数组：数组在内存中是连续存放的，开辟一块连续的内存空间。数组是根据数组的下标进行访问的，数组的存储空间，不是在静态区就是在栈上。\\n\\n指针：指针很灵活，它可以指向任意类型的数据。指针的类型说明了它所指向地址空间的内存。由于指针本身就是一个变量，再加上它所存放的也是变量，所以指针的存储空间不能确定。\\n（3）**求sizeof**：\\n\\n数组所占存储空间的内存大小是sizeof(数组)，计算数组中元素个数：sizeof（数组名）/sizeof（数据类型）\\n\\n在32位平台下，无论指针的类型是什么，sizeof（指针名）都是4，在64位平台下，无论指针的类型是什么，sizeof（指针名）都是8。\\n（4）**初始化**：\\n\\n```cpp\\n// 数组\\nint a[5] = { 0 };\\nchar b[] = \\\"Hello\\\";    // 按字符串初始化，大小为6\\nchar c[] = { \'H\',\'e\',\'l\',\'l\',\'o\',\'\\\\0\' };    // 按字符初始化\\nint* arr = new int[10];    // 动态创建一维数组\\n\\n// 指针\\n// 指向对象的指针\\nint* p = new int(0);\\ndelete p;\\n// 指向数组的指针\\nint* p1 = new int[10];\\ndelete[] p1;\\n// 指向类的指针：\\nstring* p2 = new string;\\ndelete p2;\\n// 指向指针的指针（二级指针）\\nint** pp = &p;\\n**pp = 10;\\n```\\n\\n（5）**指针操作**：\\n\\n数组名的指针操作：\\n\\n`int (*p)[4]`定义了一个数组指针，该指针指向一个包含4个元素的数组。\\n\\n```cpp\\nint a[3][4];  \\nint (*p)[4];  //该语句是定义一个数组指针，指向含4个元素的一维数组\\np = a;        //将该二维数组的首地址赋给p，也就是a[0]或&a[0][0]\\np++;          //该语句执行过后，也就是p=p+1；p跨过行a[0][]指向了行a[1][]\\n              //所以数组指针也称指向一维数组的指针，亦称行指针。\\n//访问数组中第i行j列的一个元素，有几种操作方式：\\n//*(p[i]+j)、*(*(p+i)+j)、(*(p+i))[j]、p[i][j]。其中，优先级：()>[]>*。\\n//这几种操作方式都是合法的。\\n```\\n\\n指针变量的数据操作：\\n\\n```cpp\\nchar *str = \\\"hello,douya!\\\";\\nstr[2] = \'a\';\\n*(str+2) = \'b\';\\n//这两种操作方式都是合法的。\\n```\\n\\n补充：int \\\\*p[4]和int (*p)[4]的区别和区分：因为[]的优先级要比\\\\*高，所以前者是p先和[ ]结合，表示一个数组，然后再与*结合，表示int指针类型的数组。（本质上是数组，不过是int指针类型的数组）这数组里每个元素都是int类型的指针，储存的是int类型变量的地址。\\n\\n而int(\\\\*p)[4]，p先和\\\\*结合，表示p是一个指针，int ［4］就是他的类型，表示这是一个数组类型的指针，即p是一个指向一个长度为4数组的指针，它的本质是一个指针，这个指针的类型是int类型长度为4的数组。表示，这个指针存的是int类型长度为4的数组的地址。（不是其中某个元素的地址）\\n\\n### 1.10 说说什么是函数指针，如何定义函数指针，有什么使用场景\\n\\n1. **概念**：函数指针就是指向函数的指针变量。每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址\\n2. **定义**形式如下：\\n\\n```cpp\\nint func(int a);  \\nint (*f)(int a);  \\nf = &func;  \\n```\\n\\n3. 函数指针的**应用场景**：**回调**(callback)。我们调用别人提供的 API函数(Application Programming Interface,应用程序编程接口)，称为Call；如果别人的库里面调用我们的函数，就叫回调Callback。\\n\\n  我们用系统的API叫调用，系统用我们的API叫回调。\\n\\n  程序示例：\\n\\n```cpp\\n//以库函数qsort排序函数为例，它的原型如下：\\nvoid qsort(void *base,//void*类型，代表原始数组\\n           size_t nmemb, //第二个是size_t类型，代表数据数量\\n           size_t size, //第三个是size_t类型，代表单个数据占用空间大小\\n           int(*compar)(const void *,const void *)//第四个参数是函数指针\\n          );\\n//第四个参数告诉qsort，应该使用哪个函数来比较元素，即只要我们告诉qsort比较大小的规则，它就可以帮我们对任意数据类型的数组进行排序。在库函数qsort调用我们自定义的比较函数，这就是回调的应用。\\n\\n//示例\\nint num[100];\\nint cmp_int(const void* _a , const void* _b){//参数格式固定\\n    int* a = (int*)_a;    //强制类型转换\\n    int* b = (int*)_b;\\n    return *a - *b;　　\\n}\\nqsort(num,100,sizeof(num[0]),cmp_int); //回调\\n```\\n\\n### 1.11 说说静态变量什么时候初始化\\n\\n<font color=\'red\'>对于C语言的全局和静态变量，初始化发生在任何代码执行之前，属于编译期初始化。</font>\\n\\n<font color=\'red\'>而C++标准规定：全局或静态对象当且仅当对象首次用到时才进行构造。</font>\\n\\n1. **作用域**：C++里作用域可分为6种：全局，局部，类，语句，命名空间和文件作用域\\n\\n  全局变量：全局作用域+文件作用域，可以通过extern作用于其他非定义的源文件。\\n  静态全局变量 ：全局作用域，所以无法在其他文件中使用。\\n  静态局部变量 ：局部作用域，只被初始化一次，直到程序结束。\\n  类静态成员变量：类作用域。\\n\\n2. **所在空间**：都在静态存储区。因为静态变量都在静态存储区，所以下次调用函数的时候还是能取到原来的值\\n\\n3. **生命周期**：静态全局变量、静态局部变量都在静态存储区，直到程序结束才会回收内存。类静态成员变量在静态存储区，当超出类作用域时回收内存\\n\\n### 1.12 nullptr可以调用成员函数吗，为什么？\\n\\n答案：能。\\n原因：因为在编译时对象就绑定了函数地址，和指针空不空没关系。\\n\\n因为在编译时对象就绑定了函数地址，和指针空不空没关系。pAn->breathe();编译的时候，函数的地址就和指针pAn绑定了；调用breath(\\\\*this), this就等于pAn。由于函数中没有需要解引用this的地方，所以函数运行不会出错，但是若用到this，因为this=nullptr，运行出错。\\n\\n```cpp\\n//给出实例\\nclass animal{\\npublic:\\n    void sleep(){ cout << \\\"animal sleep\\\" << endl; }\\n    void breathe(){ cout << \\\"animal breathe haha\\\" << endl; }\\n};\\nclass fish :public animal{\\npublic:\\n    void breathe(){ cout << \\\"fish bubble\\\" << endl; }\\n};\\nint main(){\\n    animal *pAn=nullptr;\\n    pAn->breathe();   // 输出：animal breathe haha\\n    fish *pFish = nullptr;\\n    pFish->breathe(); // 输出：fish bubble\\n    return 0;\\n}  \\n```\\n\\n### 1.13 什么是野指针，怎么产生的，如何避免？\\n\\n1. **概念**：野指针就是指针指向的位置是不可知的（随机的、不正确的、没有明确限制的）\\n2. **产生原因**：释放内存后指针不及时置空（野指针），依然指向了该内存，那么可能出现非法访问的错误。这些我们都要注意避免，如：\\n\\n```cpp\\nchar *p = (char *)malloc(sizeof(char)*100);  \\nstrcpy(p, \\\"Douya\\\");  \\nfree(p);//p所指向的内存被释放，但是p所指的地址仍然不变  \\n...  \\nif (p != NULL){//没有起到防错作用  \\n    strcpy(p, \\\"hello, Douya!\\\");//出错  \\n}  \\n```\\n\\n3. 避免办法：\\n   （1）初始化置为NULL\\n   （2）申请内存后判空\\n   （3）指针释放后置NULL\\n   （4）使用智能指针\\n\\n```cpp\\nint *p = NULL; //初始化置NULL\\np = (int *)malloc(sizeof(int)*n); //申请n个int内存空间  \\nassert(p != NULL); //判空，防错设计\\n//C 库函数 void *realloc(void *ptr, size_t size) 尝试重新调整之前调用 malloc 或 calloc 所分配的 ptr 所指向的内存块的大小。\\n//注意：如果大小为 0，且 ptr 指向一个已存在的内存块，则 ptr 所指向的内存块会被释放，并返回一个空指针。\\np = (int *) realloc(p, 25);//重新分配内存, p 所指向的内存块会被释放并分配一个新的内存地址\\nfree(p);  \\np = NULL; //释放后置空\\n\\nint *p1 = NULL; //初始化置NULL\\ncalloc默认设置分配的内存数据为0\\np1 = (int *)calloc(n, sizeof(int)); //申请n个int内存空间同时初始化为0 \\nassert(p1 != NULL); //判空，防错设计\\nfree(p1);  \\np1 = NULL; //释放后置空\\n\\nint *p2 = NULL; //初始化置NULL\\np2 = new int[n]; //申请n个int内存空间  \\nassert(p2 != NULL); //判空，防错设计\\ndelete []p2;  \\np2 = nullptr; //释放后置空  \\n```\\n\\n### 1.14 说说静态局部变量，全局变量，局部变量的特点，以及使用场景\\n\\n1. **首先从作用域考虑**：C++里作用域可分为6种：全局，局部，类，语句，命名空间和文件作用域。\\n   全局变量：全局作用域+文件作用域，可以通过extern作用于其他非定义的源文件。\\n   静态全局变量 ：全局作用域，所以无法在其他文件中使用。\\n   局部变量：局部作用域，比如函数的参数，函数内的局部变量等等。\\n   静态局部变量 ：局部作用域，只被初始化一次，直到程序结束。\\n2. **从所在空间考虑**：除了局部变量在栈上外，其他都在静态存储区。因为静态变量都在静态存储区，所以下次调用函数的时候还是能取到原来的值。\\n3. **生命周期**： 局部变量在栈上，出了作用域就回收内存；而全局变量、静态全局变量、静态局部变量都在静态存储区，直到程序结束才会回收内存。\\n4. **使用场景**：从它们各自特点就可以看出各自的应用场景，不再赘述。\\n\\n### 1.15 说说内联函数和宏函数的区别\\n\\n区别：\\n\\n1. **宏定义不是函数**，但是使用起来像函数。预处理器用复制宏代码的方式代替函数的调用，省去了函数压栈退栈过程，提高了效率；而**内联函数本质上是一个函数**，内联函数一般用于函数体的代码比较简单的函数，不能包含复杂的控制语句，while、switch，并且内联函数本身不能直接调用自身(内联函数不能用于迭代)。\\n\\n2. **宏定义**是在预编译的时候把所有的宏名用宏体来替换，简单的说就是字符串替换 ；而**内联函数**则是在编译的时候进行代码插入，编译器会在每处调用内联函数的地方直接把内联函数的内容展开，这样可以省去函数的调用的开销，提高效率\\n\\n3. **宏定义**是没有类型检查的，无论对还是错都是直接替换；而**内联函数**在编译的时候会进行类型的检查，内联函数满足函数的性质，比如有返回值、参数列表等\\n\\n  **说人话**：相同点是，宏定义和内联函数，相比于函数体内代码较短，逻辑简单的普通函数而言，避免了出栈入栈的开销，提高了运行效率。不同的在于，宏定义本质不是函数。只是简单的字符替换，而且不会进行检查；内联函数本质是函数，是进行代码插入，有检错（宏定义不会对传入的参数进行检查），有形参，有返回值。\\n\\n  代码示例如下：\\n\\n```cpp\\n//宏定义示例\\n#define MAX(a，b) ((a)>(b)?(a):(b))\\nMAX(a,\\\"Hello\\\")； //错误地比较int和字符串，没有参数类型检查\\n\\n//内联函数示例\\n#include <stdio.h>\\ninline int add(int a, int b){\\n    return (a + b);\\n}\\nint main(void){\\n    int a;\\n    a = add(1, 2);\\n    printf(\\\"a+b=%d\\\\n\\\", a);\\n    return 0;\\n}\\n//以上a = add(1, 2);处在编译时将被展开为：a = (a + b);\\n```\\n\\n1、使用时的一些注意事项：\\n\\n+ 使用宏定义一定要注意错误情况的出现，比如宏定义函数没有类型检查，可能传进来任意类型，从而带来错误，如举例。还有就是括号的使用，宏在定义时要小心处理宏参数，一般用括号括起来，否则容易出现二义性\\n\\n+ inline函数一般用于比较小的，频繁调用的函数，这样可以减少函数调用带来的开销。只需要在函数返回类型前加上关键字inline，即可将函数指定为inline函数。\\n\\n+ 同其它函数不同的是，最好将inline函数定义在头文件，而不仅仅是声明，因为编译器在处理inline函数时，需要在调用点内联展开该函数，所以仅需要函数声明是不够的。\\n\\n2、内联函数使用的条件：\\n\\n+ 内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。以下情况不宜使用内联：\\n\\n+ （1）如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。\\n+ （2）如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。\\n+ 内联不是什么时候都能展开的，一个好的编译器将会根据函数的定义体，自动地取消不符合要求的内联。\\n\\n### 1.16 说说运算符i++和++i的区别\\n\\n先看代码示例：\\n\\n```cpp\\n#include <stdio.h>\\nint main(){\\n    int i = 2;\\n    int j = 2;\\n    j += i++; //先赋值后加\\n    printf(\\\"i= %d, j= %d\\\\n\\\",i, j); //i= 3, j= 4\\n    i = 2;\\n    j = 2;\\n    j += ++i; //先加后赋值\\n    printf(\\\"i= %d, j= %d\\\",i, j); //i= 3, j= 5\\n}\\n```\\n\\n区别：\\n\\n1. 赋值顺序不同：++ i 是先加后赋值；i ++ 是先赋值后加；++i和i++都是分两步完成的。\\n2. 效率不同：<font color=\'red\'>后置++执行速度比前置的慢</font>。\\n3. i++ 不能作为左值，而++i 可以：\\n\\n```cpp\\nint i = 0;\\nint *p1 = &（++i）；//正确\\nint *p2 = &（i++）；//错误\\n++i = 1；//正确\\ni++ = 1；//错误\\n```\\n\\n4. 两者都不是原子操作\\n\\n### 1.17 说说new和malloc的区别，各自底层实现原理\\n\\n1. new是操作符，而malloc是函数。\\n2. new在调用的时候先分配内存，在调用构造函数，释放的时候调用析构函数；而malloc没有构造函数和析构函数。\\n3. malloc需要给定申请内存的大小，返回的指针需要强转；new会调用构造函数，不用指定内存的大小，返回指针不用强转。\\n4. new可以被重载；malloc不行\\n5. new分配内存更直接和安全。\\n6. new发生错误抛出异常，malloc返回null\\n\\n答案解析：\\n\\n**malloc底层实现**：当开辟的空间小于 128K 时，调用 brk（）函数；当开辟的空间大于 128K 时，调用mmap（）。malloc采用的是内存池的管理方式，以减少内存碎片。先申请大块内存作为堆区，然后将堆区分为多个内存块。当用户申请内存时，直接从堆区分配一块合适的空闲快。采用隐式链表将所有空闲块，每一个空闲块记录了一个未分配的、连续的内存地址。\\n\\n**new底层实现**：关键字new在调用构造函数的时候实际上进行了如下的几个步骤：\\n\\n1. 创建一个新的对象\\n2. 将构造函数的作用域赋值给这个新的对象（因此this指向了这个新的对象）\\n3. 执行构造函数中的代码（为这个新对象添加属性）\\n4. 返回新对象\\n\\n### 1.18 说说const和define的区别\\n\\nconst用于定义常量；而define用于定义宏，而宏也可以用于定义常量。都用于常量定义时，它们的\\n区别有：\\n\\n1. const生效于编译的阶段；define生效于预处理阶段。\\n2. const定义的常量，在C语言中是存储在内存中、需要额外的内存空间的；define定义的常量，运行时是直接的操作数，并不会存放在内存中。\\n3. const定义的常量是带类型的；define定义的常量不带类型。因此define定义的常量不利于类型检查。\\n\\n### 1.19 说说C++中函数指针和指针函数的区别\\n\\n1. 定义不同\\n   指针函数本质是一个函数，其返回值为指针。\\n   函数指针本质是一个指针，其指向一个函数。\\n\\n2. 写法不同\\n\\n>指针函数：int \\\\*fun(int x,int y);\\n>\\t   函数指针：int (\\\\*fun)(int x,int y);\\n\\n3. 用法不同\\n\\n用法参考以下代码示例：\\n\\n```cpp\\n//指针函数示例\\ntypedef struct _Data{\\n    int a;\\n    int b;\\n}Data;\\n//指针函数\\nData* f(int a,int b){\\n    Data * data = new Data;\\n    //...\\n    return data;\\n}\\nint main(){\\n    //调用指针函数\\n    Data * myData = f(4,5);\\n    //Data * myData = static_cast<Data*>(f(4,5));\\n   //...\\n}\\n\\n//函数指针示例\\nint add(int x,int y){\\n    return x+y;\\n}\\n//函数指针\\nint (*fun)(int x,int y);\\n//赋值\\nfun = add;\\n//调用\\ncout << \\\"(*fun)(1,2) = \\\" << (*fun)(1,2) ;\\n//输出结果\\n//(*fun)(1,2) =  3\\n```\\n\\n### 1.20 说说const int *a, int const *a, const int a, int *const a, const int *const a分别是什么，有什么特点。\\n\\n参考答案：\\n\\n```cpp\\n1. const int a;     //指的是a是一个常量，不允许修改。\\n2. const int *a;    //a指针所指向的内存里的值不变，即（*a）不变\\n3. int const *a;    //同const int *a;\\n4. int *const a;    //a指针所指向的内存地址不变，即a不变\\n5. const int *const a;   //都不变，即（*a）不变，a也不变\\n```\\n\\n### 1.21 说说使用指针需要注意什么？\\n\\n1. 定义指针时，先初始化为NULL。\\n2. 用malloc或new申请内存之后，应该立即检查指针值是否为NULL。防止使用指针值为NULL的内存。\\n3. 不要忘记为数组和动态内存赋初值。防止将未被初始化的内存作为右值使用。\\n4. 避免数字或指针的下标越界，特别要当心发生“多1”或者“少1”操作\\n5. 动态内存的申请与释放必须配对，防止内存泄漏\\n6. 用free或delete释放了内存之后，立即将指针设置为NULL，防止“野指针”\\n\\n示例代码：\\n\\n```cpp\\n//（1）初始化置NULL\\n//（2）申请内存后判空\\n//（3）指针释放后置NULL\\nint *p = NULL; //初始化置NULL\\np = (int *)malloc(sizeof(int)*n); //申请n个int内存空间  \\nassert(p != NULL); //判空，防错设计\\np = (int *) realloc(p, 25);//重新分配内存, p 所指向的内存块会被释放并分配一个新的内存地址\\nfree(p);  \\np = NULL; //释放后置空\\n\\nint *p1 = NULL; //初始化置NULL\\np1 = (int *)calloc(n, sizeof(int)); //申请n个int内存空间同时初始化为0 \\nassert(p1 != NULL); //判空，防错设计\\nfree(p1);  \\np1 = NULL; //释放后置空\\n\\nint *p2 = NULL; //初始化置NULL\\np2 = new int[n]; //申请n个int内存空间  \\nassert(p2 != NULL); //判空，防错设计\\ndelete []p2;  \\np2 = nullptr; //释放后置空  \\n```\\n\\n### 1.22 说说内联函数和函数的区别，内联函数的作用\\n\\n1. 内联函数比普通函数多了关键字inline\\n2. 内联函数避免了函数调用的开销；普通函数有调用的开销\\n3. 普通函数在被调用的时候，需要寻址（函数入口地址）；内联函数不需要寻址。\\n4. 内联函数有一定的限制，内联函数体要求代码简单，不能包含复杂的结构控制语句；普通函数没有这个要求。\\n\\n**内联函数的作用**：内联函数在调用时，是将调用表达式用内联函数体来替换。避免函数调用的开销。\\n\\n在使用内联函数时，应注意如下几点：　\\n\\n1. 在内联函数内不允许用循环语句和开关语句。　\\n\\n如果内联函数有这些语句，则编译将该函数视同普通函数那样产生函数调用代码,递归函数是不能被用来做内联函数的。内联函数只适合于只有1～5行的小函数。对一个含有许多语句的大函数，函数调用和返回的开销相对来说微不足道，所以也没有必要用内联函数实现。　\\n\\n2. 内联函数的定义必须出现在内联函数第一次被调用之前。\\n\\n### 1.23 简述C++有几种传值方式，之间的区别是什么？\\n\\n传参方式有这三种：**值传递**、**引用传递**、**指针传递**\\n\\n1. 值传递：形参即使在函数体内值发生变化，也不会影响实参的值；\\n2. 引用传递：形参在函数体内值发生变化，会影响实参的值；\\n3. 指针传递：在指针指向没有发生改变的前提下，形参在函数体内值发生变化，会影响实参的值；\\n\\n值传递用于对象时，整个对象会拷贝一个副本，这样效率低；而引用传递用于对象时，不发生拷贝行为，只是绑定对象，更高效；指针传递同理，但不如引用传递安全。\\n\\n```cpp\\n//代码示例\\n#include <iostream>\\nusing namespace std;\\n\\nvoid testfunc(int a, int *b, int &c){//形参a值发生了改变，但是没有影响实参i的值；但形参*b、c的值发生了改变，影响到了实参*j、k的值\\n    a += 1;\\n    (*b) += 1;\\n    c += 1;\\n    printf(\\\"a= %d, b= %d, c= %d\\\\n\\\",a,*b,c);//a= 2, b= 2, c= 2\\n}\\nint main(){\\n       int i = 1;\\n    int a = 1;\\n    int *j = &a;\\n    int k = 1;\\n    testfunc(i, j, k);\\n    printf(\\\"i= %d, j= %d, k= %d\\\\n\\\",i,*j,k);//i= 1, j= 2, k= 2\\n    return 0;\\n}\\n```\\n\\n### 1.24 简述const（星号）和（星号）const的区别\\n\\n代码示例：\\n\\n```cpp\\n//const* 是常量指针，*const 是指针常量\\n\\nint const *a;    //a指针所指向的内存里的值不变，即（*a）不变\\nint *const a;    //a指针所指向的内存地址不变，即a不变\\n```\\n\\n\\n\\n\\n\\n\\n## 2、C/C++内存问题\\n\\n### 2.1 简述一下堆和栈的区别\\n\\n1. **堆栈空间分配不同**。栈由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等；堆一般由程序员分配释放。\\n2. **堆栈缓存方式不同**。栈使用的是一级缓存， 它们通常都是被调用时处于存储空间中，调用完毕立即释放；堆则是存放在二级缓存中，速度要慢些。\\n3. **堆栈数据结构不同**。堆类似数组结构；栈类似栈结构，先进后出。\\n\\n### 2.2 简述C++的内存管理\\n\\n1. 内存分配方式\\n   在C++中，内存分成5个区，他们分别是堆、栈、自由存储区、全局/静态存储区和常量存储区。\\n\\n><font color=\'red\'>栈</font>，在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。\\n>\\n><font color=\'red\'>堆</font>，就是那些由malloc/realloc/calloc分配的内存块，一般一个malloc就要对应一个free。\\n>\\n><font color=\'red\'>自由存储区</font>，就是那些由new分配的内存块，和堆是十分相似的，不过是用delete来结束自己的生命。 【补充说明】\\n>\\n><font color=\'red\'>全局/静态存储区</font>，全局变量和静态变量被分配到同一块内存中\\n>\\n><font color=\'red\'>常量存储区</font>，这是一块比较特殊的存储区，里面存放的是常量，不允许修改。\\n\\n【**补充说明**】：\\n\\n如果我接着问你自由存储区与堆有什么区别，你或许这样回答：“malloc在堆上分配的内存块，使用free释放内存，而new所申请的内存则是在自由存储区上，使用delete来释放。”\\n\\n这样听起来似乎也没错，但如果我接着问：\\n\\n自由存储区与堆是两块不同的内存区域吗？它们有可能相同吗？\\n\\n你可能就懵了。\\n\\n**尽管C++标准没有要求，但很多编译器的new/delete都是以malloc/free为基础来实现的。那么请问：借以malloc实现的new，所申请的内存是在堆上还是在自由存储区上？ 明显，此时的堆与自由存储区所代表的空间是相同的。**\\n\\n如果，你重载了new运算符，使其不在堆上开辟空间，那么对于自动存储区的概念就完全不相同了。\\n\\n从技术上来说，堆（heap）是C语言和操作系统的术语。堆是操作系统所维护的一块特殊内存，它提供了动态分配的功能，当运行程序调用malloc()时就会从中分配，稍后调用free可把内存交还。而自由存储是C++中通过new和delete动态分配和释放对象的抽象概念，通过new来申请的内存区域可称为自由存储区。基本上，所有的C++编译器默认使用堆来实现自由存储，也即是缺省的全局运算符new和delete也许会按照malloc和free的方式来被实现，这时藉由new运算符分配的对象，说它在堆上也对，说它在自由存储区上也正确。但程序员也可以通过重载操作符，改用其他内存来实现自由存储，例如全局变量做的对象池，这时自由存储区就区别于堆了。我们所需要记住的就是：\\n\\n><font color=\'red\'>堆是操作系统维护的一块内存，而自由存储是C++中通过new与delete动态分配和释放对象的抽象概念。堆与自由存储区并不等价。</font>\\n\\n【**补充说明结束**】\\n\\n2. 常见的内存错误和对策\\n\\n（1）内存分配未成功，却使用了它。\\n\\n（2）内存分配虽然成功，但是尚未初始化就引用它。\\n\\n（3）内存分配成功并且已经初始化，但操作越过了内存的边界。\\n\\n（4）忘记了释放内存，造成内存泄露。\\n\\n（5）释放了内存却继续使用它。\\n\\n对策：\\n\\n（1）定义指针时，先初始化为NULL。\\n\\n（2）用malloc或new申请内存之后，应该立即检查指针值是否为NULL。防止使用指针值为NULL的内存。\\n\\n（3）不要忘记为数组和动态内存赋初值。防止将未被初始化的内存作为右值使用。\\n\\n（4）避免数字或指针的下标越界，特别要当心发生“多1”或者“少1”操作\\n\\n（5）动态内存的申请与释放必须配对，防止内存泄漏\\n\\n（6）用free或delete释放了内存之后，立即将指针设置为NULL，防止“野指针”\\n\\n（7）使用智能指针。\\n\\n3. 内存泄漏及解决办法\\n\\n**什么是内存泄露？**\\n\\n简单地说就是申请了一块内存空间，使用完毕后没有释放掉。（1）new和malloc申请资源使用后，没有用delete和free释放；（2）子类继承父类时，父类析构函数不是虚函数。（3）Windows句柄资源使用后没有释放。\\n\\n**怎么检测？**\\n\\n第一：良好的编码习惯，使用了内存分配的函数，一旦使用完毕,要记得使用其相应的函数释放掉。\\n\\n第二：将分配的内存的指针以链表的形式自行管理，使用完毕之后从链表中删除，程序结束时可检查改链表。\\n\\n第三：使用智能指针。\\n\\n第四：一些常见的工具插件，如ccmalloc、Dmalloc、Leaky、Valgrind等等。\\n\\n### 2.3 malloc和局部变量分配在堆还是栈？\\n\\n malloc是在堆上分配内存，需要程序员自己回收内存；局部变量是在栈中分配内存，超过作用域就自动回收。\\n\\n### 2.4 程序有哪些section，分别的作用？程序启动的过程？怎么判断数据分配在栈上还是堆上？\\n\\n![图1](https://s3.bmp.ovh/imgs/2022/08/29/91e07f9f6bdac247.png)\\n\\n**一个程序有哪些section**：\\n\\n如上图，从低地址到高地址，一个程序由**代码段、数据段、 BSS 段**组成。\\n\\n【1】、**数据段**：存放程序中已初始化的全局变量和静态变量的一块内存区域。\\n\\n【2】、**代码段**：存放程序执行代码的一块内存区域。只读，代码段的头部还会包含一些<font color=\'blue\'>只读的**常数变量**</font>。(全局常量和字符串常量位于全局区/静态区还是代码区，还有待商榷)\\n\\n【3】、**BSS 段**：存放程序中未初始化的全局变量和静态变量的一块内存区域。\\n\\n【4】、可执行程序在运行时又会多出两个区域：堆区和栈区。\\n\\n**堆区**：动态申请内存用。堆从低地址向高地址增长。\\n\\n**栈区**：存储局部变量、函数参数值。栈从高地址向低地址增长。是一块连续的空间。\\n\\n【5】、最后还有一个**文件映射区**，位于堆和栈之间。\\n\\n<font color=\'red\'>【警告】：在网上查阅的资料显示，字符串常量存放在全局/静态区，而不是代码区。普通常量也是位于全局/静态区。</font>根据观察和代码验证，字符串数组是变量，存放在栈区；字符串指针是常量，存放在全局/静态区。还有一点，全局/静态区是低地址，栈是高地址。\\n\\n```cpp\\n#include <stdio.h>\\n\\nvoid test01()\\n{\\nchar str1[] = \\\"abcd\\\";\\nchar str2[] = \\\"abcd\\\";\\n \\nconst char str3[] = \\\"abcd\\\";\\nconst char str4[] = \\\"abcd\\\";\\n \\nconst char *str5 = \\\"abcd\\\";\\nconst char *str6 = \\\"abcd\\\";\\n \\nchar *str7 = \\\"abcd\\\";\\nchar *str8 = \\\"abcd\\\";\\n\\nprintf(\\\"str1: %p\\\\n\\\",str1);\\nprintf(\\\"str2: %p\\\\n\\\",str2);\\nprintf(\\\"str3: %p\\\\n\\\",str3);\\nprintf(\\\"str4: %p\\\\n\\\",str4);\\n\\nprintf(\\\"str5: %p\\\\n\\\",str5);\\nprintf(\\\"str6: %p\\\\n\\\",str6);\\nprintf(\\\"str7: %p\\\\n\\\",str7);\\nprintf(\\\"str8: %p\\\\n\\\",str8);\\n}\\n\\nvoid test02()\\n{\\n    char p[]=\\\"hello world!\\\";\\n    printf(\\\"test02 p[] is %p\\\\n\\\",p);\\n\\n    char *p1=\\\"hello world!\\\";\\n    printf(\\\"test02 *p is %p\\\\n\\\",p1);\\n}\\n\\nint main()\\n{\\n    test01();\\n    test02();\\n    return 0;\\n}\\n//输出结果为:\\nstr1: 0061FEEB //栈 char str1[] = \\\"abcd\\\";\\nstr2: 0061FEE6 //栈 char str2[] = \\\"abcd\\\";\\nstr3: 0061FEE1 //栈 const char str3[] = \\\"abcd\\\";\\nstr4: 0061FEDC //栈 const char str4[] = \\\"abcd\\\";\\nstr5: 00405094 //全局/静态区 const char str3[] = \\\"abcd\\\";\\nstr6: 00405094 //全局/静态区 const char *str6 = \\\"abcd\\\";\\nstr7: 00405094 //全局/静态区 char *str7 = \\\"abcd\\\";\\nstr8: 00405094 //全局/静态区 char *str8 = \\\"abcd\\\";\\ntest02 p[] is 0061FEEF //栈 char p[]=\\\"hello world!\\\";\\ntest02 *p is 00405064 //全局/静态区 char *p1=\\\"hello world!\\\";\\n```\\n\\n<font color=\'red\'>注意！</font>字符串指针所表示的是字符串常量，并且全局常量和字符串常量都是位于全局/静态变量区，但是，局部常量位于栈区。演示代码如下所示：\\n\\n```cpp\\n#include <stdio.h>\\n\\n//已初始化的全局变量 --全局区的.data区\\nint g_a=10;\\nint g_b=12;\\n\\n//已初始化的全局静态变量   --全局区的.data区 \\nstatic int s_g_a=10;\\nstatic int s_g_b=10;\\n\\n//全局常量 全局区\\nconst int g_c_a=10;\\nconst int g_c_b=11;\\n\\nvoid test01()\\n{\\n    //静态局部变量  全局区\\n    static int s_a=10;\\n    static int s_b=11;\\n\\n    //局部常量  位于栈区\\n    const int l_g_c_a=10;\\n    const int l_g_c_b=11;\\n\\n    printf(\\\"全局变量g_a的地址是：%p\\\\n\\\",&g_a);\\n    printf(\\\"全局变量g_b的地址是：%p\\\\n\\\",&g_b);\\n\\n    printf(\\\"全局静态变量s_g_a的地址是：%p\\\\n\\\",&s_g_a);\\n    printf(\\\"全局静态变量s_g_b的地址是：%p\\\\n\\\",&s_g_b);\\n\\n    printf(\\\"静态局部变量s_a的地址是：%p\\\\n\\\",&s_a);\\n    printf(\\\"静态局部变量s_b的地址是：%p\\\\n\\\",&s_b);\\n\\n    printf(\\\"全局常量g_a的地址是：%p\\\\n\\\",&g_c_a);\\n    printf(\\\"全局常量g_b的地址是：%p\\\\n\\\",&g_c_b);\\n\\n    printf(\\\"局部常量g_a的地址是：%p\\\\n\\\",&l_g_c_a);\\n    printf(\\\"局部常量g_b的地址是：%p\\\\n\\\",&l_g_c_b);\\n\\n    //字符串常量 全局区\\n    printf(\\\"字符串常量的地址是：%p\\\\n\\\",&\\\"Hello1\\\");\\n    printf(\\\"字符串常量的地址是：%p\\\\n\\\",&\\\"Hello2\\\");\\n}\\n\\nint main()\\n{\\n    test01();\\n    return 0;\\n}\\n//测试结果为：\\n全局变量g_a的地址是：00404004\\n全局变量g_b的地址是：00404008\\n全局静态变量s_g_a的地址是：0040400C\\n全局静态变量s_g_b的地址是：00404010\\n静态局部变量s_a的地址是：00404014\\n静态局部变量s_b的地址是：00404018\\n全局常量g_a的地址是：00405064\\n全局常量g_b的地址是：00405068\\n局部常量g_a的地址是：0061FF0C\\n局部常量g_b的地址是：0061FF08\\n字符串常量的地址是：0040517D\\n字符串常量的地址是：0040519C\\n```\\n\\n<font color=\'red\'>有一种说法</font>：程序只分text区、data区、bss区，当程序运行时才会增加堆区和栈区。（linux下查看代码二进制的elf格式)\\n**程序启动的过程**：\\n1、操作系统首先创建相应的进程并分配私有的进程空间，然后操作系统的加载器负责把可执行文件的数据段和代码段映射到进程的虚拟内存空间中。\\n2、加载器读入可执行程序的导入符号表，根据这些符号表可以查找出该可执行程序的所有依赖的动态链接库。\\n3、加载器针对该程序的每一个动态链接库调用LoadLibrary\\n\\t（1）查找对应的动态库文件，加载器为该动态链接库确定一个合适的基地址。\\n\\t（2）加载器读取该动态链接库的导入符号表和导出符号表，比较应用程序要求的导入符号是否匹配该库的导出符号。\\n\\t（3）针对该库的导入符号表，查找对应的依赖的动态链接库，如有跳转，则跳到3\\n\\t（4）调用该动态链接库的初始化函数\\n4、初始化应用程序的全局变量，对于全局对象自动调用构造函数。\\n5、进入应用程序入口点函数开始执行。\\n**怎么判断数据分配在栈上还是堆上**：首先局部变量分配在栈上；而通过malloc和new申请的空间是在堆上。\\n\\n### 2.5 初始化为0的全局变量在bss还是data\\n\\n答：全局变量和静态变量，初始化了的存入data段，未初始化的存入bss段。\\n\\n### 2.6 请简述一下atomoic内存顺序\\n\\n有六个内存顺序选项可应用于对原子类型的操作：\\n\\nmemory_order_relaxed：在原子类型上的操作以自由序列执行，没有任何同步关系，仅对此操作要求原子性。\\n\\nmemory_order_consume：memory_order_consume只会对其标识的对象保证该对象存储先行于那些需要加载该对象的操作。\\n\\nmemory_order_acquire：使用memory_order_acquire的原子操作，当前线程的读写操作都不能重排到此操作之前。\\n\\nmemory_order_release：使用memory_order_release的原子操作，当前线程的读写操作都不能重排到此操作之后。\\n\\nmemory_order_acq_rel：memory_order_acq_rel在此内存顺序的读-改-写操作既是获得加载又是释放操作。没有操作能够从此操作之后被重排到此操作之前，也没有操作能够从此操作之前被重排到此操作之后。\\n\\nmemory_order_seq_cst：memory_order_seq_cst比std::memory_order_acq_rel更为严格。memory_order_seq_cst不仅是一个\\\"获取释放\\\"内存顺序，它还会对所有拥有此标签的内存操作建立一个单独全序。\\n\\n除非你为特定的操作指定一个顺序选项，否则内存顺序选项对于所有原子类型默认都是memory_order_seq_cst。\\n\\n## 2.7 简述C++中内存对齐的使用场景\\n\\n内存对齐应用于三种数据类型中：struct/class/union\\n\\nstruct/class/union内存对齐原则有四个：\\n\\n>1. 数据成员对齐规则：结构(struct)或联合(union)的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小或者成员的子成员大小的整数倍开始。\\n\\n>2. 结构体作为成员:如果一个结构里有某些结构体成员,则结构体成员要从其内部\\\"最宽基本类型成员\\\"的整数倍地址开始存储。(struct a里存有struct b,b里有char,int ,double等元素,那b应该从8的整数倍开始存储)。\\n\\n>3. 收尾工作:结构体的总大小，也就是sizeof的结果，必须是其内部最大成员的\\\"最宽基本类型成员\\\"的整数倍。不足的要补齐。(基本类型不包括struct/class/uinon)。\\n\\n>4. sizeof(union)，以结构里面size最大元素为union的size，因为在某一时刻，union只有一个成员真正存储于该地址。\\n\\n补充说明：\\n\\n1. **什么是字节对齐**\\n\\n那么什么是字节对齐？在C语言中，结构体是一种复合数据类型，其构成元素既可以是基本数据类型（如int、long、float等）的变量，也可以是一些复合数据类型（如数组、结构体、联合体等）的数据单元。在结构体中，编译器为结构体的每个成员按其自然边界（alignment）分配空间。各个成员按照它们被声明的顺序在内存中顺序存储，第一个成员的地址和整个结构体的地址相同。\\n\\n为了使CPU能够对变量进行快速的访问，变量的起始地址应该具有某些特性，即所谓的“对齐”，比如4字节的int型，其起始地址应该位于4字节的边界上，即起始地址能够被4整除，也即“对齐”跟数据在内存中的位置有关。如果一个变量的内存地址正好位于它长度的整数倍，他就被称做自然对齐。\\n\\n比如在32位cpu下，假设一个整型变量的地址为0x00000004(为4的倍数)，那它就是自然对齐的，而如果其地址为0x00000002（非4的倍数）则是非对齐的。现代计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。\\n\\n2. **为什么要字节对齐**\\n\\n需要字节对齐的根本原因在于CPU访问数据的效率问题。假设上面整型变量的地址不是自然对齐，比如为0x00000002，则CPU如果取它的值的话需要访问两次内存，第一次取从0x00000002-0x00000003的一个short，第二次取从0x00000004-0x00000005的一个short然后组合得到所要的数据，如果变量在0x00000003地址上的话则要访问三次内存，第一次为char，第二次为short，第三次为char，然后组合得到整型数据。\\n\\n而如果变量在自然对齐位置上，则只要一次就可以取出数据。一些系统对对齐要求非常严格，比如sparc系统，如果取未对齐的数据会发生错误，而在x86上就不会出现错误，只是效率下降。\\n\\n各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。比如有些平台每次读都是从偶地址开始，如果一个int型（假设为32位系统）如果存放在偶地址开始的地方，那么一个读周期就可以读出这32bit，而如果存放在奇地址开始的地方，就需要2个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该32bit数据。显然在读取效率上下降很多。\\n\\n3. **字节对齐实例**：\\n\\n```cpp\\nunion example {  \\n    int a[5];  \\n    char b;  \\n    double c;  \\n};  \\nint result = sizeof(example);  \\n/*\\n联合体只取最长的，int a[5]，长度为20，字节对齐为24\\n*/\\n\\nstruct example {  \\n    int a[5];  \\n    char b;  \\n    double c;  \\n}test_struct;\\nint result = sizeof(test_struct);  \\n/*\\nstruct总和 int 20 分为 8 8 4 char 1 double 8 最大对齐8 char补充到int的4 所以为 8+8+8（4+1）+8（double），总计32\\n*/\\n\\nstruct example {  \\n    char b;  \\n    double c;  \\n    int a;  \\n}test_struct;  \\nint result = sizeof(test_struct);  \\n/*\\n字节对齐除了内存起始地址要是数据类型的整数倍以外，还要满足一个条件，那就是占用的内存空间大小需要是结构体中占用最大内存空间的类型的整数倍，所以20不是double（8Byte）的整数倍，我们还要扩充四个字节，最后的结果是result=24\\n*/\\n```\\n\\n## 3、C++面向对象\\n\\n### 3.1 简述一下什么是面向对象\\n\\n1. 面向对象是一种编程思想，把一切东西看成是一个个对象，比如人、耳机、鼠标、水杯等，他们各自都有属性，比如：耳机是白色的，鼠标是黑色的，水杯是圆柱形的等等，把这些对象拥有的属性变量和操作这些属性变量的函数打包成一个类来表示\\n\\n2. 面向过程和面向对象的区别\\n\\n面向过程：根据业务逻辑从上到下写代码\\n\\n面向对象：将数据与函数绑定到一起，进行封装，这样能够更快速的开发程序，减少了重复代码的重写过程\\n\\n### 3.2 简述一下面向对象的三大特征\\n\\n封装、继承、多态\\n\\n1. 封装：将数据和操作数据的方法进行有机结合，隐藏对象的属性和实现细节，仅对外公开接口来和对象进行 交互。封装本质上是一种管理：我们如何管理兵马俑呢？比如如果什么都不管，兵马俑就被随意破坏了。那么我们首先建了一座房子把兵马俑给封装起来。但是我们目的全封装起来，不让别人看。所以我们开放了售票通道，可以买票突破封装在合理的监管机制下进去参观。类也是一样，不想给别人看到的，我们使用protected/private把成员封装起来。开放一些公有的成员函数对成员合理的访问。所以封装本质是一种管理。\\n\\n2. 继承：可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。\\n   三种继承关系：\\n\\n| 继承方式            | private继承     | protected继承     | public继承        |\\n| ------------------- | --------------- | ----------------- | ----------------- |\\n| 基类的private成员   | 不可见          | 不可见            | 不可见            |\\n| 基类的protected成员 | 变为private成员 | 仍为protected成员 | 仍为protected成员 |\\n| 基类的public成员    | 变为private成员 | 变为protected成员 | 仍为protected成员 |\\n\\n3. 多态：用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。实现多态，有二种方式，重写，重载。（虚函数/纯虚函数、函数重载）\\n\\n### 3.3 简述一下C++的重写与重载，以及他们之间的区别\\n\\n1、重写\\n\\n是指派生类中存在重新定义的函数。其函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致。只有函数体不同（花括号内），派生类对象调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有virtual修饰。（虚函数/纯虚函数）\\n\\n```cpp\\n#include<bits/stdC++.h>\\n\\nusing namespace std;\\n\\nclass A\\n{\\npublic:\\n    virtual    void fun()\\n    {\\n        cout << \\\"A\\\";\\n    }\\n};\\nclass B :public A\\n{\\npublic:\\n    virtual void fun()\\n    {\\n        cout << \\\"B\\\";\\n    }\\n};\\nint main(void)\\n{\\n    A* a = new B();\\n    a->fun();//输出B，A类中的fun在B类中重写\\n}\\n```\\n\\n2、重载\\n\\n我们在平时写代码中会用到几个函数但是他们的实现功能相同，但是有些细节却不同。例如：交换两个数的值其中包括（int, float,char,double)这些个类型。在C语言中我们是利用不同的函数名来加以区分。这样的代码不美观而且给程序猿也带来了很多的不便。于是在C++中人们提出了用一个函数名定义多个函数，也就是所谓的函数重载。函数重载是指同一可访问区内被声明的几个具有不同参数列（**参数的类型，个数，顺序不同**）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型。\\n\\n```cpp\\n#include<bits/stdC++.h>\\n\\nusing namespace std;\\n\\nclass A\\n{\\n    void fun() {};\\n    void fun(int i) {};\\n    void fun(int i, int j) {};\\n    void fun1(int i,int j){};\\n};\\n```\\n\\n### 3.4 C++如何实现重写与重载的？在C语言中怎么实现函数重载？\\n\\n答1：重写：在基类的函数前加上virual关键字，就可以在派生类中重写该函数，运行时将会根据对象的实际类型来调用对应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数。\\n\\n>i. 用virtual关键字申明的函数叫做虚函数，虚函数肯定是类的成员函数\\n>ii. 存在虚函数的类都有一个一维的虚函数表叫做虚表，类的对象有一个指向虚表开始的虚指针。虚表是和类对应的，虚表指针是和对象对应的\\n>iii. 多态性是一个接口多种实现，是面向对象的核心，分为类的多态性和函数的多态性\\n>iv. 重写用虚函数来实现，结合动态绑定\\n>v. 纯虚函数是虚函数再加上 = 0\\n>vi. 抽象类是指包括至少一个纯虚函数的类\\n\\n纯虚函数：virtual void fun()=0。即抽象类必须在子类实现这个函数，即先有名称，没有内容，在派生类实现内容。而虚函数可以再子类中不实现。还有，仅含有虚函数的类，并不是抽象类。\\n\\n答2：重载：C++通过命名倾轧（name mangling）技术来改名函数名，区分参数不同的同名函数，命名倾轧是在编译阶段完成的。\\n\\n题外话：C++在编译阶段通过函数名+形参列表的方式来区分函数，所以可以实现函数重载。而C语言在编译时是以函数名来区分函数的，所以C与C++混编的时候会出现错误。可以在++代码中使用extern{}关键字来保证正确编译。\\n\\n答3：c语言中不允许有同名函数，因为编译时函数命名是一样的，不像C++会添加参数类型和返回类型作为函数编译后的名称，进而实现重载。如果要用c语言显现函数重载，可通过以下方式来实现：\\n\\n>1. 使用函数指针来实现，重载的函数不能使用同名称，只是类似的实现了函数重载功能\\n>2. 重载函数使用可变参数，方式如打开文件open函数\\n>3. gcc有内置函数，程序使用编译函数可以实现函数重载\\n\\n一般方式1比较常用，示例代码：\\n\\n```cpp\\n#include<stdio.h>\\n\\nvoid func_int(void * a)\\n{\\n    printf(\\\"%d\\\\n\\\",*(int*)a);  //输出int类型，注意 void * 转化为int\\n}\\n\\nvoid func_double(void * b)\\n{\\n    printf(\\\"%.2f\\\\n\\\",*(double*)b);\\n}\\n\\ntypedef void (*ptr)(void *);  //typedef申明一个函数指针\\n\\nvoid c_func(ptr p,void *param)\\n{\\n     p(param);                //调用对应函数\\n}\\n\\nint main()\\n{\\n    int a = 23;\\n    double b = 23.23;\\n    c_func(func_int,&a);\\n    c_func(func_double,&b);\\n    return 0;\\n}\\n```\\n\\n关于typedef和函数指针的恩怨纠葛，在补充代码如下：\\n\\n```cpp\\n//形式1：返回类型(*函数名)(参数列表)\\n#include <iostream>\\nusing namespace std;\\n//定义一个函数指针pFUN，它指向一个返回类型为char，有一个整型的参数的函数\\nchar (*pFun)(int);\\n//定义一个返回类型为char，参数为int的函数\\n//从指针层面上理解该函数，即函数的函数名实际上是一个指针，\\n//该指针指向函数在内存中的首地址\\nchar glFun(int a)\\n{\\n    cout << a;\\n    //return a;\\n}\\nint main()\\n{\\n//将函数glFun的地址赋值给变量pFun\\n    pFun = glFun;\\n//*pFun”显然是取pFun所指向地址的内容，当然也就是取出了函数glFun()的内容，然后给定参数为2。\\n    (*pFun)(2);\\n    return 0;\\n}\\n\\n//形式2 typedef  返回类型(*新类型)(参数表)\\n// typedef可以让函数指针更直观方便 ,typedef是新定义了一种类型\\ntypedef char (*PTRFUN)(int); \\nPTRFUN pFun; \\nchar glFun(int a){ return;} \\nvoid main() \\n{ \\n    pFun = glFun; \\n    (*pFun)(2); \\n}\\n```\\n\\n对于typedef void(\\\\*T)(void \\\\*)，我们进行一层层的剖析\\n\\n1、首先写成 void(\\\\*T)() 可以看出 T是一个指针，是一个指向返回值为void ，参数为空的类型的函数指针\\n\\n2、在加上(void \\\\*)  为 void(\\\\*T)(void \\\\*)  就变成了一个指向 返回值为void，参数为void \\\\*类型的指针\\n\\n3、在加上上typedef ，加上后，T就不再是一个函数指针了，它代表着一种类型，这种类型可以定义一个 指向 返回值为void，参数为void \\\\*类型的指针 \\n\\n4、``比如 T t;``\\n\\n``void func(void \\\\*)；``\\n\\n``t=func ``\\n\\n### 3.5 构造函数分为哪几种？\\n\\n默认无参构造函数、拷贝构造函数、有参构造函数（初始化列表或函数体内赋值）、<font color=\'red\'>移动构造函数</font>\\n\\n需要注意：有参构造中，可细分为初始化列表he函数体内赋值。初始化列表就是在定义变量的同时就给值，函数体内赋值相当于先定义变量，再给值。当类中有成员变量为常量时，必须使用初始化列表。\\n\\n下面以代码举例，说明拷贝构造函数和移动构造函数：\\n\\n```cpp\\n//拷贝构造函数\\nTest(const Test& t)\\n    {\\n        this->i = t.i;\\n        this->p = new int(*t.p);\\n    }\\n    \\n//移动构造函数\\nclass Example{\\nprivate:\\n\\tstring *ptr;\\npublic:\\n\\t //移动构造函数\\n\\t Example (Example&& x) : ptr(x.ptr) \\n    {\\n        x.ptr = nullptr;\\n    }\\n    //拷贝构造函数 深拷贝  区别在于不会处理形参元素x\\n    Example (Example& x)\\n    {\\n    \\tdelete ptr;\\n    \\tptr=new string(x.ptr);\\n    }\\n    //有参构造函数\\n    Example (const string& str) : ptr(new string(str)) {}\\n    //重载赋值运算符\\n    Example& operator= (Example6&& x) \\n    {\\n        delete ptr; \\n        ptr = x.ptr;\\n        x.ptr=nullptr;\\n        return *this;\\n    }\\n    //打印字符串\\n    const string& content() const {return *ptr;}\\n    //重载加号运算符：\\n    Example operator+(const Example& rhs) \\n    {\\n        return Example(content()+rhs.content());\\n    }\\n}；\\n```\\n\\n### 3.6 只定义析构函数，会自动生成哪些构造函数\\n\\n只定义了析构函数，编译器将自动为我们生成拷贝构造函数和默认构造函数。\\n\\n注意：有了有参的构造了，编译器就不提供默认的构造函数。\\n\\n### 3.7 说说一个类，默认会生成哪些函数\\n\\n定义了一个空类，默认为生成以下几个函数：\\n1、无参构造函数\\n2、拷贝构造函数（默认的为浅拷贝）\\n3、重载赋值运算符\\n4、析构函数（非虚）\\n\\n### 3.8 说说 C++ 类对象的初始化顺序，有多重继承情况下的顺序\\n\\n1. 创建派生类的对象，基类的构造函数优先被调用（也优先于派生类里的成员类）；\\n\\n2. 如果类里面有成员类，成员类的构造函数优先被调用；(也优先于该类本身的构造函数）\\n\\n3. 基类构造函数如果有多个基类，则<font color=\'red\'>构造函数的调用顺序是某类在类派生表中出现的顺序</font>而不是它们在成员初始化表中的顺序；；（即：class 类名：public 基类1，public 基类2）\\n\\n4. 成员类对象构造函数如果有多个成员类对象，则<font color=\'red\'>构造函数的调用顺序是对象在类中被声明的顺序</font>而不是它们出现在成员初始化表中的顺序；（即：类内变量：类名 变量1；类名 变量2）\\n\\n5. 派生类构造函数，作为一般规则派生类构造函数应该不能直接向一个基类数据成员赋值而是把值传递给适当的基类构造函数,否则两个类的实现变成紧耦合的（tightly coupled）将更加难于正确地修改或扩展基类的实现。（基类设计者的责任是提供一组适当的基类构造函数）\\n\\n综上可以得出，初始化顺序：\\n\\n> 父类构造函数–>成员类对象构造函数–>自身构造函数\\n>\\n> 其中成员变量的初始化与声明顺序有关，构造函数的调用顺序是类派生列表中的顺序。\\n>\\n> 析构顺序和构造顺序相反。\\n\\n代码示例：\\n\\n```cpp\\n#include <iostream>\\nusing namespace std;\\nclass Base1 {\\npublic:\\n\\tBase1(int i)\\n\\t{\\n\\t\\tcout << \\\"construting Base1——\\\" << i << endl;\\n\\t}\\n\\tBase1(Base1& b1)\\n\\t{\\n\\t\\tcout << \\\"Base1 Copy constructor\\\" << endl;\\n\\t}\\n\\t~Base1()\\n\\t{\\n\\t\\tcout << \\\"~Base1\\\" << endl;\\n\\t}\\n};\\nclass Base2\\n{\\npublic:\\n\\tBase2(int j)\\n\\t{\\n\\t\\tcout << \\\"constructing Base2——\\\" << j << endl;\\n\\t}\\n\\tBase2(Base2& b2)\\n\\t{\\n\\t\\tcout << \\\"Base2 Copy constructor\\\" << endl;\\n\\t}\\n\\t~Base2()\\n\\t{\\n\\t\\tcout << \\\"~Base2\\\" << endl;\\n\\t}\\n};\\nclass Derived :public Base1, public Base2\\n{\\npublic:\\n\\t//Derived(int a, int b, int c, int d) :Base1(b), member2(c), Base2(a), member1(d)\\n\\tDerived(int a, int b, int c, int d) :Base1(a), member2(b), Base2(c), member1(d)\\n\\t{\\n\\t\\tcout << \\\"constructing Derived\\\" << endl;\\n\\t}\\n\\tDerived(Derived& d) :Base1(d), member2(d), Base2(d), member1(d)\\n\\t{\\n\\t\\tcout << \\\"Derived Copy constructor \\\" << endl;\\n\\t}\\n\\t~Derived()\\n\\t{\\n\\t\\tcout << \\\"~Derived\\\" << endl;\\n\\t}\\nprivate:\\n\\tBase2 member2; \\n\\tBase1 member1;\\n};\\n//在派生类中的，基类构造函数的调用顺序是，先看权限继承方式上的顺序：public Base1, public Base2；\\n//再看成员变量定义的顺序：Base2 member2; Base1 member1;\\nint test()\\n{\\n\\tDerived d1(1, 2, 3, 4);\\n\\tDerived d2(d1);\\n\\treturn 0;\\n}\\nint main()\\n{\\n\\ttest();\\n\\tsystem(\\\"pause\\\");\\n\\treturn 0;\\n}\\n//输出结果为：\\nconstruting Base1——1\\nconstructing Base2——3\\nconstructing Base2——2\\nconstruting Base1——4\\nconstructing Derived\\nBase1 Copy constructor\\nBase2 Copy constructor\\nBase2 Copy constructor\\nBase1 Copy constructor\\nDerived Copy constructor\\n~Derived\\n~Base1\\n~Base2\\n~Base2\\n~Base1\\n~Derived\\n~Base1\\n~Base2\\n~Base2\\n~Base1\\n```\\n\\n### 3.9 简述下向上转型和向下转型\\n\\n1. 子类转换为父类：向上转型，使用dynamic_cast(expression)，这种转换相对来说比较安全不会有数据的丢失；\\n\\n2. 父类转换为子类：向下转型，可以使用强制转换，这种转换时不安全的，会导致数据的丢失，原因是父类的指针或者引用的内存中可能不包含子类的成员的内存。\\n\\n### 3.10 简述下深拷贝和浅拷贝，如何实现深拷贝\\n\\n1. 浅拷贝：又称值拷贝，将源对象的值拷贝到目标对象中去，本质上来说源对象和目标对象共用一份实体，只是所引用的变量名不同，地址其实还是相同的。举个简单的例子，你的小名叫西西，大名叫冬冬，当别人叫你西西或者冬冬的时候你都会答应，这两个名字虽然不相同，但是都指的是你。\\n\\n2. 深拷贝，拷贝的时候先开辟出和源对象大小一样的空间，然后将源对象里的内容拷贝到目标对象中去，这样两个指针就指向了不同的内存位置。并且里面的内容是一样的，这样不但达到了我们想要的目的，还不会出现问题，两个指针先后去调用析构函数，分别释放自己所指向的位置。即为每次增加一个指针，便申请一块新的内存，并让这个指针指向新的内存，深拷贝情况下，不会出现重复释放同一块内存的错误。\\n\\n### 3.11 简述一下C++中的多态\\n\\n由于派生类重写基类方法，然后用基类引用指向派生类对象，调用方法时候会进行动态绑定，这就是多态。 多态分为静态多态和动态多态：\\n\\n1. 静态多态：编译器在编译期间完成的，编译器会根据实参类型来推断该调用哪个函数，如果有对应的函数，就调用，没有则在编译时报错。例如：\\n\\n```cpp\\ninclude<iostream>\\nusing namespace std;\\n\\nint Add(int a,int b)//1\\n{\\n    return a+b;\\n}\\n\\nchar Add(char a,char b)//2\\n{\\n    return a+b;\\n}\\n\\nint main()\\n{\\n    cout<<Add(666,888)<<endl;//1\\n    cout<<Add(\'1\',\'2\');//2\\n    return 0;\\n}\\n```\\n\\n静态多态，就是在编译阶段就实现的多态。\\n\\n2. 动态多态：其实要实现动态多态，需要几个条件----即动态绑定条件：\\n\\n> 虚函数，基类必须含有虚函数，派生类必须重写虚函数；\\n> 通过基类指针或引用来调用虚函数\\n\\n### 3.12 为什么要虚析构，为什么不能虚构造？\\n\\n1. 为什么要虚析构：将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。如果基类的析构函数不是虚函数，在特定情况下会导致派生类无法被析构。\\n\\n> i. 用派生类类型指针绑定派生类实例，析构的时候，不管基类析构函数是不是虚函数，都会正常析构\\n>\\n> ii. 用基类类型指针绑定派生类实例，析构的时候，如果基类析构函数不是虚函数，则只会析构基类，不会析构派生类对象，从而造成内存泄漏。为什么会出现这种现象呢，个人认为析构的时候如果没有虚函数的动态绑定功能，就只根据指针的类型来进行的，而不是根据指针绑定的对象来进行，所以只是调用了基类的析构函数；如果基类的析构函数是虚函数，则析构的时候就要根据指针绑定的对象来调用对应的析构函数了。\\n\\nC++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。\\n\\n2. 为什么不能虚构造？\\n\\ni. 从存储空间角度：虚函数对应一个vtable,这个表的地址是存储在对象的内存空间的。如果将构造函数设置为虚函数，就需要到vtable 中调用，可是对象还没有实例化，没有内存空间分配，如何调用。（悖论）\\n\\nii. 从使用角度：虚函数主要用于在信息不全的情况下，能使重载的函数得到对应的调用。构造函数本身就是要初始化实例，那使用虚函数也没有实际意义呀。所以构造函数没有必要是虚函数。虚函数的作用在于通过父类的指针或者引用来调用它的时候能够变成调用子类的那个成员函数。而构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数。\\n\\niii. 从实现上看，vtable 在构造函数调用后才建立，因而构造函数不可能成为虚函数。从实际含义上看，在调用构造函数时还不能确定对象的真实类型（因为子类会调父类的构造函数）；而且构造函数的作用是提供初始化，在对象生命期只执行一次，不是对象的动态行为，也没有太大的必要成为虚函数。\\n\\n### 3.13 说说模板类是在什么时候实现的\\n\\n1. 模板实例化：模板的实例化分为显式实例化和隐式实例化，前者是研发人员明确的告诉模板应该使用什么样的类型去生成具体的类或函数，后者是在编译的过程中由编译器来决定使用什么类型来实例化一个模板。不管是显式实例化或隐式实例化，最终生成的类或函数完全是按照模板的定义来实现的\\n\\n2. 模板具体化：当模板使用某种类型实例化后生成的类或函数不能满足需要时，可以考虑对模板进行具体化。具体化时可以修改原模板的定义，当使用该类型时，按照具体化后的定义实现，具体化相当于对某种类型进行特殊处理。<font color=\'blue\'>模板的具体化，就是重写模板</font>>\\n\\n代码示例：\\n\\n```cpp\\n#include <iostream>\\nusing namespace std;\\n\\n// #1 模板定义\\ntemplate<class T>\\nstruct TemplateStruct\\n{\\n    TemplateStruct()\\n    {\\n        cout << sizeof(T) << endl;\\n    }\\n};\\n\\n// #2 模板显示实例化\\ntemplate struct TemplateStruct<int>;\\n\\n// #3 模板具体化\\ntemplate<> struct TemplateStruct<double>\\n{\\n    TemplateStruct() {\\n        cout << \\\"--8--\\\" << endl;\\n    }\\n};\\n\\nint main()\\n{\\n    TemplateStruct<int> intStruct;\\n    TemplateStruct<double> doubleStruct;\\n\\n    // #4 模板隐式实例化\\n    TemplateStruct<char> llStruct;\\n}\\n//输出结果为：\\n4\\n--8--\\n1\\n```\\n\\n### 3.14 说说类继承时，派生类对不同关键字修饰的基类方法的访问权限\\n\\n类中的成员可以分为三种类型，分别为public成员、protected成员、public成员。类中可以直接访问自己类的public、protected、private成员，但类对象只能访问自己类的public成员。\\n\\n1. public继承：派生类可以访问基类的public、protected成员，不可以访问基类的private成员；\\n   派生类对象可以访问基类的public成员，不可以访问基类的protected、private成员。\\n\\n2. protected继承：派生类可以访问基类的public、protected成员，不可以访问基类的private成员；\\n   派生类对象不可以访问基类的public、protected、private成员。\\n\\n3. private继承：派生类可以访问基类的public、protected成员，不可以访问基类的private成员；\\n   派生类对象不可以访问基类的public、protected、private成员。\\n\\n### 3.15 简述一下移动构造函数，什么库用到了这个函数？\\n\\nC++11中新增了移动构造函数。与拷贝类似，移动也使用一个对象的值设置另一个对象的值。但是，又与拷贝不同的是，移动实现的是对象值真实的转移（源对象到目的对象）：源对象将丢失其内容，其内容将被目的对象占有。移动操作的发生的时候，是当移动值的对象是未命名的对象的时候。这里未命名的对象就是那些临时变量，甚至都不会有名称。典型的未命名对象就是函数的返回值或者类型转换的对象。使用临时对象的值初始化另一个对象值，不会要求对对象的复制：因为临时对象不会有其它使用，因而，它的值可以被移动到目的对象。做到这些，就要使用移动构造函数和移动赋值：当使用一个临时变量对对象进行构造初始化的时候，调用移动构造函数。类似的，使用未命名的变量的值赋给一个对象时，调用移动赋值操作。\\n\\n移动操作的概念对对象管理它们使用的存储空间很有用的，诸如对象使用new和delete分配内存的时候。在这类对象中，拷贝和移动是不同的操作：从A拷贝到B意味着，B分配了新内存，A的整个内容被拷贝到为B分配的新内存上。\\n\\n而从A移动到B意味着分配给A的内存转移给了B，没有分配新的内存，它仅仅包含简单地拷贝指针。\\n\\n看下面的例子：\\n\\n```cpp\\n// 移动构造函数和赋值\\n#include <iostream>\\n#include <string>\\nusing namespace std;\\n\\nclass Example6 {\\nprivate:\\n    string* ptr;\\npublic:\\n    Example6 (const string& str) : ptr(new string(str)) {}\\n    ~Example6 () {delete ptr;}\\n    // 移动构造函数，参数x不能是const Pointer&& x，\\n    // 因为要改变x的成员数据的值；\\n    // C++98不支持，C++0x（C++11）支持\\n    Example6 (Example6&& x) : ptr(x.ptr) \\n    {\\n        x.ptr = nullptr;\\n    }\\n    // move assignment\\n    Example6& operator= (Example6&& x) \\n    {\\n        delete ptr; \\n        ptr = x.ptr;\\n        x.ptr=nullptr;\\n        return *this;\\n    }\\n    // access content:\\n    const string& content() const {return *ptr;}\\n    // addition:\\n    Example6 operator+(const Example6& rhs) \\n    {\\n        return Example6(content()+rhs.content());\\n    }\\n};\\nint main () {\\n    Example6 foo(\\\"Exam\\\");           // 构造函数\\n    Example6 bar(move(foo));     // 移动构造函数\\n                                // 调用move之后，foo变为一个右值引用变量，\\n                                // 此时，foo所指向的字符串已经被\\\"掏空\\\"，\\n                                // 所以此时不能再调用foo\\n\\tExample6 bar2 = Example6(\\\"ple\\\"); // 拷贝构造函数\\n    bar = bar+ bar2;             // 移动赋值，在这儿\\\"=\\\"号右边的加法操作，\\n                                // 产生一个临时值，即一个右值\\n                                 // 所以此时调用移动赋值语句\\n    cout << \\\"bar\'s content: \\\" << bar.content() << \'\\\\n\';\\n    return 0;\\n}\\n//说明：std::move()函数时C++11新增的，用于将一个左值引用转换为右值引用。\\n//输出结果为：bar`s content: Example\\n//附加说明：本例中，如何调用重载赋值运算符：Example6 str2=move(bar);此时，bar字符串被删除内存，str2=Example\\n```\\n\\n### 3.16 请你回答一下 C++ 类内可以定义引用数据成员吗？\\n\\nC++类内可以定义引用成员变量，但要遵循以下三个规则：\\n\\n1. 不能用默认构造函数初始化，必须提供构造函数，用初始化列表的方式来初始化引用成员变量。否则会造成引用未初始化错误。\\n\\n2. 构造函数的形参也必须是引用类型。\\n\\n3. 不能在构造函数里初始化，必须在初始化列表中进行初始化。\\n\\n### 3.17 简述一下什么是常函数，有什么作用\\n\\n类的成员函数后面加 const，表明这个函数不会对这个类对象的数据成员（准确地说是非静态数据成员）作任何改变。在设计类的时候，一个原则就是对于不改变数据成员的成员函数都要在后面加const，而对于改变数据成员的成员函数不能加 const。所以 const 关键字对成员函数的行为作了更明确的限定：有 const 修饰的成员函数（指 const 放在函数参数表的后面，而不是在函数前面或者参数表内），只能读取数据成员，不能改变数据成员；没有 const 修饰的成员函数，对数据成员则是可读可写的。除此之外，在类的成员函数后面加 const 还有什么好处呢？那就是**常量（即 const）对象可以调用 const 成员函数，而不能调用非const修饰的函数**。正如非const类型的数据可以给const类型的变量赋值一样，反之则不成立。\\n\\n```cpp\\n#include<iostream>\\nusing namespace std;\\n\\nclass CStu\\n{\\npublic:\\n    int a;\\n    CStu()\\n    {\\n        a = 12;\\n    }\\n\\n    void Show() const\\n    {\\n        //a = 13; //常函数不能修改数据成员\\n        cout <<a << \\\"I am show()\\\" << endl;\\n    }\\n};\\n\\nint main()\\n{\\n    CStu st;\\n    st.Show();\\n    system(\\\"pause\\\");\\n    return 0;\\n}\\n```\\n\\n### 3.18 说说什么是虚继承，解决什么问题，如何实现？\\n\\n虚继承是解决C++多重继承问题的一种手段，从不同途径继承来的同一基类，会在子类中存在多份拷贝。这将存在两个问题：其一，浪费存储空间；第二，存在二义性问题，通常可以将派生类对象的地址赋值给基类对象，实现的具体方式是，将基类指针指向继承类（继承类有基类的拷贝）中的基类对象的地址，但是多重继承可能存在一个基类的多份拷贝，这就出现了二义性。虚继承可以解决多种继承前面提到的两个问题（即菱形继承问题）\\n\\n```cpp\\n#include<iostream>\\nusing namespace std;\\nclass A{\\npublic:\\n    int _a;\\n};\\nclass B :virtual public A\\n{\\npublic:\\n    int _b;\\n};\\nclass C :virtual public A\\n{\\npublic:\\n    int _c;\\n};\\nclass D :public B, public C\\n{\\npublic:\\n    int _d;\\n};\\n//菱形继承和菱形虚继承的对象模型\\nint main()\\n{\\n    D d;\\n    d.B::_a = 1;\\n    d.C::_a = 2;\\n    d._b = 3;\\n    d._c = 4;\\n    d._d = 5;\\n    cout << sizeof(D) << endl;\\n    return 0;\\n}\\n```\\n\\n分别从菱形继承和虚继承来分析：\\n\\n>菱形继承中A在B,C,D,中各有一份，虚继承中，A共享。\\n>\\n>上面的虚继承表实际上是一个指针数组。B、C实际上是虚基表指针，指向虚基表。\\n>\\n>虚基表：存放相对偏移量，用来找虚基类\\n\\n### 3.19 简述一下虚函数和纯虚函数，以及实现原理\\n\\n1. C++中的虚函数的作用主要是实现了多态的机制。关于多态，简而言之就是用父类型的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。这种技术可以让父类的指针有“多种形态”，这是一种泛型技术。**如果调用非虚函数，则无论实际对象是什么类型，都执行基类类型所定义的函数**。非虚函数总是在编译时根据调用该函数的对象，引用或指针的类型而确定。如果调用虚函数，则直到运行时才能确定调用哪个函数，运行的虚函数是引用所绑定或指针所指向的对象所属类型定义的版本。虚函数必须是基类的非静态成员函数。虚函数的作用是实现动态联编，也就是在程序的运行阶段动态地选择合适的成员函数，在定义了虚函数后，可以在基类的派生类中对虚函数重新定义，在派生类中重新定义的函数应与虚函数具有相同的形参个数和形参类型。以实现统一的接口，不同定义过程。如果在派生类中没有对虚函数重新定义，则它继承其基类的虚函数。\\n\\n\\n```cpp\\nclass Person{\\n    public:\\n        //虚函数\\n        virtual void GetName(){\\n            cout<<\\\"PersonName:xiaosi\\\"<<endl;\\n        };\\n};\\nclass Student:public Person{\\n    public:\\n        void GetName(){\\n            cout<<\\\"StudentName:xiaosi\\\"<<endl;\\n        };\\n};\\nint main(){\\n    //指针\\n    Person *person = new Student();\\n    //基类调用子类的函数\\n    person->GetName();//StudentName:xiaosi\\n}\\n```\\n\\n虚函数（Virtual Function）是通过一张虚函数表（Virtual Table）来实现的。简称为V-Table。在这个表中，主是要一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，保证其真实反应实际的函数。这样，在有虚函数的类的实例中这个表被分配在了这个实例的内存中，所以，当我们用父类的指针来操作一个子类的时候，这张虚函数表就显得尤为重要了，它就像一个地图一样，指明了实际所应该调用的函数。\\n\\n\\n2. 纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加“=0” virtualvoid GetName() =0。在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。为了解决上述问题，将函数定义为纯虚函数，则编译器要求在派生类中必须予以重写以实现多态性。同时含有纯虚拟函数的类称为抽象类，它不能生成对象。这样就很好地解决了上述两个问题。将函数定义为纯虚函数能够说明，该函数为后代类型提供了可以覆盖的接口，但是这个类中的函数绝不会调用。声明了纯虚函数的类是一个抽象类。所以，用户不能创建类的实例，只能创建它的派生类的实例。必须在继承类中重新声明函数（不要后面的＝0）否则该派生类也不能实例化，而且它们在抽象类中往往没有定义。定义纯虚函数的目的在于，使派生类仅仅只是继承函数的接口。纯虚函数的意义，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但类无法为纯虚函数提供一个合理的缺省实现。所以类纯虚函数的声明就是在告诉子类的设计者，“你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它”。\\n\\n```cpp\\n//抽象类\\nclass Person{\\n    public:\\n        //纯虚函数\\n        virtual void GetName()=0;\\n};\\nclass Student:public Person{\\n    public:\\n        Student(){\\n        };\\n        void GetName(){\\n            cout<<\\\"StudentName:xiaosi\\\"<<endl;\\n        };\\n};\\nint main(){\\n    Student student;\\n}\\n```\\n\\n### 3.20 说说纯虚函数能实例化吗，为什么？派生类要实现吗，为什么？\\n\\n1. 纯虚函数不可以实例化，但是可以用其派生类实例化，示例如下：\\n\\n```cpp\\nclass Base\\n{\\npublic:\\n    virtual void func() = 0;\\n};\\n```\\n\\n```cpp\\n #include<iostream>\\n\\n using namespace std;\\n\\n class Base\\n {\\n public:\\n     virtual void func() = 0;\\n };\\n\\n class Derived :public Base\\n {\\n public:\\n     void func() override\\n     {\\n         cout << \\\"哈哈\\\" << endl;\\n     }\\n };\\n\\n int main()\\n {\\n     Base *b = new Derived();\\n     b->func();\\n\\n     return 0;\\n }\\n\\n```\\n\\n2. 虚函数的原理采用 vtable。类中含有纯虚函数时，其vtable 不完全，有个空位。\\n   即“纯虚函数在类的vtable表中对应的表项被赋值为0。也就是指向一个不存在的函数。由于编译器绝对不允许有调用一个不存在的函数的可能，所以该类不能生成对象。在它的派生类中，除非重写此函数，否则也不能生成对象。”\\n\\n   所以纯虚函数不能实例化。\\n\\n3. 纯虚函数是在基类中声明的虚函数，它要求任何派生类都要定义自己的实现方法，以实现多态性。\\n\\n4. 定义纯虚函数是为了实现一个接口，用来规范派生类的行为，也即规范继承这个类的程序员必须实现这个函数。派生类仅仅只是继承函数的接口。纯虚函数的意义在于，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但基类无法为纯虚函数提供一个合理的缺省实现。所以类纯虚函数的声明就是在告诉子类的设计者，“你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它”。\\n\\n### 3.21 说说C++中虚函数与纯虚函数的区别\\n\\n答：\\n\\n1. 虚函数和纯虚函数可以定义在同一个类中，含有纯虚函数的类被称为抽象类，而只含有虚函数的类不能被称为抽象类。\\n\\n2. 虚函数可以被直接使用，也可以被子类重载以后，以多态的形式调用，而纯虚函数必须在子类中实现该函数才可以使用，因为纯虚函数在基类有声明而没有定义。\\n\\n3. 虚函数和纯虚函数都可以在子类中被重载，以多态的形式被调用。\\n\\n4. 虚函数和纯虚函数通常存在于抽象基类之中，被继承的子类重载，目的是提供一个统一的接口。\\n\\n5. 虚函数的定义形式：`virtual{}`;纯虚函数的定义形式：`virtual {} = 0`;在虚函数和纯虚函数的定义中不能有static标识符，原因很简单，被static修饰的函数在编译时要求前期绑定,然而虚函数却是动态绑定，而且被两者修饰的函数生命周期也不一样。\\n\\n举个虚函数的例子：\\n\\n```cpp\\nclass A\\n{\\npublic:\\n    virtual void foo()\\n    {\\n        cout<<\\\"A::foo() is called\\\"<<endl;\\n    }\\n};\\nclass B:public A\\n{\\npublic:\\n    void foo()\\n    {\\n        cout<<\\\"B::foo() is called\\\"<<endl;\\n    }\\n};\\nint main(void)\\n{\\n    A *a = new B();\\n    a->foo();   // 在这里，a虽然是指向A的指针，但是被调用的函数(foo)却是B的!\\n    return 0;\\n}\\n```\\n\\n这个例子是虚函数的一个典型应用，通过这个例子，也许你就对虚函数有了一些概念。它虚就虚在所谓“推迟联编”或者“动态联编”上，一个类函数的调用并不是在编译时刻被确定的，而是在运行时刻被确定的。由于编写代码的时候并不能确定被调用的是基类的函数还是哪个派生类的函数，所以被成为“虚”函数。\\n\\n虚函数只能借助于指针或者引用来达到多态的效果。\\n\\n\\n2. 纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加“=0” 。形如`virtual void funtion1()=0`\\n\\n为了方便使用多态特性，我们常常需要在基类中定义虚拟函数。\\n\\n在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。\\n\\n为了解决上述问题，引入了纯虚函数的概念，将函数定义为纯虚函数（方法：virtual ReturnType Function()= 0;），则编译器要求在派生类中必须予以重写以实现多态性。同时含有纯虚拟函数的类称为抽象类，它不能生成对象。这样就很好地解决了上述两个问题。\\n声明了纯虚函数的类是一个抽象类。所以，用户不能创建类的实例，只能创建它的派生类的实例。\\n\\n纯虚函数最显著的特征是：它们必须在继承类中重新声明函数（不要后面的＝0，否则该派生类也不能实例化），而且它们在抽象类中往往没有定义。\\n\\n定义纯虚函数的目的在于，使派生类仅仅只是继承函数的接口。\\n\\n纯虚函数的意义，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但类无法为纯虚函数提供一个合理的缺省实现。所以类纯虚函数的声明就是在告诉子类的设计者，“你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它”。\\n\\n### 3.22 说说 C++ 中什么是菱形继承问题，如何解决\\n\\n使用虚继承来解决该问题\\n\\n```cpp\\nclass Tiger : virtual public Animal { /* ... */ };\\nclass Lion : virtual public Animal { /* ... */ }\\n```\\n\\n### 3.23 请问构造函数中的能不能调用虚方法\\n\\n不要在构造函数中调用虚方法，从语法上讲，调用完全没有问题，但是从效果上看，往往不能达到需要的目的。\\n\\n派生类对象构造期间进入基类的构造函数时，对象类型变成了基类类型，而不是派生类类型。\\n\\n同样，进入基类析构函数时，对象也是基类类型。\\n\\n所以，虚函数始终仅仅调用基类的虚函数（如果是基类调用虚函数），不能达到多态的效果，所以放在构造函数中是没有意义的，而且往往不能达到本来想要的效果。\\n\\n### 3.24 请问拷贝构造函数的参数是什么传递方式，为什么\\n\\n1. 拷贝构造函数的参数必须使用引用传递\\n\\n2. 如果拷贝构造函数中的参数不是一个引用，即形如CClass(const CClass c_class)，那么就相当于采用了传值的方式(pass-by-value)，而传值的方式会调用该类的拷贝构造函数，从而造成无穷递归地调用拷贝构造函数。因此拷贝构造函数的参数必须是一个引用。\\n\\n需要澄清的是，传指针其实也是传值，如果上面的拷贝构造函数写成CClass(const CClass\\\\* c_class)，也是不行的。事实上，只有传引用不是传值外，其他所有的传递方式都是传值。\\n\\n### 3.25 如何理解抽象类？\\n\\n1. 抽象类的定义如下：\\n\\n纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加“=0”，有虚函数的类就叫做抽象类。\\n\\n2. 抽象类有如下几个特点：\\n\\n1）抽象类只能用作其他类的基类，不能建立抽象类对象。\\n\\n2）抽象类不能用作参数类型、函数返回类型或显式转换的类型。\\n\\n3）可以定义指向抽象类的指针和引用，此指针可以指向它的派生类，进而实现多态性。\\n\\n### 3.26 什么是多态？除了虚函数，还有什么方式能实现多态？\\n\\n1. 多态是面向对象的重要特性之一，它是一种行为的封装，就是不同对象对同一行为会有不同的状态。(举例 : 学生和成人都去买票时,学生会打折,成人不会)\\n\\n2. 多态是以封装和继承为基础的。在C++中多态分为静态多态（早绑定）和动态多态（晚绑定）两种，其中动态多态是通过虚函数实现，静态多态通过函数重载实现，代码如下：\\n\\n```cpp\\nclass A\\n{\\npublic:    \\n    void do(int a);    \\n    void do(int a, int b);\\n};\\n```\\n\\n### 3.27 简述一下虚析构函数，什么作用\\n\\n1. 虚析构函数，是将基类的析构函数声明为virtual，举例如下：\\n\\n```cpp\\nclass TimeKeeper\\n{\\npublic:    \\n    TimeKeeper() {}        \\n    virtual ~TimeKeeper() {}    \\n};\\n```\\n\\n2. 虚析构函数的主要作用是防止内存泄露。\\n\\n定义一个基类的指针p，在delete p时，如果基类的析构函数是虚函数，这时只会看p所赋值的对象，如果p赋值的对象是派生类的对象，就会调用派生类的析构函数（毫无疑问，在这之前也会先调用基类的构造函数，在调用派生类的构造函数，然后调用派生类的析构函数，基类的析构函数，所谓先构造的后释放）；如果p赋值的对象是基类的对象，就会调用基类的析构函数，这样就不会造成内存泄露。\\n\\n如果基类的析构函数不是虚函数，在delete p时，调用析构函数时，只会看指针的数据类型，而不会去看赋值的对象，这样就会造成内存泄露。\\n\\n说明：\\n我们创建一个TimeKeeper基类和一些及其它的派生类作为不同的计时方法：\\n\\n```cpp\\nclass TimeKeeper\\n{\\npublic:\\n    TimeKeeper() {}\\n    ~TimeKeeper() {}  //非virtual的\\n};\\n\\n//都继承与TimeKeeper\\nclass AtomicClock :public TimeKeeper{};\\nclass WaterClock :public TimeKeeper {};\\nclass WristWatch :public TimeKeeper {};\\n```\\n\\n如果客户想要在程序中使用时间，不想操作时间如何计算等细节，这时候我们可以设计factory（工厂）函数，让函数返回指针指向一个计时对象。该函数返回一个基类指针，这个基类指针是指向于派生类对象的\\n\\n```cpp\\nTimeKeeper* getTimeKeeper()\\n{\\n    //返回一个指针，指向一个TimeKeeper派生类的动态分配对象\\n}\\n```\\n\\n因为函数返回的对象存在于堆中，因此为了在不使用时我们需要使用释放该对象（delete）\\n\\n```cpp\\nTimeKeeper* ptk = getTimeKeeper();\\ndelete ptk;\\n```\\n\\n**此处基类的析构函数是非virtual的，因此通过一个基类指针删除派生类对象是错误的**\\n\\n<font color=\'red\'>解决办法</font>： 将基类的析构函数改为virtual就正确了\\n\\n```cpp\\nclass TimeKeeper\\n{\\npublic:\\n    TimeKeeper() {}\\n    virtual ~TimeKeeper() {}\\n};\\n```\\n\\n声明为virtual之后，通过基类指针删除派生类对象就会释放整个对象（基类+派生类）\\n\\n### 3.28 说说什么是虚基类，可否被实例化？\\n\\n1. 在被继承的类前面加上virtual关键字，这时被继承的类称为虚基类，代码如下：\\n\\n```cpp\\nclass A\\nclass B1:public virtual A;\\nclass B2:public virtual A;\\nclass D:public B1,public B2;\\n```\\n\\n2. 虚继承的类可以被实例化，举例如下：\\n\\n```cpp\\nclass Animal {/* ... */ };\\nclass Tiger : virtual public Animal { /* ... */ };\\nclass Lion : virtual public Animal { /* ... */ }\\n```\\n\\n```cpp\\nint main( )\\n{\\nLiger lg ;\\n/*既然我们已经在Tiger和Lion类的定义中声明了\\\"virtual\\\"关键字，于是下面的代码编译OK */\\nint weight = lg.getWeight();\\n}\\n```\\n\\n### 3.29  简述一下拷贝赋值和移动赋值？\\n\\n1. 拷贝赋值是通过拷贝构造函数来赋值，在创建对象时，使用同一类中之前创建的对象来初始化新创建的对象。\\n\\n2. 移动赋值是通过移动构造函数来赋值，二者的主要区别在于\\n\\n1）拷贝构造函数的形参是一个左值引用，而移动构造函数的形参是一个右值引用；\\n\\n2）拷贝构造函数完成的是整个对象或变量的拷贝，而移动构造函数是生成一个指针指向源对象或变量的地址，接管源对象的内存，相对于大量数据的拷贝**节省时间和内存空间**。\\n\\n### 3.30 仿函数了解吗？有什么作用\\n\\n1. 仿函数（functor）又称为函数对象（function object）**是一个能行使函数功能的类**。仿函数的语法几乎和我们普通的函数调用一样，不过作为仿函数的类，都<font color=\'red\'>必须重载operator()运算符</font>，举个例子：\\n\\n ```cpp\\n class Func{\\n     public:\\n         void operator() (const string& str) const {\\n             cout<<str<<endl;\\n         }\\n };\\n Func myFunc;\\n myFunc(\\\"helloworld!\\\");\\n//输出：\\nhelloworld!\\n ```\\n\\n2. 仿函数既能想普通函数一样传入给定数量的参数，还能存储或者处理更多我们需要的有用信息。我们可以举个例子：\\n\\n假设有一个`vector<string>`，你的任务是统计长度小于5的string的个数，如果使用count_if函数的话，你的代码可能长成这样：\\n\\n```cpp\\n  bool LengthIsLessThanFive(const string& str) {\\n       return str.length()<5;   \\n  }\\nint res=count_if(vec.begin(), vec.end(), LengthIsLessThanFive);\\n其中count_if函数的第三个参数是一个函数指针，返回一个bool类型的值。一般的，如果需要将特定的阈值长度也传入的话，我们可能将函数写成这样：\\n```cpp\\n bool LenthIsLessThan(const string& str, int len) {\\n      return str.length()<len;\\n  }\\n```\\n\\n这个函数看起来比前面一个版本更具有一般性，但是他不能满足count_if函数的参数要求：count_if要求的是unary function（仅带有一个参数）作为它的最后一个参数。如果我们使用仿函数，是不是就豁然开朗了呢：\\n\\n```cpp\\n  class ShorterThan {\\n      public:\\n          explicit ShorterThan(int maxLength) : length(maxLength) {}\\n          bool operator() (const string& str) const {\\n              return str.length() < length;\\n          }\\n      private:\\n          const int length;\\n  };\\n```\\n\\n### 3.31 C++ 中哪些函数不能被声明为虚函数？\\n\\n常见的不不能声明为虚函数的有：**普通函数（非成员函数），静态成员函数，内联成员函数，构造函数，友元函数**。\\n\\n1. 为什么C++不支持普通函数为虚函数？\\n\\n普通函数（非成员函数）只能被overload(重载)，不能被override(重写)，声明为虚函数也没有什么意思，因此编译器会在编译时绑定函数。\\n\\n2. 为什么C++不支持构造函数为虚函数？\\n\\n这个原因很简单，主要是从语义上考虑，所以不支持。因为构造函数本来就是为了明确初始化对象成员才产生的，然而virtual function主要是为了再不完全了解细节的情况下也能正确处理对象。另外，virtual函数是在不同类型的对象产生不同的动作，现在对象还没有产生，如何使用virtual函数来完成你想完成的动作。（这不就是典型的悖论）\\n\\n构造函数用来创建一个新的对象,而虚函数的运行是建立在对象的基础上,在构造函数执行时,对象尚未形成,所以不能将构造函数定义为虚函数\\n\\n3. 为什么C++不支持内联成员函数为虚函数？\\n\\n内联函数就是为了在代码中直接展开，减少函数调用花费的代价，而虚函数是为了在继承后对象能够准确的执行自己的动作，这是不可能统一的。（再说了，inline函数在编译时被展开，虚函数在运行时才能动态的绑定函数）\\n\\n内联函数是在编译时期展开,而虚函数的特性是运行时才动态联编,所以两者矛盾,不能定义内联函数为虚函数\\n\\n4. 为什么C++不支持静态成员函数为虚函数？\\n\\n这也很简单，静态成员函数对于每个类来说只有一份代码，所有的对象都共享这一份代码，他也没有要动态绑定的必要性。\\n\\n静态成员函数属于一个类而非某一对象,没有this指针,它无法进行对象的判别\\n\\n5. 为什么C++不支持友元函数为虚函数？\\n\\n因为C++不支持友元函数的继承，对于没有继承特性的函数没有虚函数的说法。\\n\\n### 3.32 解释下 C++ 中类模板和模板类的区别\\n\\n1. 类模板是模板的定义，不是一个实实在在的类，定义中用到通用类型参数\\n\\n2. 模板类是实实在在的类定义，是类模板的实例化。类定义中参数被实际类型所代替。\\n\\n答案解析\\n\\n1. 类模板的类型参数可以有一个或多个，每个类型前面都必须加class或typename，如template <class T1,class T2>class someclass{…};在定义对象时分别代入实际的类型名，如 someclass<int,double> obj;\\n\\n2. 和使用类一样，使用类模板时要注意其作用域，只能在其有效作用域内用它定义对象。\\n\\n3. 模板可以有层次，一个类模板可以作为基类，派生出派生模板类。\\n\\n### 3.33 虚函数表里存放的内容是什么时候写进去的？\\n\\n1. 虚函数表是一个存储虚函数地址的数组,以NULL结尾。虚表（vtable）在**编译阶段生成**，对象内存空间开辟以后，写入对象中的 v_ptr，然后调用构造函数。即：虚表在构造函数之前写入。\\n\\n2. 除了在构造函数之前写入之外，我们还需要考虑到虚表的二次写入机制，通过此机制让每个对象的虚表指针都能准确的指向到自己类的虚表，为实现动多态提供支持。\\n\\n## 4、标准模板库STL\\n\\n\\n\\n\\n## 5、C++新特性\\n\\n### 5.1 C++新特性\\n\\n内容参考于[csdn](https://blog.csdn.net/dnty00/article/details/126171485)\\n一、C++新特性\\nC++新特性主要包括包含语法改进和标准库扩充两个方面，主要包括以下11点\\n1、语法的改进\\n1）统一的初始化方法\\n在 C++11 中，可以直接在变量名后面跟上初始化列表，来进行对象的初始化\\n2）成员变量默认初始化\\n3）auto关键字用于定义变量，编译器可以自动判断的类型（前提：定义一个变量时对其进行初始化）\\n4）decltype 求表达式的类型\\n5）智能指针 shared_ptr\\n\\n和 unique_ptr、weak_ptr 不同之处在于，多个 shared_ptr 智能指针可以共同使用同一块堆内存。并且，由于该类型智能指针在实现上采用的是引用计数机制，即便有一个 shared_ptr 指针放弃了堆内存的“使用权”（引用计数减 1），也不会影响其他指向同一堆内存的 shared_ptr 指针（只有引用计数为 0 时，堆内存才会被自动释放）\\n6）空指针 nullptr（原来NULL）\\n7）基于范围的for循环\\n8）右值引用和move语义\\n\\n+ 右值引用\\n\\n```cpp\\n//左值引用\\nint num = 10;\\nint &b = num;  //正确\\nint &c = 10;   //错误，在C++98/03标准中，无法为右值添加引用\\n```\\n\\n实际开发中可能需要对右值进行修改（实现移动语义时就需要），显然左值引用的方式是行不通的。为此，C++11 标准新引入了另一种引用方式，称为右值引用，用 “&&” 表示。\\n\\n```cpp\\nint num = 10;\\n//int && a = num;  //右值引用不能初始化为左值\\nint && a = 10;\\n```\\n\\n+ move语义\\n\\n在C++11中，标准库在中提供了一个有用的函数std::move，std::move()函数并不能移动任何东西，它唯一的功能是将一个左值引用强制转化为右值引用，继而可以通过右值引用使用该值，以用于移动语义。从实现上讲，std::move基本等同于一个类型转换：static_cast<T&&>(lvalue);\\n\\n```cpp\\nmove( arg ) //其中，arg 表示指定的左值对象。该函数会返回 arg 对象的右值形式。\\n```\\n\\n2、标准模板库的扩充（往STL里面添加了一些模板类，比较好用）\\n9）无序容器（哈希表）\\n用法和功能同map一模一样，区别在于哈希表的效率更高\\n10）正则表达式\\n可以认为正则表达式实质上是一个字符串，该字符串描述了一种特定模式的字符串\\n11）Lambda表达式（匿名函数）\\nlambda表达式是一个匿名函数，用于定义并创建匿名的函数对象，以简化编程工作。举个例子：\\n\\n```cpp\\n vector<int> vec;\\n sort(vec.begin(), vec.end(), cmp); // 旧式\\n sort(vec.begin(), vec.end(), [](int a, int b) -> bool { return a < b; });   // Lambda表达式\\n```\\n\\n声明lambda表达式：\\n\\n```cpp\\n[capture list] (params list) mutable exception-> return type { function body }\\n```\\n\\n+ capture list：捕获外部变量列表\\n+ params list：形参列表\\n+ mutable指示符：用来说用是否可以修改捕获的变量\\n+ exception：异常设定\\n+ return type：返回类型\\n+ function body：函数体\\n\\n详细说明：\\n\\n1. 统一的初始化方法\\n   C++98/03 可以使用初始化列表（initializer list）进行初始化：\\n\\n```cpp\\nint i_arr[3] = { 1, 2, 3 };\\nlong l_arr[] = { 1, 3, 2, 4 };\\nstruct A\\n{\\n    int x;\\n    int y;\\n} a = { 1, 2 };\\n```\\n\\n但是这种初始化方式的适用性非常狭窄，只有上面提到的这两种数据类型可以使用初始化列表。在 C++11 中，初始化列表的适用性被大大增加了。它现在可以用于任何类型对象的初始化，实例如下：\\n\\n```cpp\\nclass Foo\\n{\\npublic:\\n    Foo(int) {}\\nprivate:\\n    Foo(const Foo &);\\n};\\nint main(void)\\n{\\n    Foo a1(123);\\n    Foo a2 = 123;  //error: \'Foo::Foo(const Foo &)\' is private\\n    Foo a3 = { 123 };\\n    Foo a4 { 123 };\\n    int a5 = { 3 };\\n    int a6 { 3 };\\n    return 0;\\n}\\n```\\n\\n在上例中，a3、a4 使用了新的初始化方式来初始化对象，效果如同 a1 的直接初始化。a5、a6 则是基本数据类型的列表初始化方式。可以看到，它们的形式都是统一的。这里需要注意的是，a3 虽然使用了等于号，但它仍然是列表初始化，因此，私有的拷贝构造并不会影响到它。a4 和 a6 的写法，是 C++98/03 所不具备的。在 C++11 中，可以直接在变量名后面跟上初始化列表，来进行对象的初始化。\\n\\n2. 成员变量默认初始化\\n   好处：构建一个类的对象不需要用构造函数初始化成员变量。\\n\\n```cpp\\n//程序实例\\n#include<iostream>\\nusing namespace std;\\nclass B\\n{\\npublic:\\n    int m = 1234; //成员变量有一个初始值\\n    int n;\\n};\\nint main()\\n{\\n    B b;\\n    cout << b.m << endl;\\n    return 0;\\n}\\n```\\n\\n3. auto关键字\\n   用于定义变量，编译器可以自动判断的类型（前提：定义一个变量时对其进行初始化）。\\n\\n```cpp\\n//程序实例\\n#include <vector>\\nusing namespace std;\\nint main(){\\n    vector< vector<int> > v;\\n    vector< vector<int> >::iterator i = v.begin();\\n    return 0;\\n}\\n```\\n\\n可以看出来，定义迭代器 i 的时候，类型书写比较冗长，容易出错。然而有了 auto 类型推导，我们大可不必这样，只写一个 auto 即可。\\n\\n4. decltype 求表达式的类型\\n\\ndecltype 是 C++11 新增的一个关键字，它和 auto 的功能一样，都用来在编译时期进行自动类型推导。\\n\\n(1)为什么要有decltype\\n\\n因为 auto 并不适用于所有的自动类型推导场景，在某些特殊情况下 auto 用起来非常不方便，甚至压根无法使用，所以 decltype 关键字也被引入到 C++11 中。\\n\\nauto 和 decltype 关键字都可以自动推导出变量的类型，但它们的用法是有区别的：\\n\\n```cpp\\nauto varname = value;\\ndecltype(exp) varname = value;\\n```\\n\\n其中，varname 表示变量名，value 表示赋给变量的值，exp 表示一个表达式。\\n\\nauto 根据\\\"=\\\"右边的初始值 value 推导出变量的类型，而 decltype 根据 exp 表达式推导出变量的类型，跟\\\"=\\\"右边的 value 没有关系。\\n\\n另外，auto 要求变量必须初始化，而 decltype 不要求。这很容易理解，auto 是根据变量的初始值来推导出变量类型的，如果不初始化，变量的类型也就无法推导了。decltype 可以写成下面的形式：\\n\\n>decltype(exp) varname;\\n\\n(2)代码示例\\n\\n```cpp\\n// decltype 用法举例\\nnt a = 0;\\ndecltype(a) b = 1;  //b 被推导成了 int\\ndecltype(10.8) x = 5.5;  //x 被推导成了 double\\ndecltype(x + 100) y;  //y 被推导成了 double\\n```\\n\\n5. 智能指针 shared_ptr\\n\\n和 unique_ptr、weak_ptr 不同之处在于，多个 shared_ptr 智能指针可以共同使用同一块堆内存。并且，由于该类型智能指针在实现上采用的是引用计数机制，即便有一个 shared_ptr 指针放弃了堆内存的“使用权”（引用计数减 1），也不会影响其他指向同一堆内存的 shared_ptr 指针（只有引用计数为 0 时，堆内存才会被自动释放）。\\n\\n```cpp\\n#include <iostream>\\n#include <memory>\\nusing namespace std;\\nint main()\\n{\\n    //构建 2 个智能指针\\n    std::shared_ptr<int> p1(new int(10));\\n    std::shared_ptr<int> p2(p1);\\n    //输出 p2 指向的数据\\n    cout << *p2 << endl;\\n    p1.reset();//引用计数减 1,p1为空指针\\n    if (p1) {\\n        cout << \\\"p1 不为空\\\" << endl;\\n    }\\n    else {\\n        cout << \\\"p1 为空\\\" << endl;\\n    }\\n    //以上操作，并不会影响 p2\\n    cout << *p2 << endl;\\n    //判断当前和 p2 同指向的智能指针有多少个\\n    cout << p2.use_count() << endl;\\n    return 0;\\n}\\n\\n/*    程序运行结果：        \\n            10\\n            p1 为空\\n            10\\n            1    \\n*/   \\n```\\n\\n6. 空指针 nullptr（原来NULL）\\n\\n nullptr 是 nullptr_t 类型的右值常量，专用于初始化空类型指针。nullptr_t 是 C++11 新增加的数据类型，可称为“指针空值类型”。也就是说，nullpter 仅是该类型的一个实例对象（已经定义好，可以直接使用），如果需要我们完全定义出多个同 nullptr 完全一样的实例对象。值得一提的是，nullptr 可以被隐式转换成任意的指针类型。例如：\\n\\n```cpp\\nint * a1 = nullptr;\\nchar * a2 = nullptr;\\ndouble * a3 = nullptr;\\n```\\n\\n 显然，不同类型的指针变量都可以使用 nullptr 来初始化，编译器分别将 nullptr 隐式转换成 int、char 以及 double\\\\* 指针类型。另外，通过将指针初始化为 nullptr，可以很好地解决 NULL 遗留的问题，比如：\\n\\n```cpp\\n#include <iostream>\\nusing namespace std;\\nvoid isnull(void *c){\\n    cout << \\\"void*c\\\" << endl;\\n}\\nvoid isnull(int n){\\n    cout << \\\"int n\\\" << endl;\\n}\\nint main() {\\n    isnull(NULL);\\n    isnull(nullptr);\\n    return 0;\\n}\\n\\n/*    程序运行结果：        \\n        int n\\n        void*c\\n*/         \\n```\\n\\n7. 基于范围的for循环\\n   如果要用 for 循环语句遍历一个数组或者容器，只能套用如下结构：\\n\\n```cpp\\nfor(表达式 1; 表达式 2; 表达式 3){\\n    //循环体\\n}\\n```\\n\\n```cpp\\n//程序实例\\n#include <iostream>\\n#include <vector>\\n#include <string.h>\\nusing namespace std;\\nint main() {\\n    char arc[] = \\\"www.123.com\\\";\\n    int i;\\n    //for循环遍历普通数组\\n    for (i = 0; i < strlen(arc); i++) {\\n        cout << arc[i];\\n    }\\n    cout << endl;\\n    vector<char>myvector(arc,arc+3);\\n    vector<char>::iterator iter;\\n    //for循环遍历 vector 容器\\n    for (iter = myvector.begin(); iter != myvector.end(); ++iter) {\\n        cout << *iter;\\n    }\\n    return 0;\\n}\\n/*    程序运行结果：        \\n        www.123.com\\n        www\\n*/      \\n```\\n\\n8. 右值引用和move语义\\n   i. 右值引用\\n\\n C++98/03 标准中就有引用，使用 \\\"&\\\" 表示。但此种引用方式有一个缺陷，即正常情况下只能操作 C++ 中的左值，无法对右值添加引用。举个例子：\\n\\n```cpp\\nint num = 10;\\nint &b = num; //正确\\nint &c = 10; //错误\\n```\\n\\n 如上所示，编译器允许我们为 num 左值建立一个引用，但不可以为 10 这个右值建立引用。因此，C++98/03 标准中的引用又称为左值引用。\\n\\n注意，虽然 C++98/03 标准不支持为右值建立非常量左值引用，但允许使用常量左值引用操作右值。也就是说，常量左值引用既可以操作左值，也可以操作右值，例如：\\n\\n```cpp\\nint num = 10;\\nconst int &b = num;\\nconst int &c = 10;\\n```\\n\\n我们知道，右值往往是没有名称的，因此要使用它只能借助引用的方式。这就产生一个问题，实际开发中我们可能需要对右值进行修改（实现移动语义时就需要），显然左值引用的方式是行不通的。\\n\\n 为此，C++11 标准新引入了另一种引用方式，称为右值引用，用 \\\"&&\\\" 表示。\\n\\n 需要注意的，和声明左值引用一样，右值引用也必须立即进行初始化操作，且只能使用右值进行初始化，比如：\\n\\n```cpp\\nint num = 10;\\n//int && a = num;  //右值引用不能初始化为左值\\nint && a = 10;\\n​ 和常量左值引用不同的是，右值引用还可以对右值进行修改。例如：\\n\\nint && a = 10;\\na = 100;\\ncout << a << endl;\\n/*    程序运行结果：        \\n        100    \\n*/          \\n​ 另外值得一提的是，C++ 语法上是支持定义常量右值引用的，例如:\\nconst int&& a = 10;//编译器不会报错\\n```\\n\\n 但这种定义出来的右值引用并无实际用处。一方面，右值引用主要用于移动语义和完美转发，其中前者需要有修改右值的权限；其次，常量右值引用的作用就是引用一个不可修改的右值，这项工作完全可以交给常量左值引用完成。\\n\\nii. move语义\\n\\n move 本意为 \\\"移动\\\"，但该函数并不能移动任何数据，它的功能很简单，就是将某个左值强制转化为右值。基于 move() 函数特殊的功能，其常用于实现移动语义。move() 函数的用法也很简单，其语法格式如下：\\n\\n> move( arg ) //其中，arg 表示指定的左值对象。该函数会返回 arg 对象的右值形式。\\n\\n```cpp\\n//程序实例\\n#include <iostream>\\nusing namespace std;\\nclass first {\\npublic:\\n    first() :num(new int(0)) {\\n        cout << \\\"construct!\\\" << endl;\\n    }\\n    //移动构造函数\\n    first(first &&d) :num(d.num) {\\n        d.num = NULL;\\n        cout << \\\"first move construct!\\\" << endl;\\n    }\\npublic:    //这里应该是 private，使用 public 是为了更方便说明问题\\n    int *num;\\n};\\nclass second {\\npublic:\\n    second() :fir() {}\\n    //用 first 类的移动构造函数初始化 fir\\n    second(second && sec) :fir(move(sec.fir)) {\\n        cout << \\\"second move construct\\\" << endl;\\n    }\\npublic:    //这里也应该是 private，使用 public 是为了更方便说明问题\\n    first fir;\\n};\\nint main() {\\n    second oth;\\n    second oth2 = move(oth);\\n    //cout << *oth.fir.num << endl;   //程序报运行时错误\\n    return 0;\\n}\\n\\n/*    程序运行结果：\\n          construct!\\n        first move construct!\\n        second move construct\\n*/            \\n```\\n\\n9. 无序容器（哈希表）\\n\\n用法和功能同map一模一样，区别在于哈希表的效率更高。\\n\\n(1) 无序容器具有以下 2 个特点：\\n\\n a. 无序容器内部存储的键值对是无序的，各键值对的存储位置取决于该键值对中的键，\\n\\n b. 和关联式容器相比，无序容器擅长通过指定键查找对应的值（平均时间复杂度为 O(1)）；但对于使用迭代器遍历容器中存储的元素，无序容器的执行效率则不如关联式容器。\\n\\n(2) 和关联式容器一样，无序容器只是一类容器的统称，其包含有 4 个具体容器，分别为 unordered_map、unordered_multimap、unordered_set 以及 unordered_multiset。功能如下表：\\n\\n| 无序容器           | 功能                                                         |\\n| ------------------ | ------------------------------------------------------------ |\\n| unordered_map      | 存储键值对 <key, value> 类型的元素，其中各个键值对键的值不允许重复，且该容器中存储的键值对是无序的。 |\\n| unordered_multimap | 和 unordered_map 唯一的区别在于，该容器允许存储多个键相同的键值对。 |\\n| unordered_set      | 不再以键值对的形式存储数据，而是直接存储数据元素本身（当然也可以理解为，该容器存储的全部都是键 key 和值 value 相等的键值对，正因为它们相等，因此只存储 value 即可）。另外，该容器存储的元素不能重复，且容器内部存储的元素也是无序的。 |\\n| unordered_multiset | 和 unordered_set 唯一的区别在于，该容器允许存储值相同的元素。 |\\n\\n 程序实例（以 unordered_map 容器为例）\\n\\n```cpp\\n#include <iostream>\\n#include <string>\\n#include <unordered_map>\\nusing namespace std;\\nint main()\\n{\\n    //创建并初始化一个 unordered_map 容器，其存储的 <string,string> 类型的键值对\\n    std::unordered_map<std::string, std::string> my_uMap{\\n        {\\\"教程1\\\",\\\"www.123.com\\\"},\\n        {\\\"教程2\\\",\\\"www.234.com\\\"},\\n        {\\\"教程3\\\",\\\"www.345.com\\\"} };\\n    //查找指定键对应的值，效率比关联式容器高\\n    string str = my_uMap.at(\\\"C语言教程\\\");\\n    cout << \\\"str = \\\" << str << endl;\\n    //使用迭代器遍历哈希容器，效率不如关联式容器\\n    for (auto iter = my_uMap.begin(); iter != my_uMap.end(); ++iter)\\n    {\\n        //pair 类型键值对分为 2 部分\\n        cout << iter->first << \\\" \\\" << iter->second << endl;\\n    }\\n    return 0;\\n}\\n\\n/*    程序运行结果：\\n          教程1 www.123.com\\n          教程2 www.234.com\\n          教程3 www.345.com\\n*/  \\n```\\n\\n10. 正则表达式\\n\\n可以认为正则表达式实质上是一个字符串，该字符串描述了一种特定模式的字符串。常用符号的意义如下：\\n\\n11. Lambda匿名函数\\n    所谓匿名函数，简单地理解就是没有名称的函数，又常被称为 lambda 函数或者 lambda 表达式。\\n\\n（1）定义\\n\\n lambda 匿名函数很简单，可以套用如下的语法格式：\\n\\n [外部变量访问方式说明符] (参数) mutable noexcept/throw() -> 返回值类型\\n​ {\\n​ 函数体;\\n​ };\\n\\n其中各部分的含义分别为：\\n\\na. [外部变量方位方式说明符]\\n\\n> [ ] 方括号用于向编译器表明当前是一个 lambda 表达式，其不能被省略。在方括号内部，可以注明当前 lambda 函数的函数体中可以使用哪些“外部变量”。\\n\\n所谓外部变量，指的是和当前 lambda 表达式位于同一作用域内的所有局部变量。\\nb. (参数)\\n\\n>和普通函数的定义一样，lambda 匿名函数也可以接收外部传递的多个参数。和普通函数不同的是，如果不需要传递参数，可以连同 () 小括号一起省略；\\n\\nc. mutable\\n\\n>此关键字可以省略，如果使用则之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，对于以值传递方式引入的外部变量，不允许在 lambda 表达式内部修改它们的值（可以理解为这部分变量都是 const 常量）。而如果想修改它们，就必须使用 mutable 关键字。\\n\\n 注意:对于以值传递方式引入的外部变量，lambda 表达式修改的是拷贝的那一份，并不会修改真正的外部变量；\\n\\nd. noexcept/throw()\\n\\n>可以省略，如果使用，在之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，lambda 函数的函数体中可以抛出任何类型的异常。而标注 noexcept 关键字，则表示函数体内不会抛出任何异常；使用 throw() 可以指定 lambda 函数内部可以抛出的异常类型。\\n\\ne. -> 返回值类型\\n\\n>指明 lambda 匿名函数的返回值类型。值得一提的是，如果 lambda 函数体内只有一个 return 语句，或者该函数返回 void，则编译器可以自行推断出返回值类型，此情况下可以直接省略\\\"-> 返回值类型\\\"。\\n\\nf. 函数体\\n\\n>和普通函数一样，lambda 匿名函数包含的内部代码都放置在函数体中。该函数体内除了可以使用指定传递进来的参数之外，还可以使用指定的外部变量以及全局范围内的所有全局变量。\\n\\n（2）程序实例\\n\\n```cpp\\n#include <iostream>\\n#include <algorithm>\\nusing namespace std;\\nint main()\\n{\\n    int num[4] = {4, 2, 3, 1};\\n    //对 a 数组中的元素进行排序\\n    sort(num, num+4, [=](int x, int y) -> bool{ return x < y; } );\\n    for(int n : num){\\n        cout << n << \\\" \\\";\\n    }\\n    return 0;\\n}\\n\\n/*    程序运行结果：\\n          1 2 3 4\\n*/ \\n```\\n\\n### 5.2 说说 C++ 中智能指针和指针的区别是什么？\\n\\n1. 智能指针\\n\\n 如果在程序中使用new从堆（自由存储区）分配内存，等到不需要时，应使用delete将其释放。C++引用了智能指针auto_ptr，以帮助自动完成这个过程。随后的编程体验（尤其是使用STL）表明，需要有更精致的机制。基于程序员的编程体验和BOOST库提供的解决方案，C++11摒弃了auto_ptr，并新增了三种智能指针：unique_ptr、shared_ptr和weak_ptr。所有新增的智能指针都能与STL容器和移动语义协同工作。\\n\\n2. 指针\\n\\n C 语言规定所有变量在使用前必须先定义，指定其类型，并按此分配内存单元。指针变量不同于整型变量和其他类型的变量，它是专门用来存放地址的，所以必须将它定义为“指针类型”。\\n\\n智能指针和普通指针的区别\\n\\n 智能指针和普通指针的区别在于智能指针实际上是对普通指针加了一层封装机制，区别是它负责自动释放所指的对象，这样的一层封装机制的目的是为了使得智能指针可以方便的管理一个对象的生命期。\\n\\n### 5.3 \\n\\n\\n## 6、C++操作系统（Linux相关）\\n\\n\\n\\n\\n## 7、计算机网络\\n\\n\\n\\n\\n\\n## 8、设计模式（摘选）\\n\\n\\n\\n\\n\\n## 9、常见编程大题\\n\\n\\n\\n\",\"articleCover\":\"https://upload.haoxx.site/config/27c7f38a329c07159a80315712680ea5.jpg\",\"articleTitle\":\"全面内容综述\",\"articleType\":1,\"categoryName\":\"编程语言基础\",\"id\":71,\"isRecommend\":0,\"isTop\":0,\"status\":1,\"tagNameList\":[]}]','PUT','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',107,'2023-06-07 16:33:59');
INSERT INTO `t_operation_log` VALUES (1173,'文章模块','添加','/admin/article/add','com.ican.controller.ArticleController.addArticle','添加文章','[{\"articleContent\":\"\\n## C++基础\\n\\n\\n\\n### 1. 虚函数\\n\\n### 2. 指针的理解\\n\\n### 3. malloc和new的基本概念以及区别\\n\\n[csdn资料](https://blog.csdn.net/weixin_43899008/article/details/123261412)\\n一、属性方面，malloc是库函数，需要头文件支持，new是运算符，需要编译器支持。\\n二、参数方面，new无需指定内存大小，编译器会自行计算；malloc需要指定内存大小。而且new会调用构造函数。\\n三、处理数组方面，new使用new[]，并使用delete[]进行释放，malloc需要手动定义数组大小，并用free释放内存。\\n四、返回类型，malloc返回值是void\\\\*指针，使用前需要显式地指定为需要的指针类型。new分配成功返回的是对象类型指针，与对象严格匹配，无类型转换，所以new是符合类型安全性操作符。\\n五、内存分配方面，new内存分配失败时，抛出bad_alloc异常，malloc分配内存失败时返回NULL。\\n六、自定义类型方面，new会先调用operator new函数，申请足够的内存，然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete就是反着来，先调用析构函数，然后operator delete函数释放内存。malloc是库函数，只能动态地申请和释放内存，无法强制要求其做自定义类型对象构造和析构函数。\\n七、new可以重载，malloc不可以\\n八、new在自由储存区分配内存，malloc在堆上分配内存。\\n九、内存泄漏方面，内存泄漏对于new和malloc都能检测出来，new可以明确指出是哪个文件的哪一行，但是malloc不可以明确指出是哪个文件的哪一行。\\n十、效率方面，new是关键字，malloc是库函数，new效率更高。\\n\\n![图1](https://s3.bmp.ovh/imgs/2022/08/28/6c46c39176ca9029.png)\\n\\n### 4. 智能指针，弱指针作用\\n\\n### 5. \\\\*p++的间隔\\n\\n### 6. 指针为NULL，访问会怎样\\n\\n简单说一下，c的NULL是宏定义，为void\\\\*，而cpp的NULL宏定义为0。cpp常用nullptr来给指针赋初值。nullptr的值为void\\\\*。\\n\\n可以给指针赋初始值为NULL，但是不可以访问。内存地址为0的区域是用户应用程序访问的禁区，一旦访问就会段错误。\\n\\n### 7. const int \\\\*p和int \\\\* const p的区别\\n\\n常量指针和指针常量。前者本质为指针，只是指针指向内存区域里存放的数据为常量，所以常量指针：指向的区域可以更改，指向的内容不可以更改；后者本质为常量，只是常量里装的是指针，所以指针指向不能改，指向的内容可以更改。\\n\\n### 8. C++ join detach\\n\\npthread_join()是在父线程中调用，等子线程运行完后通知子线程，然后父线程回收子线程资源。pthread_detach()是在子线程中调用，是子线程脱离父线程，子线程运行完后由系统回收资源。\\n\\n### 9. <font color=\'red\'>C++ 11新特性</font>\\n\\n内容参考于[csdn](https://blog.csdn.net/dnty00/article/details/126171485)\\n一、cpp新特性\\ncpp新特性主要包括包含语法改进和标准库扩充两个方面，主要包括以下11点\\n1、语法的改进\\n1）统一的初始化方法\\n在 cpp11 中，可以直接在变量名后面跟上初始化列表，来进行对象的初始化\\n2）成员变量默认初始化\\n3）auto关键字用于定义变量，编译器可以自动判断的类型（前提：定义一个变量时对其进行初始化）\\n4）decltype 求表达式的类型\\n5）智能指针 shared_ptr\\n\\n和 unique_ptr、weak_ptr 不同之处在于，多个 shared_ptr 智能指针可以共同使用同一块堆内存。并且，由于该类型智能指针在实现上采用的是引用计数机制，即便有一个 shared_ptr 指针放弃了堆内存的“使用权”（引用计数减 1），也不会影响其他指向同一堆内存的 shared_ptr 指针（只有引用计数为 0 时，堆内存才会被自动释放）\\n6）空指针 nullptr（原来NULL）\\n7）基于范围的for循环\\n8）右值引用和move语义\\n\\n+ 右值引用\\n\\n```cpp\\n//左值引用\\nint num = 10;\\nint &b = num;  //正确\\nint &c = 10;   //错误，在cpp98/03标准中，无法为右值添加引用\\n```\\n\\n实际开发中可能需要对右值进行修改（实现移动语义时就需要），显然左值引用的方式是行不通的。为此，cpp11 标准新引入了另一种引用方式，称为右值引用，用 “&&” 表示。\\n\\n```cpp\\nint num = 10;\\n//int && a = num;  //右值引用不能初始化为左值\\nint && a = 10;\\n```\\n\\n+ move语义\\n\\n在cpp11中，标准库在中提供了一个有用的函数std::move，std::move()函数并不能移动任何东西，它唯一的功能是将一个左值引用强制转化为右值引用，继而可以通过右值引用使用该值，以用于移动语义。从实现上讲，std::move基本等同于一个类型转换：static_cast<T&&>(lvalue);\\n\\n```cpp\\nmove( arg ) //其中，arg 表示指定的左值对象。该函数会返回 arg 对象的右值形式。\\n```\\n\\n2、标准模板库的扩充（往STL里面添加了一些模板类，比较好用）\\n9）无序容器（哈希表）\\n用法和功能同map一模一样，区别在于哈希表的效率更高\\n10）正则表达式\\n可以认为正则表达式实质上是一个字符串，该字符串描述了一种特定模式的字符串\\n11）Lambda表达式（匿名函数）\\nlambda表达式是一个匿名函数，用于定义并创建匿名的函数对象，以简化编程工作。举个例子：\\n\\n```cpp\\n vector<int> vec;\\n sort(vec.begin(), vec.end(), cmp); // 旧式\\n sort(vec.begin(), vec.end(), [](int a, int b) -> bool { return a < b; });   // Lambda表达式\\n```\\n\\n声明lambda表达式：\\n\\n```cpp\\n[capture list] (params list) mutable exception-> return type { function body }\\n```\\n\\n+ capture list：捕获外部变量列表\\n+ params list：形参列表\\n+ mutable指示符：用来说用是否可以修改捕获的变量\\n+ exception：异常设定\\n+ return type：返回类型\\n+ function body：函数体\\n\\n二、智能指针\\n\\n**为什么要使用智能指针**：\\n\\n智能指针的作用是管理一个指针，因为存在申请的空间在函数结束时忘记释放，造成内存泄漏的情况。使用智能指针可以很大程度上避免这个问题，因为智能指针就是一个类，当超出了类的作用域时，类会自动调用析构函数，自动释放资源。所以**智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间**。\\n智能指针的作用：处理内存泄漏问题和空悬指针问题。\\n\\ncpp中的智能指针有4种，分别为：shared_ptr、unique_ptr、weak_ptr、auto_ptr，其中auto_ptr被cpp11弃用。\\n\\n+ 对于shared_ptr，可解决资源忘记释放的内存泄漏问题，及悬空指针问题。\\n  *shared_ptr实现共享式拥有的概念，多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。从名字share就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。\\n\\n+ 对于unique_ptr，对象对其有唯一所有权。\\n  unique_ptr实现独占式拥有的概念，同一时间只能有一个智能指针可以指向该对象，它对于避免资源泄露，因为无法进行拷贝构造和拷贝赋值，但是可以进行移动构造和移动赋值。\\n\\n+ 对于weak_ptr，和 shared_ptr 搭配，不会增加引用计数，用于避免循环引用（比如 a 对象持有 b 对象，b 对象持有 a 对象），这样必然会导致内存泄露。\\n  解决shared_ptr相互引用时，两个指针的引用计数永远不会下降为0，从而导致死锁问题。而weak_ptr是对对象的一种弱引用，可以绑定到shared_ptr，但不会增加对象的引用计数\\n\\n+ 对于auto_ptr，实现独占式拥有的概念，同一时间只能有一个智能指针可以指向该对象；但auto_ptr在cpp11中被摒弃，其主要问题在于：\\n  1）对象所有权的转移，比如在函数传参过程中，对象所有权不会返还，从而存在潜在的内存崩溃问题；\\n  2）不能指向数组，也不能作为STL容器的成员\\n\\n### 10. 匿名函数\\n\\n匿名函数lambada表达式，就是没有名字的函数。最常见的匿名函数是`[](){}`。它没有参数也没有返回值。在匿名函数中，[]里面用来捕获函数外部的变量，而()里面就是匿名函数的参数，{}里面就是函数的执行代码。\\n\\n概念：cpp11提供了类似与Python的lambda表达式的方式，称为匿名函数，其好处是：使用匿名函数，可以免去函数的声明和定义。这样匿名函数仅在调用函数的时候才会创建函数对象，而调用结束后立即释放，所以匿名函数比非匿名函数更节省空间。\\n\\nLambda在STL中使用，书写上带来极大的方便。\\n捕获capture： //类似于函数名，是匿名函数的触发条件\\n\\n>[] //未定义变量.试图在Lambda内使用任何外部变量都是错误的.\\n>[x, &y] //x 按值捕获, y 按引用捕获.\\n>[&] //用到的任何外部变量都隐式按引用捕获\\n>[=] //用到的任何外部变量都隐式按值捕获\\n>[&, x] //x显式地按值捕获. 其它变量按引用捕获\\n>[=, &z] //z按引用捕获. 其它变量按值捕获\\n\\nparameters: //参数\\nreturn-type: //返回值\\nbody: //函数体\\n例子：\\n\\n```cpp\\n[](int x, int y) { return x + y; } // 隐式返回类型\\n[](int& x) { ++x; }   // 没有return语句 -> lambda 函数的返回类型是\'void\'\\n[]() { ++global_x; }  // 没有参数,仅访问某个全局变量\\n[]{ ++global_x; }     // 与上一个相同,省略了()\\n```\\n\\n### 11. 类内默认的函数\\n\\n6种：<font color=\'red\'>无参构造函数，析构函数，拷贝构造函数（浅拷贝的）、赋值运算符重载函数</font>、const成员、取地址及const取地址操作符重载。\\n\\n![](https://s3.bmp.ovh/imgs/2022/08/28/a9b8047f51af8e86.png)\\n\\n### 12. 什么时候重载拷贝构造函数\\n\\n\\n### 13. 深浅拷贝\\n\\n浅拷贝就是直接用等号连接的赋值操作，一般类中不涉及内存开辟的话，浅拷贝可以使用。深拷贝需要重写拷贝构造函数。浅拷贝就是创建一个新的指针来指向对应的内容。深拷贝是新开辟一块区域，然后向指定的内容存入这块区域，然后用一个新的指针指向这块区域。\\n\\n浅拷贝只是对指针的拷贝，浅拷贝后两个指针指向同一个内存空间；深拷贝不仅对指针进行拷贝，而且对指针指向的内容进行拷贝，经深拷贝后的指针是指向两个不同地址的指针。\\n\\n当拷贝一个基类指针到派生类时，如果调用系统默认的拷贝构造函数，这时只是对指针进行拷贝，两个指针指向同一个地址，这就会导致指针被分配了一次内存，但内存被释放了两次（两次调用析构函数），造成程序崩溃。\\n\\n对于类中开辟了内存空间的情况，必须重写拷贝构造函数以实现深拷贝，否则会出现一块内存区域被重复释放多次的错误。\\n\\n### 14. stl容器底层实现\\n\\n\\n### 15. unordered_map和map区别\\n\\n### 16. 锁的作用\\n\\n\\n### 17. lock_guard的用法\\n\\n\\n\\n## 操作系统\\n\\n### 1. 进程和线程区别\\n\\n### 2. 一个线程崩溃了对其他线程有什么影响\\n\\n## 数据结构\\n\\n### 1. 红黑树基础概念，特性，根节点是什么颜色，可以有连续两个红节点吗\\n\\n## 算法题\\n\\n### 1. 获取链表倒数第三个节点（双指针）\\n\\n\\n\\n# C++中的智能指针\\n\\n内容参考自[csdn1](https://blog.csdn.net/m0_67623521/article/details/125695620)和[csdn2](https://blog.csdn.net/K346K346/article/details/81478223?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165743267316781432922953%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=165743267316781432922953&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-81478223-null-null.142%5Ev32%5Eexperiment_2_v1,185%5Ev2%5Econtrol&utm_term=c%2B%2B%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88&spm=1018.2226.3001.4187)\\n\\n## 前言\\n\\nC++ STL（Standard Template Library）一共提供了四种指针：auto_ptr、unique_ptr、shared_ptr 和 weak_ptr，其中auto_ptr是cpp98提供的，cpp11 已将其摒弃，并提出了 unique_ptr 替代 auto_ptr。\\n\\n虽然 auto_ptr 已被摒弃，但在实际项目中仍可使用，但建议使用更加安全的 unique_ptr。cpp98中只有一种智能指针auto_ptr，这个智能指针实际上是一个封装好的类，方便管理指针，使用构造函数来生成指针，使用析构函数来释放指针，避免内存泄漏。但是auto_ptr有漏洞，基于此，提出了三种新指针，unique_ptr限制了指针的所有权，只有一个对象所持有；shared_ptr在指针管理类中新增一个计数值，来记录指针所引用对象的个数，当计数值为0时就释放指针；weak_ptr智能指针没有没有重载 operator* 和 operator->，他常作为shared_ptr的辅助指针，用于监测shared_ptr的引用计数值。\\n\\n## 1、unique_ptr\\n\\n它持有对对象的独有权——两个unique_ptr 不能指向一个对象，即 unique_ptr 不共享它所管理的对象。它无法复制到其他 unique_ptr，无法通过值传递到函数，也无法用于需要副本的任何标准模板库 （STL）算法。只能移动 unique_ptr，即对资源管理权限可以实现转移。这意味着，内存资源所有权可以转移到另一个 unique_ptr，并且原始 unique_ptr 不再拥有此资源。\\n\\nunique_ptr 与原始指针一样有效，并可用于 STL 容器。将 unique_ptr 实例添加到 STL 容器运行效率很高，因为通过 unique_ptr 的移动构造函数，不再需要进行复制操作。\\n\\n独占的指针，只可以自己使用，它指向的对象只可以他一个人使用，可以使用move将使用权转移，如：\\n\\n```cpp\\n#include <iostream>\\n#include <memory>\\nusing namespace std;\\nint main(){\\n    auto ptr1=make_unique<string> (\\\"12345\\\");\\n    cout<<*ptr1<<endl;\\n    auto ptr2=std::move(ptr1);\\n    // cout<<*ptr1<<endl;\\n    cout<<*ptr2<<endl;\\n    return 0;\\n}\\n//输出结果：\\n//12345\\n//12345\\n```\\n\\n创建智能指针的方法：通过构造函数指定、通过 reset 方法重新指定、通过 release 方法释放所有权、通过移动语义转移所有权（move），unique_ptr 还可能没有对象，这种情况被称为 empty。\\n\\n```cpp\\n#include <iostream>\\n#include <memory>\\nusing namespace std;\\nint main(){\\n    unique_ptr<int> p1;\\n    p1.reset(new int(123));\\n    cout<<*p1<<endl;\\n    unique_ptr<int> p2(new int(1234));\\n    cout<<*p2<<endl;\\n    int *p3=p1.release();\\n    cout<<*p3<<endl;\\n    unique_ptr<int> p4=move(p2);\\n    cout<<*p4<<endl;\\n \\n    return 0;\\n}\\n// 123\\n// 1234\\n// 123\\n// 1234\\n```\\n\\n## 2、auto_ptr\\n\\n引入问题：\\n\\n```cpp\\nauto_ptr< string> p1(new string (\\\"string1\\\");\\nauto_ptr<string> p2;\\np2=p1;\\n```\\n\\n如果上面的指针是普通的指针，那么就会面临一个问题，就是delete的时候会删除有两次，解决方案有多种：\\n\\n1、重载复制运算符，将其定义为深复制，这样他们俩就会指向不同的地方，缺点是会浪费空间。\\n\\n2、建立所有全概念。将指针定义为只可以有一个对象拥有，赋值运算符直接将所有权转移。这就是用于 auto_ptr 和 unique_ptr 的策略，但 unique_ptr 的策略更严格。\\n\\n3、创建智能更高的指针，跟踪引用特定对象的智能指针数。这称为引用计数。例如，赋值时，计数将加 1，而指针过期时，计数将减 1,。当减为 0 时才调用 delete。这是 shared_ptr 采用的策略。\\n\\n## 3、shared_ptr\\n\\nshared_ptr 是一个标准的共享所有权的智能指针，**允许多个指针指向同一个对象**，定义在 memory 文件中，命名空间为 std。shared_ptr 利用引用计数的方式实现了对所管理的对象的所有权的分享，即允许多个 shared_ptr 共同管理同一个对象。像 shared_ptr 这种智能指针，《Effective cpp》称之为“引用计数型智能指针”（reference-counting smart pointer，RCSP）。\\n\\nshared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性（auto_ptr 是独占的），在使用引用计数的机制上提供了可以共享所有权的智能指针，当然这需要额外的开销：\\n（1）shared_ptr 对象除了包括一个所拥有对象的指针外，还必须包括一个引用计数代理对象的指针；\\n（2）时间上的开销主要在初始化和拷贝操作上， * 和 -> 操作符重载的开销跟 auto_ptr 是一样；\\n（3）开销并不是我们不使用 shared_ptr 的理由,，永远不要进行不成熟的优化，直到性能分析器告诉你这一点。\\n\\n\\n\\n可以使用辅助类来实现该智能指针，它的具体做法如下：\\n（a）当创建智能指针类的新对象时，初始化指针，并将引用计数设置为1；\\n（b）当能智能指针类对象作为另一个对象的副本时，拷贝构造函数复制副本的指向辅助类对象的指针，并增加辅助类对象对基础类对象的引用计数（加1）；\\n（c）使用赋值操作符对一个智能指针类对象进行赋值时，处理复杂一点：先使左操作数的引用计数减 1（为何减 1：因为指针已经指向别的地方），如果减1后引用计数为 0，则释放指针所指对象内存。然后增加右操作数所指对象的引用计数（为何增加：因为此时做操作数指向对象即右操作数指向对象）；\\n（d）完成析构函数：调用析构函数时，析构函数先使引用计数减 1，如果减至 0 则 delete 对象。\\n接口：\\n\\n```cpp\\nclass Point {\\nprivate:\\n    int x, y;\\npublic:\\n    Point(int xVal = 0, int yVal = 0) :x(xVal), y(yVal) {}\\n    int getX() const { return x; }\\n    int getY() const { return y; }\\n    void setX(int xVal) { x = xVal; }\\n    void setY(int yVal) { y = yVal; }\\n};\\n```\\n\\n实现：\\n\\n```cpp\\nclass SmartPtr {\\npublic:\\n\\t//构造函数\\n\\tSmartPtr() { rp = nullptr; }\\n\\tSmartPtr(Point *ptr):rp(new RefPtr(ptr)) {}\\n\\tSmartPtr(const SmartPtr &sp):rp(sp.rp) { \\n\\t\\t++rp->count;\\n\\t\\tcout << \\\"in copy constructor\\\" <<endl;\\n\\t}\\n\\t\\n\\t// 重载赋值运算符\\n\\tSmartPtr& operator=(const SmartPtr& rhs) {\\n\\t\\t++rhs.rp->count;\\n\\t\\tif (rp != nullptr && --rp->count == 0) {\\n\\t\\t\\tdelete rp;\\n\\t\\t}\\n\\t\\trp = rhs.rp;\\n\\t\\tcout << \\\"in assignment operator\\\" << endl;\\n\\t\\treturn *this;\\n\\t}\\n\\t\\n\\t// 重载->操作符\\n\\tPoint* operator->() {\\n\\t\\treturn rp->p;\\n\\t}\\n\\t\\n\\t// 重载*操作符\\n\\tPoint& operator*() {\\n\\t\\treturn *(rp->p);\\n\\t}\\n \\n\\t~SmartPtr() {\\n\\t\\tif (--rp->count == 0) delete rp;\\n\\t\\telse cout << \\\"还有\\\" << rp->count << \\\"个指针指向基础对象\\\" << endl;\\n\\t}\\n \\nprivate:\\n\\tRefPtr* rp;\\n};\\n```\\n\\n## 4、weak_ptr\\n\\nweak_ptr 被设计为与 shared_ptr 共同工作，可以从一个 shared_ptr 或者另一个 weak_ptr 对象构造而来。weak_ptr 是为了配合 shared_ptr 而引入的一种智能指针，它更像是 shared_ptr 的一个助手而不是智能指针，因为它不具有普通指针的行为，没有重载 operator* 和 operator-> ，因此取名为 weak，表明其是功能较弱的智能指针。***它的最大作用在于协助 shared_ptr 工作，可获得资源的观测权，像旁观者那样观测资源的使用情况。观察者意味着 weak_ptr 只对 shared_ptr 进行引用，而不改变其引用计数，当被观察的 shared_ptr 失效后，相应的 weak_ptr 也相应失效。**\\n\\n解决循环引用的问题，用法：\\n\\n```cpp\\nweak_ptr<T> w;\\t \\t//创建空 weak_ptr，可以指向类型为 T 的对象\\nweak_ptr<T> w(sp);\\t//与 shared_ptr 指向相同的对象，shared_ptr 引用计数不变。T必须能转换为 sp 指向的类型\\nw=p;\\t\\t\\t\\t//p 可以是 shared_ptr 或 weak_ptr，赋值后 w 与 p 共享对象\\nw.reset();\\t\\t\\t//将 w 置空\\nw.use_count();\\t\\t//返回与 w 共享对象的 shared_ptr 的数量\\nw.expired();\\t\\t//若 w.use_count() 为 0，返回 true，否则返回 false\\nw.lock();\\t\\t\\t//如果 expired() 为 true，返回一个空 shared_ptr，否则返回非空 shared_ptr\\n```\\n\\nweak_ptr 对象引用资源时不会增加引用计数，但是它能够通过 lock() 方法来判断它所管理的资源是否被释放。\\n\\n### weak_ptr指针的作用\\n\\n现在要说的问题是，weak_ptr 到底有什么作用呢？从上面那个例子看来，似乎没有任何作用。其实 weak_ptr 可用于打破循环引用。引用计数是一种便利的内存管理机制，但它有一个很大的缺点，那就是不能管理循环引用的对象。一个简单的例子如下：\\n\\n```cpp\\n#include <iostream>\\n#include <memory>\\n  \\nclass Woman;  \\nclass Man {\\nprivate:  \\n    //std::weak_ptr<Woman> _wife;  \\n    std::shared_ptr<Woman> _wife;  \\npublic:  \\n    void setWife(std::shared_ptr<Woman> woman) {  \\n        _wife = woman;  \\n    }  \\n  \\n    void doSomthing() {  \\n        if(_wife.lock()){}  \\n    }  \\n  \\n    ~Man() {\\n        std::cout << \\\"kill man\\\\n\\\";  \\n    }  \\n};  \\n  \\nclass Woman {  \\nprivate:  \\n    //std::weak_ptr<Man> _husband;  \\n    std::shared_ptr<Man> _husband;  \\npublic:  \\n    void setHusband(std::shared_ptr<Man> man) {  \\n        _husband = man;  \\n    }  \\n    ~Woman() {  \\n        std::cout <<\\\"kill woman\\\\n\\\";  \\n    }  \\n};\\n\\nint main(int argc, char** argv) {  \\n    std::shared_ptr<Man> m(new Man());  \\n    std::shared_ptr<Woman> w(new Woman());  \\n    if(m && w) {  \\n        m->setWife(w);  \\n        w->setHusband(m);  \\n    }  \\n    return 0;  \\n}\\n```\\n\\n在 Man 类内部会引用一个 Woman，Woman 类内部也引用一个 Man。当一个 man 和一个 woman 是夫妻的时候，他们直接就存在了相互引用问题。man 内部有个用于管理wife生命期的 shared_ptr 变量，也就是说 wife 必定是在 husband 去世之后才能去世。同样的，woman 内部也有一个管理 husband 生命期的 shared_ptr 变量，也就是说 husband 必须在 wife 去世之后才能去世。这就是循环引用存在的问题：husband 的生命期由 wife 的生命期决定，wife 的生命期由 husband 的生命期决定，最后两人都死不掉，违反了自然规律，导致了内存泄漏。\\n\\n一般来讲，解除这种循环引用有下面三种可行的方法：\\n（1）当只剩下最后一个引用的时候需要手动打破循环引用释放对象。\\n（2）当 parent 的生存期超过 children 的生存期的时候，children 改为使用一个普通指针指向 parent。\\n（3）使用弱引用的智能指针打破这种循环引用。\\n虽然这三种方法都可行，但方法 1 和方法 2 都需要程序员手动控制，麻烦且容易出错。这里主要介绍一下第三种方法，使用弱引用的智能指针std:weak_ptr 来打破循环引用。\\n\\nweak_ptr 对象引用资源时不会增加引用计数，但是它能够通过 lock() 方法来判断它所管理的资源是否被释放。**做法就是上面的代码注释的地方取消注释，取消 Woman 类或者 Man 类的任意一个即可，也可同时取消注释，全部换成弱引用 weak_ptr**。\\n\\n另外很自然地一个问题是：既然 weak_ptr 不增加资源的引用计数，那么在使用 weak_ptr 对象的时候，资源被突然释放了怎么办呢？不用担心，因为不能直接通过 weak_ptr 来访问资源。那么如何通过 weak_ptr 来间接访问资源呢？答案是在需要访问资源的时候 weak_ptr 为你生成一个shared_ptr，shared_ptr 能够保证在 shared_ptr 没有被释放之前，其所管理的资源是不会被释放的。创建 shared_ptr 的方法就是 lock() 成员函数。\\n\\n注意： shared_ptr 实现了 operator bool() const 方法来判断被管理的资源是否已被释放。\\n\\n## 5、如何选择智能指针\\n\\n上文简单地介绍了 cpp STL 的四种智能指针。当然，除了 STL 的智能指针，cpp 准标准库 Boost 的智能指针，比如 boost::scoped_ptr、boost::shared_array、boost::intrusive_ptr 也可在实践中使用，但这里不做进一步介绍，有兴趣的读者可以参考：[cpp 智能指针详解](https://blog.csdn.net/xt_xiaotian/article/details/5714477)。\\n\\n在了解 STL 的四种智能指针后，大家可能会想另一个问题：在实际应用中，应使用哪种智能指针呢？\\n\\n下面给出几个使用指南。\\n（1）如果程序要使用多个指向同一个对象的指针，应选择 shared_ptr。这样的情况包括：\\n\\n将指针作为参数或者函数的返回值进行传递的话，应该使用 shared_ptr；\\n两个对象都包含指向第三个对象的指针，此时应该使用 shared_ptr 来管理第三个对象；\\nSTL 容器包含指针。很多 STL 算法都支持复制和赋值操作，这些操作可用于 shared_ptr，但不能用于 unique_ptr（编译器发出 warning）和 auto_ptr（行为不确定）。如果你的编译器没有提供 shared_ptr，可使用 Boost 库提供的 shared_ptr。\\n（2）如果程序不需要多个指向同一个对象的指针，则可使用 unique_ptr。如果函数使用 new 分配内存，并返还指向该内存的指针，将其返回类型声明为 unique_ptr 是不错的选择。这样，所有权转让给接受返回值的 unique_ptr，而该智能指针将负责调用 delete。可将 unique_ptr 存储到 STL 容器中，只要对容器元素不使用拷贝操作的算法即可（如 sort()）。例如，可在程序中使用类似于下面的代码段。\\n\\n```cpp\\nunique_ptr<int> make_int(int n) {\\n    return unique_ptr<int>(new int(n));\\n}\\n\\nvoid show(unique_ptr<int>& p1) {\\n    cout << *p1 << \' \';\\n}\\n\\nint main() {\\n\\t//...\\n    vector<unique_ptr<int>> vp(size);\\n    for(int i = 0; i < vp.size(); i++) {\\n\\t\\tvp[i] = make_int(rand() % 1000);       // copy temporary unique_ptr\\n\\t}\\n    vp.push_back(make_int(rand() % 1000));     // ok because arg is temporary\\n    for_each(vp.begin(), vp.end(), show);      // use for_each()\\n\\t//...\\n}\\n```\\n\\n其中 push_back 调用没有问题，因为它返回一个临时 unique_ptr，该 unique_ptr 被赋给 vp 中的一个 unique_ptr。另外，如果按值而不是按引用给 show() 传递对象，for_each() 将非法，因为这将导致使用一个来自 vp 的非临时 unique_ptr 初始化 pi，而这是不允许的。前面说过，编译器将发现错误使用 unique_ptr 的企图。\\n\\n在 unique_ptr 为右值时，可将其赋给 shared_ptr，这与将一个 unique_ptr 赋给另一个 unique_ptr 需要满足的条件相同，即 unique_ptr 必须是一个临时对象。与前面一样，在下面的代码中，`make_int() `的返回类型为 `unique_ptr<int>`：\\n\\n```cpp\\nunique_ptr<int> pup(make_int(rand() % 1000));\\t\\t// ok\\nshared_ptr<int> spp(pup);\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// not allowed, pup as lvalue\\nshared_ptr<int> spr(make_int(rand() % 1000));    \\t// ok\\n```\\n\\n模板 shared_ptr 包含一个显式构造函数，可用于将右值 unique_ptr 转换为 shared_ptr。shared_ptr 将接管原来归 unique_ptr 所有的对象。\\n\\n在满足 unique_ptr 要求的条件时，也可使用 auto_ptr，但 unique_ptr 是更好的选择。如果你的编译器没有unique_ptr，可考虑使用 Boost 库提供的 scoped_ptr，它与 unique_ptr 类似。\\n（3）虽然说在满足 unique_ptr 要求的条件时，使用 auto_ptr 也可以完成对内存资源的管理，但是因为 auto_ ptr 不够安全，不提倡使用，即任何情况下都不应该使用 auto_ptr。\\n（4）为了解决 shared_ptr 的循环引用问题，我们可以祭出 weak_ptr。\\n（5）在局部作用域（例如函数内部或类内部），且不需要将指针作为参数或返回值进行传递的情况下，如果对性能要求严格，使用 scoped_ptr 的开销较 shared_ptr 会小一些。scoped_ptr正如其名，是一个局部指针。\\n\\n## 6、auto_ptr存在的问题\\n\\n尽可能不要把auto_ptr设置为全局指针；除非自己知道后果，否则不要把auto_ptr赋值给同类型的另一个智能指针。\\n\\n在某些应用场景下，拷贝构造函数的意义不明确，同理赋值语句也是这个道理，意义同样不明确，因为C11标准之前并不存在移动赋值和移动构造的概念，还有就是之前谈到的一个对象和一组对象的问题，对于自定义类型而言，auto_ptr的析构函数仅能够析构一个对象，不能够处理一组对象的情况，这些都是尚未解决的问题。\\n\\nauto_ptr指针当使用赋值语句将ptr1赋值给ptr2时，程序并未报错，但实际上存在隐患。问题1：auto_ptr并不共享管理权，当使用赋值语句将指针赋值后，ptr1将失去对内存的管理权。问题2：程序结束时，内存释放时会被释放两次，引发程序崩溃。\",\"articleCover\":\"\",\"articleTitle\":\"C++方面的部分内容\",\"articleType\":1,\"categoryName\":\"编程语言基础\",\"isRecommend\":0,\"isTop\":0,\"status\":1,\"tagNameList\":[]}]','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',33,'2023-06-07 16:34:52');
INSERT INTO `t_operation_log` VALUES (1174,'文章模块','添加','/admin/article/add','com.ican.controller.ArticleController.addArticle','添加文章','[{\"articleContent\":\"\\n\\nC++：基本数据类型/扩展数据类型、复合数据类型、函数、循环和分支、类、模板、内存模型/命令空间/堆的使用、异常。\\n\\n数据类型：基本数据类型分为整型和浮点型。整型有bool、char、short int、int、long int、long long；浮点型有float、double还有long double。扩展类型则是unsigned XXX。\\n\\n复合数据类型有数组、结构体、共用体、枚举、字符串、String类、指针、(vector容器和array)。注意，数组的两种替代品：vector使用new实现的类模板，可变长，方便且安全。array和数组一样定长，但是方便且安全。可以用方法begin和end来确定头尾，避免越界，用at方法来取元素时会自动检查越界问题，要比数组用方括号安全一些。\\n\\n函数：\\n\\n循环：for、while、do_while。分支：if/else、switch/case、三元运算符?:\\n\\n类：类的申明与定义、类的继承（注意权限问题）、（构造函数、拷贝构造函数深拷贝浅拷贝、析构函数），还有static和const修饰的方法和属性的一些使用注意事项，最后还有一个问题就是友元（全局函数友元和类友元）\\n\\n重载：函数重载和运算符重载。注意cpp三要素：封装、继承、多态。\\n\\n模板：函数模板、类模板\\n\\n\\n异常：try throw catch\\n\\n文件IO\\n\\n## 1、char与signed char和signed char\\n\\n一般char就是signed char （VC编译器、X86上的GCC），不过arm-linux-gcc却把char定义为 unsigned char。在存储介质中的表现形式是一样的，占1字节8bit。区别在于看第一位是不是符号位。\\n\\nint默认就是signed int。\\n\\n在补充一点，32位和64位系统中，数据类型的不同之处：\\n\\n在32位机器和64机器中int类型都占用4个字节。编译器可以根据自身硬件来选择合适的大小，但是需要满足约束：short和int型至少为16位，long型至少为32位，并且short型长度不能超过int型，而int型不能超过long型。这即是说各个类型的变量长度是由编译器来决定的，而当前主流的编译器中一般是32位机器和64位机器中int型都是4个字节（例如，GCC）。下面列举在GCC编译器下32位机器和64位机器各个类型变量所占字节数：\\n![图1](https://s3.bmp.ovh/imgs/2022/08/10/e2def3a84e510cd9.png)\\n需要关注的是，一般而言，32位机器和64位最大的不同就是long和指针。一般32位的long是4字节，64位是8字节；32位的指针是4字节，64位的指针是8字节。\",\"articleCover\":\"\",\"articleTitle\":\"C++复习总攻略\",\"articleType\":1,\"categoryName\":\"编程语言基础\",\"isRecommend\":0,\"isTop\":0,\"status\":1,\"tagNameList\":[]}]','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',31,'2023-06-07 16:35:31');
INSERT INTO `t_operation_log` VALUES (1175,'标签模块','删除','/admin/tag/delete','com.ican.controller.TagController.deleteTag','删除分类','[[15]]','DELETE','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',23,'2023-06-07 16:35:36');
INSERT INTO `t_operation_log` VALUES (1176,'分类模块','删除','/admin/category/delete','com.ican.controller.CategoryController.deleteCategory','删除分类','[[50]]','DELETE','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',24,'2023-06-07 16:35:40');
INSERT INTO `t_operation_log` VALUES (1177,'文章模块','添加','/admin/article/add','com.ican.controller.ArticleController.addArticle','添加文章','[{\"articleContent\":\"\\n[参考资料](https://zhuanlan.zhihu.com/p/467001575)\\n\\n![cpp关键字图示](https://s3.bmp.ovh/imgs/2022/07/14/d1b5fade281cfa4b.jpg)\\n\\n## 1）auto\\n\\ncpp11的 auto 表示变量的自动类型推断。即在声明变量的时候，根据变量初始值的类型自动为此变量选择匹配的类型。\\n\\n```cpp\\nauto x = 3; // x 为 int 类型\\ncout << typeid(x).name() << endl;auto \\n```\\n\\n变量必须在定义时初始化，这类似于const关键字。\\n\\n## 2）bool、true、false\\n\\nbool 类型是cpp 中的基本数据结构。bool 类型只有两个取值，true 和 false。true 表示“真”，false 表示“假”。\\nbool 类型常用于条件判断、开关变量的值或函数返回值。\\n\\n## 3）char、wchar_t\\n\\nchar 类型表示单个字符。char 类型的数据需要用单引号括起来：\\nchar letter =\'A\';\\nwchar_t 是宽字符类型，每个 wchar_t 类型占2个字节，16位宽。汉字的表示就需要用到 wchar_t。\\n<font color=\'skyblue\'>字符与整数密切相关，它们在内部其实是被存储为整数</font>。每个可打印的字符以及许多不可打印的字符都被分配一个唯一的数字。用于编码字符的最常见方法是 ASCII（美国信息交换标准代码的首字母简写）。\\n**备注**：UTF-8编码方式，中文占3个字符，中文标点也占3个字符。*UTF-8存储中文时占2-4个字节。utf-8是变长的、不定长的，ucs-4范围是1~6字节。 决定一个utf8字长度得看它首个字符，根据左侧位1的个数来决定占用了几个字节。*\\n\\n## 4）int、short、long\\n\\n略\\n\\n## 5）float、double、long double\\n\\n略\\n\\n## 6）signed和unsigned\\n\\n区别在于二进制数据时，第一位是否为符号位\\n\\n## 7）enum枚举类型\\n\\nenum 表示枚举类型，可以给出一系列固定值，实质上是 int 类型\\n\\n```cpp\\nenum color {\\n    RED = 0,\\n    GREEN = 1,\\n    BLUE = 2 \\n};\\n```\\n\\n## 8）union联合体类型\\n\\nunion 是联合体类型，通过共享内存，一个union可以有多个数据成员。但在任意时刻，联合中只能有一个数据成员可以有值。例如\\n\\n```cpp\\nunion price {\\n    char x\\n    int y;\\n    double z; \\n};\\n```\\n\\n## 9）struct和class     \\n\\nclass是一般的类类型，struct在cpp中是特殊的类类型，声明中默认的访问权限与class不同，struct是public，class是private。\\n\\n结构体是一种特殊形态的类,它和类一样,可以有自己的数据成员和函数成员,可以有自己的构造函数和析构函数,可以控制访问权限，可以继承,支持包含多态等,二者定义的语法形式也几乎一样。结构体和类的唯一区别在于，结构体和类具有不同的默认访问控制属性：在类中,对于未指定访问控制属性的成员，其访问控制属性为私有类型(private) ;在结构体中,对于未指定任何访问控制属性的成员,其访问控制属性为公有类型。\\n\\n结构体可以有函数成员(包含构造函数和析构函数)，但实质上是函数指针。C语言没有权限控制的说法，C语言的结构体自然不能对成员进行权限控制。\\n\\n```cpp\\n#include <stdio.h>\\ntypedef struct CStructure\\n{\\nint (*memberFunction)(); //结构体里的函数成员，实质上是函数指针\\n}CStructure;\\nint globalFunction()\\n{\\nprintf(\\\"Member function of a struct in C\\\\n\\\");\\nreturn 0;\\n}\\nint main()\\n{\\nCStructure obj; //创建结构体对象\\nobj.memberFunction=globalFunction;//为函数指针赋值\\nobj.memberFunction();//使用函数指针\\nreturn 0;\\n}\\n```\\n\\n## 10）sizeof运算符用于获取数据类型占用的字节数\\n\\nsizeof 运算法用于获取数据类型占用的字节数。\\n\\ncpp中有5种不能重载的运算符：两个是类的成员引用符号（.和->)，一个是类空间引用符号(::)，一个是唯一的三元运算符(?:)，还有一个就是sizeof运算符\\n\\n## 11）typeid运算符可以输出变量的类型\\n\\ntypeid运算符可以输出变量的类型。\\n![程序示例1](https://s3.bmp.ovh/imgs/2022/07/14/8a88a709070fd5a4.jpg)\\n![程序示例2](https://s3.bmp.ovh/imgs/2022/07/14/a1eb9b5310ce14da.png)\\n\\n## 12）typedef \\n\\ntypedef 可以为现有数据类型创建一个别名，便于程序的阅读和编写。\\n**补充**：\\n\\ntypedef和define都是替一个对象取一个别名，以此增强程序的可读性，区别如下：\\n**（1）原理不同**\\n\\n#define是C语言中定义的语法，是预处理指令，在预处理时进行简单而机械的字符串替换，不作正确性检查，只有在编译已被展开的源程序时才会发现可能的错误并报错。\\n\\ntypedef是关键字，在编译时处理，有类型检查功能。它在自己的作用域内给一个已经存在的类型一个别名，但不能在一个函数定义里面使用typedef。用typedef定义数组、指针、结构等类型会带来很大的方便，不仅使程序书写简单，也使意义明确，增强可读性。\\n\\n**（2）功能不同**\\n\\ntypedef用来定义类型的别名，一是起到类型易于记忆的功能。另一个是定义机器无关的类型。如定义一个REAL的浮点类型，在目标机器上它可以获得最高的精度：typedef long double REAL， 在不支持long double的机器上，看起来是这样的，typedef double REAL，在不支持double的机器上，是这样的，typedef float REAL\\n\\n#define不只是可以为类型取别名，还可以定义常量、变量、编译开关等。\\n\\n**（3）作用域不同**\\n\\n#define没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用，而typedef有自己的作用域\\n\\n**（4）对指针的操作不同**\\n\\n```C\\n例1：\\n#define INTPTR1 int*     //新的别名放在中间，注意：#define N 5,别名N在中间\\ntypedef int* INTPTR2; //新的别名在后面\\nINTPTR1 p1, p2;\\nINTPTR2 p3, p4;\\n含义分别为，\\n声明一个指针变量p1和一个整型变量p2 //因为#define知识简单的字符替换\\n声明两个指针变量p3、p4\\n例2：\\n#define INTPTR1 int*\\ntypedef int* INTPTR2;\\nint a = 1;\\nint b = 2;\\nint c = 3;\\nconst INTPTR1 p1 = &a;//等同于const int* p1,p1是常量指针\\nconst INTPTR2 p2 = &b;//等同于const int* p2,p2是常量指针\\nINTPTR2 const p3 = &c;//等同于int* const p3，p3是指针常量\\n````\\n\\n```cpp\\n//一、关于“指针常量“和“常量指针”的一些思考：\\n主要是看这个表述最后的那个名词：是常量还是指针。那么它的本质就是对应的常量还是指针。\\n//1、指针常量：本质是常量，但是常量里面装的是指针。\\n表达式为（先*后const）：int* const p;\\n所以，指针指向的地址不能变，但是地址中存储的值可以变化。\\nint a=1,b=2;\\nint* const p=&a;\\ncout<<*p<<endl; //值为1\\n*p=7; //正确，指针常量允许修改值。\\n*p=&b; //错误！指针常量不允许修改指向的地址\\n\\n//2、常量指针：本质是指针，但是指针指向常量\\n表达式为（先const后*）：const int* q;或者 int const* q; \\n注意： const* int q;会报错。\\n所以，指针指向的地址可以变，但是指针所指向的值不允许变化。\\nint c=1,d=2;\\nint const *q=&c;  // 或者 const int* q=&c;\\ncout<<*q<<endl; //值为1\\n*q=7; //错误！常量指针不允许修改值。\\nq=&d; //正确，常量指针允许修改指向的地址\\n```\\n\\n因为<font color=\'red\'>*引用* 是指针常量</font>嘛，所以引用本身是一个常量，但是里面装的是指针。即：引用的指针不能变，但是指向的内容可以变化。在定义**引用**的同时，必须初始化。\\n\\n+ 引用除了给变量赋予新的名称，还可以用于函数形参（常见于类的拷贝构造）。\\n+ 引用可以用作函数返回值。注意，不要返回局部变量。还有**函数调用作左值**的使用。\\n+ 常量引用，形如：`const int& v;`\\n\\n**小技巧**：\\n\\n+ 指针常量/常量指针，就看这个词的最后两个字是什么，它的本质就是什么。\\n+ 指针常量：是一个常量，常量里面装的是指针，所以指针的指向内存不能改变；\\n+ 常量指针：是一个指针，指针指向内存中存放的数据是称量，所以指针的指向内存可以变，但是存放的数据可以变。\\n\\n## 13）static \\n\\n用于声明静态变量或类的静态函数。静态变量作用范围在一个文件内，程序开始时分配空间，结束时释放空间，默认初始化为 0，使用时可改变其值。\\ncpp 类的成员变量被声明为 static（称为静态成员变量），意味着它被该类的所有实例所共享，也就是说当某个类的实例修改了该静态成员变量，其修改值为该类的其它所有实例所见；而类的静态成员函数也只能访问静态成员（变量或函数）。\\n**static和extern**\\n\\n对于全局变量和函数而言，两者功能相反，extern想让程序使用其他文件的函数或全局变量；static是将函数和全局变量限制在本文件当中。\\n\\n对于局部变量，static是将变量的创建空间从栈区更改到了静态数据区。\\n**class类中的static成员函数/变量 和 const成员函数/变量**\\n\\n0、前言\\n\\n为什么cpp中会出现/保留static关键字和const关键字呢？\\n参考链接：https://zhuanlan.zhihu.com/p/141113043\\n\\nstatic有两个功能，对于全局变量和函数，是限制其作用域；对于局部变量，是将其创建空间从栈区更改到静态存储区，以保证在函数调用结束时，变量值不会被释放。\\n\\n在cpp类的多个对象中，如果我们想要一个变量值，可以让所有对象共享，常规的做法是使用全局变量。但是全局变量的使用破坏了类的封装性，而类的静态变量，既可以让类内对象共享，也可以对类外对象隐藏。\\n\\n**cpp中为什么会引入const**\\n\\ncpp有一个类型严格的编译系统，这使得cpp程序的错误在编译阶段即可发现许多，从而使得出错率大为减少，因此，也成为了cpp与c相比，有着突出优点的一个方面。\\n\\nc中很常用的预处理命令`#define 变量名 变量值`，可以很方便地进行值替代。这种值代替至少有三个优势：\\n\\n> 一是避免了意义模糊的数字出现，使得程序语义流畅清晰，如下例：\\n> 　　#define user_num_max 107 这样就避免了直接使用107带来的困惑。\\n> 　　二是可以很方便地进行参数的调整与修改，如上例，当人数由107变为201时，进改动此处即可，\\n> 　　三是提高了程序的执行效率，由于使用了预编译器进行值替代，并不需要为这些常量分配存储空间，所以执行的效率较高。\\n\\n预处理语句虽然有以上的许多优点，但它有个比较致命的缺点，即，预处理语句仅仅只是简单值替代，缺乏类型的检测机制。这样预处理语句就不能享受cpp严格类型检查的好处，从而可能成为引发一系列错误的隐患。\\n\\n结论：\\n\\n> const 推出的初始目的，正是为了取代预编译指令，消除它的缺点，同时继承它的优点。\\n\\n现在它的形式变为：`const typename 变量名=变量值`，**为什么const能很好的替代预定义命令？**\\n\\n> 1． 首先，以const 修饰的常量值，具有不可变性，这是它能取代预定义语句的基础。\\n> 2． 第二，很明显，它也同样可以避免意义模糊的数字出现，同样可以很方便地进行参数的调整和修改。\\n> 3． 第三，<font color=\'red\'>cpp的编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高</font>，同时，这也是它取代预定义语句的重要基础。这里，我要提一下，为什么说这一点是也是它能取代预定义语句的基础，这是因为，编译器不会去读存储的内容，如果编译器为const分配了存储空间，它就不能够成为一个编译期间的常量了。\\n> 4． 最后，const定义也像一个普通的变量定义一样，它会由编译器对它进行类型的检测，消除了预定义语句的隐患。\\n\\n**const 使用场景分析**\\n\\n1. const用于修饰指针的两种情况\\n\\n```c\\nint const *a; 　//a可变，*a不可变 [常量指针，本质为指针，指针指向的内存空间存放的是常量。所以，值不能变，指针能变。即*a不能变，a能变]\\nint *const a; 　//a不可变，*a可变 [指针常量，本质为常量，常量里存放的是指针。所以指针指向不能变，值能变，例如cpp的引用。即a不能变，*a能变]\\n```\\n\\n*分析*：const 是一个左结合的类型修饰符，它与其左侧的类型修饰符和为一个类型修饰符，所以，int const 限定\\\\*a,不限定a。int \\\\*const 限定a,不限定\\\\*a。\\n\\n2. const 限定函数的传递值参数\\n   *分析*：上述写法限定参数在函数体中不可被改变。由值传递的特点可知，var在函数体中的改变不会影响到函数外部。所以，此限定与函数的使用者无关，仅与函数的编写者有关。\\n3. const限定函数的返回值\\n\\n```C\\nconst int fun1(); \\nconst myclass fun2();\\n```\\n\\n*分析*：上述写法限定函数的返回值不可被更新，当函数返回内部的类型时（如fun1），已经是一个数值，当然不可被赋值更新，所以，此时const无意义，最好去掉，以免困惑。当函数返回自定义的类型时（如fun2），这个类型仍然包含可以被赋值的变量成员，所以，此时有意义。\\n\\n一般而言，当返回值类型是指针或者class类，或者struct结构体时，返回值用const限制才比较合适。当返回值是基本数据类型时，用const并无意义。\\n\\n4. 传递与返回指针\\n\\n此种情况最为常见，由地址变量的特点可知，适当使用const，意义昭然。\\n\\n5. const限定类的成员函数\\n\\n```cpp\\nclass classname {\\n　public:\\n　　int fun() const; //常成员函数\\n　.....\\n}\\n```\\n\\n　　注意：采用此种const 后置的形式是一种规定，亦为了不引起混淆。在此函数的声明中和定义中均要使用const,因为const已经成为类型信息的一部分。\\n\\n> 获得能力：可以操作常量对象。\\n>       失去能力：不能修改类的数据成员，不能在函数中调用其他不是const的函数。\\n\\n**const使用总结**\\n\\n> 1. 函数返回值为const时，返回的东西赋给一个类型相同的标示后其不能为左值；\\n> 2. 用const定义的int可用来开辟数组，但const定义的常量数组中的元素，不能用来定义数组。\\n> 3. const int *i; int const *i; int * const i; 前两个功能相同，说明i所指向的值不变；最后一个说明指针指向的地址不变，但值可以变。\\n> 4. 类中的const成员函数,定义为在原型后加const。常量函数不能修改类中的任何属性。但有两种方法可以修改。\\n>\\n> > 1) {(yourclass *)this->member = values;}\\n> > 2) 将一个成员定义成mutable即可被常量函数修改。\\n>\\n> 5. 类中的常量const 类型的，不能在类中被用来定义数组。而enum {ONE=100; TWO=2};定义的ONE、TWO 却可以。通常的enum定义的值分配问题：enum A{ L=9, Z};此时Z的值为10。\\n\\n一、静态数据成员的特点\\n\\n+ 静态成员不属于某一个对象，而是属于整个类（定义在数据段）\\n+ 静态成员供所有对象共享，每个对象可以调用且修改。一个对象修改，其他对象也跟着变化\\n+ 可以直接通过类名直接访问\\n+ *注意!* 静态数据成员，类内定义，类外初始化\\n\\n二、类的静态成员函数\\n\\n+ 类的静态成员函数不属于某一个对象，属于整个类，所以不存在this指针\\n+ 因为没有this指针，所以不能调用普通成员函数和变量\\n+ 静态成员函数不能用const修饰\\n+ 静态成员函数只能访问类的静态成员，不能访问普通成员。因为类的静态成员是属于整个类的，在类定义好的时候就已经在内存开辟了空间，而普通成员是在对象生成的时候才在内存开辟空间，如果使用静态成员函数去访问普通的类会出错\\n+ 普通成员函数可以调用静态成员或者非静态成员\\n\\n三、类的常量成员const\\n常量数据成员特点：\\n\\n+ 必须在构造函数那里进行列表初始化，不可以在构造函数内部初始化\\n+ 初始化以后不可以再修改\\n\\n四、常量成员函数const\\n\\n+ 常量成员函数内不允许对类的成员变量进行修改，也不允许对函数的const参数进行修改（防止对成员变量误操作）\\n\\n五、比较compare：静态和常量\\n\\n+ 静态成员变量类内定义，类外初始化。常量成员必须在构造函数的初始化列表中初始化，不能在函数体中初始化；\\n+ 普通对象能调用静态成员函数，能调用常量成员函数。静态对象只能调用静态成员函数，不能访问普通成员变量和函数*(因为类的静态成员是属于整个类的，在类定义好时就已经在内存中开辟了空间，而普通成员是在对象生成的时候才在内存中开辟空间，如果使用静态成员函数访问普通成员变量/函数就会出错)*。常对象只能访问常成员函数。常成员函数只能调用常成员变量(防止这个函数修改普通变量的值)，不过普通变量可用mutable关键字修饰，这样，常成员函数就可以了调用和修改它了。\\n+ <font color=\'red\'>需要注意的是</font>,其实静态成员函数可以访问为非静态成员变量，只是十分复杂，故不建议采用。之前说到，静态成员函数不能访问普通成员变量，是因为没有this指针，那么如果静态函数的形参就包含该类，那就可以访问该类的普通成员变量了。`如类A中有static void f(A a); static int a,int b，void A::f(A a) {cout<<a;//正确，cout<<b;//错误；cout<<a.b/正确}`。\\n+ 建议规范调用静态成员函数和变量，即使用类名而非对象名来调用静态对象。如A::a和A::func(),而不是A obj;obj.a和obj.func()。\\n+ \\n\\n## 14）public、protected、private \\n\\n权限修饰符。\\n\\n## 15）virtual\\n\\n用于声明虚基类、虚函数。虚函数=0时，则为纯虚函数，纯虚函数所在的类称为抽象类。\\n\\n## 16）override、final\\n\\noverride 用于表示当前函数重写了基类的虚函数。\\nfinal 用于禁止类继承、禁止重载虚函数。\\n\\n## 17）operator\\n\\n用于重载操作符。如下重载类Person的 == 运算法：\\n![程序示例](https://s3.bmp.ovh/imgs/2022/07/14/12e8450b6ab81b3a.jpg)\\n\\n## 18）const、constexpr\\n\\nconst 表示所修饰的对象或变量不能被改变。\\nconstexpr 用于生成常量表达式，常量表达式主要是允许一些计算发生在编译时，而不是运行的时候。\\n\\n## 19）using\\n\\n用于在当前文件引入命名空间，例如：using namespace std；\\n在子类中，使用 using 声明引入基类成员名称。\\n\\n## 20）namespace\\n\\ncpp标准程序库中的所有标识符都被定义于一个名为 std 的namespace中。\\n命名空间除了系统定义的名字空间之外，还可以自己定义，定义命名空间用关键字 namespace，使用命名空间时用符号 :: 指定。\\n\\n## 21）inline\\n\\n声明为内联函数，即在编译时将所调用的函数代码直接嵌入到主调函数中。\\n作用是提高效率，但是程序应尽量短小\\n\\n## 22）new、delete  <font color=\'red\'>补充</font>\\n\\nnew 用于向内存申请一段新的空间，delete 用于释放申请空间。\\n用new创建一个int型的空间，并附初始值：`int *p=new int(2);`。 `delete p`\\n用new创建一个数组的空间，并附初始值：`int *p=new int [5](0);` `delete[] p`\\n\\n## 23）this\\n\\n每个类成员函数都隐含了一个this指针，用来指向类本身。\\nthis指针一般可以省略，但在赋值运算符重载的时候要显示使用。静态成员函数没有this指针。\\n\\n## 24）nullptr\\n\\ncpp11新引入的，用来声明一个 空指针，代替NULL。\\nint* p = nullptr;\\n\\n## 25）void\\n\\n特殊的\\\"空\\\"类型，指定函数无返回值或无参数。\\n\\n## 26）friend\\n\\n用于声明友元关系。\\n友元可以访问与其有 friend 关系的类中的 private/protected 成员，通过友元直接访问类中的 private/protected 成员的主要目的是提高效率。\\n友元包括友元函数和友元类。全局函数/成员函数做友元，类做友元。\\n\\n#### 4.4.1 全局函数做友元\\n\\n```cpp\\nclass Building\\n{\\n\\t//告诉编译器 goodGay全局函数 是 Building类的好朋友，可以访问类中的私有内容\\n\\tfriend void goodGay(Building * building);\\n\\npublic:\\n\\n\\tBuilding()\\n\\t{\\n\\t\\tthis->m_SittingRoom = \\\"客厅\\\";\\n\\t\\tthis->m_BedRoom = \\\"卧室\\\";\\n\\t}\\n\\n\\npublic:\\n\\tstring m_SittingRoom; //客厅\\n\\nprivate:\\n\\tstring m_BedRoom; //卧室\\n};\\n\\n\\nvoid goodGay(Building * building)\\n{\\n\\tcout << \\\"好基友正在访问： \\\" << building->m_SittingRoom << endl;\\n\\tcout << \\\"好基友正在访问： \\\" << building->m_BedRoom << endl;\\n}\\n\\n\\nvoid test01()\\n{\\n\\tBuilding b;\\n\\tgoodGay(&b);\\n}\\n\\nint main(){\\n\\n\\ttest01();\\n\\n\\tsystem(\\\"pause\\\");\\n\\treturn 0;\\n}\\n```\\n\\n\\n\\n#### 4.4.2 类做友元\\n\\n```cpp\\nclass Building;\\nclass goodGay\\n{\\npublic:\\n\\tgoodGay();\\n\\tvoid visit();\\nprivate:\\n\\tBuilding *building;\\n};\\nclass Building\\n{\\n\\t//告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类中私有内容\\n\\tfriend class goodGay;\\npublic:\\n\\tBuilding();\\npublic:\\n\\tstring m_SittingRoom; //客厅\\nprivate:\\n\\tstring m_BedRoom;//卧室\\n};\\nBuilding::Building()\\n{\\n\\tthis->m_SittingRoom = \\\"客厅\\\";\\n\\tthis->m_BedRoom = \\\"卧室\\\";\\n}\\ngoodGay::goodGay()\\n{\\n\\tbuilding = new Building;\\n}\\nvoid goodGay::visit()\\n{\\n\\tcout << \\\"好基友正在访问\\\" << building->m_SittingRoom << endl;\\n\\tcout << \\\"好基友正在访问\\\" << building->m_BedRoom << endl;\\n}\\nvoid test01()\\n{\\n\\tgoodGay gg;\\n\\tgg.visit();\\n\\n}\\nint main(){\\n\\n\\ttest01();\\n\\n\\tsystem(\\\"pause\\\");\\n\\treturn 0;\\n}\\n```\\n\\n#### 4.4.3 成员函数做友元\\n\\n```cpp\\nclass Building;\\nclass goodGay\\n{\\npublic:\\n\\n\\tgoodGay();\\n\\tvoid visit(); //只让visit函数作为Building的好朋友，可以发访问Building中私有内容\\n\\tvoid visit2(); \\n\\nprivate:\\n\\tBuilding *building;\\n};\\n\\n\\nclass Building\\n{\\n\\t//告诉编译器  goodGay类中的visit成员函数 是Building好朋友，可以访问私有内容\\n\\tfriend void goodGay::visit();\\n\\npublic:\\n\\tBuilding();\\n\\npublic:\\n\\tstring m_SittingRoom; //客厅\\nprivate:\\n\\tstring m_BedRoom;//卧室\\n};\\n\\nBuilding::Building()\\n{\\n\\tthis->m_SittingRoom = \\\"客厅\\\";\\n\\tthis->m_BedRoom = \\\"卧室\\\";\\n}\\n\\ngoodGay::goodGay()\\n{\\n\\tbuilding = new Building;\\n}\\n\\nvoid goodGay::visit()\\n{\\n\\tcout << \\\"好基友正在访问\\\" << building->m_SittingRoom << endl;\\n\\tcout << \\\"好基友正在访问\\\" << building->m_BedRoom << endl;\\n}\\n\\nvoid goodGay::visit2()\\n{\\n\\tcout << \\\"好基友正在访问\\\" << building->m_SittingRoom << endl;\\n\\t//cout << \\\"好基友正在访问\\\" << building->m_BedRoom << endl;\\n}\\n\\nvoid test01()\\n{\\n\\tgoodGay  gg;\\n\\tgg.visit();\\n\\n}\\n\\nint main(){\\n    \\n\\ttest01();\\n\\n\\tsystem(\\\"pause\\\");\\n\\treturn 0;\\n}\\n```\\n\\n\\n\\n## 27）template \\n\\n模板，cpp中泛型机制的实现。模板就是实现代码重用机制的一种工具，它可以实现类型参数化，即把类型定义为参数， 从而实现了真正的代码可重用性。模版可以分为两类，一个是函数模版，另外一个是类模版。\\n\\n## 28）if、else\\n\\n用于条件语句。\\n\\n## 29）for、while、do\\n\\n用于循环语句。\\n\\n## 30）switch、case、default\\n\\n用于分支语句。switch 表示分支语句的起始，根据 switch 条件跳转到 case 标记或 defalut 标记的分支上。\\n\\n## 31）break、continue、goto\\n\\nbreak用于跳出for、while循环或switch语句。\\ncontinue用于跳到一个循环的起始位置。\\ngoto用于无条件跳转到函数内的标记处，一般情况不建议使用goto。\\n\\n## 32）and、or、xor、not、bitand、bitor\\n\\nand 表示逻辑与 &&；\\nor 表示逻辑或 ||；\\nxor 表示逻辑异或 ^；\\nnot 表示逻辑非 !；\\nbitand 表示按位与 &；\\nbitor 表示按位或 |。\\n\\n## 33）return\\n\\nreturn表示从被调函数返回到主调函数继续执行，返回时可带一个返回值。\\n\\n## 34）try、catch、throw\\n\\n用于异常处理。try 指定 try 块的起始，try 块后的 catch 可以捕获异常，异常由 throw 抛出。\\n\\n## 35）noexcept\\n\\ncpp11中，用于声明一个函数不可以抛出任何异常。\\n\\n## 36）static_cast、const_cast、dynamic_cast、reinterpret_cast\\n\\ncpp类型风格来性转换：\\nstatic_cast用于静态转换；\\nconst_cast删除const变量的属性，方便赋值；\\ndynamic_cast用于将一个父类对象的指针转换为子类对象的指针或引用；\\nreinterpret_cast将一种类型转换为另一种不同的类型。\\n参考链接：https://www.cnblogs.com/wangchaoguo-li/p/14210679.html\\n\\n|       方式       |                           使用场景                           |\\n| :--------------: | :----------------------------------------------------------: |\\n|   static_cast    | 基本数据类型之间的转换使用，例如float转int，int转char等；子类对象指针转换成父类对象指针也可以使用static_cast；在有类型指针和void\\\\*之间转换使用，不能使用static_cast在有类型指针之间进行类型转换。 |\\n|   dynamic_cast   | 用于将父类的指针或引用转换为子类的指针或引用，此场景下父类必须要有虚函数（只要拥有虚函数就行） |\\n|    const_cast    |       用于常量指针或引用与非常量指针或引用之间的转换。       |\\n| reinterpret_cast | 类似C语言中的强制类型转换，什么都可以转，尽量不要使用此方式。 |\\n\\n**static_cast**\\n\\n基本数据类型之间的转换使用，例如float转int，int转char等，在有类型指针和void\\\\*之间转换使用，子类对象指针转换成父类对象指针也可以使用static_cast（<font color=\'red\'>不能使用static_cast在有类型指针之间进行类型转换</font>）。\\n\\n```c\\n#include <iostream>\\n\\nusing namespace std;\\n\\nstruct Base {\\n    virtual void Func() { cout << \\\"Base Func \\\\n\\\"; }\\n};\\n\\nstruct Derive : public Base {\\n    void Func() override { cout << \\\"Derive Func \\\\n\\\"; }\\n};\\n\\nint main()\\n{\\n    float f = 1.23;\\n    cout << \\\"f \\\" << f << endl;\\n    int i = static_cast<int>(f);\\n    cout << \\\"i \\\" << i << endl;\\n\\n    void *p;\\n    int *i_p = static_cast<int *>(p);\\n    void *pi = static_cast<void *>(&f);\\n    int *pi = static_cast<int *>(&f);  //error invalid static_cast from type ‘float*’ to type ‘int*’\\n\\n    Derive d;\\n    d.Func();\\n    Base *b = static_cast<Base *>(&d);\\n    b->Func();\\n    return 0;\\n}\\n```\\n\\n**dynamic_cast**\\n\\n用于将父类的指针或引用转换为子类的指针或引用，此场景下父类必须要有虚函数（只要拥有虚函数就行），因为dynamic_cast是运行时检查，检查需要运行时信息RTTI。\\n\\n```cpp\\n#include <iostream>\\n\\nusing namespace std;\\n\\nstruct Base {\\n    virtual void Func() { cout << \\\"Base Func \\\\n\\\"; }\\n};\\n\\nstruct Derive : public Base {\\n    void Func() override { cout << \\\"Derive Func \\\\n\\\"; }\\n};\\n\\nint main() {\\n    Derive d;\\n    d.Func();\\n    Base *b = dynamic_cast<Base *>(&d);\\n    b->Func();\\n    Derive *dd = dynamic_cast<Derive *>(b);\\n    dd->Func();\\n    return 0;\\n}\\n```\\n\\n**const_cast**\\n\\n用于常量指针或引用与非常量指针或引用之间的转换，只有const_cast才可以对常量进行操作，一般都是用它来去除常量性（去除常量性是危险操作，还是要谨慎操作）。\\n\\n```cpp\\nint main() {\\n    int data = 10;\\n    const int *cpi = &data;\\n\\n    int *pi = const_cast<int *>(cpi);\\n\\n    const int *cpii = const_cast<const int *>(pi);\\n    return 0;\\n}\\n```\\n\\n**reinterpret_cast**\\n\\n类似C语言中的强制类型转换，什么都可以转，万不得已不要使用，一般前三种转换方式不能解决问题了使用这种强制类型转换方式。\\n\\n```cpp\\nint main() {\\n    int data = 10;\\n    int *pi = &data;\\n\\n    float *fpi = reinterpret_cast<float *>(pi);\\n\\n    return 0;\\n}\\n```\\n\\n## 37）register\\n\\n提示编译器尽可能把变量存入到CPU内部寄存器中。\\n\\n## 38）explicit\\n\\nexplicit 的作用是禁止单参数构造函数被用于自动类型转换，比较典型的是容器类型。\\n\\n再次注意，是单参数，形如`explicit Fraction(int numerator:m_numerator(numerator){}`，还有一种情况是多参数，但是后面几个参数都有默认值，只有第一个参数没有默认值：`explicit Fraction(int numerator, int denominator = 1): m_numerator(numerator), m_denominator(denominator){}`\\n\\n注意：当类的声明和定义分别在两个文件中时，explicit只能写在在声明.h中，不能写在定义.c中。\\n参考链接：[CSDN](https://blog.csdn.net/l2563898960/article/details/97769569)\\nexplicit意为清晰地，明确的意思，顾名思义，它的作用就是阻止隐式转换的发生。\\n**例如**: cpp中只带有一个参数的构造函数,或者或者除了第一个参数外其余参数都有缺省值的多参构造函数,承担了两个角色:\\n1.用于构建单参数的类对象.\\n2.隐含的类型转换操作符.\\n\\n>例如:一个类A的构造函数A(int i)就是，既可以用来作为构造器，又可以实现隐式转换A a=1；因为1可以通过构造函数A(int i)转换为一个类A的对象。(隐含的类型转换操作符)\\n\\n但有时候，我们并不想让他进行隐式转换，这是cpp的explicit关键字就起作用了。\\nexplicit的三种使用情况：**类型转换（operator())**、**单操作数构造函数**、**同时出现类型转换和有参构造函数**\\n再说下面的内容前，需要提及：类型类型转换函数的一般形式：\\n\\n```cpp\\noperator 数据类型() const\\n{\\n\\t//函数实现\\n}\\n```\\n\\n> 1.转换函数必须是类的成员函数\\n> 2.转换函数不能声明返回类型\\n> 3.形参列表必须为空\\n> 4.类型转换函数通常应该是const\\n\\n### 使用情况1：类型转换\\n\\n```cpp\\n#include<iostream>\\nusing namespace std;\\nclass Fraction{\\npublic:\\n\\tFraction(int numerator, int denominator = 1): m_numerator(numerator), m_denominator(denominator){}\\n\\toperator double() const   //类型转换函数\\n\\t{\\n\\t\\treturn (double)m_numerator/m_denominator;\\n\\t}\\nprivate:\\n\\tint m_numerator;\\n\\tint m_denominator;\\n};\\n\\nint main(void)\\n{\\n\\tFraction f(3, 5);\\n\\tdouble d = 3.5 + f;\\n\\tcout << d << endl;\\n\\treturn 0;\\n}\\n```\\n\\n我们设计了一个Fraction类(分数类), 在主函数中定义了一个分数对象<font color=red>f</font>,然后将<font color=red>3.5 + f</font>赋值给double类型变量<font color=red>d</font>, 但是我们发现f并不是一个double类型的变量,因此编译器会从Fraction类中寻找<font color=red>operator double()</font>函数,隐式调用该函数将Fraction类型转换成一个double类型. <font color=red>operator double()</font>就是我们所说的类型转换函数(type conversion function).\\n\\n注意，此代码中含有隐式类型转换。在计算3.5+f时，类的对象f回调用类型转换函数operator double()来将f转换成double。\\n\\n使用explicit关键字来避免隐式类型转换，在进行类型转换时，必须显示声明：用`static_cast<double>f`\\n\\n```cpp\\n#include<iostream>\\nusing namespace std;\\nclass Fraction{\\npublic:\\n\\tFraction(int numerator, int denominator = 1): m_numerator(numerator), m_denominator(denominator){}\\n\\texplicit operator double() const    //不能隐式类型转换了\\n\\t{\\n\\t\\treturn (double)m_numerator/m_denominator;\\n\\t}\\nprivate:\\n\\tint m_numerator;\\n\\tint m_denominator;\\n}；\\n\\nint main(void)\\n{\\n\\tFraction f(3, 5);\\n\\tdouble d = 3.5 + static_cast<double>(f);//必须显式类型转换\\n\\tcout << d << endl;\\n\\treturn 0;\\n}\\n```\\n\\n### 使用情况2：有参构造函数\\n\\n对于3.5+f，上面的例子是使用类型转换来实现的。其实，也可以使用重载运算符+的方法来实现，不过，需要写成f+3.5的形式。\\n\\n```cpp\\n//code 1\\n#include<iostream>\\nusing namespace std;\\nclass Fraction\\n{\\npublic:\\n    Fraction(int numerator, int denominator = 1) : m_numerator(numerator), m_denominator(denominator) {}\\n    double operator+(double a)\\n    {\\n        return (double)this->m_numerator /this->m_denominator+a;\\n    }\\nprivate:\\n    int m_numerator;\\n    int m_denominator;\\n};\\n\\nint main(void)\\n{\\n    Fraction f(3, 5);\\n    double d = f+3.5;\\n    cout << d << endl;\\n    system(\\\"pause\\\");\\n    return 0;\\n}\\n////////////////operator+中隐藏的类型转换//////////////////////////////\\n//code 2\\n#include<iostream>\\nusing namespace std;\\nclass Fraction\\n{\\n public:\\n \\tFraction(int numerator, int denominator = 1): m_numerator(numerator), m_denominator(denominator){}\\n \\tdouble operator+(const Fraction& a)\\n \\t{\\n \\t\\treturn (a.m_numerator + this->m_numerator)/(a.m_denominator + this->m_denominator);\\n \\t}\\n private:\\n \\tint m_numerator;\\n\\tint m_denominator;\\n }\\n \\n int main(void)\\n{\\n\\tFraction f(3, 5);\\n\\tdouble d = f + 3;\\n\\tcout << d << endl;\\n\\treturn 0;\\n}\\n```\\n\\n在double d = f + 3 这句话中构造函数就是前面所提到的第二种角色隐含的类型转换操作符.,因为执行到这句话首先会调用+的重载函数,该函数的调用对象默认为左操作数,右操作数为Fraction类型,因此会调用有参构造函数将3转换成Fraction类型,然后将得到的返回值double类型赋值给变量d.\\n\\n同理如果不想让构造函数进行隐式类型转换,可以在构造函数前面加上explicit关键字,防止进行隐式转换.使用方法如下:\\n\\n```cpp\\n#include<iostream>\\nusing namespace std;\\nclass Fraction\\n{\\n public:\\n \\texplicit Fraction(int numerator, int denominator = 1): m_numerator(numerator), m_denominator(denominator){}\\n \\tdouble operator+(const Fraction& a)\\n \\t{\\n \\t\\treturn (a.m_numerator + this->m_numerator)/(a.m_denominator + this->m_denominator);\\n \\t}\\n private:\\n \\tint m_numerator;\\n\\tint m_denominator;\\n };\\n \\n int main(void)\\n{\\n\\tFraction f(3, 5);\\n\\tdouble d = f + 3;//注意，此处代码会报错\\n\\tcout << d << endl;\\n\\tsystem(\\\"pause\\\");\\n\\treturn 0;\\n\\t//想要代码运行，需要将3类型准换为Fraction类，即使用类的有参构造函数。但是有参构造函数使用explicit修饰，不能隐式类型转换。\\n}\\n```\\n\\n### 使用情形3：有参构造和类型转换函数同时出现\\n\\n```cpp\\n#include<iostream>\\nusing namespace std；\\nclass Fraction\\n{\\n public:\\n \\tFraction(int numerator, int denominator = 1): m_numerator(numerator), m_denominator(denominator){}\\n \\toperator int()  //强制类型转换\\n \\t{\\n \\t\\treturn m_numerator/denominator;\\n \\t}\\n \\tint operator+(const Fraction& a)//重载运算符+，以及隐式使用了有参构造函数\\n \\t{\\n \\t\\treturn (a.m_numerator + this->m_numerator)/(a.m_denominator + this->m_denominator);\\n \\t}\\n private:\\n \\tint m_numerator;\\n\\tint m_denominator;\\n }\\n\\n int main(void)\\n{\\n\\tFraction f(3, 5);\\n\\tint d = f + 3;//上面两种方法都有效，使用哪个？有歧义\\n\\tcout << d << endl;\\n\\treturn 0;\\n}\\n```\\n\\n这时你会发现会产生一个二义性问题,在执行int d = f + 3的时候到底是该选择类型转换函数,将f转换成int类型再继续运算呢?还是应该将3作为构造函数的参数进行隐式转换,然后再调用+运算符重载函数呢?\\n解决这个问题的办法就是使用explicit关键字限制,具体方法有两种：\\n1.在构造函数前面加上explicit关键字, 防止int类型隐式转换成为Fraction类型.\\n2.在类型转换函数前面加上explicit关键字,这样只有显示调用类型转换`static_cast<int>(f)`时,才会调用该函数.\\n**总结**：\\n\\n1. cpp中，一个参数的构造函数(或者除了第一个参数外其余参数都有缺省值的多参构造函数)，承担了两个角色。\\n\\n+ 用于构建单参数的类对象\\n+ 隐含的类型转换操作符\\n\\n2. explicit关键字只对有一个参数的类构造函数有效, 如果类构造函数参数大于或等于两个时, 是不会产生隐式转换的, 所以explicit关键字也就无效了\\n3. 声明为explicit的构造函数不能在隐式转换中使用，只能显示调用，去构造一个类对象。\\n\\n```cpp\\nBase base(‘a’) //显示调用,OK\\nBase base = ‘a’ //隐式调用,err 调用了单参数的有参构造函数，或多参数，但后面几个参数有缺省值的\\n```\\n\\n4. 尽量避免有二义性的类型转换，如果类中包含一个或多个隐式类型转换，则必需使用explicit关键字确保在类类型和目标类型之间只存在唯一一种隐式转换方式，否则将出现二义性。\\n5. 但是将拷贝构造函数声明成explicit并不是良好的设计，一般只将有单个参数的constructor声明为explicit，而copy constructor不要声明为explicit.\\n\\n## 39）extern\\n\\n1、\\n\\n当出现extern “C”时，表示 extern “C”之后的代码按照C语言的规则去编译；\\n\\n当extern修饰变量或函数时，表示其具有外部链接属性，即其既可以在本模块中使用也可以在其他模块中使用。\\n\\n为什么会出现 extern “C\\\" ?因为C不支持函数重载，而cpp支持函数重载，所以两类编程语言在汇编时对函数的处理方式不一样。c语言是用函数名来匹配，cpp使用函数名+形参列表来匹配。对于函数`Func(int i,int j)`,c语言的汇编结果为Func，cpp汇编结果为`_Z8Funcii`，这样如果c和cpp混编的话就会出现链接时找不到函数定义的情况。\\n**注意**：除了函数重载外，extern “C”不影响cpp的其他特性\\n\\n```cpp\\n//一般情况，extern \\\"C\\\"是和函数声明放在一起，即位于h头文件中\\n//情况1：在cpp中调用c代码的函数\\nc文件中有一个函数： void Transfer(int a,char b);\\ncpp文件必须用extern \\\"C\\\"声明该函数如下才可以实现调用：\\nextern \\\"C\\\" void Transfer(int a,char b);\\n\\n//情况2：c调用cpp代码的函数\\nc文件若要调用，就必须在cpp文件中用extern \\\"C\\\"来声明该函数，否则cpp在编译过程中就会对其进行名字改编，c文件就找不到该函数的原型\\ncpp文件中有一函数：\\n        void Transfer(int a; char b);\\n但必须用extern \\\"C\\\"来声明后，如下：\\n        extern “C” void Transfer(int a; char b);\\nc文件才可以调用void Transfer(int a; char b)函数。\\n\\n//附加说明1\\n在.cpp文件中引用c的头文件：\\n　// cpp code\\n　　extern “C” {\\n　　#include “my-header1.h”\\n　　#include “my-header2.h”\\n　　}\\n//附加说明2\\nc的头文件如果想被cpp文件使用的话：\\n#ifdef __cplusplus\\nextern \\\"C\\\" {\\n#endif\\n ...   // 按照C语言的规则去编译，C语言的头文件声明放在此处\\n#ifdef __cplusplus\\n}\\n#endif\\n使用附加说明1，cpp代码能正确使用c的头文件。使用附加说明2，该c头文件可被c和cpp正确使用。两种情况，仍选其一即可。\\n```\\n\\n2、extern关键字的常规使用\\nextern是用来声明全局变量或者全局函数的，需要注意，是声明，不是定义\\n`extern  int  i; //声明变量i，但没分配存储空间，还不能使用`，还有`int  i; //定义了变量i，并分配了空间，可以使用`。注意：在程序中一个变量可以声明多次，但只能定义一次。如果声明时有初始化式，也会被当做定义，例如：\\n`extern  int  i = 5； //定义了变量5 ，说明：这样做不规范，会被报警告`\\n后面的程序中若再出现extern  int  i = 5；或者int  i;的语句，就会出错，因为变量只能定义一次。\\n\\n**关于extern的进一步说明**：对于普通定义的变量，常规定义正常使用；在其他文件中要使用此变量时，需要先加extern做声明，编辑器才会在当前文件以外的文件中去寻找该变量或函数的定义，例如：\\n\\n```cpp\\nfile1:\\n\\tint i=10;\\nfile2:\\n\\textern int i;\\n\\ti=2;\\n```\\n\\n**特别地**：对于被const修饰的变量或函数而言，这个变量/函数默认为“局部的”。即使在其他文件中使用extern修饰了也无法使用。如果想在其他文件中使用这个变量，必须在定义该const变量时，显式地指出它将用于外部文件：\\n\\n```cpp\\nfile1:\\nextern const int i=10;\\nfile2:\\nextern const int i;\\n```\\n\\n**说明**：extern与static的功能是相对的。extern用于在程序中使用其他文件中定义的变量或函数，1）static修饰函数，用于将函数的使用限制在当前文件内。2）static修饰全局变量也是同样的道理，限制变量的使用区域。3）static修饰局部变量，那变量的创建空间就从栈区变更到了静态数据区，可用于多次调用某个函数时，函数内计数值的递增。\\n\\n## 40）mutable\\n\\nmutable就是为了突破成员函数 const的限制，可以在const函数里面来修改被mutable修饰的成员变量。\",\"articleCover\":\"\",\"articleTitle\":\"C++关键字说明\",\"articleType\":1,\"categoryName\":\"编程语言基础\",\"isRecommend\":0,\"isTop\":0,\"status\":1,\"tagNameList\":[]}]','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',42,'2023-06-07 16:36:15');
INSERT INTO `t_operation_log` VALUES (1178,'文章模块','添加','/admin/article/add','com.ican.controller.ArticleController.addArticle','添加文章','[{\"articleContent\":\"---\\ntitle: C++指针与常量知识点说明\\ndate: 2022-10-30\\ncategory:\\n - 1编程语言基础\\n\\nfooter: <a href=\\\"https://beian.miit.gov.cn/#/Integrated/index\\\">渝ICP备2023001651号</a>\\n\\n---\\n\\n:::tip\\nC++指针与常量知识点说明\\n:::\\n\\n<!-- more -->\\n\\n\\n[参考资料](https://www.cnblogs.com/zpcdbky/p/4902688.html)\\n\\n网上常见的说法似乎有误：\\n\\n```cpp\\nconst int* p  //常量指针\\nint* const p  //指针常量\\n```\\n\\n在外文书籍中很少有这种说法。一种简洁易懂的说法是：\\n\\n> 指向常量的指针----`const int* p`     【常量指针】\\n>\\n> 本身是常量的指针----`int* const p`  【本身是常量的指针】，也是cpp中的引用\\n\\n判断方法：\\n\\t**先找到\\\\*，然后看\\\\*的两边，右边是对指针p本身的限定，左边是对p所指向的东西的限定。**\\n\\n说明：(顺带一提：\\\\*号优先级排第二，从右往左结合)\\n\\n1.const int\\\\* p：\\n\\n就是所谓的“指向常量的指针”。这里注意，<font color=\\\"blue\\\">所谓“指向常量”只是这个指针的“一厢情愿”，只是一种效果上的等价。</font>事实上，const int \\\\*p=&a;a既可以是常量(const int a=10;)又可以是变量(int a=10;)，但p一厢情愿地认为它所指的就是一个常量，所以它不允许通过自己来修改所指，这就造成一种效果上的等价——从p的角度看，它所指的“的确”是常量。所以，<font color=\\\"red\\\">对“指向常量的指针”的最佳理解应为：我们不能通过该指针修改它所指向的东西（常量或者变量）。</font>\\n\\n 注意，const int \\\\*p=&a;只是说不能通过p来修改a，如果a本身不是const的，通过其它方式修改a自然是可以的（例如直接++a）。\\n\\n另外一点，由于p本身只是一个普通的指针，所以允许在声明时不初始化。但需要注意的是，我们只是说可以，但并不提倡这样做。在任何时候都不应该让指针无所指，如果在声明一个指针时还不知道让它指向谁，就先将其初始化为nullptr或NULL（nullptr是cpp11新特性，用它比用NULL更安全些，这里不详细介绍）。\\n\\n2.int\\\\* const p：\\n\\n就是所谓的“本身是常量的指针”。关于“p本身不能修改但可以通过p修改其所指”这一点，我们在讲判断方法时已经说过，这里主要再说一下p的初始化。\\n\\n由于p本身是const的，所以在编译的时候必须知道p的值（即p所指向的东西的地址），所以在声明p的同时必须初始化p。但要注意，对于 int\\\\* const p=&a，我们只要求a的地址是确定的，但a的值可以不确定。\\n\\n3.const int\\\\* cosnt p：\\n\\n就是所谓的“所指和本身都是常量的指针”。它的语法特性就是前两者的结合，这里不再赘述。\\n\\n4.补充说明：\\n\\n引用生命是必须初始化，且必须左值初始化。这一点与“本身是敞亮的指针”(int\\\\* const p)的特性一样。事实上，我们完全可以借用“本身是常量的指针”来理解甚至定义引用：\\n\\n**引用是一个指向不可变的、被编译器自动解引用的指针，即，引用是一个被编译器自动解引用的“本身是常量的指针”。**\\n-\",\"articleCover\":\"\",\"articleTitle\":\"C++指针与常量知识点说明\",\"articleType\":1,\"categoryName\":\"编程语言基础\",\"isRecommend\":0,\"isTop\":0,\"status\":1,\"tagNameList\":[]}]','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',38,'2023-06-07 16:36:49');
INSERT INTO `t_operation_log` VALUES (1179,'文章模块','添加','/admin/article/add','com.ican.controller.ArticleController.addArticle','添加文章','[{\"articleContent\":\"---\\ntitle: C/C++的比较\\ndate: 2022-04-01\\ncategory:\\n - 1编程语言基础\\n\\nfooter: <a href=\\\"https://beian.miit.gov.cn/#/Integrated/index\\\">渝ICP备2023001651号</a>\\n\\n---\\n\\n:::tip\\nC/C++的比较\\n:::\\n\\n<!-- more -->\\n\\n\\n## 1、第一部分 C++高級編程\\n\\n以下部分内容来源于[知乎：C++高级编程学习笔记](https://zhuanlan.zhihu.com/p/414375745)\\n1.头文件添加注释(文件名, 作者, 函数简介, 日期). （建议而非必要）\\n2.当头文件数目较多时, 应将头文件放在include目录下, 源文件放在source目录下.\\n3.const常量有数据类型, 宏常量#define没有数据类型.\\n4.对于重载赋值运算符`operator =`, 应该用\\\"引用传递\\\"方式。形如：\\n\\n```cpp\\nA operator=(B &b)\\n{\\n\\tA a;\\n    a.Data=b.Data;\\n    return a;\\n}\\n//或\\n#include <iostream>\\nusing namespace std;\\n\\nclass Distance\\n{\\nprivate:\\n    int feet;\\n    int inches;\\npublic:\\n    Distance(){\\n        feet=0;\\n        inches=0;\\n    }\\n    Distance(int f,int i){\\n        feet=f;\\n        inches=i;\\n    }\\n    void operator=(const Distance &D) //赋值运算符重载\\n    {\\n\\t\\tfeet=D.feet;\\n        inches=D.inches;\\n    }\\n    void displayDistance()\\n    {\\n\\t\\tcout<<\\\"F: \\\"<<feet<<\\\"I: \\\"<<inches<<endl;\\n    }\\n};\\nint main()\\n{\\n\\tDistance D1(11,10),D2(5,11);\\n\\t\\n\\tcout<<\\\"First Distance : \\\";\\n\\tD1.displayDistance();\\n\\tcout<<\\\"Second Distance : \\\";\\n\\tD2.displayDistance();\\n\\t\\n\\t//使用赋值运算符\\n\\tD1=D2;\\n\\tcout<<\\\"then,the new First Distance :\\\";\\n\\tD1.displayDistance();\\n\\treturn 0;\\n}\\n```\\n\\n5.函数入口处用assert检查\\n6.内存分配方式有三种, 从静态存储区域分配, 从栈上分配, 从堆上分配, 静态存储区包括全局变量, static变量等.\\n7.C++/C语言，没有办法知道指针所指的内存容量.\\n8.指针消亡了, 不表示所指的内存会被自动释放。内存被释放了, 不表示指针会消亡或者成了NULL指针.\\n9.指针被free或delete之后, 别忘记设置为NULL.\\n\\n关于8和9的思考：先用指针开辟一个空间，然后在令指针为NULL。这时，指针消亡了，但是内存空间还在，只是不能使用了（内存泄漏）。对开启了空间的指针free或者delete，内存空间会被释放，但是指针还能使用（只是使用前需要重新在赋指针值）。\\n10.malloc不调用构造函数, new自动调用构造函数, free和delete类似.\\nmalloc是c语言的底层函数，new是C++的类方法。\\n11.为什么要用重载? (1) 便于记忆。(2) 不得不, 比如说类的多个构造函数\\n12.不能编译头文件\\n全局变量定义时, (直接赋值), extern无作用\\n全局变量声明时, extern告诉编译器, 定义部分在其它模块中\\n全局变量默认extern\\n13.重载: 同一个类中, 或都是全局函数.\\n覆盖: 分别位于派生类与基类中, 函数名与参数都相同，有virtual关键字，用于多态.\\n隐藏: 分别位于派生类与基类中, 只要同名, 且非覆盖, 均为隐藏.\\n14.函数参数的缺省值，只能出现在函数的<font color=\\\"red\\\">声明</font>中. \\n15.操作符重载。调用时, 普通函数参数出现在圆括号内, 对于运算符, 参数出现在其左右两侧。定义时，可定义为全局函数和类的成员函数，后者比前者少了一个参数。\\n16.类的构造次序，先构造基类，再构造构造函数的参数，再构造成员，再构造自己。析构完全相反。\\n17.String a(\\\"hello\\\"); String b=a; 其实是调用了b的拷贝构造函数，最好写成String b(a).\\n18.对于一个类，编译器默认生成4个函数，无参构造函数，拷贝构造函数，析构函数，赋值函数(重载=运算符)\\n19.类的析构函数，应为虚函数, 多态\\n20.对于非内部数据类型的输入参数，应该将“值传递”的方式，改为“const 引用传递”，目的是提高效率。例如，将void Func(A a)，改为 void Func(const A &a)。其实实参在向形参传递值时，是用实参的值在栈上重新开辟了一块临时空间，再来装实参的值。如果使用引用的方法，就是单纯地指针传递，没有开辟空间这个步骤，节约时间，节约栈内存。\\n21.引用被创建的同时，必须被初始化，一旦引用被初始化，就不能改变引用的关系。引用的实质是<font color=\\\"red\\\">指针常量</font>。即：<font color=\\\"red\\\">指针常量：本质为常量，常量里面装的是指针。所以，指针的指向不能变，指向的内存空间中，存放的值可以变</font>。\\n22.对比于C语言的函数，cpp增加了重载，内联，const和virtual四种新机制，重载和内联机制，既可以用于全局函数，也可用于类的成员函数，const与virtual机制，仅用于类的成员函数\\n23.赋值符号的重载，不能为友元，只能是类的成员函数\\n\\n## 2、第二部分 cpp和C的区别\\n\\n紧接上文，还是参考[知乎专栏](https://zhuanlan.zhihu.com/p/414375745)\\n1、概述\\n\\n+ C++三要素：封装、继承、多态。封装是class，继承是class的继承，多态是函数重载和运算符重载\\n+ 面向对象：\\n  对象：存在即合理，抽象性：物以类聚，封装：事物的封闭性，继承：事物的相似性，多态：事物的多样性。\\n+ 面向对象的方法：\\n  ![图1](https://s3.bmp.ovh/imgs/2022/07/25/b6c212804ba23100.jpg)\\n+ cpp是什么？\\n  cpp是c语言的超集；是面向对象编程；可移植性，不牺牲性能和底层功能。可以用cpp compiler将cpp代码翻译成c代码\\n+ cpp适合？\\n  算法、应用开发、C/cpp服务器\\n+ cpp设计原则\\n  =1、cpp设计成使用静态型别机制、与C同样高效，可移植的，多用途程序设计语言。\\n  =2、cpp设计成直接的和广泛的，支持多种程序设计风格（程序化程序设计、数据抽象化、面向对象程序设计、泛型程序设计）。\\n  =3、cpp设计成给程序设计者，更多的选择，即使可能导致程序设计者选择错误。\\n  =4、cpp设计成尽可能与C兼容，提供一个从C到cpp的平滑过渡。\\n  =5、cpp避免平台限定，或没有普遍用途的特性。\\n  =6、cpp不使用会带来额外开销的特性。\\n  =7、cpp设计成无需复杂的程序设计环境。\\n\\n2、流的概念\\ncpp的I/O是以字节流的形式实现的，流(stream)实际上就是一个字节序列。\\n输入流: 在输入操作中，字节从输入设备(如键盘、磁盘、网络连接等)流向内存；输出流: 在输出操作中，字节从内存流向输出设备(如显示器、打印机、磁盘、网络连接等);这里“流”，试图说明字符，随着时间顺序生成或消耗的。输人/输出系统的任务，实际上就是以一种稳定、可靠的方式，在设备与内存之间传输数据。cpp并没有直接定义，进行输入输出的任何语句，这些功能是由标准IO库完成。\\n\\n3、命名空间\\n实际上就是，一个由程序设计者命名的内存区域，程序设计者，可以根据需要指定一些有名字的空间域，把一些全局实体，分别放在各个命名空间中，从而与其它全局实体分隔开来。\\n\\n命名空间是ANSIcpp引入的，可以由用户命名的作用域，用来处理程序中常见的同名冲突。\\n4、cpp程序的执行过程\\n预处理、汇编、编译、连接\\n5、C/cpp的字符串比较\\n\\n① C语言字符串练习 char st[100];\\n① cpp语言字符串练习 string str;\\n\\n② 检测字符串长度 int len = strlen(st);\\n② 检测字符串长度 int len = str.length();\\n\\n③ 字符串比较 strcmp(st1, st2);\\n③ 字符串比较 str1.compare(str2);\\n\\n④ 在已有字符串后，追加新串 strcat(st1, st2); strncat(st1,st2,n);\\n④ 在已有字符串后，追加新串 str1 += str2; str1.append(str2);\\n\\n⑤ 字符串拷贝 strcpy(st1,st2); strncpy(st1,st2, n);\\n⑤ 字符串拷贝 str2 = str1; str2 = str1.substr();\\n\\n⑥ 字符串查找 where = strchr(st, ch)\\n⑥ 字符串查找 where = str1.find(str2);\\n\\n6、c/cpp的数据类型和变量\\n数据类型：\\n![图3](https://s3.bmp.ovh/imgs/2022/07/25/9a78f1d9dd477a24.jpg)\\n程序运行过程中，值能否发生改变，分为**常量和变量**\\n从变量作用域的大小考虑：全局变量，局部变量\\n全局变量：定义在所有的函数体之外，在程序开始运行时，分配存储空间，在程序结束时，释放存储空间\\n函数中定义的变量，称为局部变量（Local Variable）\\n从变量的生命周期考虑: 静态生存周期和动态生存周期\\n动态存储变量：变量仅在需要的时候，分配和占用内存\\n静态存储变量：变量在程序运行过程中，占用固定的内存\\n从变量的在内存中位置考虑：普通变量与指针变量\\n\\nC语言中没有引用，cpp中才有引用，引用的主要用途，就是在函数传参和返回值上。如果既要利用引用提高使用效率，又要保护传递给函数的数据，不在函数中被改变，就应当使用常引用。\\n\\n如果输入参数，以值传递的方式传递对象，宜改用“&”引用方式来传递，这样可以省去临时对象的构造和析构过程，提高效率。特别是函数形参为类对象时，最好使用引用传递，而非值传递。\\n\\n如果函数的返回值是一个对象，有些场合，用“引用传递”替换“值传递”，可以提高效率，有些场合不可以。\\n\\n常引用\\n\\n声明一个引用，不是新定义一个变量，只是该引用名是目标变量的一个别名，本身不是一种数据类型，引用不占存储单元。对引用取地址，就是对目标变量取地址。\\n\\n还需注意，所谓常引用，这个“常”只对引用有效，对原数据是无效的。例如`int a=10;const int &b=a;a=20；//该语句有效，b=20;//该语句无效！`\\n\\n警告：主函数不允许操作栈指针！（如何区分指针和引用？）\\n\\n```cpp\\n#include<iostream>\\nusing namespace std;\\nint &getlnt(const int v) //int&返回引用，int* getlnt(*)是返回指针\\n{\\nint *p = new int(v);\\nreturn *p;\\n}\\nint main()\\n{\\nint &n = getlnt(123456789);\\n//出错！栈指针在函数退出时会立即释放，操作野指针是非法的！\\ncout << n << endl;\\nint *pp = &n;\\ndelete pp; //删除失败\\nreturn 0;\\n}\\n```\\n\\n7、c/cpp函数说明\\n函数实现的三结构：函数申明、函数（体）实现、函数调用\\n函数体的构成：返回值类型、函数名、形参表、函数体\\n函数与指针：指针函数和函数指针\\n指针函数：本身是函数，返回值是指针。形如：`int* func_sum(int n)`，再次提醒：操作栈指针是非法的，对于返回值是指针的函数，这个指针①应当是指向静态变量static，或者该指针②全局变量指针。反正这个指针不能指向栈空间。\\n函数指针：本质是一个指针，他指向了函数。形如`ret (*p)(参数列表)`，其中p称为函数指针。\\n\\n```cpp\\nint max(int a,int b)\\n{\\n\\treturn a>b?a:b;\\n}\\nint min(int a,int b)\\n{\\n\\treturn a<b?a:b;\\n}\\nint main()\\n{\\n    int (*p)(int,int); //或者int (*p)(int a,int b)\\n    p=max; //给函数指针赋值\\n    int ret1=p(10,20);\\n    p=min;\\n    int ret2=p(2,10);\\n    return 0;\\n}\\n```\\n\\n**为什么要使用函数指针**\\n\\n那么，有不少人就觉得，本来很简单的函数调用，搞那么复杂干什么？其实在这样比较简单的代码实现中不容易看出来，当项目比较大，代码变得复杂了以后，函数指针就体现出了其优越性。\\n\\n举个例子，如果我们要实现数组的排序，我们知道，常用的数组排序方法有很多种，比如快排，插入排序，冒泡排序，选择排序等，如果不管内部实现，你会发现，除了函数名不一样之外，返回值，包括函数入参都是相同的，这时候如果要调用不同的排序方法，就可以使用指针函数来实现，我们只需要修改函数指针初始化的地方，而不需要去修改每个调用的地方（特别是当调用特别频繁的时候）。\\n\\n**函数指针的典型应用：回调函数**\\n函数指针的一个典型应用就是**回调函数**。回调函数就是一个通过函数指针来调用其他函数的函数。其将函数指针作为一个参数，传递给另一个函数。\\n\\n```cpp\\n#include<stdio.h>\\n#include<stdlib.h>\\n\\n//函数功能：实现累加求和\\nint func_sum(int n)\\n{\\n        int sum = 0;\\n        if (n < 0)\\n        {\\n                printf(\\\"n must be > 0\\\\n\\\");\\n                exit(-1);\\n        }\\n        for (int i = 0; i < n; i++)\\n        {\\n                sum += i;\\n        }\\n        return sum;\\n}\\n\\n//这个函数是回调函数，其中第二个参数为一个函数指针，通过该函数指针来调用求和函数，并把结果返回给主调函数\\nint callback(int n, int (*p)(int))\\n{\\n\\treturn p(n);\\n}\\n\\nint main(void)\\n{\\n    int n = 0;\\n    printf(\\\"please input number:\\\");\\n    scanf(\\\"%d\\\", &n);\\n    printf(\\\"the sum from 0 to %d is %d\\\\n\\\", n, callback(n, func_sum));       //此处直接调用回调函数，而不是直接调用func_sum函数\\n    return 0;\\n}\\n```\\n\\n上面这个简单的demo就是一个比较典型的回调函数的例子。在这个程序中，回调函数callback无需关心func_sum是怎么实现的，只需要去调用即可。\\n\\n这样的好处就是，如果以后对求和函数有优化，比如新写了个func_sum2函数的实现，我们只需要在调用回调函数的地方将函数指针指向func_sum2即可，而无需去修改callback函数内部。\\n\\n回调函数广泛用于开发场景中，比如信号函数、线程函数等，都使用到了回调函数的知识。\\n\\n内存五区（按地址从低到高排序）：代码区、文字常量区（字符串常量）、全局区（静态区）、堆区、栈区。（来源百度）\\n内存四区：代码区（存放代码）、全局区（存放全局变量、静态变量和常量）、栈区、堆区。（黑马）\\n\\nc/cpp增强了函数类型：\\n基础函数：内联函数（cpp新增，c语言在c99后也引入了）、函数重载、模板函数（泛型编程）\\n成员函数：构造/析构函数、常成员函数、静态成员函数、虚函数\\n\\n内联函数inline：主要解决程序的运行效率问题。针对那种函数体代码量较小，但是又会频繁调用的函数，在编译阶段，编译器会将函数名直接替换成函数体，以节省函数调用出栈入栈的开销。\\n\\n以代码量增加为代价，提高程序运行效率。\\n\\n内联函数的定义，必须出现在该函数第一次被调用前;内联函数不能有复杂的控制语句，如switch，goto和while。递归函数不能是内联函数，（递归函数）自己调用自己的函数如果用于内联的话，反而会影响效率。\\n递归：自己调用自己；迭代：A调用B来获取新值。递归中一定含有迭代，迭代中不一定有递归。数据类型：树的打印函数使用了递归的方法。\\n\\n```cpp\\n//迭代\\nvoid print_shu(int i)\\n{\\n\\t...\\n}\\nint main()\\n{\\n\\tfor(int i=0;i<n;i++)\\n\\t{\\n\\t\\tprint_shu(i);          //迭代\\n\\t}\\n\\treturn 0;\\n\\t\\n}\\n//递归\\n```\\n\\n![图4](https://s3.bmp.ovh/imgs/2022/07/25/054dd7c396abe92b.png)\\n函数重载：形参个数不同、形参顺序不同或形参类型不同。（返回值类型不能作为重载依据）\\n函数形参默认值（缺省值）：如果同时存在函数声明和函数定义，默认值应在声明中给定，而不允许在定义中给定。默认值按从右到左的顺序。\\n形参的默认值，可以是全局常量、全局变量、表达式、函数调用，但不能为局部变量。例如，\\n\\n```cpp\\nvoid funcl(）\\n{\\nint k；\\nvoid g(int x=k)；//k为局部变量\\n}\\n```\\n\\n## 3、第三部分 C++新特性\\n\\n参考链接[南邮武三郎的文章](https://www.zhihu.com/people/wujitao/posts?page=4)\",\"articleCover\":\"\",\"articleTitle\":\"C/C++的比较\",\"articleType\":1,\"categoryName\":\"编程语言基础\",\"isRecommend\":0,\"isTop\":0,\"status\":1,\"tagNameList\":[]}]','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',35,'2023-06-07 16:37:08');
INSERT INTO `t_operation_log` VALUES (1180,'文章模块','添加','/admin/article/add','com.ican.controller.ArticleController.addArticle','添加文章','[{\"articleContent\":\"---\\ntitle: C/C++学习思路\\ndate: 2022-10-30\\ncategory:\\n - 1编程语言基础\\n\\nfooter: <a href=\\\"https://beian.miit.gov.cn/#/Integrated/index\\\">渝ICP备2023001651号</a>\\n\\n---\\n\\n:::tip\\nC/C++学习思路\\n:::\\n\\n<!-- more -->\\n\\n\\n学完编程语言是基础，但仅仅掌握基础还不顾，离上手干活还有很大的鸿沟。鸿沟在于**编程基础四大件和应用实践编程**\\n\\n编程四大件：数据结构和算法、计算机网络、操作系统和设计模式\\n\\n应用编程实践：这部分会涉及到一些工具、编程环境、和具体编程实践，应该说这一部分学完，自己应该能做点东西出来、或者说能看懂一些实际项目的代码。包括但不限于：Linux操作系统的学习和使用（包含常用系统配置和shell脚本的使用）、编译/调试工具的使用、Linux环境编程（Linux系统编程、多线程编程和网络编程）\\n\\n-----------------------------------------\\n\\nC/cpp与Java的比较\\n\\nC/cpp与Java还是有很大的区别的。C是一种面向过程的更偏向于底层的编程语言，cpp是一种面向对象的编程语言。C和cpp，尤其是cpp，语言粒度细、机制多，性能虽然高，但语言本身的包袱也确实重，我们更愿意称它为“造轮子”的语言！也正因为C和cpp性能好，粒度细，所以什么都能做。而Java本身就是一种服务于互联网软件开发（后端开发+客户端开发）的语言，它是一个明显的“生态圈”的概念，所以应用领域非常清晰。更一般地来说，Java是纯应用层的，而C/cpp程序员既需要对底层知识有所了解，也需要知道应用层的知识。\\n\\n------------------------------------------\\n\\n岗位分析\\n\\n一般来说，C/cpp更适合做后台开发。包括：通信公司的后台开发、互联网公司的后台开发、游戏公司的后台开发。。。\\n\\n后台开发的职责细分，有：有做数据处理和分析的、有做基础协议和通信的、有做基础协议和通信的、甚至有做后台系统驱动和内核的。。。\\n\\n-------------------------------------------\\n\\n编程语言本身的学习\\n\\n**C语言**：\\n\\n+ 除了最基本的变量、条件、循环、字符串、数组、函数、结构体外\\n+ C语言最最最重要的就是<font color=\\\"red\\\">指针</font>和<font color=\\\"red\\\">内存管理</font>。以后在工作中多半靠这两个东西吃饭，而且也是检验C语言掌握情况的两大标准\\n\\n> **推荐书籍**：《C Primer Plus》、《C和指针》、《C专家编程》\\n\\n**cpp**：\\n\\n+ cpp和C语言确实是不同的语言，但是cpp确实是对C语言的延伸，可以理解为在C语言里加入了面向对象的特性。因为只有面向对象特性的加持，代码才能更好的**复用**、**扩展**和**工程化**，这是大型项目的必备要素\\n+ 除了C语言所有的底子之外，还需要学习cpp的面向对象（封装、继承与多态）特性、**泛型**、**模板**、**STL**等等\\n\\n> 推荐书籍（有先后顺序）：《cpp Primer》、《Effective cpp》、《cpp 标准程序库》、《STL源码剖析》《深度探索cpp对象模型》\\n\\n**最后一个小建议是**：语言部分的学习建议不要拖太久，一定要规划好时间，一鼓作气，高强度给它压下来，否则容易把自己拖泄气。\\n\\n-----------------------------------------\\n\\n编程基础“四大件”\\n\\n四大件是指：数据结构和算法、计算机网络、操作系统、设计模式\\n\\n1、数据结构和算法\\n\\n可以说这个直接决定了面试的成败！几种基础数据结构类型得烂熟于心，比如：<font color=\\\"red\\\">字符串、链表、二叉树、堆、栈、队列、哈希</font>等；基本的几大算法也要了如指掌，比如<font color=\\\"red\\\">查找、排序、动态规划、分治</font>等等。\\n\\n> 参考资料： 《大话数据结构》、《算法》、《剑指offer》《LeetCode刷题》 ，建议多在LeetCode上刷题\\n\\n2、计算机网络\\n\\n此处的计算机网络指的就是TCP/IP协议栈，可以说它是当下互联网通信的基石，无论如何一定要对TCP/IP的协议栈了如指掌，主要就是学习和掌握原理，包括：**ARP协议、IP协议、ICMP协议、TCP和UDP协议、DNS协议、HTTP协议、HTTPS协议**。\\n\\n> 推荐书籍： 《TCP/IP详解》\\n\\n3、操作系统\\n\\n该部分重点包括：进程和线程的相关原理（原子性、并发、锁）、内存相关原理（内存分布、内存调度）\\n\\n> 推荐书籍：《深入理解计算机系统》\\n\\n4、设计模式\\n\\n倒不需要23种设计模式全部记住，常见的几个如：**单例模式、工厂模式、代理模式、策略模式、模板方法模式**建议熟练于心。\\n\\n> 推荐书籍：《大话设计模式》、《设计模式之禅》\\n\\n------------------------------------------\\n\\n应用编程实践\\n\\n这部分会涉及到一些工具、编程环境、和具体编程实践，应该说这一部分学完，自己应该能做点东西出来、或者说能看懂一些实际项目的代码。\\n\\n1、Linux操作系统的使用\\n\\n包括：常见的Linux系统命令和基本的Shell编程\\n\\n> 推荐书籍：《鸟哥的私房菜》\\n\\n2、编译/调试工具\\n\\n我想大家最熟悉的一定是GCC了，与该命令配套的还有make/makefile脚本也必须掌握。作为make升级版的扩平台编译脚本Cmake和CmakeLists.txt也需要掌握。在gcc编译时，进场要指定头文件和库文件路径，这时常用的pkg-config命令就配上用场了。\\n\\n进阶一点的，除了GCC还有其他的编译工具，比如Clang。还有其他的跨平台的交叉编译工具链等等也需要学习。\\n\\n在程序调试中，GDB也需要掌握。\\n\\n3、Linux环境编程\\n\\n（1）Linux系统编程\\n\\n调用Linux系统的API来进行程序编写和功能实现。\\n\\n（2）多线程编写\\n\\n这一点与编程四大件之一的《操作系统》有很大的联系，进行多进程、多线程的程序编写，还有考虑进程间/线程间的通信：共享内存，还有考虑多进程间/多线程间的变量读写问题：互斥量、信号量、互斥锁、读写锁。一般在这部分，还会涉及到内存的开辟和释放问题。\\n\\n此处指的是多线程编程实践相关的东西，一般包括：线程、资源、信号、同步、互斥、锁等等一些具体的编程方法。\\n\\n（3）网络编程\\n\\n此处的网络编程主要指的是具体Linux系统上的网络编程 API和 IO函数的编程实践。一般是TCP和UDP相关的程序，涉及到点对点通信、广播通信、客户端-服务器-客户端通信等等。\",\"articleCover\":\"\",\"articleTitle\":\"C/C++的比较\",\"articleType\":1,\"categoryName\":\"编程语言基础\",\"isRecommend\":0,\"isTop\":0,\"status\":1,\"tagNameList\":[]}]','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',31,'2023-06-07 16:37:36');
INSERT INTO `t_operation_log` VALUES (1181,'文章模块','修改','/admin/article/update','com.ican.controller.ArticleController.updateArticle','修改文章','[{\"articleContent\":\"---\\ntitle: C/C++学习思路\\ndate: 2022-10-30\\ncategory:\\n - 1编程语言基础\\n\\nfooter: <a href=\\\"https://beian.miit.gov.cn/#/Integrated/index\\\">渝ICP备2023001651号</a>\\n\\n---\\n\\n:::tip\\nC/C++学习思路\\n:::\\n\\n<!-- more -->\\n\\n\\n学完编程语言是基础，但仅仅掌握基础还不顾，离上手干活还有很大的鸿沟。鸿沟在于**编程基础四大件和应用实践编程**\\n\\n编程四大件：数据结构和算法、计算机网络、操作系统和设计模式\\n\\n应用编程实践：这部分会涉及到一些工具、编程环境、和具体编程实践，应该说这一部分学完，自己应该能做点东西出来、或者说能看懂一些实际项目的代码。包括但不限于：Linux操作系统的学习和使用（包含常用系统配置和shell脚本的使用）、编译/调试工具的使用、Linux环境编程（Linux系统编程、多线程编程和网络编程）\\n\\n-----------------------------------------\\n\\nC/cpp与Java的比较\\n\\nC/cpp与Java还是有很大的区别的。C是一种面向过程的更偏向于底层的编程语言，cpp是一种面向对象的编程语言。C和cpp，尤其是cpp，语言粒度细、机制多，性能虽然高，但语言本身的包袱也确实重，我们更愿意称它为“造轮子”的语言！也正因为C和cpp性能好，粒度细，所以什么都能做。而Java本身就是一种服务于互联网软件开发（后端开发+客户端开发）的语言，它是一个明显的“生态圈”的概念，所以应用领域非常清晰。更一般地来说，Java是纯应用层的，而C/cpp程序员既需要对底层知识有所了解，也需要知道应用层的知识。\\n\\n------------------------------------------\\n\\n岗位分析\\n\\n一般来说，C/cpp更适合做后台开发。包括：通信公司的后台开发、互联网公司的后台开发、游戏公司的后台开发。。。\\n\\n后台开发的职责细分，有：有做数据处理和分析的、有做基础协议和通信的、有做基础协议和通信的、甚至有做后台系统驱动和内核的。。。\\n\\n-------------------------------------------\\n\\n编程语言本身的学习\\n\\n**C语言**：\\n\\n+ 除了最基本的变量、条件、循环、字符串、数组、函数、结构体外\\n+ C语言最最最重要的就是<font color=\\\"red\\\">指针</font>和<font color=\\\"red\\\">内存管理</font>。以后在工作中多半靠这两个东西吃饭，而且也是检验C语言掌握情况的两大标准\\n\\n> **推荐书籍**：《C Primer Plus》、《C和指针》、《C专家编程》\\n\\n**cpp**：\\n\\n+ cpp和C语言确实是不同的语言，但是cpp确实是对C语言的延伸，可以理解为在C语言里加入了面向对象的特性。因为只有面向对象特性的加持，代码才能更好的**复用**、**扩展**和**工程化**，这是大型项目的必备要素\\n+ 除了C语言所有的底子之外，还需要学习cpp的面向对象（封装、继承与多态）特性、**泛型**、**模板**、**STL**等等\\n\\n> 推荐书籍（有先后顺序）：《cpp Primer》、《Effective cpp》、《cpp 标准程序库》、《STL源码剖析》《深度探索cpp对象模型》\\n\\n**最后一个小建议是**：语言部分的学习建议不要拖太久，一定要规划好时间，一鼓作气，高强度给它压下来，否则容易把自己拖泄气。\\n\\n-----------------------------------------\\n\\n编程基础“四大件”\\n\\n四大件是指：数据结构和算法、计算机网络、操作系统、设计模式\\n\\n1、数据结构和算法\\n\\n可以说这个直接决定了面试的成败！几种基础数据结构类型得烂熟于心，比如：<font color=\\\"red\\\">字符串、链表、二叉树、堆、栈、队列、哈希</font>等；基本的几大算法也要了如指掌，比如<font color=\\\"red\\\">查找、排序、动态规划、分治</font>等等。\\n\\n> 参考资料： 《大话数据结构》、《算法》、《剑指offer》《LeetCode刷题》 ，建议多在LeetCode上刷题\\n\\n2、计算机网络\\n\\n此处的计算机网络指的就是TCP/IP协议栈，可以说它是当下互联网通信的基石，无论如何一定要对TCP/IP的协议栈了如指掌，主要就是学习和掌握原理，包括：**ARP协议、IP协议、ICMP协议、TCP和UDP协议、DNS协议、HTTP协议、HTTPS协议**。\\n\\n> 推荐书籍： 《TCP/IP详解》\\n\\n3、操作系统\\n\\n该部分重点包括：进程和线程的相关原理（原子性、并发、锁）、内存相关原理（内存分布、内存调度）\\n\\n> 推荐书籍：《深入理解计算机系统》\\n\\n4、设计模式\\n\\n倒不需要23种设计模式全部记住，常见的几个如：**单例模式、工厂模式、代理模式、策略模式、模板方法模式**建议熟练于心。\\n\\n> 推荐书籍：《大话设计模式》、《设计模式之禅》\\n\\n------------------------------------------\\n\\n应用编程实践\\n\\n这部分会涉及到一些工具、编程环境、和具体编程实践，应该说这一部分学完，自己应该能做点东西出来、或者说能看懂一些实际项目的代码。\\n\\n1、Linux操作系统的使用\\n\\n包括：常见的Linux系统命令和基本的Shell编程\\n\\n> 推荐书籍：《鸟哥的私房菜》\\n\\n2、编译/调试工具\\n\\n我想大家最熟悉的一定是GCC了，与该命令配套的还有make/makefile脚本也必须掌握。作为make升级版的扩平台编译脚本Cmake和CmakeLists.txt也需要掌握。在gcc编译时，进场要指定头文件和库文件路径，这时常用的pkg-config命令就配上用场了。\\n\\n进阶一点的，除了GCC还有其他的编译工具，比如Clang。还有其他的跨平台的交叉编译工具链等等也需要学习。\\n\\n在程序调试中，GDB也需要掌握。\\n\\n3、Linux环境编程\\n\\n（1）Linux系统编程\\n\\n调用Linux系统的API来进行程序编写和功能实现。\\n\\n（2）多线程编写\\n\\n这一点与编程四大件之一的《操作系统》有很大的联系，进行多进程、多线程的程序编写，还有考虑进程间/线程间的通信：共享内存，还有考虑多进程间/多线程间的变量读写问题：互斥量、信号量、互斥锁、读写锁。一般在这部分，还会涉及到内存的开辟和释放问题。\\n\\n此处指的是多线程编程实践相关的东西，一般包括：线程、资源、信号、同步、互斥、锁等等一些具体的编程方法。\\n\\n（3）网络编程\\n\\n此处的网络编程主要指的是具体Linux系统上的网络编程 API和 IO函数的编程实践。一般是TCP和UDP相关的程序，涉及到点对点通信、广播通信、客户端-服务器-客户端通信等等。\",\"articleCover\":\"https://upload.haoxx.site/config/27c7f38a329c07159a80315712680ea5.jpg\",\"articleTitle\":\"C/C++学习思路\",\"articleType\":1,\"categoryName\":\"编程语言基础\",\"id\":77,\"isRecommend\":0,\"isTop\":0,\"status\":1,\"tagNameList\":[]}]','PUT','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',24,'2023-06-07 16:38:43');
INSERT INTO `t_operation_log` VALUES (1182,'文章模块','添加','/admin/article/add','com.ican.controller.ArticleController.addArticle','添加文章','[{\"articleContent\":\"---\\ntitle: C/C++字符串处理函数大汇总\\ndate: 2023-04-01\\ncategory:\\n - 1编程语言基础\\n\\nfooter: <a href=\\\"https://beian.miit.gov.cn/#/Integrated/index\\\">渝ICP备2023001651号</a>\\n\\n---\\n\\n:::tip\\nC/C++字符串处理函数大汇总\\n:::\\n\\n<!-- more -->\\n\\n\\n\\n参考资料：[cnblogs](https://www.cnblogs.com/kongweisi/p/14676259.html)\\n1、strlen(str*)  计算字符串长度（不含\'\\\\0\'） sizeof是计算所占内存大小，包含‘\\\\0’ \\n\\n2、strcpy(目标字符串，源字符串）或strncpy(目的字符串，源字符串，长度) 不会复制\\\\0\\n注意：内存复制：，emcpy(目的地址，源地址，sizeof()长度) 恢复至\\\\0，注意目的地址要分配足够的空间，不然会段错误\\n\\n3、字符串追加函数strcat(目标字符串，源字符串) 或strncat(目的字符串。源字符串，长度)\\n\\n4、比较字符串strcmp(s1,s2)  strncmp(s1,s2,strlen()长度)\\n\\n5、字符串格式转换函数sprintf()  sscanf()\\nsprintf使用的较多，使用场景比如，1.获取时间戳，格式化时间格式；2.日志文件系统写入格式化；\\n\\n6、strstr字符串中查找指定字符串     **推荐使用cpp的string的find函数**\\n`char* strstr(源字符串s1，\\\"匹配字符串s2\\\")`。\\n\\n7、strchr字符串中查找指定字符      **推荐使用cpp的string的find函数**\\n`char* strchar(源字符串s1，\'字符c\')`。参数1是字符串，参数2是字符。查找该字符在字符串中最后一次出现的位置。换个思路向：或者，是从右侧开始找，寻找字符在字符串中最后一次出现的位置。这个函数可以用来处理路径字符串，来获取文件名。对于s1=\\\"a/b/c/d.jpg\\\"，字符c=\'/\'，对于函数`char* p=strchr(s1,\'/\')`,函数返回值p=“/d.jpg\\\"。一般使用时是p+1，即”d.jpg\\\"。\\n\\n8、字符串分割函数strtok()      **推荐使用cpp封装的split方法，其中要用到cpp的流和getline函数**\\n参考博客：[参考博客](http://c.biancheng.net/view/1345.html)\\n格式：strtok（目标字符串，“目标字符串中所包含的字符”）\\n\\n9、atoi()转整形/atof()转双精度/atol()转long整型\\n注意：①跳过前面的空格字符，直到遇到数字或正负号才开始做转换，而遇到非数字或字符串结束符(\'\\\\0\')才结束转换\\n\\n10、strpbrk\\n`char* strpbrk(s1,s2)`，s1中寻找第一次出现s2中任意字符是的字符串指针。比如，s1=\\\"Hi,Linux\\\" ,s2=\\\"Linux\\\"，那么函数返回字符串指针所指向的字符串内容为i,Linux\\n\\n11、strcasecmp\\n忽略大小写，比较字符串大小。第一个参数为s1，第二个参数为s2，s1小时返回负数。\\n\\n12、strspn\\n`char* strspn(字符串s1，字符串s2)`，strspn()返回的数值为n，则代表字符串s 开头连续有n 个字符都是属于字符串accept内的字符。\",\"articleCover\":\"\",\"articleTitle\":\"C/C++字符串处理函数大汇总\",\"articleType\":1,\"categoryName\":\"编程语言基础\",\"isRecommend\":0,\"isTop\":0,\"status\":1,\"tagNameList\":[]}]','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',31,'2023-06-07 16:39:04');
INSERT INTO `t_operation_log` VALUES (1183,'文章模块','添加','/admin/article/add','com.ican.controller.ArticleController.addArticle','添加文章','[{\"articleContent\":\"---\\ntitle: Python学习思路\\ndate: 2022-10-30\\ncategory:\\n - 1编程语言基础\\n\\nfooter: <a href=\\\"https://beian.miit.gov.cn/#/Integrated/index\\\">渝ICP备2023001651号</a>\\n\\n---\\n\\n:::tip\\nPython学习思路\\n:::\\n\\n<!-- more -->\\n\\n\\n## 第一部分 入门：字面量/注释/数据类型/标识符和运算符\\n\\n### 1、字面量\\n\\n字面量是指“代码中，被卸下来的固定的值，被称之为字面量”，常见的有数字（整数、浮点数、布尔）、字符串、列表、元组、集合和字典。\\n\\nPython中定义变量不需要写上变量类型名，直接用“变量名=值”的方式定义和初始化变量。布尔变量的取值只能是True和Flase。字符串可由任意数量的字符组成。\\n\\n列表List，是有序的可变序列。它是python中使用最频繁的数据类型，可有序记录一堆数据。\\n\\n元组Tuple，有序的不可变序列。可以有序记录一堆不可变的python数据集合。\\n\\n集合Set，无需不重复集合，可无序记录一堆不重复的python数据集合。\\n\\n字典Dictionary，无序的键值对，可无序记录一堆键值对的python数据集合。\\n\\n### 2、注释\\n\\n注释有单行：#  ;多行： \\\"\\\"\\\"\\n\\n### 3、print格式化打印\\n\\n基础：print(内容1，内容2，内容3，。。。)，示例：`print(\\\"变量a的结果是：\\\",a,\\\"\\\\n\\\")`\\n进阶版：使用%来进行格式化打印。\\n①整数输出\\n\\n```python\\n%o   ----   oct八进制\\n%d   ----   dec十进制\\n%x   ----   hex十六进制\\n示例：\\n>>> print(\'%o\' % 20)    ,输出 24\\n>>> print(\'%d\' % 20)    ,输出 20\\n>>> print(\'%x\' % 20)    ,输出 14\\n```\\n\\n②浮点数输出\\n\\n```python\\n%.nf   ----   保留小数点后n位小数\\n%.ne   ----   保留小数点后n为小数，以指数形式输出打印\\n%.ng   ----   保留n位有效数字\\n示例：（注意：计算有效位时，小数点也算一个）\\n>>> print(\'%f\' % 1.11)    ,输出 1.110000\\n>>> print(\'%.1f\' % 1.11)    ,输出 1.1\\n>>> print(\'%e\' % 1.11)    ,输出 1.110000e+00\\n>>> print(\'%e\' % 1.11)    ,输出 1.110000e+00\\n>>> print(\'%.1e\' % 1.11)    ,输出 1.1e+00\\n>>> print(\'%g\' % 221.1111)    ,输出 221.111  ，默认g是6位有效数字\\n>>> print(\'%.2g\' % 221.1111)    ,输出 2.2e+03 ，自动转换为科学计数法\\n```\\n\\n③整数输出\\n\\n```python\\n%0nd   ----   输出指定位数的十进制，如有效数字位数不够，前方补零\\n>>> print(\'%05n\' % 123)   ,输出00123\\n```\\n\\n④字符串输出\\n\\n```python\\n%ns   ----   右对齐，占位符10位\\n%-ns   ----  左对齐，占位符10位\\n%.ns   ----  左对齐，占位符10位\\n%n.ms   ---- n位占位符，截取m位字符串\\n示例：\\n>>> print(\'%s\' % \'hello world\')      ,输出 hello world\\n>>> print(\'%20s\' % \'hello world\')    ,输出           hello word (右对齐，字符串为10，所以前面要补10个空格)\\n>>> print(\'%-20s\' % \'hello world\')    ,输出 hello world         (左对齐，后面补10个空格)\\n>>> print(\'%.2s\' % \'hello world\')    ,输出 he\\n>>> print(\'%10.2s\' % \'hello world\')    ,输出         he (默认右对齐，总长度为10，取两个字符，所以前面有8个空格)\\n>>> print(\'%-10.2\' % \'hello world\')    ,输出 he        (左对齐，输出一个he加上8个空格)\\n```\\n\\n```python\\n# 用print打印字符串输出\\n方法1：\\nprint(\\\"the a is %d\\\" % a)\\n方法2：\\nprint(f\\\"the a is {a}\\\")\\n方法3：\\nprint(\\\"current path length: {}, It costs {} s\\\".format(pathLen, time.time() - start_time))\\n方法1的例子2：\\nprint(\\\"current path length: %f, It costs %f s\\\" % (pathLen, time.time() - start_time))\\n```\\n\\n### 4、数据类型与数据类型的转换\\n\\n使用print和type来获取变量的<font color=\'red\'>数据</font>类型。 `type(被查看类型的数据)`\\n注意，变量没有类型，有类型的是数据。\\n\\n数据类型转换： int()   str()    float()\\n\\n### 5、标识符\\n\\n了解并掌握常用的关键字（区分大小写）：False True  None ,其余关键字均为小写\\n\\n标识符：变量、函数的命名(只允许字母、数字和下划线，甚至包含中文做变量名)。但是中文做变量名支持不完善，不建议用。\\n\\n标识符命名规则：\\n\\n+ 内容限定\\n+ 大小写敏感\\n+ 不可使用关键字\\n\\n### 6、基本运算符、以及布尔类型与比较运算符\\n\\n常见的有：加减乘除，还有<font color=\'blue\'>取整除符号</font>： `//`，比如：`5//2==2`，还有<font color=\'blue\'>取余符号</font>，比如：`5%2==1`，还有<font color=\'blue\'>指数符号</font>，`5**2==25`。\\n\\n另外，上述符号还可以与等号相结合，构成符合运算符。\\n\\n比较运算符：\\n大于，小于，大于等于，小于等于，等于，不等于\\n\\n### 7、字符串的三种定义方式与字符串的拼接、格式化\\n\\n单引号、双引号、三引号。python中的字符串不区分单字符和字符串，所以单引号和双引号功能是一样的。三引号中的字符串可以跨行。\\n\\n使用+号对多个字符串进行拼接。\\n\\n方式①：使用三类常见的占位符与%相结合来进行字符串的格式化输出：\\n常见的占位符：\\n\\n+ 字符串  %s\\n+ 整数     %d\\n+ 浮点数  %f\\n\\n```python\\nname=\\\"测试姓名\\\"\\nyear_num=1999\\nstock_price=19.9\\nmessage=\\\"我是：%s,我成立于：%d，我今天的估价是：%f\\\" % (name,year_num,stock_price)\\nprint(message)\\n```\\n\\n方式②：格式化的精度控制\\n使用辅助符号m.n来进行精度控制：\\n\\n+ m，控制宽度，要求是数字（<font color=\'red\'>很少使用，设置的宽度小于数字自身，不生效</font>）\\n+ .n，控制小数点精度，要求是数字，<font color=\'red\'>会进行小数位的四舍五入</font>。\\n+ 一半在m前面没有任何东西，默认表示右对齐，当m大于数字的最大有效位时，在前面补空格。如果m前面有个`-`号，表示左对齐，当m大于数字的有效位数时，不需要在前面不空格，在数字的后面补空格。\\n  方式③：掌握快速进行字符串格式化的方式：\\n  通过语法：`f\\\"内容{变量}\\\"`的格式来进行快速格式化。例如：\\n\\n```python\\nname=\\\"测试姓名\\\"，stock=19.9,year=1999\\nprint(f\\\"我是：{name},我成立于：{year}，我今天的估价是：{stock}\\\")\\n```\\n\\n这样做的特点是：\\n\\n+ 这种写法不做精度控制\\n+ 也不理会类型\\n+ 适用于快速格式化字符串\\n\\n方式④：技巧：对表达式的格式化\\n上述三种方法，都是对变量进行格式化处理，那如果不需要使用变量存储，可不可以直接对表达式进行格式化处理呢？\\n\\n表达式：是一个具有明确执行结果的代码语句，比如：1+1, 2\\\\*4，他们就是表达式，因为他们有明确的结果，就是一个数值。又比如，常见的变量定义：`name=\\\"张三\\\"`也是一种表达式，因为他也有结果，就是把一个字符串常量付给了一个变量存储。\\n\\n下面。使用上述三种对变量的格式化方法，来处理表达式：\\n\\n```python\\nprint(\\\"1 * 1 的结果是： %d\\\" % (1*1))\\nprint(f\\\"1 * 1 的结果是：{1 * 1}\\\")\\nprint(\\\"字符串在python中的类型是…%s\\\" % type(\'字符串\'))\\n```\\n\\n### 8、数据的输入：input\\n\\n1、基础版：\\n\\n```python\\nname=input()\\nprint(\\\"your name is %s\\\" % name)\\n```\\n\\n2、进阶版\\n\\n```python\\nname=input(\\\"请输入你的名字：\\\")\\nprint(\\\"your name is %s\\\" % name)\\n```\\n\\n需要注意，input()接收并存入变量里的数据，均是字符串类型。就算你输入的是整数，也是转换成了字符串类型在存储的。用int()来得到整型值。10.16.63.184\\n\\n## 第二部分 代码结构：逻辑结构与函数\\n\\n### 9、if-else的条件语句、while/for循环语句、switch/case条件分支以及continue/break\\n\\n①if-elif-else代码块示例：\\n代码示例：\\n\\n```python\\nif 条件1：\\n\\t满足条件1后该做的动作\\nelif 条件2:\\n\\t满足条件2后该做的动作\\nelse:\\n\\t所有条件都不满足后的动作\\n```\\n\\nif-else的多层嵌套：秘诀：空格缩进，python根据缩进来判断代码块的归属和层次关系。\\n\\n②while代码块示例：\\n\\n```python\\nwhile 条件：\\n\\t满足条件后的动作\\n```\\n\\n③for循环代码块示例：\\n\\n```python\\nfor 临时变量 in 待处理的数据集\\n\\t临时变量满足条件时，执行的语句\\n#例如：\\nname=\\\"test\\\"\\nfor x in name\\n\\tprint(x)  # 输出t e s t\\n```\\n\\n上述待处理的数据集，严格来讲，称之为：<font color=\'red\'>可迭代类型</font>。可迭代类型是指，其内容可以一个个一次取出的一种类型，包括：\\n\\n+ 字符串\\n+ 列表     如：name_list=[\'Lisa\',\\\"Micheal\\\",\'LiHua\']\\n+ 元组\\n+ etc等等\\n\\n通过学习range语句，获得一个简单的数学序列（可迭代类型的一种）：\\n语法1：`range(num)`，获取一个从0开始，到num结束的数字序列（不含num本身）。如range(5)就是获得一个从0 ~ ~ 4的序列：[0,1,2,3,4]。\\n语法2：`range(num1,num2)`,获取一个从num1开始到num2结束的数字序列（包含num1但是不包含num2）。如range(1,5)就是输出序列[1,2,3,4]。\\n语法3：`range(num1,num2,step)`,获取一个从num1开始到num2结束，包含num1但是不包含num2的数字序列，并且步长为step。如range(1,8,2)就是输出序列：[1,3,5,7]。\\n\\n### 10、函数\\n\\n#### 10.1 函数基础\\n\\n注意：函数体内为局部变量，函数体外为全局变量。但是，可以在函数体内，使用关键字`global`来将函数内部的变量声明为全局变量，如：\\n\\n```python\\ndef testA()：\\n\\tglobal num\\n\\tnum = 20\\n\\tprint(\\\"testA中的num为：\\\",num)\\n\\ndef testB()：\\n\\tprint(\\\"testB中的num为：\\\"，num)\\n\\t\\ntestA()\\ntestB()\\nprint(f\\\"全局变量num为{num}\\\")\\n```\\n\\n#### 10.2 函数进阶\\n\\n##### 1、函数的多个返回值\\n\\n```python\\ndef  xxx()：\\n\\treturn 1,2    //return语句后接多个变量，每个变量用逗号隔开\\n//并且。return支持多种不同数据类型的数据return\\n```\\n\\n##### 2、函数传参\\n\\n2.1 位置参数\\n<font color=\'red\'>位置参数</font>：调用函数时根据函数定义的参数位置来传递参数\\n<font color=\'blue\'>注意</font>：传递的参数和定义的参数的顺序及个数必须一致\\n\\n```python\\ndef user_info(name,hei,gner)：\\n\\tprint(f\\\"{name}的{hei}是{gner}\\\\n\\\")\\n\\t\\n#函数调用\\nuser(\\\"李华\\\",\\\"身高\\\",175)\\n```\\n\\n2.2 关键字参数\\n<font color=\'red\'>关键字参数</font>：函数调用时通过“键=值”形式传递参数.\\n<font color=\'red\'>作用</font>: 可以让函数更加清晰、容易使用，同时也清除了参数的顺序需求.\\n<font color=\'blue\'>注意</font>：函数调用时，如果有位置参数时，位置参数必须在关键字参数的前面，但关键字参数之间不存在先后顺序\\n\\n```python\\ndef user_info(name,hei,gner)：\\n\\tprint(f\\\"{name}的{hei}是{gner}\\\\n\\\")\\n\\t\\n#函数调用\\nuser(hei=\\\"身高\\\",name=\\\"李华\\\",gner=175)\\n//或者：位置参数和关键字参数混用：注意位置参数必须放在最前面\\nuser(175,hei=\\\"身高\\\",name=\\\"李华\\\")\\n```\\n\\n2.3 缺省参数\\n<font color=\'red\'>缺省参数</font>：缺省参数也叫默认参数，用于定义函数，为参数提供默认值，调用函数时可不传该默认参数的值（注意：所有位置参数必须出现在默认参数前，包括函数定义和调用）.\\n<font color=\'red\'>作用</font>: 当调用函数时没有传递参数, 就会使用默认是用缺省参数对应的值\\n<font color=\'blue\'>注意</font>：函数调用时，如果为缺省参数传值则修改默认参数值, 否则使用这个默认值\\n\\n```python\\ndef user_info(name,hei,gner=175)：\\n\\tprint(f\\\"{name}的{hei}是{gner}\\\\n\\\")\\n\\t\\n#函数调用\\nuser(hei=\\\"身高\\\",name=\\\"李华\\\")\\n//或者：位置参数和关键字参数混用：注意位置参数必须放在最前面\\nuser(180,hei=\\\"身高\\\",name=\\\"李华\\\")\\n```\\n\\n2.4 不定长参数\\n<font color=\'red\'>不定长参数</font>：不定长参数也叫可变参数. 用于不确定调用的时候会传递多少个参数(不传参也可以)的场景.\\n<font color=\'red\'>作用</font>: 当调用函数时不确定参数个数时, 可以使用不定长参数\\n不定长参数的类型：\\n\\n+ 1、位置传递\\n+ 2、关键字传递\\n\\n1、位置传递：\\n\\n传进的<font color=\'red\'>所有参数</font>都会被<font color=\'red\'>args变量收集</font>，它会根据传进参数的位置合并为一个元组(tuple)，<font color=\'red\'>args是元组类型</font>，这就是<font color=\'red\'>位置传递</font>\\n\\n```python\\ndef user_info(*args)：\\n\\tprint(args)\\n\\t\\n#函数调用\\nuser_info(\'TOM\')\\nuser_info(\'TOM\',18)\\n```\\n\\n2、关键字传递\\n\\n参数是<font color=\'red\'>“键=值”</font>形式的形式的情况下, 所有的“键=值”都会被<font color=\'red\'>kwargs接受</font>, 同时会根据“键=值”组成<font color=\'red\'>字典</font>。\\n\\n```python\\ndef user_info(**kwargs)：\\n\\tprint(kwargs)\\n\\t\\n#函数调用\\nuser_info(name=\'TOM\',age=18)\\n```\\n\\n\\n位置不定长传递以\\\\*号标记一个形式参数，以元组的形式接受参数，形式参数一般命名为args\\n\\n关键字不定长传递以\\\\*\\\\*号标记一个形式参数，以字典的形式接受参数，形式参数一般命名为kwargs\\n\\n##### 3、匿名函数\\n\\n1、函数作为参数传递\\n\\n函数本身是可以作为参数，传入另一个函数中进行使用的。\\n\\n将函数传入的作用在于：传入计算逻辑，而非传入数据。示例如下：\\n\\n```python\\ndef test_func(a,b,func)：\\n\\tresult=func(a,b)\\n\\tprint(result)\\n\\ndef func1(x,y)：\\n\\treturn x+y\\ndef func2(x,y)：\\n\\treturn x*y\\n\\t\\n# 函数调用测试\\ntest_func(1,2,func1) # 打印结果为3\\ntest_func(1,2,func2) # 打印结果为2\\n```\\n\\n2、lambda匿名函数\\n\\ndef定义的函数都是有名称的，并且可以基于名称多次使用该函数。而lambda函数可以定义没有函数名的<font color=\'red\'>匿名</font>函数，且匿名函数仅能使用一次。\\n\\n注意：\\n\\n+ 匿名函数用于临时构建一个函数，只用一次的场景\\n+ 匿名函数的定义中，函数体只能写一行代码，如果函数体要写多行代码，不可使用匿名函数。\\n\\n匿名函数定义的语法：\\n`lambda 传入参数：函数体`  # 注意：函数体仅允许只有一行代码\\n\\n+ lambda 是关键字，表示定义匿名函数\\n+ 传入参数表示匿名函数的形式参数，如：x, y 表示接收2个形式参数\\n+ 函数体，就是函数的执行逻辑，要注意：只能写一行，无法写多行代码\\n  示例：\\n\\n```python\\ndef test_func(a,b,func)：\\n\\tresult=func(a,b)\\n\\tprint(result)\\n\\n# 函数调用\\ntest_func(1,2,lambda x,y: x+y)  # 打印输出3\\n```\\n\\n\\n\\n\\n\\n## 第三部分 数据容器\\n\\n### 11.1、五类数据容器入门\\n\\n数据容器根据特点的不同，如：\\n\\n+ 是否支持重复元素\\n+ 是否可以修改\\n+ 是否有序\\n\\n列表(List)、元组(tuple)、字符串(str)、集合(set)、字典(dict)\\n\\n>列表List，是有序的可变序列。它是python中使用最频繁的数据类型，可有序记录一堆数据。\\n>\\n>元组Tuple，有序的不可变序列。可以有序记录一堆不可变的python数据集合。\\n>\\n>字符串String\\n>\\n>集合Set，无需不重复集合，可无序记录一堆不重复的python数据集合。\\n>\\n>字典Dictionary，无序的键值对，可无序记录一堆键值对的python数据集合。\\n\\n序列：序列是指内容连续、有序，可使用下标索引的一类数据容器。<font color=\'red\'>列表、元组和字符串</font>，均可以视为序列。序列不是一种新的数据容器，而是多种数据容器的一种共通属性。\\n\\n**序列的切片**：\\n\\n格式为：<font color=\'red\'>[起始下标:结束下标:步长]</font>\\n\\n注意：\\n\\n+ 1、步长为负数，表示反向取（注意，起始下标和结束下标也要反向标记）\\n+ 2、注意，此操作<font color=\'blue\'>不会影响序列本身，而是会得到一个新的序列（列表、元组、字符串）</font>\\n\\n正向切片：\\n![](https://s3.bmp.ovh/imgs/2022/10/14/e76148b450adaad2.png)\\n\\n反向切片：\\n![](https://s3.bmp.ovh/imgs/2022/10/14/eed814e7ce28fd0e.png)\\n举例如下：\\n\\n```python\\n说明：列表方括号，元组圆括号，字符串使用双引号，集合大括号，字典也是大括号\\n---------------------\\n一、列表\\n列表：name_list=[\'王力宏\',\'周杰伦\',\'林俊杰\',\'白洁\']\\n列表2：name_list=[\'王力宏\',\'周杰伦\',24，True,12.31]\\n---------------------\\n二、元组\\n元组：t1=(1,\'王力宏\',True,11.44)    # 元组内的元素在定义后就不可以更改了\\n元组2：t2=(\'hello\',)        # 元组内只有一个元素的话，这个数据后要添加逗号\\n---------------------\\n三、字符串\\n字符串：str1=\\\"iccaa\\\"\\n---------------------\\n四、集合\\nnames={\'王力宏\',\'周杰伦\',\'林俊杰\',12,\'王力宏\'}  # 集合去重且无序，因为无序，所以不支持下标访问\\nprint(names)     # 输出为 \'王力宏\',\'周杰伦\',\'林俊杰\',12\\n---------------------\\n五、字典\\n字典：my_dict={\'网络\':99,\'所示\':23,\'啊啊\':82} # 1、字典的key和value可以是任意类型的数据，但key不可为字典。2、key不可重复，重复会对原有数据覆盖。和集合一样，无序，不可使用下标访问。3、value可以为字典，从而构成嵌套字典\\n字典2：stu_score={\\n\\t\\\"王力宏\\\"：{\\\"语文\\\":42,\\\"数学\\\":42,\\\"英语\\\":32}\\n\\t\\\"周杰伦\\\": {\\\"语文\\\":31,\\\"数学\\\":92,\\\"英语\\\":25}\\n\\t\\\"李 白\\\": {\\\"语文\\\":13,\\\"数学\\\":62,\\\"英语\\\":52}\\n}\\n嵌套字典的使用：\\nprint(stu_score[\\\"王力宏\\\"])   # 输出为 {\\\"语文\\\":42,\\\"数学\\\":42,\\\"英语\\\":32}\\nprint(stu_score[\\\"王力宏\\\"][\\\"语文\\\"]) # 输出为 42\\n```\\n\\n<font color=\'red\'>列表</font>的特点：\\n\\n+ 可以容纳多个数据，上限为2^63^-1=9,223,372,036,854,775,807个\\n+ 可以容纳不同类型的数据（混装）\\n+ 数据是有序存储的（有下标序号）\\n+ 允许重复数据存在\\n+ 可以修改（增加或删除元素等）\\n\\n<font color=\'red\'>元组</font>的特点：      多数特性与列表一致，最大的不同在于不可修改性\\n\\n+ 可以容纳多个数据\\n+ 可以容纳不同类型的数据（混装）\\n+ 数据是有序存储的（下标索引）\\n+ 允许重复数据存在\\n+ <font color=\'blue\'>不可以修改</font>（增加或删除元素等）\\n+ 支持for循环\\n\\n<font color=\'red\'>字符串</font>的特点：\\n\\n+ <font color=\'blue\'>只可以存储字符串</font>\\n+ 长度任意（取决于内存大小）\\n+ 支持下标索引\\n+ 允许重复字符串存在\\n+ <font color=\'blue\'>不可以修改</font>（增加或删除元素等）\\n+ 支持for循环\\n\\n字符串的特点基本有列表、元组相同。与列表、元组不同的在于：字符串容器要求可以容纳的类型式单一的，只能是字符串类型。与列表不同与元组相同的在于：字符串不可更改。\\n\\n<font color=\'red\'>集合</font>的特点：\\n\\n+ 可以容纳多个数据\\n+ 可以容纳不同类型的数据（混装）\\n+ <font color=\'blue\'>数据是无序存储的</font>（不支持下标索引）\\n+ <font color=\'blue\'>不允许重复数据存在</font>\\n+ 可以修改（增加或删除元素等）\\n+ 支持for循环\\n\\n<font color=\'red\'>字典</font>的特点：\\n\\n+ 可以容纳多个数据\\n+ 可以容纳不同类型的数据（混装）\\n+ <font color=\'blue\'>每一份数据是KeyValue键值对</font>（不支持下标索引）\\n+ <font color=\'blue\'>可以通过Key获取到Value，Key不可重复(重复会覆盖)</font>\\n+ 不支持下标索引\\n+ 可以修改（增加或删除元素等）\\n+ 支持for循环，不支持wehile循环\\n\\n### 11.2 列表\\n\\n#### 11.2.1 列表的定义方式\\n\\n```python\\n变量名称 = [元素1,元素2,元素3,...]\\n定义空列表：变量名=list() 或 变量名=[]\\n支持嵌套：my_list=[[1,2,3],[4,5,6]]\\n```\\n\\n#### 11.2.2 列表的下标索引\\n\\n正向索引：下标从0开始，0,1,2,3...\\n反向索引：下标从-1开始，-1，-2，-3...\\n嵌套列表也是支持下标索引的。\\n\\n#### 11.2.3 列表的常用操作（方法）\\n\\n如果将函数定义为类中成员，那么他就称为方法。函数与方法定义是一致的，只是使用格式不同。\\n\\n下面将介绍列表的常用操作：增删改查和统计/清空操作。其实这些都是数据容器的基本操作，不过对于元组和字符串来将，增删改+清空操作是不存在的。\\n\\n```python\\nmy_list= [\'ass\',\'ss\',\'wwas\']\\n-----------------------------\\n1、查询1、根据下标，查询元素值：\\nprint(my_list[2])\\n查询2、根据元素值查询对应的坐标：\\nprint(my_list.index(\\\"ss\\\"))\\n----------------------------\\n2、插入\\n2.1 在指定位置插入：insert\\nmy_list.insert(1,\\\"haha\\\")\\nprint(my_list)  # 输出为： \'ass\',\\\"haha\\\"，\'ss\',\'wwas\'\\n2.2 在结尾追加append\\nmy_list.append(\\\"yuhao\\\")\\nprint(my_list)  # 输出为： \'ass\'，\'ss\',\'wwas\',\\\"yuhao\\\"\\n2.3 先从其他容器中取出数据，在依次追加到列表尾部\\nmy_list.extend([4,1,6])\\nprint(my_list)  # 输出为： \'ass\'，\'ss\',\'wwas\',4,1,6\\n------------------------------\\n3、删除\\n3.1 用del关键字删除\\ndel my_list[0] # 删除单个  或者  del my_list # 删除全部\\ndel my_list[1:3]  # 删除链表的下标为1到下标为2的元素，用冒号来指定子区间，包含前者而不包含后者\\n3.2 使用列表方法pop删除\\nmy_list.pop([index=-1])  # 默认是出栈最后一个元素\\nmy_list.pop()  # 出栈最后一个元素\\nmy_list.pop(2)  # 出栈下标为2的元素，注意下标号从0开始\\n3.3 使用列表方法clear来清空列表\\nmy_list.clear()  \\n3.4 根据元素值而非下标位置来删除元素\\n#使用remove删除与元素值相匹配的第一个元素\\nmy_list.remove(\'ass\')\\n## 注意，del和pop都可以按照坐标来删除元素，但是del是关键字，pop是方法。del可以删除区间，del可以删除全部，而pop不能。还有del删除后不会将删除元素返回，但是pop会将删除的元素返回。\\n-------------------------------\\n4、更改\\n# 直接用下标来对元素值进行更改\\nmy_list[1]=\'hehhe\'\\n--------------------------------\\n5、查找\\n通过下标号获取元素值；或者通过元素值反向查找下标号.index(\'ass\')\\n查找列表最小值的方法1：.sort()，然后list[0];方法2;min(list)\\n---------------------------------\\n6、统计\\n6.1 通过某元素在列表中的个数\\nmy_list.count(\\\"ass\\\")\\n6.2 统计列表的长度\\nlen(my_list)\\n```\\n\\n![](https://s3.bmp.ovh/imgs/2022/10/14/1134525ff952347e.png)\\n\\n#### 11.2.4 列表的遍历\\n\\n1、使用while遍历\\n\\n```python\\nindex = 0\\nwhile index < len(列表)：\\n\\t元素=列表[index]\\n\\tindex++\\n```\\n\\n2、使用for循环遍历\\n\\n```python\\nfor i in my_list\\n\\tprint(i)\\n```\\n\\n3、while和for循环的区别与联系\\n\\n+ 在循环控制上：\\n+ + while循环<font color=\'blue\'>可以自定循环条件</font>，并自行控制\\n+ + for循环<font color=\'blue\'>不可以自定循环条件</font>，只可以一个个从容器内取出数据\\n+ 在无限循环上：\\n+ + while循环<font color=\'blue\'>可以</font>通过条件控制做到无限循环\\n+ + for循环理论上<font color=\'blue\'>不可以</font>，因为被遍历的容器容量不是无限的\\n+ 在使用场景上：\\n+ + while循环适用于任何想要循环的场景\\n+ + for循环适用于，遍历数据容器的场景或简单的<font color=\'blue\'>固定次数</font>的循环场景\\n\\n### 11.3 元组tuple\\n\\n#### 11.3.1 元组的定义方式\\n\\nmy_tuple=(\'as\',\'sas\',\'asa\')\\n定义空元组：my_tupe=tuple() 或my_tuple=()\\n定义嵌套元组：my_tuple=((1,2,1),(2,1,6),(2,1))\\n定义单个元素的元组：mt_tuple=(1,)  或(\'hello\',)\\n\\n#### 11.3.2 元组的常用操作（方法）\\n\\n```python\\nmy_tuple=(\'wqw\',\'dsd\',\'sd\')\\n1、查找\\n1.1 根据下标查找\\ntest=my_tuple[2]\\n1.2 根据元素值查找下标值\\nnum=my_tuple.index(\'wqw\')\\n2、统计\\n2.1 统计某元素在元组中出现的次数\\nprint(my_tuple.count(\'wqw\'))\\n2.2 统计元组长度\\nprint(len(my_tuple))\\n```\\n\\n#### 11.3.1 元组的遍历\\n\\n1、while遍历\\n\\n```python\\nindex=0\\nwhile index < len(my_tuple):\\n\\tprint(my_tuple[index])\\n\\tindex++\\n```\\n\\n2、for循环遍历\\n\\n```python\\nfor i in my_puple\\n\\tprint(i)\\n```\\n\\n### 11.4 字符串\\n\\n#### 11.4.1 字符串的索引\\n\\n下标索引，正向从0开始，反向从-1开始\\n\\n#### 11.4.2 字符串的操作（方法）\\n\\n字符串与元组类似，内部元素不允许改动。所以，可使用的操作很少。\\n\\n```python\\n1、查找\\n通过下标或者index方法\\n---------------------------------\\n2、替换replace  # 注意，不是替换字符串本身，而是新生成了一个字符串\\nname=\\\"iteima itcast\\\"\\nnew_name = name.replace(\\\"it\\\",\\\"黑马\\\")\\nprint(new_name)       # 输出为 黑马eima 黑马cast\\n---------------------------------\\n3、字符串分割 （是重新得到一个对象）\\n将源字符串按照指定的分割方式，分割成几个子字符串，并存入列表\\nname=\\\"传智播客  传智教育  差遵化  送达\\\"\\nnew_name = name.split(\\\" \\\")\\nprint(type(new_name))   # 输出为 <class \'list\'>\\nprint(new_name) # 输出为 [\'传智播客\',\'传智教育\',\'差遵化\',\'送达\']\\n---------------------------------\\n4、字符串规整\\n4.1 去掉前后空格\\nmy_str=\\\"  itrima and itcast  \\\"\\nprint(my_str.strip()) #输出为 \\\"itrima and itcast\\\"\\n4.2 去前后指定字符串\\nmy_str=\\\"12itrima and itcast21\\\"\\nprint(my_str.strip(\\\"12\\\")) #输出为 \\\"itrima and itcast\\\"\\n#注意，传入的是\\\"12\\\"，其实是按照单个字符来的，\\\"1\\\"和\\\"2\\\"都会被移除\\n---------------------------------\\n5、统计\\n统计某字符串的出现次数：print(my_str.count(\\\"it\\\"))\\n统计字符串长度：print(len(my_str))\\n---------------------------------\\n6、检查字符串的子串\\n# find()函数的作用是检查一个字符串是否是另一个字符串的子串，并返回子串所在的起始位置索引\\n语法：string_object.find(sub, start, end)\\n参数含义：\\nsub：必选参数。指定要检索的字符串，可以直接使用字符串具体的值或字符串变量；\\nstart：可选参数。检查搜索开始的索引，默认为0；\\nend：可选参数。检查搜索停止的索引，默认为字符串string_object的长度。\\n注意，find()函数在执行检查搜索时，start处的字符将会被检查，而end是停止检索的索引，所以end索引处的字符不会参与检查搜索。\\n方法返回值：\\n如果字符串string_object中包含sub，则返回sub在string_object中起始的位置索引，否则返回-1。\\n示例：\\nstr1 = \\\"该网站的名称是：翔宇亭IT乐园\\\"\\nstr2 = \\\"翔宇亭\\\"\\nprint(str1.find(str2)) #结果为：8\\n# 在字符串中，一个中文算一个字符。\\n```\\n\\n![](https://s3.bmp.ovh/imgs/2022/10/14/d034ba3b4152f0e2.png)\\n\\n#### 11.4.3 字符串的遍历\\n\\n1、while遍历\\n\\n```python\\nindex=0\\nwhile index < len(my_str):\\n\\tprint(my_str[index])\\n\\tindex++\\n```\\n\\n2、for循环遍历\\n\\n```python\\nfor i in my_str\\n\\tprint(i)\\n```\\n\\n\\n\\n\\n接下来将学习“集合”和“字典”，这两种方式都是无序的，所以不可以使用下标访问。集合会组合相同项，字典可以使用键名来获取键值。\\n\\n### 11.5 集合\\n\\n#### 11.5.1 集合简介及集合的常见操作（方法）\\n\\n集合，最重要的一个特点就是可以去重。使用一个大括号来定义一个集合。\\nmt_set={\\\"11a\\\",\\\"as\\\",\\\"das\\\"}\\n定义空集合： my_set=set()\\n提醒：my_dict={}是定义了一个空字典，而不是空集合\\n\\n集合的常见操作（方法）\\n\\n```python\\n--------------------\\n   操作集合时，一定要在心中谨记，集合内部是无序的，你看到在代码中集合的第一个元素是\\\"hello\\\"，但其实在内存中第一个元素有可能不是\\\"hello\\\"。因为集合需要对元素进行判断和删除重复元素的操作，就有可能会打乱内部元素的排序。\\n--------------------\\n1、添加新元素add   (其他几种数据容器的添加方法是insert或append)\\nmy_set={\\\"hello\\\",\\\"world\\\"}\\nmy_set.add(\\\"inte\\\")\\nprint(my_set)   # 输出为 {\\\"hello\\\",\\\"world\\\",\\\"inte\\\"}\\n2、移除元素remove\\nmy_set={\\\"hello\\\",\\\"sdsdsd\\\",\\\"sdaa\\\",\\\"world\\\"}\\nmy_set.remove(\\\"asaa\\\")\\nprint(my_set)   # 输出为 {\\\"hello\\\",\\\"sdsdsd\\\",\\\"world\\\"}\\n3、从集合中随即取出一个元素\\nelement=my_set.pop()\\n4、清空集合\\nmy_set.clear()\\n---------------------\\n5、集合之间的操作\\n5.1 取出了两个子集的差集\\n6.功能：判断两个集合的差集，取出1中有的而2中没有的，并存入新的集合\\nset1={1,2,3}\\nset2={2,3,4}\\nset_dif=set1.different(set2)\\nprint(set_dif)  # 输出结果为 {1}，且集合1和集合2不变\\n5.2 消除两个子集的差集\\n功能：对比集合1和集合2，在集合1中，删除和集合2中相同的元素\\n结果：集合1被改变，集合2不变化\\nset1={1,2,3}\\nset2={2,3,4}\\nset1.different_update(set2)\\nprint(set1)  # 输出{1}\\n5.3 两集合合并\\n功能：将集合1和集合2合并为一个集合\\n结果：出现一个新集合，且集合1和集合2都不改变\\nset3=set1.union(set2)\\nprint(set3)  # 输出为 {1,2,3,4}\\n\\n---------------------\\n6、统计集合中元素的数量\\nprint(len(my_set))\\n集合没有count方法，因为所有元素均唯一。\\n```\\n\\n![](https://s3.bmp.ovh/imgs/2022/10/14/daa03b0bad2855b3.png)\\n\\n#### 11.5.2 集合的遍历\\n\\n因为集合内部无序，所以不能使用下标访问。因此，不能使用while循环，但是for循环不受影响。\\n\\n```python\\nset={1,2,3}\\nfor i in set\\n\\tprint(i)\\n```\\n\\n字典也是同样的道理\\n\\n\\n### 11.6 字典\\n\\n#### 11.6.1 字典的常见操作（方法）\\n\\n```python\\n1、新增元素\\nstu_score={\\n\\t\\\"网\\\"=11\\n\\t\\\"里\\\"=22\\n\\t\\\"bai1\\\"=33\\n}\\nstu_score[\\\"张\\\"]=89\\n2、更新元素值\\n注意，字典的键名不可以重复，对已存在的键名进行操作就是在更新键值。\\nstu_score[\\\"张\\\"]=21\\n3、删除元素\\n语法：字典.pop(键名)  # 获取指定键名的键值，并从字典中删除该元素\\n4、清空元素\\n语法：字典.clear()\\n5、获取全部的key键名\\nget_all_keys=stu_score.keys()\\nprint(get_all_keys)  # 输出为 dict_keys([\'网\',\'里\',\'bail\'])，类型为<class \'dict_keys\'>\\n5.2 获取全部的键值\\nprint(stu_score.values())\\n6、遍历字典（只能使用for）\\nfor i in my_dict:\\n\\tprint(f\\\"字典中，键名为{i}的键值为{my_dict[i]}\\\")\\n或：\\nfor i in my_dict.keys():\\n    print(f\\\"字典中，键名为{i}的键值为{my_dict[i]}\\\")\\n7、获取字典中所有键值对的数量\\nprint(len(my_dict))\\n8、根据指定的键名获取键值\\nprint(my_dict.get(\'网\'))  或  print(my_dict.get(\'网\',\'里\')) \\n9、通过gets方法，根据键名获取键值\\n# 语法： get(key, \\\"输出的信息\\\")\\n# get方法根据第一个参数在键名中查找，找到了对应的键，打印其键值；没找到对应的键，就输出第二个参数对应的内容。如果第二个参数为空，就输出None。\\n10、items方法，查找字典中所有的键值对，并返回一个可迭代对象，且对象是元组类型的。\\ndict1 = {\'name\': \'Rose\', \'age\': 30, \'sex\': \'女\'}\\nprint(dict1.items())\\n#输出结果为：dict_items([(\'name\', \'Rose\'), (\'age\', 30), (\'sex\', \'女\')])\\n# 输出结果的类型是：<class \'dict_items\'>\\n```\\n\\n![](https://s3.bmp.ovh/imgs/2022/10/14/434f88294d37e333.png)\\n\\n### 11.7 几种数据容器的总结\\n\\n1、数据容器的分类\\n\\n+ 是否支持下标索引\\n+ + 支持：列表、元组、字符串 - 序列类型\\n+ + 不支持：集合、字典 - 非序列类型\\n+ 是否支持重复元素\\n+ + 支持：列表、元组、字符串 - 序列类型\\n+ + 不支持：集合、字典 - 非序列类型\\n+ 是否可以修改\\n+ + 支持：列表、集合、字典\\n+ + 不支持：元组、字符串\\n\\n![](https://s3.bmp.ovh/imgs/2022/10/14/75c25d928730e470.png)\\n\\n![](https://s3.bmp.ovh/imgs/2022/10/14/1bb99fb466c009c1.png)\\n\\n### 11.8 数据容器的通用操作\\n\\n1、都支持for循环遍历。但是，只有能读取下标的数据容器才支持while循环。即只有列表、元组和字符串才支持while循环，集合和字典仅支持for循环。\\n\\n2、通用的\\\"统计\\\"方法：\\n列表、元组和字符串都支持以下三种方法：求长度、求最大元素和求最小元素：\\n![](https://s3.bmp.ovh/imgs/2022/10/15/3b575f44ccd40b62.png)\\n\\n3、通用的转换功能（除了不能转成字典）\\n![](https://s3.bmp.ovh/imgs/2022/10/15/bc6b7d83e5de3542.png)\\n\\n4、通用的排序功能\\n\\nsorted的参数reverse=True代表降序排序\\n![](https://s3.bmp.ovh/imgs/2022/10/15/2055118e74bd42c4.png)\\n\\n\\n\\n## 第四部分 文件IO\\n\\n### 12、文件IO\\n\\n文件编/解码：就是将内容翻译成二进制的一种方式，常用的有UTF-8、GBK、big5等。\\n\\n文件的操作，常见的主要有文件的的打开、关闭、读、写等操作。文件打开用open函数，写用write函数，读用read、readline()或readlines函数，文件关闭用close函数。一般文件写write还伴随有flush缓存刷新。\\n\\n1、文件打开的操作：\\n语法格式为：`open(name,mode,encoding)`\\nname：是要打开的目标文件名的字符串(可以包含文件所在的具体路径)。\\nmode：设置打开文件的模式(访问模式)：只读、写入、追加等。\\nencoding:编码格式（推荐使用UTF-8）\\n\\n|    mode    |                             描述                             |\\n| :--------: | :----------------------------------------------------------: |\\n|     r      | 以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。 |\\n|     w      | 打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，<font color=\'red\'>原有内容会被删除</font>。如果该文件<font color=\'red\'>不存在，创建新文件</font>。 |\\n|     a      | 打开一个文件用于追加。如果该文件已存在，<font color=\'red\'>新的内容将会被写入到已有内容之后</font>。如果该文件<font color=\'red\'>不存在，创建新文件进行写入</font>。 |\\n| 示例代码： |                                                              |\\n\\n```python\\nf=open(\\\"python.txt\\\",\'r\',encoding=UTF-8)\\n# 注意：此时的`f`是`open`函数的文件对象，对象是Python中一种特殊的数据类型，拥有属性和方法，可以使用对象.属性或对象.方法对其进行访问，后续面向对象课程会给大家进行详细的介绍。\\n\\n```\\n\\n2、读操作\\n\\n**read()方法**：\\n\\n`文件对象.read(num)`\\nnum表示要从文件中读取的数据长度（单位为字节）。如果不设置num，默认为读取文件中所有数据。\\n\\n**readline()和readlines()方法**：\\nreadline()方法是只读取一行内容，\\nreadlines可以按照行的方式把整个文件中的内容进行一次性读取，并且返回的是一个<font color=\'blue\'>列表</font>，其中每一行的数据为一个元素。\\n\\n这个readlines方法经常与for循环搭配使用。\\n\\n```python\\nfor line in open(\\\"python.txt\\\",\\\"r\\\"):\\n\\tprint(line)\\n```\\n\\n3、文件的关闭\\n\\n```python\\nf=open(\\\"python.txt\\\",\\\"r\\\")\\nf.close()\\n```\\n\\n4、with open语法\\n\\n```python\\nwith open(\\\"python.txt\\\",\\\"r\\\") as f:\\n\\tf.readlines()\\n\\n# 通过在with open的语句块中对文件进行操作,\\n# 可以在操作完成后自动关闭close文件，避免遗忘掉close方法\\n```\\n\\n5、文件的写入、文件的追加写入\\n\\n```python\\n#（1）普通写入：文件不存在会创建，文件存在会先清空在写入\\nf=open(\'python.txt\',\'w\')\\nf.write(\\\"hello,world\\\")\\nf.flush()\\n#（2）追加写入，在原内容上追加写入内容\\nf=open(\'python.txt\',\'a\')\\nf.write(\\\"hello,world\\\")\\nf.flush()\\n```\\n\\n注意：\\n\\n> 直接调用write，内容并未真正写入文件，而是会积攒在程序的内存中，称之为缓冲区\\n>\\n> 当调用flush的时候，内容会真正写入文件\\n>\\n> 这样做是避免频繁的操作硬盘，导致效率下降（攒一堆，一次性写磁盘）\\n\\n\\n## 第五部分  扩展\\n\\n### 13、异常\\n\\n代码示例：\\n\\n```python\\ntry:\\n\\tf=open(\'test.txt\',\'r\')\\nexcept Exception as e:\\n\\tf=open(\'test.txt\',\'w\')\\nelse:\\n\\tprint(\\\"没有异常，真开心\\\")\\nfinally:\\n\\tf.close()\\n\\t# 一般try下方只放一行尝试执行的代码\\n```\\n\\n1、try后跟的可能会出现BUG的代码，如果该代码出现了错误，就跳转到except后的语句进行执行。如果没有出错，就跳转到else后的语句进行执行。不论try后的代码是否出现错误，最终都会执行finally后的代码。\\n\\n2、当捕获多个异常时，可以把要捕获的异常类型的名字，放到except 后，并使用元组的方式进行书写：`xcept(NameError,ZeroDivisionError)`\\n\\n3、捕获异常并输出信息：\\n\\n```python\\nNameError, ZeroDivisionError) as e:\\n    print(e)\\n```\\n\\n4、使用`except`或`except Exception`来捕获所有类型的异常。\\n![](https://s3.bmp.ovh/imgs/2022/10/15/25f7c38edf8d70a9.png)\\n\\n5、异常的传递性\\n\\n假设main函数调用func1()，func1()调用func2()。如果func2()出现了异常，并且没处理，异常会传递到func1()；如果fun1()也没处理，异常会传递到main()；如果main()也没处理，程序就会报错。这就是异常的传递性。基于此原理，我们可以在main函数中设置异常处理函数，这样就能确保所有异常都能被捕捉到。\\n\\n注意：当所有函数都没有处理异常时，程序就会报错。\\n![](https://s3.bmp.ovh/imgs/2022/10/15/5c506fda7a3a2468.png)\\n\\n### 14、模块的导入、包的导入\\n\\npython模块Module：是一个python文件，以.py结尾。模块能定义函数、类和变量，模块中也能饱含可执行的代码。（类似于c语言的.h和配套的.c文件糅合在一起的那种）\\n\\n模块的作用:  python中有很多各种不同的模块, 每一个模块都可以帮助我们快速的实现一些<font color=\'red\'>功能</font>, 比如实现和时间相关的功能就可以使用time模块我们可以认为<font color=\'red\'>一个模块</font>就是<font color=\'red\'>一个工具包</font>, 每一个工具包中都有各种不同的工具供我们使用进而实现各种不同的功能。\\n\\n什么是Python包？包就像个文件夹，里面装了若干个模块。\\n\\n> <font color=\'red\'>从物理上看</font>，包就是一个文件夹，在该文件夹下包含了一个 <font color=\'red\'>__init__.py 文件</font>，该文件夹可用于包含多个<font color=\'red\'>模块文件</font>\\n>\\n> <font color=\'red\'>从逻辑上看</font>，包的本质依然是模块\\n\\n#### 14.1 模块的导入\\n\\n包的作用：当我们的模块文件越来越多时,包可以帮助我们管理这些模块, 包的作用就是包含多个模块，但包的本质依然是模块\\n\\n刚刚说过，模块类似于c语言中的.h和.c文件，那么一定有类似于#include的操作咯，示例如下：\\n\\n```python\\n语法：[from 模块名] import [模块 | 类 | 变量 | 函数 | * ][as 别名]\\n常见用法示例：\\nimport 模块名\\nimport 模块名1,,模块名2\\nfrom 模块名 import 类、变量、方法等\\nfrom 模块名 import *\\nimport 模块名 as 别名\\nfrom 模块名 import 功能名 as 别名\\n```\\n\\n注意：只使用import时，需要用`模块名.方法()`的方式调用对应的方法；如果是使用import的话，直接用方法：`方法()`。而as只是起一个别名，当模块名比较长或者不好记时，用别名也是一种不错的方法。\\n\\n#### 14.2 自定义模块\\n\\n其实就是新建一个python文件，里面写上对应的类或函数。然后和你的主程序放在一个目录下，用`import 文件名`的方式来引用。模块的名字就是文件的名字（不要带.py）。也就是说自定义模块名必须要符合标识符命名规则\\n\\n1、模块的测试\\n\\n当模块写好后，开发人员可以在模块后写上测试代码，来验证模块函数的可行性。可是，这样的话，不论是模块还是调用模块的代码中都会执行这部分测试代码，这显然不是我们想要的。使用`if __name__==\'__main__\'`来解决这个问题：\\n\\n```python\\ndef test(a,b)\\n\\tprint(a+b)\\n\\n# 只在当前文件中调用该函数，其他导入的文件内不符合该条件，则不执行test函数调用\\nif __name__==\'__main\':\\n\\ttest(1,2)\\n```\\n\\n2、注意事项\\n\\n```python\\n#模块1代码module1.py\\ndef my_test(a,b)\\n\\tprint(a+b)\\n#模块2代码module2.py\\ndef my_test(a,b)\\n\\tprint(a*b)\\n# 导入模块和调用功能代码\\nimport module1  # 或 from module1 import my_test\\nimport module2  # 或 from module2 import my_test\\n#方法测试\\nmy_test(1,2)  # 输出结果为2,同名方法就调用最新的那个\\n\\n## 可行的解决办法之一\\nfrom module1 import my_test as my_test1\\nfrom module2 import my_test as my_test2\\n```\\n\\n3、`__all__`可以控制模块内的那些方法可以被导入\\n\\n```python\\n# 模块文件module.py\\n__all__ = [test_A]\\n\\ndef test_A():\\n\\tprint(\'testA\')\\ndel test_B():\\n\\tprint(\'testB\')\\n\\n# 测试文件test.py\\nfrom module import *\\ntest_A()  //运行正常\\ntest_B()  //运行出错，显示没定义\\n```\\n\\n#### 14.3 自创建包、导入包和通过pip安装第三方包\\n\\n1、自创建包\\n\\n> ①新建包“my_package”\\n>\\n> ②新建包内模块：\\\"my_module1.py\\\"和\\\"my_module2.py\\\"，然后在模块内写对应的类和方法\\n>\\n> ③新建包后，包内会自动创建init.py来管理和控制包的导入行为。\\n\\n**Pycharm中的步骤**：[New]      [Python Package]    输入包名    [OK]     新建功能模块(有联系的模块)\\n\\n2、包的导入\\n方式一：\\n\\n```python\\nimport 包名.模块名\\n#使用\\n包名.模块名.方法名\\n```\\n\\n方法二：（前提：必须在init.py文件中添加`__all__=[]`，来控制允许导入的模块列表\\n\\n```python\\nfrom 包名 import *\\n# 注意：__all__这种方法针对的是from XXX import * ,对import XXX这种方式无效\\n```\\n\\n3、第三方包的导入\\n我们知道，包可以包含一堆的Python模块，而每个模块又内含许多的功能。\\n\\n所以，我们可以认为：一个包，就是一堆同类型功能的集合体。\\n\\n在Python程序的生态中，有许多非常多的第三方包（非Python官方），可以极大的帮助我们提高开发效率，如：\\n\\n+ 科学计算中常用的：numpy包\\n+ 数据分析中常用的：pandas包\\n+ 大数据计算中常用的：pyspark、apache-flink包\\n+ 图形可视化常用的：matplotlib、pyecharts\\n+ 人工智能常用的：tensorflow\\n\\n**安装方法**：\\n1、直接：pip install 包名\\n2、用国内源下载和安装：`pip install -i https://pypi.tuna.tsinghua.edu.cn/simple` 包名\\n\\n### 15、数据的可视化分析\\n\\n#### 15.1 折线图\\n\\n1、json数据格式\\n\\n```python\\nimport json\\ndata_dict={\\\"name\\\":\\\"老王\\\",\\\"sex\\\":\\\"famle\\\",\\\"age\\\":20}\\n# 将python字典转换成json数据\\ndata_json=json.dumps(data_dict)\\n## 如果有中文，可以带上ensure_ascii=False来确保中文正常转换\\ndata_json=json.dumps(data_dict,ensure_ascii=False)\\n# 将json数据转换成python字典\\ndata_dumps=json.loads(data_json)\\n```\\n\\n关机json数据格式测试案例：\\n![](https://s3.bmp.ovh/imgs/2022/10/16/321d1c102158afa7.png)\\n![](https://s3.bmp.ovh/imgs/2022/10/16/3429e2e7a286ce02.png)\\n\\n2、pyecharts模块介绍和快速入门\\n\\nEcharts 是个由百度开源的数据可视化，凭借着良好的交互性，精巧的图表设计，得到了众多开发者的认可。而 Python 是门富有表达力的语言，很适合用于数据处理。\\n\\n开发可视化图表，需要用到这个包。[官方示例文档](https://gallery.pyecharts.org/#/README)\\n\\n2.1 画一个基础折线图：\\n\\n```python\\n# 导包，导入Line功能来构建折线图\\nfrom pyecharts.charts import Line\\n\\n# 得到折线图对象\\nline=Line()\\n# 添加x/y轴数据   axis的意思是轴\\nline.add_xaxis([\\\"中国\\\",\\\"美国\\\",\\\"英国\\\"])\\nline.add_yaxis(\\\"GDP\\\",[30,20,10])\\n# 生成图表  render使成为，使表现\\nline.render()\\n```\\n\\n2.2 pyecharts的全局配置和系列配置选项\\n\\n全局配置项可以做很多工作：\\n\\n> 配置图表的标题\\n>\\n> 配置图例\\n>\\n> 配置鼠标移动效果\\n>\\n> 配置工具栏\\n>\\n> 等整体配置项\\n\\n代码示例：\\n\\n```python\\nline.set_global_opts(\\n\\ttitle_opts=TitleOpts(\\\"测试\\\"，pos_left=\\\"center\\\",pos_bottom=\\\"1%\\\"),\\n\\tlegend_opts=LegenfOpts(is_show=True),\\n\\tvisualmap_opts=VisualMapOpts(is_show=True),\\n\\ttoolbox_opts=ToolboxOpts(is_show=True),\\n\\ttooltip_opts=TooltipOpts(is_show=True),\\n)\\n```\\n\\n系列配置：\\n先导入包：\\n\\n```python\\nfrom pyecharts.charts import Line\\nimport pyecharts.options as opts\\n```\\n\\n然后，折线图的相关配置选项\\n![](https://s3.bmp.ovh/imgs/2022/10/16/1e3610da99f33f5b.png)\\n然后，y轴坐标的配置选项\\n![](https://s3.bmp.ovh/imgs/2022/10/16/fd22b3bc8c11fd9a.png)\\n然后，全局配置选项\\n![](https://s3.bmp.ovh/imgs/2022/10/16/fb1a846ba437877c.png)\\n代码示例：\\n\\n```python\\nfrom pyecharts.charts import Line\\nimport pyecharts.options as opts\\n\\nl=(\\n\\tLine(init_opts=opts.InitIpts(width=\\\"1600px\\\",height=\\\"800px\\\"))\\n\\t.add_xaxis(xaxis_data=x1_data[0,-1,2])\\n\\t.add_yaxix(\\n\\t\\tseriwa_name=\\\"美国确诊人数\\\"，\\n\\t\\ty_axix=y1_data[0；-1]，\\n\\t\\tsymbol_size=10,\\n\\t\\tlabel_opts=opts.LabelOpts(is_show=False),\\n\\t\\tlinestyle_opts=opts.LineStyleOpts(width=2)\\n\\t\\t)\\n\\t.set_global_opts(\\n        title_opts=opts.TitleOpts(title=\\\"测试\\\"，\\tpos_left=\\\"center\\\",pos_bottom=\\\"1%\\\"),\\n       xaxis_opts=opts.AxisOpts(name=\\\"时间\\\")，\\n       yaxis_opts=opts.AxisOpts(name=\\\"累计确诊人数\\\")，\\n       legend_opts=opts.LegendOpts(pos_left=\\\"70%\\\"),\\n\\t\\t)\\n\\t)\\n```\\n\\n#### 15.2 地图\\n\\n从pyecharts导入模块Map和VisualMapOpts\\n\\n```python\\nfrom pyecharts.charts import Map\\nfrom pyecharts.options import VisualMapOpts\\n```\\n\\n然后就是导入数据，设置格式，显示图片，略。\\n\\n\\n\\n#### 15.3 动态展示柱状图\\n\\n从pyecharts导入模块Bar\\n1、基础柱状图\\n\\n```python\\nfrom pyecharts.charts import Bar  # 基础柱状图\\nbar=Bar()\\nbar.add_xaxis([\\\"中国\\\",\\\"因果\\\",\\\"美国\\\"])\\nbar.add_yaxis(\\\"GDP\\\",[10,20,30])\\nbar.render(\\\"基础柱状图.html\\\")\\n```\\n\\n反转x、y轴：`bar.reversal_axis()`\\n设置数值标签在右侧：`bar.add_yaxis(\\\"GDP\\\",[10,20,30],label_opts=LabelOpts(position=\\\"right\\\"))`\\n\\n2、基础时间线柱状图\\n\\n> 掌握基础的时间线配置动态图表\\n>\\n> 掌握设置主题更改颜色样式\\n\\n柱状图描述的是分类数据，回答的是每一个分类中『有多少？』这个问题. 这是柱状图的主要特点,同时柱状图很难动态的描述一个趋势性的数据. 这里pyecharts为我们提供了一种解决方案-<font color=\'red\'>时间线</font>\\n\\n如果说一个Bar、Line对象是一张图表的话，时间线就是创建一个一维的x轴，轴上每一个点就是一个图表对象。要导入TimeLine模块：`from pyecharts.charts import Bar,TimeLine`。代码示例如下：\\n\\n```python\\nfrom pyecharts.chrts import Bar,TimeLine\\nfrom pyecharts.options import *\\n\\nbar1=Bar()\\nbar1.add_xaxis([\\\"中国\\\",\\\"因果\\\",\\\"美国\\\"])\\nbar1.add_yaxis(\\\"GDP\\\",[10,20,30],label_opts=LabelOpts(position=\\\"right\\\"))\\nbar1.reversal_axis()\\n\\nbar2=Bar()\\nbar2.add_xaxis([\\\"中国\\\",\\\"因果\\\",\\\"美国\\\"])\\nbar2.add_yaxis(\\\"GDP\\\",[30,50,20],label_opts=LabelOpts(position=\\\"right\\\"))\\nbar2.reversal_axis()\\n\\n# 创建时间线对象\\ntimeline=TimeLine()\\n# 将柱状图添加到时间线对象中\\ntimeline.add(baar1,\\\"2021年GDP\\\")\\ntimeline.add(bar2,\\\"2022年GDP\\\")\\n# 通过时间线绘图\\ntimeline.render(\\\"基础柱状图-时间线.html\\\")\\n\\n## 设置自动播放\\ntimeline.add_schema(\\n\\tplay_interval=1000,     # 自动播放的时间间隔，单位毫秒\\n\\tis_timeline_show=True,  # 是否在自动播放时，显示时间线\\n\\tis_auto_play=True,      # 是否自动播放\\n\\tis_loop_play=True,      # 是否循环自动播放\\n)\\n```\\n\\n时间线设置主题：\\n\\n```python\\nfrom pyecharts.global import ThemeType\\n# 创建时间线对象\\ntimeline=TimeLine(\\n\\t{\\\"theme\\\":ThemeType.LIGHT}\\n)\\n```\\n\\n主题的其他配置选项见下图：\\n![](https://s3.bmp.ovh/imgs/2022/10/16/ee45d67c9af77da8.png)\\n\\n3、动态柱状图绘制\\n\\n> 1. 掌握列表的sort方法并配合lambda匿名函数完成列表排序\\n>\\n> 2. 完成图表所需的数据处理\\n>\\n> 3. 完成GDP动态图表绘制\\n\\n3.1 需求分析\\n\\n简单分析后，发现最终效果图中需要：\\n\\n1. GDP数据处理为亿级\\n2. 有时间轴，按照年份为时间轴的点\\n3. x轴和y轴反转，同时每一年的数据只要前8名国家\\n4. 有标题，标题的年份会动态更改\\n5. 设置了主题为LIGHT\\n\\n最终效果图：\\n![](https://s3.bmp.ovh/imgs/2022/10/16/7c6087271250c484.png)\\n\\n代码示例：\\n\\n1、处理数据\\n![](https://s3.bmp.ovh/imgs/2022/10/16/0b6ffdafd38e7a38.png)\\n![](https://s3.bmp.ovh/imgs/2022/10/16/199b4d8405330400.png)\\n\\n2、准备时间线\\n![](https://s3.bmp.ovh/imgs/2022/10/16/5d1c21a705f36697.png)\\n\\n3、自动播放和绘图\\n![](https://s3.bmp.ovh/imgs/2022/10/16/379d6908a207ba41.png)\\n\\n\\n\\n\\n### 16、python中的类与对象（封装、继承与多态）\\n\\n#### 16.1、类的封装与定义（方法、属性）\\n\\n1、关键点：掌握类的定义和使用，掌握成员方法的使用，掌握self关键字的作用（self是不是与c++的this指针很像？）\\n\\n```python\\nclass Student:\\n\\tname=None\\n\\tage=None\\n\\tdef say_hi(self):\\n\\t\\tprintf(f\\\"Hi,{self.name}!\\\")\\n\\n# 调用\\nstu=Student()\\nstu.name=HaoY\\nstu.say_hi()\\n```\\n\\n从上述实例可以看出类中有属性（成员变量），有方法（成员方法）。可以看到，类中定义的方法和外面定义的函数时非常类似的，仍需注意一点的是，类中方法的第一个形参必须是self，方法中调用类内属性时，必须使用self指针；类外调用方法时，不用填充第一个形参self。\\n使用构造方法，通过传参的方式初始化类的对象（是不是与c++的构造函数很相似）\\n\\n2、self的作用\\n\\n+ 表示类对象本身的意思\\n+ 只有通过self，成员方法才能访问类的成员变量\\n+ self出现在形参列表中，但不占用参数位置，无需理会\\n\\n3、类的构造方法：使用`__init__`来实现类对象的初始化：\\n\\n```python\\n# 该方法在构建类对象时，会自动运行：stu=Student(\\\"HaoY\\\",23,1100992)\\ndef __init__(self,name,age,tel)\\n\\tself.name=name\\n\\tself.age=age\\n\\tself.tel=tel\\n```\\n\\n4、掌握python的其他内置方法  （类中的内置方法）\\n上文学习的`__init__` 构造方法，是Python类内置的方法之一。这些内置的类方法，各自有各自特殊的功能，这些内置方法我们称之为：魔术方法。（以下部分内置方法为常用的）\\n\\n> `__init__`：类的构造方法\\n>\\n> `__str__`：字符串方法\\n>\\n> `__lt__` 和 `__gt__`：小于、大于符号比较\\n>\\n> `__le__`  和  `__ge__` ：小于等于、大于等于符号比较\\n>\\n> `__eq__`：等于符号比较\\n\\n4.1 `__str__`方法\\n\\n直接print(对象)，输出的结果是对象的内存地址。这个地址在python中没啥用。我们可以在类中新增`__str__`方法，这样当使用print(对象)时，输出的就是我们指定的字符串了。示例如下：\\n\\n```python\\nclass Student:\\n\\tdef __init__(self,name,age):\\n\\t\\tself.name=name\\n\\t\\tself.age=age\\n\\n# 测试  （不使用__str__方法）\\nstu=Student(\\\"HaoY\\\",23)\\nprint(stu)   # 输出： <__main.Student object at 0x000002200CFD6040>\\nprint(str(stu)) # 输出： <__main.Student object at 0x000002200CFD6040>\\n--------------------------------------------------------------\\nclass Student:\\n\\tdef __init__(self,name,age):\\n\\t\\tself.name=name\\n\\t\\tself.age=age\\n\\tdef __str__(self):\\n\\t\\treturn f\\\"哈哈，你看到我了吗？\\\"\\n\\n# 测试   （使用__str__方法）\\nstu=Student(\\\"HaoY\\\",23)\\nprint(stu)   # 输出： 哈哈，你看到我了吗？\\nprint(str(stu)) # 输出： 哈哈，你看到我了吗？\\n```\\n\\n4.2 `__lt__`  /  `__gt__`小于/大于符号比较方法\\n\\n注意，直接用小于/大于福来来比较两个类对象，是错误的用法。但是在类中添加了`__lt__`内置方法后，就可以实现直接用大于小于符号来比较两个类对象的操作了。（有点像c++的重载大于小于操作符的方法）\\n\\n```python\\nclass Student:\\n\\tdef __init(self,name,age):\\n\\t\\tself.name=name\\n\\t\\tself.age=age\\n\\n\\tdef __lt__(self,other):\\n\\t\\treturn self.age < other.age\\n# 测试\\nstu1=Student(\\\"HaoY\\\",23)\\nstu2=Student(\\\"WuMan\\\",22)\\nprint(stu1<stu2)  # 结果： False\\nprint(stu1>stu2)  # 结果： True  注意，实现大于符号需要写`def __gt__`，上面的类未实现\\n```\\n\\n4.3 `__le__`  /  `__ge__`小于等于 / 大于等于符号比较方法\\n\\n与4.2内容相似。还有`__eq__`也是类似的用法。\\n\\n5、类的封装：私有成员变量/方法的设置（注意与c++的不同）\\n\\n如何定义私有变量和私有方法？\\n\\n答：在变量名和方法名前，加上两个下划线即可。`__name`和`def __keep_score(self)`\\n\\n私有变量只能在类内使用，不能被对象调用。不能被对象赋值，不能被对象读值。在类内的方法中，通过self来调用私有变量。\\n\\n```python\\npthon.__name=\\\"HaoY\\\"   # 不报错，但无效\\nprint(pthon.__name)   # 报错，无法使用\\n```\\n\\n#### 16.2、类的继承\\n\\n单继承：\\n\\n```python\\n# 父类\\nclass Phone:\\n\\tIMEI=None\\n\\tproducer=None\\n\\n# 子类  继承表示：将从父类那里继承（复制）来成员变量和成员方法（不含私有）\\nclass Xiao(Phone)\\n\\tface_id=True\\n\\n```\\n\\n多继承（多父类的同名函数问题，继承顺序问题）还有pass关键字\\n\\n```python\\nclass Phone:\\n\\tIMEI=None\\n\\tproducer=None\\n\\nclass Ss:\\n\\tface_id=True\\n\\nclass Bb:\\n\\tface_chec=True\\n\\tproducer=\\\"HM\\\"\\n\\t\\nclass MyPhone(Phone,Ss,Bb)\\n\\tpass\\n\\n## 温馨提示：关于多继承的优先级问题\\n如上所示，子类MyPhone继承了三个类，而父类Phone和父类Ss都有成员属性producer，并且这个属性是公共属性并非私有属性。那么，在子类中使用该变量时（假设子类未重新定义该变量），子类实际调用的哪个父类的属性呢？\\n\\n答案：继承优先级从左到右，优先级从高到底。所以，子类调用producer属性时，输出None而不是HM。\\n```\\n\\n复写：（与C++的虚函数类似）在子类中 重新定义同名的属性或方法即可\\n\\n一般在子类复写了父类方法后，在子类调用该方法就是调用子类中的方法。那有什么方式可以再子类中调用父类方法吗？\\n\\n```python\\n## 前提：只能在子类内调用父类的同名成员。子类的类对象直接调用会调用子类复写的成员\\n# 方式一：\\n使用子类中的父类变量/方法来调用\\n调用变量：父类成员.变量\\n调用方法：父类成员.成员方法(self)\\n# 方法二：\\n使用super()调用父类变量/方法\\n调用变量：super().变量\\n调用方法：super().方法\\n```\\n\\n#### 16.3、类的多态\\n\\n在C++中的多态有两种，一是函数多态，根据形参数据类数量和位置的不同，产生多态行为；而是类中函数为纯虚函数，此时类为抽象类，子类继承该父类并重新父类方法是另一种多台。\\n\\npython中没有函数多态，只有类的抽象继承。\\n父类定义方法，但不实现，子类重新定义方法并实现。这样就实现了父类一个方法有多种输出结果的多态。示例;\\n\\n```python\\nclass father:\\n\\tdef speak():\\n\\t\\tpass\\nclass son1:\\n\\tdef speak()\\n\\t\\tprint(\\\"哇哇哇\\\")\\nclass son2:\\n\\tdef speak()\\n\\t\\tprint(\\\"哈哈哈\\\")\\n```\\n\\n>抽象类：含有抽象方法的类称之为抽象类\\n>\\n>抽象方法：方法体是空实现的（pass）称之为抽象方法\\n\\n\\n\\n#### 16.4、类型注解问题（ctrl+p弹出函数传参提示）\\n\\nPython3.5引入了类型注解，它的功能是方便静态类型检查工具、IDE等第三方工具，来为编程提供便利和提前排错。\\n\\n主要功能：\\n\\n+ 帮助第三方IDE工具（如PyCharm）对代码进行类型推断，协助做代码提示\\n+ \\n+ 帮助开发者自身对变量进行类型注释（备注）\\n\\n类型注解分为变量注解、函数（方法）形参列表和返回值注解和Union类型注解。注解只是提示性的，不是决定性的，不会真正的对类型做验证和判断。\\n\\n##### 16.4.1 变量的注解\\n\\n```python\\n# 基本语法： 变量：类型\\n# 1、基础数据类型注解\\nvar_1： int = 10\\nvar_2: float=3.12\\nvar_3: bool=True\\nvar_4: str=\\\"itheima\\\"\\n#2、类对象的类型注解\\nclass Student:\\n\\tpass\\nstu:student=Sthdent()\\n#3、基础容器注解\\nmy_list:list=[1,2,3]\\nmy_tuple:tuple=(1,2,3)\\nmy_set:set={1,2,3}\\nmy_dict:dict={\\\"Aa\\\":1,\\\"Bb\\\":2}\\nmy_str:str=\\\"itheima\\\"\\n#4、容器类型详细注解\\n## 注意：\\n### + 元组类型设置类型详细注解，需要将每一个元素都标记出来。注意哦，元组很特殊，需要把每一个元素类型都标列出来\\n### + 字典类型设置类型详细注解，需要2个类型，第一个是key第二个是value\\nmy_list:list[int]=[1,2,3]\\nmy_tuple:tuple[int]=(1,2,3)\\nmy_set:set[int]={1,2,3}\\nmy_dict:dict[str,int]={\\\"Aa\\\":1,\\\"Bb\\\":2}\\n\\n# 注意，警告！下面这种复合数据类型的写法，只在python3.9后才支持的。在python3.5~python3.9之间，对于复合型的数据类型，请使用Union类型\\nmy_list:list[int,str,float]=[1,\\\"2\\\",3.12]\\nmy_tuple:tuple[int,str,float]=(1,\\\"2\\\",3.12)\\nmy_set:set[int,str,float,bool]={1,\\\"2\\\",3.12,True}\\n```\\n\\n除了使用`变量：类型`的方式注解外，也可以在注释中进行类型注解\\n语法：`#type:类型`\\n\\n```python\\nvar_1=random.randint(1,10)  #type:int\\nvar_2=json,loads(data)      #type:dict[str,int]\\nvar_3=func()                #type:Student\\n```\\n\\n一般直接定义的普通变量无需注解，一般能看出它的类型，但是存储函数返回值、类对象的返回值的变量，可能很难直接看出它的数据类型，所以需要注解：\\n\\n```python\\n#小总结，第一种注解方式：\\nvar_1:int=random.randint(1,10) \\nvar_2:dict=json,loads(data)    \\nvar_3:Student=func()\\n# 第二种注解方式  在注释中：\\nvar_1=random.randint(1,10)  #type:int\\nvar_2=json,loads(data)      #type:dict[str,int]\\nvar_3=func()                #type:Student\\n```\\n\\n##### 16.4.2 函数（方法）的类型注解\\n\\n1、形参注解\\n语法形式：\\n\\n```python\\ndef 函数方法名(形参名1：类型1，形参名2：类型2，...):\\n\\tpass\\n```\\n\\n2、返回值注解\\n语法形式：\\n\\n```python\\ndef 函数方法名(形参名1：类型1，形参名2：类型2，...) -> 返回值类型：\\n\\tpass\\n```\\n\\n综合示例：\\n\\n```python\\ndef add(x:int,y:int) -> int:\\n\\treturn x+y\\ndef func(data:list[int]) -> list[int]\\n\\tpass\\n```\\n\\n##### 16.4.3 Union类型的注解\\n\\n在含有多种数据类型的数据容器中进行类型注释，就需要一点技巧了。Union类型就是解决这一问题的方法之一。\\n\\n先导包：`from typing import Union`\\n对于单一数据类型的容器或函数形参/返回值注解，可以直接使用：\\n\\n```python\\nmy_list:list[int]=[1,2,3]\\nmy_dict:dict[str,int]={\\\"HM\\\":11,\\\"ds\\\":22}\\n```\\n\\n对于含有多种数据类型的容器或函数形参、返回值，就需要Union类型的帮助了。\\n\\n```python\\n# 也可以将复合的这几种数据类型拆开，不过这种写法只在python3.9后才支持\\n# my_list:list[int,str]=[1,2,\\\"HM\\\",\\\"lalala\\\"]\\n\\nfrom typing import Union\\nmy_list:list[Union[str,int]]=[1,2,\\\"HM\\\",\\\"lalala\\\"]\\nmy_dict:dict[str,Union[str,int]]={\\\"HM\\\":11,\\\"sanaj\\\":\\\"heihie\\\"}\\n# 使用Union[类型,类型,...]，\\n# 可以实现联合类型注解  在函数形参和返回值上，也是可以用的：\\ndef func(data:Union[int,str]) -> Union[int,str]:\\n\\tpass\\n```\",\"articleCover\":\"\",\"articleTitle\":\"Python学习思路\",\"articleType\":1,\"categoryName\":\"编程语言基础\",\"isRecommend\":0,\"isTop\":0,\"status\":1,\"tagNameList\":[\"Python\"]}]','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',59,'2023-06-07 16:39:33');
INSERT INTO `t_operation_log` VALUES (1184,'文章模块','添加','/admin/article/add','com.ican.controller.ArticleController.addArticle','添加文章','[{\"articleContent\":\"---\\ntitle: 参考资料汇总\\ndate: 2022-10-30\\nauthor: HaoXX\\ncategory:\\n - 1编程语言基础\\n\\nfooter: <a href=\\\"https://beian.miit.gov.cn/#/Integrated/index\\\">渝ICP备2023001651号</a>\\n\\n---\\n\\n:::tip\\n参考资料汇总\\n:::\\n\\n<!-- more -->\\n\\n<p align=\\\"center\\\" style=\\\"color:blue\\\">\\n  <a href=\\\"https://mp.weixin.qq.com/s/ePhaYezFblgt0NgbvtWqww\\\" target=\\\"_blank\\\">\\n    <h2 align=\\\"center\\\">\\n        仓库内容持续更新中...\\n    </h2>\\n  </a>\\n</p>\\n\\n\\n<!-- <p>\\n  <br>\\n</p> -->\\n\\n<p align=\\\"center\\\">\\n    <a href=\\\"https://mp.weixin.qq.com/s/ePhaYezFblgt0NgbvtWqww\\\" target=\\\"_blank\\\">\\n        <img src=\\\"https://cdn.jsdelivr.net/gh/justacoder99/r2coding@master/img/r2coding_logo_index.15y992dieibg.png\\\" width=\\\"\\\"/>\\n    </a>\\n</p>\\n\\n\\n\\n<p align=\\\"center\\\">\\n  <a href=\\\"https://github.com/rd2coding/Road2Coding\\\" target=\\\"_blank\\\"><img src=\\\"https://img.shields.io/badge/Github-r2coding-red.svg\\\"></a>\\n  <a href=\\\"https://gitee.com/rd2coding/Road2Coding\\\" target=\\\"_blank\\\"><img src=\\\"https://img.shields.io/badge/Gitee-r2coding-blue.svg\\\"></a>\\n  <a href=\\\"https://space.bilibili.com/384068749\\\" target=\\\"_blank\\\"><img src=\\\"https://img.shields.io/badge/bilibili-哔哩哔哩-critical\\\"></a>\\n  <a href=\\\"https://mp.weixin.qq.com/s/ePhaYezFblgt0NgbvtWqww\\\" target=\\\"_blank\\\">\\n    <img src=\\\"https://img.shields.io/badge/微信联系作者-WeChat-green.svg\\\" alt=\\\"微信联系\\\">\\n  </a>\\n</p>\\n\\n\\n自学之路漫又长，唯有不断总结，不断回味，不断分享，才能成长！\\n\\n联系我可以[【微信】](#微信)私我\\n\\n---\\n\\n# **为什么会有这个开源仓库**\\n\\n---\\n\\n本仓库取名 **r2coding**，即 **Road To Coding**，意为「编程自学之路」，是自学编程以来所用资源和分享内容的大聚合。\\n\\n旨在为编程自学者提供一系列：\\n\\n>  - **清晰的编程自学路线**\\n>  - **各编程岗位方向的知识点梳理**\\n>  - **靠谱的资源**\\n>  - **高效的工具**\\n>  - **务实的技术文章**\\n\\n方便自己也方便他人。仓库内容会保持**持续更新**，欢迎收藏品鉴！\\n\\n---\\n\\n# **本仓库内容地图**\\n\\n---\\n\\n![](https://cdn.jsdelivr.net/gh/justacoder99/r2coding@master/img/contentmap.3sdmma4od740.png)\\n\\n---\\n\\n# **编程自学路线+知识大梳理**\\n\\n---\\n\\n本仓库目前整理收录了6个大方向（岗位）的学习路线+知识点大梳理，分别为：\\n\\n- **Java后端开发**\\n- **前端开发**\\n- **C/C++后台开发**\\n- **大数据开发**\\n- **嵌入式开发**\\n- **网络安全方向**\\n\\n\\n后续本仓库也会持续更新和增加更多方向岗位的学习路线...\\n\\n---\\n\\n<!-- tabs:start -->\\n\\n### **Java后端开发**\\n\\n详情链接 **→** [《Java后端开发学习路线+知识点大梳理》](https://mp.weixin.qq.com/s/rAoamIey7cARMES7kfIaLw)\\n\\n![](https://cdn.jsdelivr.net/gh/justacoder99/r2coding@master/img/jawa.391vqmg83lc0.png)\\n\\n> 注：图片上传后可能被压缩，如需无损版高清大图，可去微信公众号「**CodeSheep**」后台回复「**后端开发**」四个字获取即可\\n\\n详情链接 **→** [《Java后端开发学习路线+知识点大梳理》](https://mp.weixin.qq.com/s/rAoamIey7cARMES7kfIaLw)\\n\\n### **前端开发**\\n\\n详情链接 **→** [《前端开发学习路线+知识点大梳理》](https://mp.weixin.qq.com/s/_8lvpPDArM_Z-MI9iul1AA)\\n\\n![](https://cdn.jsdelivr.net/gh/justacoder99/r2coding@master/img/front.6uquir77a6c0.png)\\n\\n> 注：图片上传后可能被压缩，如需无损版高清大图，可去微信公众号「**CodeSheep**」后台回复「**前端开发**」四个字获取即可\\n\\n详情链接 **→** [《前端开发学习路线+知识点大梳理》](https://mp.weixin.qq.com/s/_8lvpPDArM_Z-MI9iul1AA)\\n\\n### **大数据开发**\\n\\n详情链接 **→** [《大数据开发学习路线+知识点大梳理》](https://mp.weixin.qq.com/s/dm2Qm4zZhHxEvcFgNS_mrA)\\n\\n![](https://cdn.jsdelivr.net/gh/justacoder99/r2coding@master/img/bigdata.21roso2lxdsw.png)\\n\\n> 注：图片上传后可能被压缩，如需无损版高清大图，可去微信公众号「**CodeSheep**」后台回复「**大数据**」三个字获取即可\\n\\n详情链接 **→** [《大数据开发学习路线+知识点大梳理》](https://mp.weixin.qq.com/s/dm2Qm4zZhHxEvcFgNS_mrA)\\n\\n### **嵌入式开发**\\n\\n详情链接 **→** [《嵌入式开发学习路线+知识点大梳理》](https://mp.weixin.qq.com/s/AJqbhz3InV3G8TVjTHn6dg)\\n\\n![](https://cdn.jsdelivr.net/gh/justacoder99/r2coding@master/img/embed.2kqjbi961600.png)\\n\\n> 注：图片上传后可能被压缩，如需无损版高清大图，可去微信公众号「**CodeSheep**」后台回复「**嵌入式**」三个字获取即可。\\n\\n详情链接 **→** [《嵌入式开发学习路线+知识点大梳理》](https://mp.weixin.qq.com/s/AJqbhz3InV3G8TVjTHn6dg)\\n\\n### **C/C++后台开发**\\n\\n详情链接 **→** [《C/C++（偏后台）开发学习路线+知识点大梳理》](https://mp.weixin.qq.com/s/tXilzUzN7cDhnc3ztw4Vlw)\\n\\n### **网络安全方向**\\n\\n详情链接 **→** [《网络安全方向学习路线+知识点大梳理》](https://mp.weixin.qq.com/s/pPs5Gm9I3a6-nMZQ42kaWg)\\n\\n<!-- tabs:end -->\\n\\n---\\n\\n# **常用编程软件和工具**\\n\\n---\\n\\n> [!NOTE]\\n>\\n>  - [**【置顶笔记下载1】熬10天夜，我肝出了这个PDF版「服务器软件安装手册」**](https://mp.weixin.qq.com/s/YNOZSQ5smo1uGE5ZttUZ_w)\\n>\\n>  - [**【置顶笔记下载2】再肝两夜，写了个「服务器项目部署」实战PDF手册**](https://mp.weixin.qq.com/s/JUJ6qu_ec3s1JmTxQt_V3g)\\n\\n> **工欲善其事，必先利其器！**\\n\\n一个易上手、好用、高效的软件工具对于程序员工作效率的提升是不言而喻的，这些常用开发软件和工具比如：\\n\\n> - 基础的软件开发环境和设施\\n> - 好用高效的在线工具和网站\\n> - 本地常用的一些编程软件\\n> - Linux操作系统\\n> - 版本控制工具\\n> - 高效的IDE和编辑器\\n> - API管理工具/文档管理工具\\n> - CI守护系统\\n> - ...... 等等\\n\\n接下来我们一项一项详细盘点。\\n\\n---\\n\\n## 常用在线工具集\\n\\n---\\n\\n> [!NOTE]\\n>\\n>  - [**【本章节置顶资源下载】自学编程一路走来，这些私藏工具和网站我全贡献出来了！（附我的浏览器书签下载）**](https://mp.weixin.qq.com/s/XUHnLCbq7mDWhOc9imTVzg)\\n\\n程序员在平时的日常**工作**、**学习**、**开发**、**做笔记**、**写博客**等过程中还是有很多好用并且高效的**在线工具推荐**的，毕竟我们不是每时每刻我们都需要那种很重量级的本地软件。\\n\\n下面将分成**16个大类**，共整理了约**130+个**常用的在线工具和网站供大家食用。\\n\\n---\\n\\n<!-- tabs:start -->\\n\\n#### **在线画图工具**\\n\\n程序员经常接触的无非也就是流程图、思维导图、原型图、UML图、网络拓扑图、组织结构图等等这些。\\n\\n下面这四个在线画图网站我想应该足够了，其中那个processon是我用得最多的，历史文章中几乎所有相关的图形都是用它绘制，然后导出图片的。\\n\\n- [在线画图工具ProcessOn](https://www.processon.com/)\\n- [在线画图工具Draw.io](https://app.diagrams.net/)\\n- [在线思维导图工具MindLine](http://www.mindline.cn/webapp)\\n- [PlantUML在线编辑器](http://haha98k.com/)\\n\\n#### **在线编解码工具**\\n\\n- [BASE64编解码工具](https://base64.supfree.net/)\\n- [MD5编码工具](https://www.zxgj.cn/g/md5)\\n- [AES/DES加解密](http://www.fly63.com/tool/cipher/)\\n- [JWT解码工具](http://jwt.calebb.net/)\\n- [ASCII编解码工具](https://www.matools.com/code-convert-ascii)\\n- [Unicode编解码工具](https://www.zxgj.cn/g/unicode)\\n- [UTF-8编解码工具](https://www.zxgj.cn/g/utf8)\\n- [字符串编解码工具](https://www.zxgj.cn/g/enstring)\\n- [URL编解码工具](http://tool.chinaz.com/tools/urlencode.aspx?jdfwkey=lbixz1)\\n\\n#### **在线转换工具**\\n\\n- [在线ASCII码对照表](http://www.fly63.com/tool/ascii/)\\n- [通用进制转换工具](https://www.zxgj.cn/g/jinzhi)\\n- [在线浮点数十进制转换](http://www.binaryconvert.com/)\\n- [RGB颜色转换](https://www.zxgj.cn/g/yansezhi)\\n- [时间戳转换工具](https://www.zxgj.cn/g/unix)\\n- [计量单位换算工具](http://www.fly63.com/tool/unitable/)\\n- [在线JSON解析](http://www.json.cn/)\\n- [在线JS代码格式化工具](https://prettier.io/playground/)\\n- [SQL压缩/格式化工具](https://www.zxgj.cn/g/sqlformat)\\n- [JSON和XML在线转换](https://www.zxgj.cn/g/jsonxml)\\n- [JSON/YAML在线转换](http://www.fly63.com/tool/jsonyaml/)\\n- [人民币大小写转换工具](http://www.fly63.com/tool/renmingbi/)\\n\\n#### **正则表达式工具**\\n\\n- [正则表达式调试工具](https://regexr.com/)\\n- [正则表达式可视化工具](https://jex.im/regulex/)\\n\\n#### **网络工具**\\n\\n- [IP地址归属地查询](https://www.ip138.com/)\\n- [IP地址查询](https://www.ipip.net/ip.html)\\n- [HTTP在线接口测试工具](http://www.fly63.com/php/http/)\\n\\n#### **在线编译运行工具**\\n\\n- [C#在线编译运行](https://rextester.com/)\\n- [C/C++在线编译调试](https://www.onlinegdb.com/)\\n- [在线编译工具套装](https://c.runoob.com/)\\n\\n#### **可视化/格式化工具**\\n\\n- [在线前端编辑器](https://codepen.io/)\\n- [在线数据可视化](https://flourish.studio/)\\n- [在线JSON解析](http://www.json.cn/)\\n- [在线CSS代码可视化工具](https://enjoycss.com/)\\n- [XML格式化工具](https://www.zxgj.cn/g/xmlformat)\\n- [在线JS代码格式化工具](https://prettier.io/playground/)\\n- [SQL压缩/格式化工具](https://www.zxgj.cn/g/sqlformat)\\n- [JSON和XML在线转换](https://www.zxgj.cn/g/jsonxml)\\n- [JSON/YAML在线转换](http://www.fly63.com/tool/jsonyaml/)\\n\\n#### **在线生成器**\\n\\n- [UUID在线生成器](https://www.zxgj.cn/g/uuid)\\n- [随机数生成器](https://www.zxgj.cn/g/suijishu)\\n\\n#### **其他常用在线开发相关工具**\\n\\n- [在线Nginx配置工具](https://nginxconfig.io/)\\n- [在线文本代码比对工具](http://www.fly63.com/tool/textdiff/)\\n- [在线Chrome浏览器插件](https://www.crx4chrome.com/)\\n- [在线接口文档管理工具](http://www.docway.net/)\\n\\n#### **在线素材工具**\\n\\n如果你也写文章，或者做视频，那就一定少不了要找素材，包括各种图片、背景、emoji表情、表情包、壁纸、视频、gif图等等。\\n\\n如此一来，那些好用的在线素材工具就必不可少了，比如像各种表情包工具、icon图标库、矢量图库、图片素材库、壁纸库等等。\\n\\n- [免费透明背景图片素材](http://pngimg.com/)\\n- [Emoji表情包下载](https://emojiisland.com/)\\n- [open source icons](https://feathericons.com/)\\n- [阿里巴巴矢量图标库](https://www.iconfont.cn/)\\n- [表情包在线网站](https://fabiaoqing.com/)\\n- [免费PNG图片库](https://pluspng.com/)\\n- [ICON图标在线下载](https://www.iconfinder.com/)\\n- [极简壁纸](https://bz.zzzmh.cn/)\\n- [Wallpaper Abyss壁纸](https://wall.alphacoders.com)\\n- [Pixabay图片素材库](https://pixabay.com/zh/)\\n- [Unsplash图片素材库](https://unsplash.com)\\n- [Pexels图片素材库](http://www.pexels.com)\\n- [NASA图片视频素材库](https://images.nasa.gov)\\n\\n#### **设计制作类工具**\\n\\n对于那些文章创作者和视频创作者而言，设计封面，做海报，设计LOGO，图片美化等等基本也是刚需。\\n\\n这样大概率日常会用到一些简易好上手的在线设计制作类工具，比如在线P图、音/视频轻量化剪辑、logo制作、海报设计制作、图片美化、在线图片转换或生成等等，毕竟不是每时每刻我们都需要那种重量级的本地软件。\\n\\n- [在线PS](https://www.uupoop.com/)\\n- [在线音频剪辑](https://www.weixinsyt.com/)\\n- [在线视频剪辑](https://www.kapwing.com/)\\n- [免费logo在线制作](http://www.uugai.com/)\\n- [艺术字体在线生成](https://www.qt86.com/)\\n- [在线表格转换工具](https://tableconvert.com/)\\n- [在线海报设计工具](https://www.designcap.com/)\\n- [图片智能放大工具](https://bigjpg.com/)\\n- [二维码美化器](https://mh.cli.im/)\\n- [在线代码截图工具](https://carbon.now.sh/)\\n- [在线抠图工具](https://www.remove.bg/zh)\\n- [ICO图标在线生成](http://www.fly63.com/php/ico/)\\n- [SVG转PNG工具](http://www.fly63.com/tool/svg2img/)\\n- [视频转GIF工具](http://www.fly63.com/tool/giftxt/)\\n- [二维码在线生成器](http://www.fly63.com/tool/ewm/)\\n- [二维码在线解码](http://www.fly63.com/php/decoder/)\\n\\n#### **写作辅助工具**\\n\\n在我写文章的过程中经常会用到和写作相关的辅助工具，比方说：字数统计工具、Markdown格式的文章排版工具、图床网站、代码截图工具等等，所以下面这些在线工具就能很好地满足我的需求。\\n\\n- [在线字数统计](https://www.eteste.com/)\\n- [mdnice markdown排版工具](https://mdnice.com/)\\n- [md2all markdown排版工具](http://md.aclickall.com/)\\n- [在线图床神器](https://picx.xpoet.cn/)\\n- [在线免费图床](https://sm.ms/)\\n- [图壳图床](https://imgkr.com/)\\n- [在线代码截图工具](https://carbon.now.sh/)\\n- [在线短链接工具](https://urlify.cn/)\\n- [在线文本替换](http://www.fly63.com/tool/textreplace/)\\n\\n#### **在线办公工具**\\n\\n这部分在线工具主要用来处理一些和文档以及文稿相关的事情，经常用到的比如：在线的全套pdf处理和转换工具、各种各样多媒体文件间的相互转换工具、在线识别工具、在线压缩工具等等。\\n\\n- [pdf在线处理工具套装1](https://smallpdf.com/cn/pdf-tools)\\n- [pdf在线处理工具套装2](https://tools.pdf24.org/zh/)\\n- [pdf转word在线工具](https://www.pdftoword.com/)\\n- [在线多媒体转换器合集](https://cn.office-converter.com/)\\n- [在线文字识别工具](https://ocr.wdku.net/)\\n- [在线文件压缩工具](https://docsmall.com/)\\n\\n#### **文档笔记工具**\\n\\n好记性不如烂笔头，作为一个学习者，我觉得记笔记是必不可少的步骤。当然现在基本都做电子笔记和电子文档比较多。\\n\\n现如今各式各样优秀的文档工具和笔记软件鳞次栉比，好用的也有很多，整理成如下列表，这东西各有长处，使用哪个最合意还得看个人习惯和需求了。\\n\\n- [印象笔记](https://www.yinxiang.com/)\\n- [有道笔记](https://note.youdao.com/)\\n- [OneNote](https://www.onenote.com/)\\n- [幕布](https://mubu.com/)\\n- [为知笔记](https://www.wiz.cn/)\\n- [石墨文档](https://shimo.im/)\\n- [Simplenote](https://simplenote.com/)\\n- [语雀](https://www.yuque.com/)\\n\\n#### **编程学习网**\\n\\n- [哔哩哔哩](https://www.bilibili.com/)\\n- [C语言网](https://www.dotcpp.com/)\\n- [cppreference](http://zh.cppreference.com/)\\n- [中国大学MOOC](https://www.icourse163.org/)\\n- [牛客网](www.nowcoder.com)\\n- [网易公开课](https://open.163.com/)\\n- [CodeGym](https://codegym.cc/)\\n- [BeginnersBook](https://beginnersbook.com/)\\n- [JavaSED](http://www.javased.com/)\\n- [codecademy](https://www.codecademy.com/)\\n- [Coursera](https://www.coursera.org/)\\n- [StackOverFlow](https://stackoverflow.com/)\\n- [LeetCode](https://leetcode-cn.com/)\\n- [LintCode](https://www.lintcode.com/)\\n\\n#### **在线教程和文档**\\n\\n这部分主要集中了我在做开发过程中随手参考所要用到的几乎所有在线教程和官方文档，有中文版文档的我基本都优先列出来了，但更多时候是英文的官方文档。\\n\\n<!-- panels:start -->\\n\\n<!-- div:left-panel -->\\n\\n- [Git中文教程](https://git-scm.com/book/zh/v2)\\n- [SVN中文手册](http://svnbook.red-bean.com/nightly/zh/index.html)\\n- [jQuery API中文文档](https://jquery.cuishifeng.cn/)\\n- [Nginx中文文档](https://www.nginx.cn/doc/index.html)\\n- [Kafka中文文档](https://kafka.apachecn.org/)\\n- [Mybatis中文文档](https://mybatis.org/mybatis-3/zh/index.html)\\n- [微信小程序官方文档](https://developers.weixin.qq.com/miniprogram/dev/framework/)\\n- [Nodejs中文教程文档](http://nodejs.cn/learn)\\n- [Apache Web Server文档](http://httpd.apache.org/docs/)\\n- [Spring文档中文版](https://www.springcloud.cc/spring-reference.html)\\n- [Golang标准库文档中文版](https://studygolang.com/pkgdoc)\\n- [Java 8官方文档](https://docs.oracle.com/javase/8/docs/api/index.html)\\n- [Maven官方文档](http://maven.apache.org/guides/)\\n- [Tomcat 8官方文档](http://tomcat.apache.org/tomcat-8.0-doc/index.html)\\n\\n<!-- div:right-panel -->\\n\\n- [Spring Boot官方文档](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/)\\n- [RabbitMQ官方文档](https://www.rabbitmq.com/documentation.html)\\n- [RocketMQ官方文档](http://rocketmq.apache.org/docs/quick-start/)\\n- [Dubbo中文文档](https://dubbo.apache.org/zh/docs/)\\n- [Netty官方文档](https://netty.io/wiki/index.html)\\n- [Elasticsearch官方文档](https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html)\\n- [Spring Cloud官方文档](https://spring.io/projects/spring-cloud)\\n- [Docker官方文档](https://docs.docker.com/get-started/)\\n- [Kubernetes中文文档](https://kubernetes.io/zh/docs/home/)\\n- [Thymeleaf官方文档](https://www.thymeleaf.org/documentation.html)\\n- [Vue.js中文文档](https://cn.vuejs.org/v2/guide/)\\n- [React.js官方文档](https://reactjs.org/docs/getting-started.html)\\n- [Jenkins中文文档](https://www.jenkins.io/zh/doc/)\\n\\n<!-- panels:end -->\\n\\n<!-- tabs:end -->\\n\\n---\\n\\n## 常用本地软件\\n\\n---\\n\\n<p align=\\\"left\\\">\\n    <a href=\\\"https://mp.weixin.qq.com/s/ePhaYezFblgt0NgbvtWqww\\\" target=\\\"_blank\\\">\\n        <img src=\\\"https://cdn.jsdelivr.net/gh/justacoder99/r2coding@master/img/localsoftware.2x9vakmja2g.png\\\" width=\\\"\\\"/>\\n    </a>\\n</p>\\n\\n\\n这里将常用软件分为了5大类，包括：\\n\\n> - 社交/娱乐/上网\\n> - 办公软件\\n> - 效率和美化软件\\n> - UP主必备\\n> - 程序员生产力工具\\n\\n- [点击查看：我的常用软件大公开！](https://mp.weixin.qq.com/s/ONx6wjGjQSvOOIgnEBTNJQ)\\n\\n---\\n\\n## 基础软件开发环境和设施\\n\\n---\\n\\n**什么叫基础软件开发环境？**\\n\\n很好理解。学Java得要装JDK吧？学Python得要Python环境吧？学数据库得要MySQL吧？等等，这些在学习编程之前都是应该提前在自己的电脑上准备好的，而且尽量把全套都先备好，后面直接就用了。\\n\\n经常听到有小伙伴反馈和提问有关编程环境搭建和基础软件设施安装的相关问题。\\n\\n> - 啥？JDK明明装了，为啥还是not found？ \\n> - 咦？Maven明明配了加速，咋下载依赖还这么慢？ \\n> - 诶？MySQL明明装了，咋Navicat连会报错？ \\n> - 哦？Tomcat咋出不来页面？......\\n\\n每次都是照着网上现搜的帖子操作，一顿操作猛如虎，一看结果各种有问题，要不报错，要不环境起不来，等等。装个环境就浪费了很多时间，而且过了一段时间又忘，还得重新搜帖子，该踩的坑一个都不少...\\n\\n既然大家有这方面需求，想来想去，关于这个问题，我还是决定写一个事无巨细的PDF文档，把所有编程环境和基础软件设施的安装过程给详细地记录下来了。\\n\\n[熬10天夜，我肝出了这个PDF版「编程软件（环境）安装手册」](https://mp.weixin.qq.com/s/YNOZSQ5smo1uGE5ZttUZ_w)\\n\\n内容包含常见基础开发环境和设施的安装部署，包括：\\n\\n> - Linux操作系统\\n> - Git工具\\n> - Java环境JDK\\n> - Node基础环境\\n> - Python基础环境\\n> - Maven项目构建和管理\\n> - MySQL数据库\\n> - Redis缓存\\n> - RabbitMQ消息队列\\n> - Tomcat应用服务器\\n> - Nginx Web服务器\\n> - Docker环境\\n> - Kubernetes环境\\n> - Elasticsearch搜索引擎\\n> - ZooKeeer环境\\n> - Kafka消息队列\\n\\n大家有需要的可以：[点击此处 → 下载获取](https://mp.weixin.qq.com/s/YNOZSQ5smo1uGE5ZttUZ_w)！\\n\\n---\\n\\n## Linux操作系统\\n\\n---\\n\\n<p align=\\\"left\\\">\\n    <a href=\\\"https://mp.weixin.qq.com/s/ePhaYezFblgt0NgbvtWqww\\\" target=\\\"_blank\\\">\\n        <img src=\\\"https://cdn.jsdelivr.net/gh/justacoder99/r2coding@master/img/linuxos.qciprfz30dc.png\\\" width=\\\"\\\"/>\\n    </a>\\n</p>\\n\\n\\n实际企业级开发和项目部署，大部分情况下基本都是基于Linux环境进行的，所以掌握常用的命令、配置、网络和系统管理、基本的Shell编程等尽量还是要熟练一些，对后续项目实践都大有裨益。\\n\\n> [!Note]\\n>\\n>  - [**本章节置顶资源1：《Linux命令速查备忘手册.pdf》下载**](https://mp.weixin.qq.com/s/GJYVt376C_g4406ux5uw0Q)\\n>  - [**本章节置顶资源2：《Linux命令行大全.pdf》下载**](https://mp.weixin.qq.com/s/3rV556_0piRNsSpDYwuZ8g)\\n\\n- [常用Linux操作系统大盘点](https://mp.weixin.qq.com/s/x8rwsIOzYEPXmEVXmWJ4Tg)\\n- [人手一套Linux环境之：macOS版教程](https://mp.weixin.qq.com/s/WeZLtfrMdnISpX3v5WpJfA)\\n- [人手一套Linux环境之：Windows版教程](https://mp.weixin.qq.com/s/onVwwEQ1DAwbvK7qS2YNxg)\\n- [69张图：详细记录Ubuntu 20.04安装配置过程](https://mp.weixin.qq.com/s/vkLZ_3Jp4HdQ8PDIMYsGEw)\\n- [废柴电脑拯救计划：借助Debian搭建个人专属云服务器](https://mp.weixin.qq.com/s/YpWp-b3vcAtb_jBwCM7wtg)\\n- [常用Linux命令大整理](https://mp.weixin.qq.com/s/Kog6AfXYINIDwKMpJMkGFQ)\\n- [面试常问的20个Linux命令](https://mp.weixin.qq.com/s/3NI4FWuOfYMJBiKqqnpqMA)\\n- [Linux 桌面进化史](https://mp.weixin.qq.com/s/jQAJQo28UsY3YIxC5ci1sA)\\n- [Linux迎来29岁：从个人爱好到统治世界的操作系统内核！](https://mp.weixin.qq.com/s/6-yb1N-SwHr4EaQ-fvU4Ow)\\n- [漫画：Linux 内核到底长啥样？](https://mp.weixin.qq.com/s/4G6re30hxAacxmCLjP8KpQ)\\n- [资源下载 → 《Linux命令速查备忘手册.pdf》](https://mp.weixin.qq.com/s/GJYVt376C_g4406ux5uw0Q)\\n- [资源下载 → 《Linux命令行大全.pdf》](https://mp.weixin.qq.com/s/3rV556_0piRNsSpDYwuZ8g)\\n\\n---\\n\\n## 版本控制工具\\n\\n---\\n\\n<p align=\\\"left\\\">\\n    <a href=\\\"https://mp.weixin.qq.com/s/ePhaYezFblgt0NgbvtWqww\\\" target=\\\"_blank\\\">\\n        <img src=\\\"https://cdn.jsdelivr.net/gh/justacoder99/r2coding@master/img/gcm.1sv6s8asfzc0.jpeg\\\" width=\\\"\\\"/>\\n    </a>\\n</p>\\n\\n\\n- [资源下载 → 豆瓣9.1分的Pro Git学习手册YYDS！](https://mp.weixin.qq.com/s/xDYSG4uDz9rgNCuk0RxLjg)\\n- [科普篇：Git和SVN对比](https://mp.weixin.qq.com/s/bUYz9JwqAYH_Fn6nHPSmTg)\\n- [科普篇：5分钟了解Git的前世今生](https://mp.weixin.qq.com/s/VvpjFUXd6jcatACHyFPHfg)\\n- [科普篇：Git操作与常用命令集锦](https://mp.weixin.qq.com/s/swnwBiuyVmhs5iPqv3H6BQ)\\n- [原理篇：图解Git中的最常用命令](https://mp.weixin.qq.com/s/DRCeDhYiwQQToKukk4RM4g)\\n- [原理篇：从原理角度理解记忆Git常见命令](https://mp.weixin.qq.com/s/DQVVYOWdOPuRsy3m0fg6Xg)\\n- [实践篇：从实践中彻底上手Git](https://mp.weixin.qq.com/s/sp1YUQ2vnQaIGH4tO3j1Vw)\\n- [实践篇：Git分支开发](https://mp.weixin.qq.com/s/touo-rygtz0tG6y8NKw65A)\\n- [实践篇：如何使用GitHub Flow给开源项目贡献代码](https://mp.weixin.qq.com/s/JMNQi3BSTmKpF9vXMEdKHw)\\n- [技巧篇：一招搞定GitHub下载加速！](https://mp.weixin.qq.com/s/SYR4zvjhAH1mX9fxdp8cbA)\\n- [技巧篇：如何在同一台电脑上同时使用多个Git账号](https://mp.weixin.qq.com/s/Qt4bqReZU3ydIsMtCVC0eA)\\n\\n---\\n\\n## IDE/编辑器\\n\\n<p align=\\\"left\\\">\\n    <a href=\\\"https://mp.weixin.qq.com/s/ePhaYezFblgt0NgbvtWqww\\\" target=\\\"_blank\\\">\\n        <img src=\\\"https://cdn.jsdelivr.net/gh/justacoder99/r2coding@master/img/ide.720nw0czwbs0.png\\\" width=\\\"\\\"/>\\n    </a>\\n</p>\\n\\n\\n- [IDEA 2021.3升级发布](https://mp.weixin.qq.com/s/9Ar4KhQYSEP8B2mBaudWpQ)\\n- [IDEA 2021.2升级体验](https://mp.weixin.qq.com/s/WQiHpAv4bjEIz3fghzamEA)\\n- [IDEA 2021.1升级体验](https://mp.weixin.qq.com/s/dojfVvkrxru1eH8Pep7irw)\\n- [IDEA 2020.3升级体验](https://mp.weixin.qq.com/s/FhURpMKa9oi2FrV_0woOtw)\\n- [IDEA 2020.1升级体验](https://mp.weixin.qq.com/s/Ua4TYlcNntLr-x9WQirHyg)\\n- [IDEA插件分享：开发必备的IDEA神级插件大分享](https://mp.weixin.qq.com/s/xMwGAL_7sGkmnFvWZroVPw)\\n- [我的IDEA写代码小技巧：幸福感+效率爆棚](https://mp.weixin.qq.com/s/V2uAxmdq2e0Hl-y5GaD-Qw)\\n- [为啥我的IDEA Maven依赖下载总是失败？](https://mp.weixin.qq.com/s/KNk04dv6Z-ERrHiY03qdAw)\\n- [试水JetBrains官方新编程字体](https://mp.weixin.qq.com/s/RK_ygHgMjayL5-qTnlHbeg)\\n- [如何使用IDEA远程调试线上代码](https://mp.weixin.qq.com/s/WLTfgkPnJYJf9PZM8d8w4Q)\\n- [利用VS Code进行远程开发教程](https://mp.weixin.qq.com/s/ZDVYk188oPLugRI6oeVYIQ)\\n- [VS Code常用插件+快捷键整理](https://mp.weixin.qq.com/s/_3mwj5_MNln__3SSI8BJ3Q)\\n\\n---\\n\\n## API管理/文档管理\\n\\n---\\n\\n<p align=\\\"left\\\">\\n    <a href=\\\"https://mp.weixin.qq.com/s/ePhaYezFblgt0NgbvtWqww\\\" target=\\\"_blank\\\">\\n        <img src=\\\"https://cdn.jsdelivr.net/gh/justacoder99/r2coding@master/img/apidocs.2qlxsrvx2vy0.png\\\" width=\\\"\\\"/>\\n    </a>\\n</p>\\n\\n\\n- [科普篇：前后端都分离了，有哪些好用的API管理系统？](https://mp.weixin.qq.com/s/Ahs6fnIfFVVPOn3NZpIsNA)\\n- [科普篇：几款常用的在线文档神器](https://mp.weixin.qq.com/s/G6-6gqYnTvEsWOGIoj16ZQ)\\n- [一款零注解API接口文档生成工具](https://mp.weixin.qq.com/s/I_pH1V9iUu-IUayMA5oQSg)\\n\\n---\\n\\n## CI系统\\n\\n---\\n\\n<p align=\\\"left\\\">\\n    <a href=\\\"https://mp.weixin.qq.com/s/ePhaYezFblgt0NgbvtWqww\\\" target=\\\"_blank\\\">\\n        <img src=\\\"https://cdn.jsdelivr.net/gh/justacoder99/r2coding@master/img/ci.3iokn4xypxy0.png\\\" width=\\\"\\\"/>\\n    </a>\\n</p>\\n\\n\\n- [常用CI工具大盘点](https://mp.weixin.qq.com/s/PgoXJcJX_sm5132VGQoZ1w)\\n- [Jenkins Pipeline使用入门](https://mp.weixin.qq.com/s/Y2gxBmBK2HPvr1uKUUxRYA)\\n- [讨论：你们公司用啥CI守护系统？](https://mp.weixin.qq.com/s/4NlLEyy2QXX5_snX4r7FSw)\\n\\n## 其他软件/工具/网站\\n\\n- [自学数据结构和算法的9大工具和网站](https://mp.weixin.qq.com/s/f9dfQQbpKjMopH6m2Gjiiw)\\n- [12个常见的编程开发自学网站汇总](https://mp.weixin.qq.com/s/jFc-6QK2Mv1zHuhuFrqhog)\\n- [常用Web服务器软件大盘点](https://mp.weixin.qq.com/s/J1XjIwtEKjaltqWH-0qmgw)\\n- [9款最佳编程字体推荐](https://mp.weixin.qq.com/s/VB1jGIWWp4XdsLwXe-PKlQ)\\n- [5款时间管理工具推荐](https://mp.weixin.qq.com/s/71Cr9UxvQc6CdmguQIh-IA)\\n- [一个程序员的常用在线工具网站分享](https://mp.weixin.qq.com/s/oMAJaKDfr_bmgCVD0CX1oA)\\n- [2020年度开发者工具Top 100名单](https://mp.weixin.qq.com/s/VtmcuYGt96S4750UFYKnXQ)\\n- [Linux服务器上几个常用的监控小工具整理](https://mp.weixin.qq.com/s/zWIv5yBTD0Tvt8txb8znrA)\\n- [效率神器PowerToys使用攻略](https://mp.weixin.qq.com/s/LUPa_uSEd91Pj08VwxsxEQ)\\n- [22款适合程序员的终端生产力小工具推荐](https://mp.weixin.qq.com/s/k19ZT_yH4lzNLUYkH2GUJA)\\n- [9款优秀的代码比对工具推荐](https://mp.weixin.qq.com/s/IU5mmLxflgswICEo3BCWLA)\\n- [几款提升效率的软件神器](https://mp.weixin.qq.com/s/HZRz_A8bLcOTuzcezYEFZg)\\n- [命令行效率神器 NuShell ！](https://mp.weixin.qq.com/s/0f6JpBiPqCY8cZ2Ich0Lmg)\\n\\n---\\n\\n---\\n\\n# **计算机基础**\\n\\n---\\n\\n**计算机基础是最最重要的！** 即使后面的东西都没学（或者来不及学），基础部分是肯定需要完成的，这也是后面所有应用框架学习和做项目的基石；反之，在应用框架的学习或者做项目时如果感觉吃力，那就可能非常有必要回过头再来巩固对应的基础知识。\\n\\n计算机基础的学习不是一蹴而就的，需要一定的反复和回炉才能做到真正的融会贯通，需要一个过程。珍惜每一次回顾和复习基础的机会，应扎实精进，步步为营。\\n\\n那我们口口声声所说的编程基础（计算机基础）到底指是什么呢？\\n\\n此处整理为**六大方面：**\\n\\n- 一两门你最熟悉的编程语言（不求多，但求精！）\\n- 数据结构和算法\\n- 计算机网络\\n- 操作系统（计组）\\n- 数据库/SQL\\n- 设计模式\\n\\n---\\n\\n## 编程语言\\n\\n---\\n\\n语言在精不在多，切记！完全掌握了一门语言，上手其他的都不难！\\n\\n---\\n\\n<!-- tabs:start -->\\n\\n#### **Java**\\n\\n\\n- **基本功趣味学习（精讲）**\\n\\n  - [资源下载 → Java基础核心知识大总结pdf笔记下载](https://mp.weixin.qq.com/s/jn7oraFlhRkOmiv3rh74WA)\\n  - [夯实基本功之：Java程序员找对象攻虐！](https://mp.weixin.qq.com/s/aZg9SZT3DWkCkEsjlUjTtQ)\\n  - [夯实基本功之：浮点数在计算机中是如何表示的](https://mp.weixin.qq.com/s/LVpvmBO0GY6TC4gwL_12Yw)\\n  - [夯实基本功之：flaot和double使用时的大坑](https://mp.weixin.qq.com/s/UyYDt3HB8IO_AoSDLndhxA)\\n  - [夯实基本功之：为什么要面向接口编程](https://mp.weixin.qq.com/s/Dg9LcKJBrabcnvC_6wga-A)\\n  - [夯实基本功之：枚举精讲](https://mp.weixin.qq.com/s/DgOr7cat8SP0zoY7Ke3toQ)\\n  - [夯实基本功之：深拷贝/浅拷贝精讲](https://mp.weixin.qq.com/s/ypCIMGxyp7AX5cxG5UJ1Hg)\\n  - [夯实基本功之：序列化和反序列化精讲](https://mp.weixin.qq.com/s/0EfIUB9E-0Oh_Clwuxswuw)\\n  - [夯实基本功之：函数式编程例析](https://mp.weixin.qq.com/s/yI82juBiirJ56BZfGJezLw)\\n  - [夯实基本功之：如何去掉冗长的if/else代码](https://mp.weixin.qq.com/s/ufRf8DQQRYQI0q2VxG3hQg)\\n  - [夯实基本功之：注解精讲](https://mp.weixin.qq.com/s/gdYysBB3aD_HmPyvEThFXw)\\n  - [夯实基本功之：为什么不要用Date表示时间](https://mp.weixin.qq.com/s/v-Va_GuSUGr9HVAW84kloQ)\\n  - [夯实基本功之：去除烦人的NullPointerException空指针异常](https://mp.weixin.qq.com/s/RsC7peRsFaJAEcG2eTJb0Q)\\n  - [夯实基本功之：为什么要重写hashcode和equals方法](https://mp.weixin.qq.com/s/QZPezSruj0qvBUJEM4jB0g)\\n  - [夯实基本功之：Object类精讲](https://mp.weixin.qq.com/s/eJy74CbzthHMgRPOA_4wEA)\\n  - [夯实基本功之：List使用踩坑记录](https://mp.weixin.qq.com/s/9bw2-pkuYSKEnstb4KGsqQ)\\n  - [夯实基本功之：Map使用踩坑记录](https://mp.weixin.qq.com/s/D21mcfI4cxNf4D9ukjESog)\\n  - [夯实基本功之：面试必问的ConcurrentHashMap精讲](https://mp.weixin.qq.com/s/cnpfLL4TeL2oyEcHia6Bmg)\\n  - [夯实基本功之：死磕Java I/O流知识](https://mp.weixin.qq.com/s/xzV0uiQ0Q2ii5I54f8DPWQ)\\n  - [夯实基本功之：你一般是怎么遍历HashMap的](https://mp.weixin.qq.com/s/d93H9TwJKSnpkSBMYJ7QWQ)\\n  - [夯实基本功之：try-catch的使用姿势](https://mp.weixin.qq.com/s/AbZH57nUtePC728XfCvrcw)\\n  - [夯实基本功之：if和swictch性能例析](https://mp.weixin.qq.com/s/YbXBWhSlZTwY_bBqpNP2YA)\\n  - [夯实基本功之：Java HashMap源码剖析](https://mp.weixin.qq.com/s/xv0GmAU8fVlS_sxWKWUWYw)\\n  - [夯实基本功之：String性能提升10倍的几个用法](https://mp.weixin.qq.com/s/KRRLt0EaIwDEPCTGvqnWJA)\\n  - [实践篇：Java源码编译实战](https://mp.weixin.qq.com/s/K0ehqbxrzSz07nqnqRvn5A)\\n  - [面试篇：这10道基础Java面试题，虐哭了多少人](https://mp.weixin.qq.com/s/oBDrFnuk1lbfuNHkrhAC5w)\\n  - [面试篇：Java基础知识面试题大集合](https://mp.weixin.qq.com/s/f-qIQGbzwHcW5Ur51rCqgg)\\n  - [Java 11新特性例析](https://mp.weixin.qq.com/s/kNMQp-vjVK6Fq07xalZkng)\\n  - [Java 15新特性例析](https://mp.weixin.qq.com/s/1SVao6dMMLhNoFTOvnLy8g)\\n  - [科普：Java收不收费跟我们有毛关系吗？](https://mp.weixin.qq.com/s/QrWASACHkMGVop7gNe2DOA)\\n\\n\\n- **多线程和并发**\\n\\n  - [资源下载 → Java多线程+并发编程知识点详细总结PDF文档下载！](https://mp.weixin.qq.com/s/EGQAuvITVJT3fZUdQG84sw)\\n  - [夯实基本功之：Java并发之原子性、有序性、可见性](https://mp.weixin.qq.com/s/30__VavtpJxEojUjYglGhQ)\\n  - [夯实基本功之：ThreadLocal源码剖析](https://mp.weixin.qq.com/s/ND-nUCGvXTHkEClKqN1qrQ)\\n  - [夯实基本功之：Java线程池使用例析](https://mp.weixin.qq.com/s/TF04dB-i0q0-dOTqlprmYA)\\n  - [夯实基本功之：彻底搞懂多线程中的volatile](https://mp.weixin.qq.com/s/fxl3od5UObRrPGe2AVvAPA)\\n  - [夯实基本功之：面试必问的ConcurrentHashMap精讲](https://mp.weixin.qq.com/s/cnpfLL4TeL2oyEcHia6Bmg)\\n  - [夯实基本功之：详解Java并发编程中的各种锁](https://mp.weixin.qq.com/s/Sb1tZC_6CWE57TKvJeMmkA)\\n  - [Java并发和多线程基础面试题大集合](https://mp.weixin.qq.com/s/pIVf97W4DuAPNxq6zgRvsQ)\\n  - [科普向：Java线程和操作系统的线程到底有啥区别？](https://mp.weixin.qq.com/s/ykQ8wkBr-jHzbcD-7HGMEQ)\\n\\n\\n- **JVM虚拟机**\\n\\n  - [夯实基本功之：Java内存模型精讲](https://mp.weixin.qq.com/s/lEgHPertXyguZIkv61LlKQ)\\n  - [夯实基本功之：面试必问的JVM GC机制](https://mp.weixin.qq.com/s/bHkgpznnqixDNyDKwdAbOg)\\n  - [夯实基本功之：JVM垃圾回收硬核18问（附答案）](https://mp.weixin.qq.com/s/XsZUF2nBUSEJoGIA8RimJw)\\n  - [夯实基本功之：搞懂JVM的三大参数类型](https://mp.weixin.qq.com/s/TlX81xJ9fnuDIOTkDxrd1Q)\\n  - [夯实基本功之：了解G1垃圾收集器](https://mp.weixin.qq.com/s/KASLkkZnjGwVgm_1jbe-mA)\\n  - [实践篇：JDK源码编译上手实践](https://mp.weixin.qq.com/s/MDM6w2Dw_HYc9XzZevQNeA)\\n  - [实践篇：线上服务的YGC问题排查例析](https://mp.weixin.qq.com/s/-8xYoAkBUoavcSl69I0XJw)\\n  - [实践篇：线上服务的FGC问题排查例析](https://mp.weixin.qq.com/s/Sjh9qFPKF250vLQGZig6nw)\\n  - [面试题：Java虚拟机（JVM）面试题大集合1](https://mp.weixin.qq.com/s/T2DqgJ9-0QiRZQYUeR3c8w)\\n  - [面试题：Java虚拟机（JVM）面试题大集合2](https://mp.weixin.qq.com/s/ZYoeC8yyfReEJDFSqiW8hw)\\n\\n\\n<!-- tabs:end -->\\n\\n---\\n\\n## 数据结构+算法题\\n\\n---\\n\\n数据结构和算法题对于程序员的重要性不言而喻。参加过笔试或者面试过的小伙伴应该知道，可以说这个东西某一程度上直接决定了面试的成败，现在的互联网公司技术岗面试，数据结构+算法题基本都是必选项。\\n\\n除了几种基础数据结构类型得烂熟于心，基本的几大算法(或者说算法思想)也要了如指掌之外，参加求职前，不论是校招还是社招，非常有必要好好刷一刷LeetCode上的数据结构和算法题，以保持题感。\\n\\n---\\n\\n- [资源下载 → LeetCode算法刷题Golang版答案PDF文档](https://mp.weixin.qq.com/s/EaDLaLy3YjrNiSoNofwMMA)\\n- [资源下载 → LeetCode算法刷题C++版答案PDF文档](https://mp.weixin.qq.com/s/qR6KTfldk41lsOj1Ghp6Og)\\n- [资源下载 → LeetCode算法刷题Java版答案PDF文档](https://mp.weixin.qq.com/s/kWTJ9640mPegr5wqVE0GMg)\\n- [资源下载 → 谷歌学长的数据结构+算法题代码笔记手册](https://mp.weixin.qq.com/s/gXH98f1p5cCYVETCn9w9kA)\\n- [数据结构：24张图详解九大数据结构](https://mp.weixin.qq.com/s/ZVwIUN-xf9FuxOFXW8H3Nw)\\n- [数据结构：哈希表详解](https://mp.weixin.qq.com/s/UanDueZi3MwlcKYGMNQPGg)\\n- [数据结构：栈Stack的几种含义理解](https://mp.weixin.qq.com/s/v6rr0M9AW_kSMEtjkc-Mqw)\\n- [数据结构：各种树详解](https://mp.weixin.qq.com/s/k4-RaW4ROlo6chSXsO_4AA)\\n- [数据结构：跳表精讲](https://mp.weixin.qq.com/s/czkZcQL8mEqG2xeX8huqsA)\\n- [数据结构：数组和链表的性能对比](https://mp.weixin.qq.com/s/iG9zNHYLkEyHF3M4RpoWKw)\\n- [算法：十大经典排序算法大梳理 (动图+代码)](https://mp.weixin.qq.com/s/ekGdneZrMa23ALxt5mvKpQ)\\n- [算法：排序算法趣味对比](https://mp.weixin.qq.com/s/za_MJY3-r9Gfiu3BJfej7Q)\\n- [算法：二分法及其变种](https://mp.weixin.qq.com/s/1ExIav9uK4bvVnnf4t0H2Q)\\n- [算法：10张图搞定KMP算法](https://mp.weixin.qq.com/s/H1ttBFuBY5n3Dbh3YaTmlw)\\n- [算法：面试官最爱的字符串匹配算法精讲](https://mp.weixin.qq.com/s/FYx3acRh9JXAIb7y97G39A)\\n- [算法：8大常见算法思想总结](https://mp.weixin.qq.com/s/vGjcX4nHv6QT2-qKHZM8Dw)\\n- [算法：一文彻底学会递归思路解题](https://mp.weixin.qq.com/s/JLbjzCdVlJ_de2uGgBsUzw)\\n- [算法：10张动图理解递归](https://mp.weixin.qq.com/s/uuNaZfzhG3KaoEtez8Migw)\\n- [算法：分治算法详解](https://mp.weixin.qq.com/s/a3_bMRmTqZxMBruYsPC9-w)\\n- [算法：递归算法详解](https://mp.weixin.qq.com/s/tqGKHZzSyDBgEp-oWsOztQ)\\n- [算法：动态规划常见算法题例析](https://mp.weixin.qq.com/s/bGH_o1BsJtgnC2rFugtsRw)\\n- [算法：搞定算法复杂度分析](https://mp.weixin.qq.com/s/mBTyBkeNHoW7-Rcbv2Exwg)\\n- [算法：常用算法复杂度速查表](https://mp.weixin.qq.com/s/U6D1PNjuBAcRd5UZRr0F3w)\\n- [算法：常见刷题模式套路分析](https://mp.weixin.qq.com/s/JhHPAaOInIi4lZ-UrCLdgg)\\n- [算法：算法题刷题的心得和建议](https://mp.weixin.qq.com/s/Gz9-f_G6P-0tKrReAinw0A)\\n- [算法：求职必刷算法题大集锦](https://mp.weixin.qq.com/s/HUS12phrTbNzAE6uFHO9lg)\\n- [工具推荐：自学数据结构和算法的9大工具和网站](https://mp.weixin.qq.com/s/f9dfQQbpKjMopH6m2Gjiiw)\\n\\n---\\n\\n## 计算机网络\\n\\n---\\n\\n**为什么一定要学好计算机网络？**\\n\\n原因很简单，因为计算机网络中的各种协议栈是当下繁荣的互联网通信的基石，尤其建议要牢固熟练地掌握TCP/IP协议栈。\\n\\n---\\n\\n- [视频科普：计算机网络该怎么学](https://www.bilibili.com/video/BV1U4411M71p)\\n- [概念科普：如何系统地学习计算机网络](https://mp.weixin.qq.com/s/v34D8xWGPW8LgENy3G2QZA)\\n- [概念科普：计算机网络的89个核心概念](https://mp.weixin.qq.com/s/t8Dz-4D6BuBevZYz5Jhklg)\\n- [概念科普: 为什么网络IO会被阻塞](https://mp.weixin.qq.com/s/M9DANSrACS4xUt6UM03IxA)\\n- [工具科普：学网络时，可以先落实这几款利器工具](https://mp.weixin.qq.com/s/hZF2P4oQE6dsuXKWLEgDKA)\\n- [探究原理：浏览器输入网址一回车，后面到底发生了什么](https://mp.weixin.qq.com/s/t2Csrl7idUXISKW54cpV1g)\\n- [探究原理：你可能没有细究过的TCP/IP](https://mp.weixin.qq.com/s/AjcW7ELOTTqqdnUHpMbccQ)\\n- [探究原理：一个数据包在网络中到底是怎么游走的](https://mp.weixin.qq.com/s/07zloKKMUl-RHN6tWqZIJQ)\\n- [探究原理：两台计算机之间究竟是如何通信的](https://mp.weixin.qq.com/s/ZCddesfN0qISh3Rqo2jbWA)\\n- [探究原理：ping命令用得这么6，原理知道不](https://mp.weixin.qq.com/s/55bbQX2-SUNe6PEI9My5fA)\\n- [探究原理：一台Linux服务器最多能支撑多少个TCP连接](https://mp.weixin.qq.com/s/QuCxkSjdM_E12lXlpnhKIQ)\\n- [探究原理：都说HTTP协议无状态，这里的「状态」到底指什么](https://mp.weixin.qq.com/s/EZwOUGMrGKEF_POisJKmuw)\\n- [探究原理：Session/Cookie/Token](https://mp.weixin.qq.com/s/5oFKdbFWgZrwqESNTZn77w)\\n- [探究原理：Cookie、Session、Token 背后的故事](https://mp.weixin.qq.com/s/oMDCi0kLpn31T00QkxfkQA)\\n- [探究原理：三次握手底层深度理解](https://mp.weixin.qq.com/s/u242LSHnePBg_KbMc0ioTA)\\n- [知识总结：计网IP部分知识总结](https://mp.weixin.qq.com/s/21Tk-8gxpDoH9DNWNYCWmA)\\n- [知识总结：图解HTTP的前世今生](https://mp.weixin.qq.com/s/vk_QZDpJLVEXXNe1jYzd8w)\\n- [知识总结：HTTP和HTTPS协议大总结](https://mp.weixin.qq.com/s/8HJ-V1BbV9wp89HS-XulXw)\\n- [面试相关：2w+字的计算机网络常见面试题整理](https://mp.weixin.qq.com/s/C82YpO0gwC8LHcJSHbR81A)\\n- [面试相关：GET和POST到底有什么区别](https://mp.weixin.qq.com/s/H4gbg7bfnw61jZQcapTnMw)\\n- [面试相关：面试最爱问的三次握手和四次挥手问题](https://mp.weixin.qq.com/s/lFnyBaaP3f0eNcKGW5RtCg)\\n- [面试相关：HTTP常见面试题集合](https://mp.weixin.qq.com/s/FJGKObVnU61ve_ioejLrtw)\\n- [面试相关：计网TCP/UDP部分高频面试题集合](https://mp.weixin.qq.com/s/doxVJZ1G6187B4AOXb0JlA)\\n- [面试相关：计算机网络高频12问](https://mp.weixin.qq.com/s/PIGfhMaAx9R5C4x5eJQnIw)\\n- [实践系列：网络排错思路大总结](https://mp.weixin.qq.com/s/L8jmABzoI_e4dCcECenHtQ)\\n- [实践系列：抓个包看一看浏览器里的HTTP请求到底是如何完成的](https://mp.weixin.qq.com/s/_fB7r53BGZRvpG9YAPRQ8A)\\n\\n---\\n\\n## 操作系统\\n\\n---\\n\\n学好操作系统有利于我们深入理解计算机底层，这样平时在遇到疑难杂症时，能够更容易看到问题的本质，并高效解决；另外操作系统里的很多优秀的设计思想、经典的架构、算法、思路也值得我们反复理解和思考，很多思想在平时的工作中也可以借鉴和运用。\\n\\n---\\n\\n- [知识总结：学编程要懂的操作系统基础](https://mp.weixin.qq.com/s/ttncekujB82g88GRx3a6lQ)\\n- [知识总结：程序员必知的89个操作系统核心概念](https://mp.weixin.qq.com/s/VsQ7IpP-jnXSjJhOAzl-ew)\\n- [知识总结：操作系统主要概念硬核讲解](https://mp.weixin.qq.com/s/1Rzvu9uCTef5l_8Qw3ff0A)\\n- [知识总结：20张图详解操作系统内存管理部分知识点](https://mp.weixin.qq.com/s/m-AmxDVUfko7OTUsCapnPA)\\n- [知识总结：这才是对进程和线程最通俗易懂的解释](https://mp.weixin.qq.com/s/FoYiPB-2LuIpnTW8gck2EQ)\\n- [知识总结：操作系统并发三剑客之进程/线程/协程](https://mp.weixin.qq.com/s/Pfc31qoWfL6_uva6ePBmVA)\\n- [知识总结：操作系统高并发服务模型大科普](https://mp.weixin.qq.com/s/yXMgpAhz3JhtCtutMQnXvQ)\\n- [知识总结：这可能是讲死锁最通俗的一篇文章](https://mp.weixin.qq.com/s/7AHS5AlY2OaiLO4ag6zVMQ)\\n- [知识总结：一举拿下网络IO模型](https://mp.weixin.qq.com/s/vwJ5T7x1Jv4wa_x7nwr54Q)\\n- [知识总结：用一个故事来感受一下什么叫NIO](https://mp.weixin.qq.com/s/iFIt8t-q6hU-Ghwlj0hohw0)\\n- [知识总结：多路复用、非阻塞、线程与协程](https://mp.weixin.qq.com/s/xIfxzxCfbvBvQ2c0aUuA0A)\\n- [知识总结：搞懂原码/反码/补码](https://mp.weixin.qq.com/s/laP7Vxl6o40mIYBS7Cuj7A)\\n- [知识总结：30张图解高并发服务模型哪家强](https://mp.weixin.qq.com/s/a2Q1DQqOHdhtGEjJ4QxPew)\\n- [原理探究：新建一个空文件到底会占用多少磁盘空间？](https://mp.weixin.qq.com/s/vMvAgo9IWaLtDwxW1627YA)\\n- [面试相关：2.5w字+36张图+1周时间：爆肝操作系统面试题！](https://mp.weixin.qq.com/s/lR_A3jbfRiRjchz_lyyKxw)\\n- [面试相关：1.3w字的操作系统高频面试题大分享](https://mp.weixin.qq.com/s/oTEMOQY1xcG8uVceW-kLDA)\\n- [面试相关：学完操作系统内存管理，能回答这8个问题吗](https://mp.weixin.qq.com/s/5f3ku77xSO8UlaOsTkOnHQ)\\n\\n---\\n\\n## 数据库/SQL\\n\\n- [原理探究：详解一条SQL的执行过程](https://mp.weixin.qq.com/s/OnGaqyUpB58pC2rqqzIzgw)\\n- [原理探究：MySQL的数据存在磁盘上到底长什么样](https://mp.weixin.qq.com/s/36Jaj79Y8BxFoDB3Bwe7mg)\\n- [原理探究：数据库索引到底是什么](https://mp.weixin.qq.com/s/WMuxdG3ymNMWWDk1XhLwZQ)\\n- [原理探究：为什么MySQL索引要用B+ tree](https://mp.weixin.qq.com/s/d7Zfat2fP6IX5DMKKtEIjQ)\\n- [原理探究：为什么用了索引，SQL查询还是慢](https://mp.weixin.qq.com/s/-mOOchaXx_pKI6qWhohEnA)\\n- [原理探究：数据库索引的原理和使用准则](https://mp.weixin.qq.com/s/4K3borSZXt-yc5t5UJnJpQ)\\n- [原理探究：为什么你写的SQL那么慢](https://mp.weixin.qq.com/s/iBnav_WPrX5vjR-NbdNeQg)\\n- [原理探究：count(1)和count(*)到底哪个效率高](https://mp.weixin.qq.com/s/lyAFcnZIoyhACw78Nf9xQg)\\n- [原理探究：为什么阿里规定超过三张表禁止join](https://mp.weixin.qq.com/s/7vN9Nf20NGnvLKALHw_O1Q)\\n- [原理研究：什么是MySQL索引下推？](https://mp.weixin.qq.com/s/aPVs9Jrk07KsXcXdPOpx5A)\\n- [原理探究：为什么大公司后台数据库都要搞分库分表？](https://mp.weixin.qq.com/s/yflzIQFiNa3tDJm7U9P8ig)\\n- [原理探究：MySQL不会丢失数据的奥秘就藏在这里](https://mp.weixin.qq.com/s/QBeyJz2gVq1p7wBxcY1Gfw)\\n- [原理探究：MySQL主从复制那些事儿](https://mp.weixin.qq.com/s/CCLsmKSsodtkz4iX84Cdig)\\n- [实践应用：常见的SQL错误（不当）写法例析](https://mp.weixin.qq.com/s/caBYeVtZvNzbSs4q-6710Q)\\n- [实践应用：SQL优化的几个角度](https://mp.weixin.qq.com/s/hl11JYMwl30FsDVZ40CLVQ)\\n- [实践应用：数据库、数据表设计规范例析](https://mp.weixin.qq.com/s/hE2uKE2ffNCmeHLRn2KSTQ)\\n- [实践应用：梳理开发中常用的SQL优化途径](https://mp.weixin.qq.com/s/jl0j-T6XldN6Nq-jYoQ-gA)\\n- [实践应用：先更新数据库还是先更新缓存？](https://mp.weixin.qq.com/s/SPgtpfgv6bz2AfPa1CYYeQ)\\n- [实践应用：百亿级数据分表后如何分页查](https://mp.weixin.qq.com/s/EplL3kBx5vOXGDhDOP8NjQ)\\n- [实践应用：什么是SQL注入攻击](https://mp.weixin.qq.com/s/mnZT0Z5L6Hi6gRgEO1C9tg)\\n- [实践应用：用对这些场景下的数据库索引，领导说我有点东西](https://mp.weixin.qq.com/s/4K3borSZXt-yc5t5UJnJpQ)\\n- [实践应用：一个遗留项目的SQL优化实战录](https://mp.weixin.qq.com/s/MA7FVeJDMg8WDJABiBWpBA)\\n- [实践应用：误删数据库后该如何恢复](https://mp.weixin.qq.com/s/UYZZkrbAetgnPUjGa71fJA)\\n- [实践应用：如何科学根治慢SQL？](https://mp.weixin.qq.com/s/eQKphrkPeN_-EcWIxETz9Q)\\n- [面试相关：面试官最爱的数据库索引连环问](https://mp.weixin.qq.com/s/MLvJsJuFAHHcllqvk1nVRQ)\\n- [面试相关：30道保底的MySQL数据库面试题集合](https://mp.weixin.qq.com/s/aBboeqEphejICklAKLqS2Q)\\n- [面试相关：数据库自增ID用完了会怎样](https://mp.weixin.qq.com/s/WqM5mhnLOqZhcdzPLeWh5w)\\n- [面试相关：如何保证缓存和数据库的一致性问题？](https://mp.weixin.qq.com/s/RDOKLnG7P1j5Ehu3EyrsCQ)\\n- [面试相关：面试官最爱的MySQL连环问](https://mp.weixin.qq.com/s/8ddEzG-NzzFD35ehvbER7A)\\n- [面试相关：如何实现丝滑的数据库扩容](https://mp.weixin.qq.com/s/1VCC3i6ZCk7sb9kVRZ1czQ)\\n\\n---\\n\\n## 设计模式\\n\\n  - [资源下载 → 23种设计模式学习笔记PDF文档](https://mp.weixin.qq.com/s/miV4SH1Eb_FMogQ2XYvPuA)\\n  - [单例模式详解](https://mp.weixin.qq.com/s/dXUgiMacKjwTBwX16cXNBA)\\n  - [工厂模式讲解, 引入Spring IOC](https://mp.weixin.qq.com/s/8TfJ1uhMiKHnTmlF9D0L2Q)\\n  - [什么是动态代理模式](https://mp.weixin.qq.com/s/GT1-yrxJ5KF0xeMydbJDCQ)\\n  - [经典面试题：Spring用到了哪些设计模式](https://mp.weixin.qq.com/s/ZcKqGT2Sn4wVScExSF9Alg)\\n\\n## 其他\\n\\n- [每个开发人员都应该了解一点的UML规范](https://mp.weixin.qq.com/s/7-CTSWN-VLYgPH5H2nPU8w)\\n- [计算机时间到底是怎么来的](https://mp.weixin.qq.com/s/VFUg1S0ApuFzlTNYSCLkMQ)\\n- [乱码问题科普：“锟斤拷”的前世今生~](https://mp.weixin.qq.com/s/kTADQtTeOWPuXsvR9HsUIg)\\n- [从一个面试题看程序员的几项基本功](https://mp.weixin.qq.com/s/dVgDv1bNH8ivO0Ft0FtmZg)\\n\\n---\\n\\n# **应用框架和工具**\\n\\n---\\n\\n计算机基础聊完了，接下来就是应用和实践的环节了。这部分通常会涉及到一些**工具**、**编程环境**、以及**应用框架**。\\n\\n企业级开发不同于个人自学，出于**可复用性**、**稳定性**、**开发成本**、**开发效率**、**质量保证**等一系列因素的考量，不可能每一个功能、每一个组件都从0开始徒手造轮子，所以这时候各种应用框架和工具的出现就非常有帮助了。\\n\\n其实框架讲白了就是别人经过多年迭代写好的一套**工具**、**代码库**、**逻辑**、亦或是**流程**，把原本都需要从0开始手写的基本功能和组件都给封装进去，用户只要符合框架约定的规则进行编码，或者调用框架提供的方法或者工具，就能快速拉起业务功能，创造实际经济价值。\\n\\n所以框架的出现从不同的角度看也是有多面性的：对于企业级开发效率提升而言肯定是有帮助的，但是对于程序员个人思考编码能力提升却未必是好事，所以多注重基础、深挖原理，提升自身竞争力还是非常有必要的。\\n\\n\\n## Spring系列框架\\n\\n<!-- panels:start -->\\n\\n<!-- div:left-panel -->\\n\\n- [原理探究：Spring Boot项目究竟是怎么启动的？源码剖析](https://mp.weixin.qq.com/s/-MYQ-meSUcr-wZhfUbGq3Q)\\n- [原理探究：SpringBoot中@SpringBootApplication注解探秘](https://mp.weixin.qq.com/s/NqG7GzsPhwI76h3nujTCgQ)\\n- [原理探究：Spring @Autowired注解详解](https://mp.weixin.qq.com/s/uYNpoxcZ22goiev3uSus2w)\\n- [原理探究：Spring @Value注解详解](https://mp.weixin.qq.com/s/LGYSChfDLKuCQVMYGi0Omg)\\n- [原理探究：Spring框架是如何解决循环依赖问题的](https://mp.weixin.qq.com/s/m2DrtDxBzShtNF2Uk6zSAg)\\n- [原理探究：Spring中竟然有12种定义Bean的方法](https://mp.weixin.qq.com/s/YZT7NURQsNBSoSNsWBciQg)\\n- [原理探究：Spring的Controller究竟是单例还是多例，如何保证并发安全](https://mp.weixin.qq.com/s/PNmlpv786kgk5Pyhr5XSsw)\\n- [原理探究：为什么Spring的Bean默认是单例的](https://mp.weixin.qq.com/s/uQxxGpJJo4XfkLfHHp8nHw)\\n- [原理探究：单点登录(SSO)原理和实现](https://mp.weixin.qq.com/s/8brVERYV-XMIGB0Qly_mOg)\\n- [原理探究：面试常问的Spring IoC原理解析](https://mp.weixin.qq.com/s/0zRks2Cz36S8N70Uonb0OA)\\n- [原理探究：了解这些，就可以在Spring启动时为所欲为了](https://mp.weixin.qq.com/s/yXKPNB2dB99K_9gOWw6UHg)\\n- [实践应用：Spring Boot日志框架实践](https://mp.weixin.qq.com/s/uVqkLkkxot-zsoVPo1ri1A)\\n- [实践应用：利用神器BTrace追踪线上Spring Boot应用运行时信息](https://mp.weixin.qq.com/s/NH7ck79I3U0bJTEv37aECw)\\n- [实践应用：Spring Boot项目集成全局唯一ID生成器UidGenerator](https://mp.weixin.qq.com/s/GGeavPrGAzF1YOxCSk3YrQ)\\n- [实践应用：Spring Boot Admin2.0开箱体验](https://mp.weixin.qq.com/s/jdV8X_R9eeZRus5bfoSNNg)\\n- [实践应用：Spring Boot项目传参校验最佳实践](https://mp.weixin.qq.com/s/WQ-2fPOxk0GvSHiRR5-kQw)\\n- [实践应用：Spring Boot项目优雅传参方式讨论与实践](https://mp.weixin.qq.com/s/AdtUX9davFH-C60gBypnoA)\\n- [实践应用：基于Spring Security Oauth2的SSO单点登录+JWT权限控制实践](hhttps://mp.weixin.qq.com/s/ZLUOWYVsf6gDcT94X_saJg)\\n- [实践应用：封装一个好用的流水号ID生成器id-spring-boot-starter](https://mp.weixin.qq.com/s/AEWjwIEjVMf_cRixiIb7-Q)\\n- [实践应用：封装一个好用的elasticsearch-spring-boot-starter](https://mp.weixin.qq.com/s/V2jGlNn4EsM-_RheIk0TYg)\\n- [实践应用：Spring Boot项目集成jasypt-spring-boot加密组件](https://mp.weixin.qq.com/s/CTDEFxTKdk0qxK9VNSEIqw)\\n- [实践应用：基于Spring Security+JWT的权限系统设计](https://mp.weixin.qq.com/s/sMi1__Rw_s75YDaIdmTWKw)\\n  <!-- div:right-panel -->\\n- [实践应用：Spring Boot项目集成全局唯一ID生成器Vesta](https://mp.weixin.qq.com/s/u3ioahBPOno81dp3f2IDJA)\\n- [实践应用：Spring Boot项目集成Mybatis-Plus](https://mp.weixin.qq.com/s/SeXKbp9ee-FMNKfuSqpZFw)\\n- [实践应用：如何自制一个Spring Boot Starter并推到远端公服](https://mp.weixin.qq.com/s/J0UcedPhgHiTndk80CNikA)\\n- [实践应用：Spring Boot项目集成Ehcache缓存](https://mp.weixin.qq.com/s/OWX-hsk1F11Bvk2PWmnzxA)\\n- [实践应用：Spring Boot项目集成自然语言处理工具包HanLP](https://mp.weixin.qq.com/s/2-HdLggtBSmiyJI449cLow)\\n- [实践应用：基于Spring Boot实现图片上传/加水印一把梭操作](https://mp.weixin.qq.com/s/PGFDNoNuzlOR0m-tiIQGWw)\\n- [实践应用：Spring Boot项目集成EVCache缓存实践](https://mp.weixin.qq.com/s/d7do5NZeu4-yRo2RfJK7uA)\\n- [实践应用：Spring Boot项目集成Guava Cache本地缓存实践](https://mp.weixin.qq.com/s/C4VBAm4N3AjvXJ303wdV5A)\\n- [实践应用：Spring Boot项目集成MyBatis Generator进行数据层代码自动生成](https://mp.weixin.qq.com/s/ehe7Ub5RAYAql_oPZmerAQ)\\n- [实践应用：初探Kotlin+SpringBoot联合编程](http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247484900&idx=2&sn=45df41412575afb244f75de08b6bbe7f&chksm=fdded320caa95a36e85c510a1a72951b97a579511db7bd58aba2270020434b5579b8c3ce578f&scene=21#wechat_redirect)\\n- [实践应用：Spring Boot项目集成神器Lombok实践](http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247485020&idx=1&sn=3c3405807f96a597398f513c48bb094e&chksm=fdded098caa9598e6159bd7315180e149e6a789a3ee75d42b4acaaae96669504e08378eeddae&scene=21#wechat_redirect)\\n- [实践应用：Spring项目集成Lombok插件的优缺点分析](https://mp.weixin.qq.com/s/7pv9TwWHzF624sVMFDypvQ)\\n- [实践应用：Spring Boot应用监控实战](https://mp.weixin.qq.com/s/dt2B8Pku1dSXQuzDJYiEgQ)\\n- [实践应用：Spring Boot项目部署于外置Tomcat容器](https://mp.weixin.qq.com/s/UvFWTyFUUwfRXi1ZqmZdGA)\\n- [实践应用：Spring Boot热部署加持](https://mp.weixin.qq.com/s/M5Y1VInGRkx_RHJn9KWBpA)\\n- [实践应用：Spring Boot高效数据聚合之道](https://mp.weixin.qq.com/s/N7hzj4IR-di_KEgOts5OBg)\\n- [实践应用：Spring项目日志打印常见问题](https://mp.weixin.qq.com/s/p5LTCPgsGoEjuKL0F65PAg)\\n- [面试相关：Spring面试夺命连环10连问](https://mp.weixin.qq.com/s/euzbHPpQG2BSKl93N5L1Hg)\\n- [面试相关：Spring经典面试题集合](https://mp.weixin.qq.com/s/q4CajkpSUC8TCgv55VK5aQ)\\n- [面试相关：Spring Boot基础面试题集合](https://mp.weixin.qq.com/s/cLh9xCDkVG0KV-uaX8PkNw)\\n- [面试相关：Spring Cloud基础面试题集合](https://mp.weixin.qq.com/s/g0br3PfTmm8C_nkKbzE_ig)\\n- [面试相关：说说Spring用到了哪些设计模式？](https://mp.weixin.qq.com/s/ZcKqGT2Sn4wVScExSF9Alg)\\n- 内容持续更新中...\\n\\n\\n<!-- panels:end -->\\n\\n<!-- panels:start -->\\n\\n<!-- div:left-panel -->\\n\\n## 前后端分离\\n\\n- [概念科普：到底什么是RESTful ？](https://mp.weixin.qq.com/s/um5kDYBscf5sy7FUhmP7ww)\\n- [概念科普：RESTful风格的前世今生](https://mp.weixin.qq.com/s/lrFQUEITm_3zASIBR1mcQw)\\n- [概念科普：为什么需要前后端分离？](https://mp.weixin.qq.com/s/Y0z-3r_Mdm-etCwa0GmQmQ)\\n- [实践应用：前后端分离的接口规范，我们是如何做的？](https://mp.weixin.qq.com/s/zAOYAcR-6DEJU_s0qXe91g)\\n- [实践应用：前后端分离式开发：高效协作10条准则](https://mp.weixin.qq.com/s/niYHlrCDIkA1NqPVI_VJ8w)\\n- [实践应用：前后端分离后，接口联调总是甩锅怎么办？](https://mp.weixin.qq.com/s/TqSQ21nNvV5WwWDY_WItQA)\\n- [实践应用：前后端分离项目接口优雅数据交互例析](https://mp.weixin.qq.com/s/B-mJjBeJy5W7s2O79Iitqg)\\n- [实践应用：前后端分离实践中常遇到的跨域问题](https://mp.weixin.qq.com/s/Sjrgf3Tp3vR5zsNIiYzdpA)\\n- [工具推荐：前后端都分离了，该搞个好用的API管理系统了](https://mp.weixin.qq.com/s/Ahs6fnIfFVVPOn3NZpIsNA)\\n\\n<!-- div:right-panel -->\\n\\n## 分布式/微服务\\n\\n- [科普篇：企业里常用的软件架构剖析](https://mp.weixin.qq.com/s/NJFJ5UrzGk0cMGL1oZe0Bg)\\n- [科普篇：单体→分布式→微服务，这些年的软件架构是如何发育的](https://mp.weixin.qq.com/s/kfhCEDSUGwnNUbtGDL_rvQ)\\n- [科普篇：微服务架构的全局图景分析](https://mp.weixin.qq.com/s/Iy1dguNFkU73r1FxYIvlIQ)\\n- [科普篇：分布式架构负载均衡的几种方式](https://mp.weixin.qq.com/s/8CvoGCtGDvMHR91Lx89pxQ)\\n- [科普篇：RPC 技术(框架) 大科普](https://mp.weixin.qq.com/s/iTnKumgre3SzrBuWf8KB6g)\\n- [原理探究：什么是分布式事务](https://mp.weixin.qq.com/s/_56jq_p_nDUiBwaI2MTlmA)\\n- [原理探究：Redis分布式锁保姆级无死角分析](https://mp.weixin.qq.com/s/RViDM1WHE61SDLNKzUmTAg)\\n- [原理探究：如何设计一个高并发的秒杀架构？](https://mp.weixin.qq.com/s/fLLd-ml-gdo3-700iJso_A)\\n- [原理探究：亿级流量网关设计思路](https://mp.weixin.qq.com/s/J0aSVry1-Ss1OTA-jQAX3w)\\n- [原理探究：分布式架构的几个常见的坑](https://mp.weixin.qq.com/s/pg6lyAkgAaqSAZjiPgQTWA)\\n- [原理探究：什么是异地多活架构](https://mp.weixin.qq.com/s/Uv9pAOocep2rUW5qgGFSSw)\\n- [实践应用：RPC框架实践之：Apache Thrift](https://mp.weixin.qq.com/s/iCw-CHa5ITz6zoQI78Wb3w)\\n- [实践应用：RPC框架实践之：Google gRPC](https://mp.weixin.qq.com/s/LdzkBUzvyjMVW7pgzkA23w)\\n- [实践应用：Spring Cloud Feign的两种使用姿势](https://mp.weixin.qq.com/s/U4eustBBu9N-6B1SRsYc7w)\\n- [实践应用：Spring Cloud Eureka Server高可用之：在线扩容](https://mp.weixin.qq.com/s/oMsZquaphqEJqoGt1dt9WA)\\n- [实践应用：Eureka Server 开启Spring Security Basic认证](https://mp.weixin.qq.com/s/tRRwG1jnWi5r1XlbeBlv8g)\\n- [实践应用：Eureka Server启用 https服务指北](https://mp.weixin.qq.com/s/EAi7F3lBQ7ZrjSjNnFkj4g)\\n- [实践应用：微服务调用链追踪中心搭建](https://mp.weixin.qq.com/s/c55ejzWEU6SQBdcmTTRC1g)\\n- [实践应用：利用Zipkin追踪Mysql数据库调用链](https://mp.weixin.qq.com/s/wQRBxBBXCnP0YKPvtIPRcA)\\n- [实践应用：一个小团队的微服务架构改造之路](https://mp.weixin.qq.com/s/VjBiUmQNQPpSHeSVjK1C2A)\\n- 内容持续更新中...\\n\\n\\n<!-- div:left-panel -->\\n\\n## 容器/集群\\n\\n- [知识总结：常用虚拟化技术（VMware/KVM/Docker）对比](https://mp.weixin.qq.com/s/hVNMfh9nWdilXHSqvyS9ng)\\n- [知识总结：Docker从入门到干活，看这一篇入门](https://mp.weixin.qq.com/s/YlcvlUQ-xkz25PuYkeEQqw)\\n- [知识总结：Docker Swarm的前世今生](https://mp.weixin.qq.com/s/jf4qWaEYfn0CH5A6fG6MKw)\\n- [知识总结：编写高效Dockerfile的几条准则](https://mp.weixin.qq.com/s/MDGvWKkk4npWtqo2k4tsfg)\\n- [实践应用：Docker Swarm集群初探](https://my.oschina.net/hansonwang99/blog/1603378)\\n- [实践应用：利用ELK搭建Docker容器化应用日志中心](https://mp.weixin.qq.com/s/sO9_TixS0XrKoCKIS9oETw)\\n- [实践应用：Docker容器可视化监控中心搭建](https://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247483763&idx=1&sn=6ceb9e73540b5016dadfb212636b3855&scene=21#wechat_redirect)\\n- [实践应用：Docker容器跨主机通信之直接路由方式](https://mp.weixin.qq.com/s/evxiE6nhK6_y6zLMFWHTKQ)\\n- [实践应用：利用TICK搭建Docker容器可视化监控中心](https://mp.weixin.qq.com/s/-54IZbsX2nQIHaMZ1y6fTQ)\\n- [实践应用：利用Kubeadm部署Kubernetes 1.13.1集群实践录](https://mp.weixin.qq.com/s/wx68Chw1XaKQ1cb57jTiOw)\\n- [实践应用：利用K8S技术栈打造个人私有云（连载之：初章）](http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247483699&idx=1&sn=57b84f4ec72c8a578934cdb4225e6fe7&chksm=fdded7f7caa95ee198652c295b48b74565fd244afc4dccc0551b036c8216caab0397a1342d99&scene=21#wechat_redirect)\\n- [实践应用：利用K8S技术栈打造个人私有云（连载之：K8S集群搭建）](http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247483755&idx=1&sn=92a547c579aeacf1db9a8f0e56601b52&chksm=fdded7afcaa95eb9d6aa6cf323bff1df46692fc6a6672e0a483105f091ddf9670fb06d034e2a&scene=21#wechat_redirect)\\n- [实践应用：利用K8S技术栈打造个人私有云（连载之：K8S环境理解和练手）](http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247483758&idx=1&sn=629b6219a06374b2050703b9549037fa&chksm=fdded7aacaa95ebc9a3e88e839515b13109752c26c586032ae60219d2c3b24e13385e1bcd37c&scene=21#wechat_redirect)\\n- [实践应用：利用K8S技术栈打造个人私有云（连载之：基础镜像制作与实验）](http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247483759&idx=1&sn=8403d42fe1769a252f9ee2997fc2f561&chksm=fdded7abcaa95ebd8cdae86f4d692f1f6e92daab74dbbd8c56c6db8fe6aa2a3616ccce1eebb1&scene=21#wechat_redirect)\\n- [实践应用：利用K8S技术栈打造个人私有云（连载之：K8S资源控制）](http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247483760&idx=1&sn=d44f2c744ccdc965fb6c7e4d9efe9f92&chksm=fdded7b4caa95ea278d7363b4b4788d84914b915422a9cc98e7936c3bce0c7ce1197abfac13f&scene=21#wechat_redirect)\\n- 内容持续更新中...\\n\\n<!-- div:right-panel -->\\n\\n## 缓存/MQ/中间件/服务器\\n\\n- [缓存：Redis字符串类型内部编码剖析](https://mp.weixin.qq.com/s/tL2HVoeEH9hnalb9-tuoXg)\\n- [缓存：Redis哈希结构内存模型剖析](https://mp.weixin.qq.com/s/TdPcIMnv4iKIx3dRjei95A)\\n- [缓存：15张图解：为什么Redis这么快](https://mp.weixin.qq.com/s/0R0Evh1QX5BPOQt9233vpQ)\\n- [缓存：Redis面试全攻略、面试题大集合](https://mp.weixin.qq.com/s/6NobACeeKCcUy98Ikanryg)\\n- [缓存：把Redis当作队列来用，真的合适吗？](https://mp.weixin.qq.com/s/aNdWL3xKtjOd_briXL6Bjg)\\n- [缓存：缓存和数据库一致性问题，看这个就够了](https://mp.weixin.qq.com/s/RDOKLnG7P1j5Ehu3EyrsCQ)\\n- [缓存：面试官爱问的Redis高频面试题大集合](https://mp.weixin.qq.com/s/lxMP4-Z3DzQg5fRqLs9XNA)\\n- [缓存：1分钟科普：什么是缓存穿透、缓存雪崩、缓存击穿？](https://mp.weixin.qq.com/s/m9trzqE3Zd0KHC1cA3PlZQ)\\n- [缓存：如何构建一个稳定的高性能Redis集群？](https://mp.weixin.qq.com/s/x1AobPWpMufNWqrBnc5sZg)\\n- [缓存：轻量级memcached缓存代理twemproxy初探实践](https://mp.weixin.qq.com/s/Fgg2bNhdOTRfHIzGX86X3Q)\\n- [缓存：先更新数据库还是先更新缓存](https://mp.weixin.qq.com/s/SPgtpfgv6bz2AfPa1CYYeQ)\\n- [MQ：消息队列RabbitMQ快速入门上手](https://mp.weixin.qq.com/s/WMriUm27CZkiSWEt1f4lig)\\n- [MQ：Kafka快速入门上手](https://mp.weixin.qq.com/s/bUNAD2fkGTD73jVLw8rDHg)\\n- [MQ：从面试角度一文学完Kafka](https://mp.weixin.qq.com/s/o-rqnOH4FHeHaz0VqoHnFg)\\n- [MQ：为什么Kafka用得这么多？](https://mp.weixin.qq.com/s/vC0YbMJxHqs0JfcdAxjhHg)\\n- [MQ：刨根问底之Kafka到底会不会丢消息](https://mp.weixin.qq.com/s/PDvG5vSuA_NCkJ3mMUua5w)\\n- [MQ：大厂面试必备之消息队列连环问](https://mp.weixin.qq.com/s/u6_WH-r1bRc4m7CUm21Tew)\\n- [MQ：后端岗面试必备之Dubbo九连问](https://mp.weixin.qq.com/s/wM0Vj_YMh7881NwK-AwKSw)\\n- [服务器：Nginx服务器开箱体验](https://mp.weixin.qq.com/s/mif0NmY1Ij6lapHppb6LFg)\\n- [服务器：从一份配置清单详解Nginx服务器配置](https://mp.weixin.qq.com/s/099PJZE89JVNnaF0kwePDQ)\\n- [服务器：为什么Nginx能轻松撑起几万并发](https://mp.weixin.qq.com/s/VR1jEhJVXCfja3Pmo_kKkw)\\n- [搜索引擎：CentOS7上搭建多节点Elasticsearch集群](https://mp.weixin.qq.com/s/pdQNDMQQnXpoVKIA8JpyQQ)\\n- [搜索引擎：一文上手Elasticsearch常用可视化管理工具](https://mp.weixin.qq.com/s/BE8LrpviJNXGV41bhzGFTw)\\n- [搜索引擎：从一份定义文件详解ELK中Logstash插件结构](https://mp.weixin.qq.com/s/d2maG61HB2_rU56DYD2A9w)\\n- [搜索引擎：Elasticsearch索引的映射配置详解](https://mp.weixin.qq.com/s/C8JTxdjeSCR22xeAiLHHGg)\\n- [其他中间件：ZooKeeper面试常见十二问](https://mp.weixin.qq.com/s/ir0uurwo95hB3g__vTceJQ)\\n- [其他中间件：基于代理的数据库分库分表框架Mycat实践](https://mp.weixin.qq.com/s/3L5PcA0dGlrqJ2FjM_C77Q)\\n- 内容持续更新中...\\n\\n<!-- div:left-panel -->\\n\\n\\n<!-- panels:end -->\\n\\n---\\n\\n---\\n\\n# **书籍/资料推荐**\\n\\n---\\n\\n<p align=\\\"left\\\">\\n    <a href=\\\"https://mp.weixin.qq.com/s/ePhaYezFblgt0NgbvtWqww\\\" target=\\\"_blank\\\">\\n        <img src=\\\"https://cdn.jsdelivr.net/gh/justacoder99/r2coding@master/img/bookref.32p5e3kiqri0.jpg\\\" width=\\\"\\\"/>\\n    </a>\\n</p>\\n\\n\\n---\\n\\n毫无疑问的是，对于上文提到的 **「编程基础」** 部分，有大量经典的书籍值得阅读，每一本都是大师们若干年经验的汇聚，所以学好编程基础，对于我们普通人来说，看书是一个非常直接有效的方式。\\n\\n很多经典书看一遍可能远远不够，正所谓 **「初看懵、再看迷、三看发现有点小意思」** 讲的就是这个道理，这事急不得，而且有些东西的确需要一个反反复复的过程，有些甚至是在工作后的实践中才会遇到，所以珍惜每一次回炉重造的过程吧。\\n\\n---\\n\\n书籍资料推荐：\\n\\n- [Java开发：我的Java后端开发小书架](https://mp.weixin.qq.com/s/voNG467kSVfR-yjwelQhow)\\n- [Java开发：一份Java程序员的珍藏书单](https://mp.weixin.qq.com/s/OislKcvk-YSFstIl2PcrbA)\\n- [C/C++开发：自学C/C++书籍整理](https://www.bilibili.com/video/BV1ob411m76i)\\n- [前端开发：前端开发学习资料+书籍盘点](https://mp.weixin.qq.com/s/JFmj5cMhpJ2BKFq2p4IQGw)\\n- [嵌入式开发：嵌入式开发学习资料+书籍推荐](https://mp.weixin.qq.com/s/nkBsUgbuMK3ArHfFc2417w)\\n- [视频：我的计算机编程书单](https://www.bilibili.com/video/BV1kJ411W7pi)\\n\\n互联网开源教程推荐：\\n\\n- [羊哥当时自学数据结构和算法的9大工具](https://mp.weixin.qq.com/s/f9dfQQbpKjMopH6m2Gjiiw)\\n- [拜访了这位小哥的GitHub后，我失眠了](https://mp.weixin.qq.com/s/-Xp84QH5zQvvHaGWTJF9MA)\\n- [GitHub上这份计算机自学指南火了~](https://mp.weixin.qq.com/s/C48HcLYlLbYx1O82U0mpyg)\\n- [GitHub 40000星！收下这份宇宙最强「程序员生存指南」](https://mp.weixin.qq.com/s/V_Dfs44C3wtzlMGdUgY7qg)\\n\\n\\n**编程资源汇总和下载** → [点击查看](#资源下载)\\n\\n编程视频教程推荐 →  [点击查看](#视频教程)\\n\\n---\\n\\n# **项目经验获得**\\n\\n## 自学党如何获得项目经验？\\n\\n[---> 点击查看](https://www.bilibili.com/video/BV1Ai4y1V7PX)\\n\\n<!-- panels:start -->\\n\\n<!-- div:left-panel -->\\n\\n## 个人博客/网站搭建\\n\\n- [手把手教你从0开始搭建自己的个人博客之：Hexo版](https://www.bilibili.com/video/BV1Yb411a7ty)\\n- [手把手教你从0开始搭建自己的个人博客之：Hugo版](https://www.bilibili.com/video/BV1q4411i7gL)\\n- [手把手教你从0开始搭建自己的个人博客之：Wordpress+Docker版](https://www.bilibili.com/video/BV12E41127Uj)\\n- [建站神器：Hexo+Kaze+Gitee！](https://mp.weixin.qq.com/s/DrEc8FqycC15hp2X010wxQ)\\n- [Win10下Hexo博客搭建教程及阿里云服务器部署实战](https://mp.weixin.qq.com/s/JTTUYJTvtdT6X2fvLUBFZg)\\n\\n## 开源项目\\n\\n- [开源协议：开源软件的许可协议，先了解一下](https://mp.weixin.qq.com/s/ojGRSWSaJutAsBC0i5_6jA)\\n- [Java开源项目：看完这篇，别人的Java开源项目结构应该能看懂](https://mp.weixin.qq.com/s/5Ar5B9Ah2BdO8i9YjMQ7Qg)\\n- [Java开源项目：Java领域学习和练手的开源项目分享：第一弹](https://mp.weixin.qq.com/s/PmxVlkI9LUmnqqSk0Frqeg)\\n- [Java开源项目：Java领域学习和练手的开源项目分享：第二弹](https://mp.weixin.qq.com/s/y59hmDbQj1QglVj90viZqw)\\n- [Java开源项目：Java领域学习和练手的开源项目分享：第三弹](https://mp.weixin.qq.com/s/jjugnXIr3G0u7i9krbmmqg)\\n- [C/C++开源项目：几款适合初学者学习和练手的C/C++开源项目](https://mp.weixin.qq.com/s/bRNiqhZZXaoRwPEt8GIpLg)\\n- [C/C++开源项目：几款适合进阶学习和练手的C/C++开源项目](https://mp.weixin.qq.com/s/fNgOqKlITKa4yTbULO2Atw)\\n- [人工智能开源项目：AI领域几款标杆开源项目大巡礼](https://mp.weixin.qq.com/s/I9lr_SEg70OO_v-GOIUgjQ)\\n- [Python开源项目：几个炫酷的Python开源项目](https://mp.weixin.qq.com/s/Fu4OMojTJK0MrZohsLOx4w)\\n- [B站开源了哪些优秀的开源项目](https://mp.weixin.qq.com/s/Uq_Pf_mn6clC9XrgKclMDw)\\n- [读源码的7大心得总结](https://mp.weixin.qq.com/s/eWN7I8eHGE2exrdF3xziIA)\\n\\n<!-- div:right-panel -->\\n\\n## 实际项目需求和问题例析\\n\\n- [实践案例：实际项目业务接口的幂等性问题](https://mp.weixin.qq.com/s/gqvgysyGcP3yr0of_GwaTw)\\n- [实践案例：URL短链接服务如何设计](https://mp.weixin.qq.com/s/KPUuCU-q1SqnHzeyQeQzhw)\\n- [实践案例：亿行数据超大文件如何高效导入生产数据库](https://mp.weixin.qq.com/s/A-ZwcxlkB7Groe4k4Vq1Ew)\\n- [实践案例：订单系统一般怎么设计](https://mp.weixin.qq.com/s/-3g1ljoIrYWhhTHTF2RmLw)\\n- [实践案例：百亿级数据分表后如何分页查](https://mp.weixin.qq.com/s/EplL3kBx5vOXGDhDOP8NjQ)\\n- [实践案例：线上服务的YGC问题排查例析](https://mp.weixin.qq.com/s/-8xYoAkBUoavcSl69I0XJw)\\n- [实践案例：线上服务的FGC问题排查例析](https://mp.weixin.qq.com/s/Sjh9qFPKF250vLQGZig6nw)\\n- [实践案例：一个小团队的微服务架构改造之路](https://mp.weixin.qq.com/s/VjBiUmQNQPpSHeSVjK1C2A)\\n- [实践案例：一个遗留项目的SQL优化实战录](https://mp.weixin.qq.com/s/MA7FVeJDMg8WDJABiBWpBA)\\n- [实践案例：分布式锁使用不当导致的业务损失例析](https://mp.weixin.qq.com/s/OhkdQJ10biLOIezXc_vhkA)\\n- [实践案例：定时任务的几种简单方案](https://mp.weixin.qq.com/s/0p44f213fYdtr5LPJlrfLQ)\\n- [实践案例：项目常用的6种URL去重方案汇总](https://mp.weixin.qq.com/s/3zXdH2MALmWj57MWt0dImw)\\n- [实践案例：分布式系统架构的几个常见的坑](https://mp.weixin.qq.com/s/pg6lyAkgAaqSAZjiPgQTWA)\\n- [项目架构科普：企业里常用的软件架构剖析](https://mp.weixin.qq.com/s/NJFJ5UrzGk0cMGL1oZe0Bg)\\n- [项目架构科普：单体→分布式→微服务，这些年的软件架构是如何发育的](https://mp.weixin.qq.com/s/kfhCEDSUGwnNUbtGDL_rvQ)\\n- [项目架构科普：微服务架构的全局图景分析](https://mp.weixin.qq.com/s/Iy1dguNFkU73r1FxYIvlIQ)\\n- [原理解析：如何设计一个高并发的秒杀架构？](https://mp.weixin.qq.com/s/fLLd-ml-gdo3-700iJso_A)\\n- [原理解析：高并发系统设计的常见问题小结](https://mp.weixin.qq.com/s/ZzxmDbs08waUCtO7PeUhqw)\\n- [原理解析：亿级流量网关设计思路](https://mp.weixin.qq.com/s/J0aSVry1-Ss1OTA-jQAX3w)\\n- [原理解析：实际网站用户密码是如何存储的](https://mp.weixin.qq.com/s/Fd3cUDrqr0CsCl7FvZgd7Q)\\n- [原理解析：死磕搜索引擎背后的故事](https://mp.weixin.qq.com/s/Q1rZYvgklC_mBqfmIEC0Dw)\\n- [原理解析：用微信扫码登录的背后发生了什么](https://mp.weixin.qq.com/s/1lG-aAyVycO4zTbOqdy6BA)\\n- [原理解析：扫码付款背后的原理解析](https://mp.weixin.qq.com/s/RjVLsAhiMIYzsMhXJiReNg)\\n- [原理解析：收款码背后的原理剖析](https://mp.weixin.qq.com/s/1b9jBfwM9_RLkMPquqAuMw)\\n- [原理解析：支付掉单背后的几个问题](https://mp.weixin.qq.com/s/Kske9ahRcIUM5XEs2ZIN3A)\\n- [原理解析：手机没网却能支付成功的背后原理](https://mp.weixin.qq.com/s/VROp_0M3mz5Zhhnz0ZSmKQ)\\n- [原理解析：高并发场景下，先更新缓存还是先更新数据库？](https://mp.weixin.qq.com/s/1FDb63R_OMbSJo9VOWSr3Q)\\n- [原理解析：如何保证缓存和数据库的一致性问题？](https://mp.weixin.qq.com/s/RDOKLnG7P1j5Ehu3EyrsCQ)\\n- [原理解析：什么是分布式事务？](https://mp.weixin.qq.com/s/_56jq_p_nDUiBwaI2MTlmA)\\n- [原理解析：Redis分布式锁实践分析](https://mp.weixin.qq.com/s/RViDM1WHE61SDLNKzUmTAg)\\n- [原理解析：高并发下如何保证接口的幂等性？](https://mp.weixin.qq.com/s/QgliAGeUAISQVR4VNWqdgA)\\n- [原理解析：如何实现丝滑的数据库扩容](https://mp.weixin.qq.com/s/1VCC3i6ZCk7sb9kVRZ1czQ)\\n- [原理解析：如何构建一个稳定的高性能Redis集群？](https://mp.weixin.qq.com/s/x1AobPWpMufNWqrBnc5sZg)\\n- 内容持续更新中...\\n\\n\\n<!-- panels:end -->\\n\\n---\\n\\n# **面试准备和求职**\\n\\n---\\n\\n该板块会持续更新各技术方向的求职面试题集合、面经、以及一些小伙伴的求职心得与经历感悟。\\n\\n## 简历相关\\n\\n- [资源下载 → 简历模板下载（word版）](https://mp.weixin.qq.com/s/-qlU2-a-vvXWOHXzKHRm6A)\\n- [程序员写简历时必须注意的技术词汇拼写](https://mp.weixin.qq.com/s/q5gPSIiJqVvbI6Xa4dMXwA)\\n- [国内程序员最容易发音错误的单词集合](https://mp.weixin.qq.com/s/VJsp5SzGuOCGl-mWdbtCxQ)\\n\\n## 工作岗位科普\\n\\n- [科普：学C++的以后能从事哪些岗位](https://mp.weixin.qq.com/s/LEWBkJ5wkAIIcuv98g1Yhg)\\n- [科普：物联网行业的岗位、技能](https://mp.weixin.qq.com/s/AtSMfjq0GXQdVxo2o6s3-g)\\n- [科普：学Linux的以后能做什么](https://mp.weixin.qq.com/s/EA_iYwpSIMQGgpCrvvVOzA)\\n- 持续更新中 ...\\n\\n## 面试题集合\\n\\n<!-- panels:start -->\\n\\n<!-- div:left-panel -->\\n\\n- [C/C++：C语言/C++基础面试知识大集合](https://mp.weixin.qq.com/s/7mx58Idw1pL0MjPIFBUB1Q)\\n- [C/C++：68道C语言/C++常见面试题集合](https://mp.weixin.qq.com/s/BRQ-3uvstdZPO-cnLGCVzA)\\n- [Java：Java面试题硬核全梳理 ~](https://mp.weixin.qq.com/s/p1zxnGVeTDJiyjgowRIoBA)\\n- [Java：10道精选Java基础面试题集合](https://mp.weixin.qq.com/s/oBDrFnuk1lbfuNHkrhAC5w)\\n- [Java：Java基础知识面试题大集合](https://mp.weixin.qq.com/s/f-qIQGbzwHcW5Ur51rCqgg)\\n- [Java：Java集合硬核面试50问（附答案）](https://mp.weixin.qq.com/s/si_V6J_6ZZn4Akc12mMk2g)\\n- [Java：面试必问的JVM GC机制精讲](https://mp.weixin.qq.com/s/bHkgpznnqixDNyDKwdAbOg)\\n- [Java：JVM虚拟机面试题大集合](https://mp.weixin.qq.com/s/T2DqgJ9-0QiRZQYUeR3c8w)\\n- [Java：JVM垃圾回收硬核18问](https://mp.weixin.qq.com/s/XsZUF2nBUSEJoGIA8RimJw)\\n- [Java：面试官常问的一些JVM面试题](https://mp.weixin.qq.com/s/ZYoeC8yyfReEJDFSqiW8hw)\\n- [Java：Java并发和多线程基础面试题大集合](https://mp.weixin.qq.com/s/pIVf97W4DuAPNxq6zgRvsQ)\\n- [Java：面试常问的ThreadLocal源码剖析](https://mp.weixin.qq.com/s/ND-nUCGvXTHkEClKqN1qrQ)\\n- [Java：面试常问的线程池例析](https://mp.weixin.qq.com/s/TF04dB-i0q0-dOTqlprmYA)\\n- [Java：面试常问的volatile剖析](https://mp.weixin.qq.com/s/kQ498ifh4OUEDd829JIhnQ)\\n- [Java：面试必问的ConcurrentHashMap精讲](https://mp.weixin.qq.com/s/cnpfLL4TeL2oyEcHia6Bmg)\\n- [Java：说说什么是Java内存模型](https://mp.weixin.qq.com/s/lEgHPertXyguZIkv61LlKQ)\\n- [Java：浮点数精度问题面试例析](https://mp.weixin.qq.com/s/VXRRMabz_fvwnZeLWT-ybg)\\n- [计网：2w+字的计算机网络常见面试题整理](https://mp.weixin.qq.com/s/C82YpO0gwC8LHcJSHbR81A)\\n- [计网：面试最爱问的三次握手和四次挥手问题](https://mp.weixin.qq.com/s/lFnyBaaP3f0eNcKGW5RtCg)\\n- [计网：计算机网络高频12问](https://mp.weixin.qq.com/s/PIGfhMaAx9R5C4x5eJQnIw)\\n- [计网：GET和POST到底有什么区别](https://mp.weixin.qq.com/s/H4gbg7bfnw61jZQcapTnMw)\\n- [计网：TCP/UDP 部分高频面试题大集合](https://mp.weixin.qq.com/s/doxVJZ1G6187B4AOXb0JlA)\\n- [计网：HTTP常见面试题集合](https://mp.weixin.qq.com/s/FJGKObVnU61ve_ioejLrtw)\\n- [计网：浏览器输入网址并回车，后面到底发生了什么](https://mp.weixin.qq.com/s/t2Csrl7idUXISKW54cpV1g)\\n- [计网：都说HTTP协议是无状态的，这里的「状态」到底指什么？](https://mp.weixin.qq.com/s/EZwOUGMrGKEF_POisJKmuw)\\n- [操作系统：操作系统面试题集合](https://mp.weixin.qq.com/s/lR_A3jbfRiRjchz_lyyKxw)\\n- [操作系统：内存管理部分8个常见面试题汇总](https://mp.weixin.qq.com/s/5f3ku77xSO8UlaOsTkOnHQ)\\n- [操作系统：操作系统面试题大分享](https://mp.weixin.qq.com/s/oTEMOQY1xcG8uVceW-kLDA)\\n- [操作系统：面试常问的20个Linux命令](https://mp.weixin.qq.com/s/3NI4FWuOfYMJBiKqqnpqMA)\\n- [应用框架：Spring夺命连环10连问](https://mp.weixin.qq.com/s/euzbHPpQG2BSKl93N5L1Hg)\\n- [应用框架：Spring 经典面试题大集合](https://mp.weixin.qq.com/s/q4CajkpSUC8TCgv55VK5aQ)\\n- [应用框架：Spring Boot基础面试题大集合](https://mp.weixin.qq.com/s/cLh9xCDkVG0KV-uaX8PkNw)\\n- [应用框架：Spring Cloud基础面试题大集合](https://mp.weixin.qq.com/s/g0br3PfTmm8C_nkKbzE_ig)\\n\\n<!-- div:right-panel -->\\n\\n- [数据库：MySQL面试硬核25问（附答案）](https://mp.weixin.qq.com/s/vdOOVQtZhrJXsvRUjq0HqQ)\\n- [数据库：先更新数据库还是先更新缓存？](https://mp.weixin.qq.com/s/SPgtpfgv6bz2AfPa1CYYeQ)\\n- [数据库：如何保证缓存和数据库的一致性问题？](https://mp.weixin.qq.com/s/RDOKLnG7P1j5Ehu3EyrsCQ)\\n- [数据库：面试官最爱的MySQL连环问](https://mp.weixin.qq.com/s/8ddEzG-NzzFD35ehvbER7A)\\n- [数据库：如何实现丝滑的数据库扩容](https://mp.weixin.qq.com/s/1VCC3i6ZCk7sb9kVRZ1czQ)\\n- [数据库：数据库索引到底是什么](https://mp.weixin.qq.com/s/WMuxdG3ymNMWWDk1XhLwZQ)\\n- [数据库：为什么MySQL索引要用B+ tree](https://mp.weixin.qq.com/s/d7Zfat2fP6IX5DMKKtEIjQ)\\n- [数据库：为什么用了索引，SQL查询还是慢](https://mp.weixin.qq.com/s/-mOOchaXx_pKI6qWhohEnA)\\n- [数据库：慢SQL背后的原理是什么](https://mp.weixin.qq.com/s/iBnav_WPrX5vjR-NbdNeQg)\\n- [数据库：30道保底的MySQL数据库面试题汇总](https://mp.weixin.qq.com/s/aBboeqEphejICklAKLqS2Q)\\n- [数据库：用心整理的9道MySQL面试题](https://mp.weixin.qq.com/s/JQCtqM6aep3jtgiRL_9J5g)\\n- [中间件：面试官爱问的Redis高频面试题集合](https://mp.weixin.qq.com/s/lxMP4-Z3DzQg5fRqLs9XNA)\\n- [中间件：Redis面试全攻略、面试题大集合](https://mp.weixin.qq.com/s/6NobACeeKCcUy98Ikanryg)\\n- [中间件：什么是缓存穿透、缓存雪崩、缓存击穿？](https://mp.weixin.qq.com/s/m9trzqE3Zd0KHC1cA3PlZQ)\\n- [中间件：说说为什么Redis能这么快？](https://mp.weixin.qq.com/s/0R0Evh1QX5BPOQt9233vpQ)\\n- [中间件：如何构建一个稳定的高性能Redis集群？](https://mp.weixin.qq.com/s/x1AobPWpMufNWqrBnc5sZg)\\n- [中间件：把Redis当作队列来用，真的合适吗？](https://mp.weixin.qq.com/s/aNdWL3xKtjOd_briXL6Bjg)\\n- [中间件：Redis分布式锁的详细分析](https://mp.weixin.qq.com/s/RViDM1WHE61SDLNKzUmTAg)\\n- [中间件：ZooKeeper面试十二连问](https://mp.weixin.qq.com/s/ir0uurwo95hB3g__vTceJQ)\\n- [中间件：消息队列面试连环问总结](https://mp.weixin.qq.com/s/xpSel2nsLkf3yck5edNMJQ)\\n- [中间件：Kafka面试要点梳理](https://mp.weixin.qq.com/s/o-rqnOH4FHeHaz0VqoHnFg)\\n- [中间件：说说你对RPC技术是怎么理解的？](https://mp.weixin.qq.com/s/iTnKumgre3SzrBuWf8KB6g)\\n- [中间件：后端岗面试必备之Dubbo九连问](https://mp.weixin.qq.com/s/wM0Vj_YMh7881NwK-AwKSw)\\n- [中间件：为什么Nginx能轻松撑起几万并发？](https://mp.weixin.qq.com/s/VR1jEhJVXCfja3Pmo_kKkw)\\n- [系统架构：企业里常用的软件架构科普](https://mp.weixin.qq.com/s/NJFJ5UrzGk0cMGL1oZe0Bg)\\n- [系统架构：单体→分布式→微服务，这些年的软件架构是怎么发展的](https://mp.weixin.qq.com/s/kfhCEDSUGwnNUbtGDL_rvQ)\\n- [系统架构：如何设计一个高并发的秒杀架构？](https://mp.weixin.qq.com/s/fLLd-ml-gdo3-700iJso_A)\\n- [系统架构：分布式架构的几个常见的坑](https://mp.weixin.qq.com/s/pg6lyAkgAaqSAZjiPgQTWA)\\n- [系统架构：说说分布式架构负载均衡的几种方式](https://mp.weixin.qq.com/s/8CvoGCtGDvMHR91Lx89pxQ)\\n- [系统架构：说说什么是分布式事务？](https://mp.weixin.qq.com/s/_56jq_p_nDUiBwaI2MTlmA)\\n- [系统架构：亿级流量网关的设计思路](https://mp.weixin.qq.com/s/J0aSVry1-Ss1OTA-jQAX3w)\\n- [设计模式：说说Spring用到了哪些设计模式？](https://mp.weixin.qq.com/s/ZcKqGT2Sn4wVScExSF9Alg)\\n\\n<!-- panels:end -->\\n\\n## 求职经历分享\\n\\n- [小伙伴经历分享：Linux后台开发该如何准备](https://mp.weixin.qq.com/s/joFBDntI9PmyVRiKPHwpRg)\\n- [二本无实习上岸滴滴京东58复盘(一)](https://mp.weixin.qq.com/s/V0nRwXQlkNBnBneERZQURQ)\\n- [二本无实习上岸滴滴京东58复盘(二)](https://mp.weixin.qq.com/s/BnbBQGL-S2sGdRtNh7DN1A)\\n- [小伙伴面经分享(一)：深信服(含答案)](https://mp.weixin.qq.com/s/3YfKHo2lW-NC1tEA_u-mlQ)\\n- [小伙伴面经分享(二)：京东(含答案)](https://mp.weixin.qq.com/s/sc-7rc6obYZNFcc1mjNPAg)\\n- [一位程序媛的秋招软件开发岗面试经历](https://mp.weixin.qq.com/s/jAPYcMULqQl6AE_Vv7BZhQ)\\n- [写简历→面试→谈薪：一绿向北](https://mp.weixin.qq.com/s/0RoFVAezxW8cl3bjlAHbQg)\\n- [小红书后台开发岗面试经历复盘~](https://mp.weixin.qq.com/s/4L3J45Wj81yjoZIQ3ZVSog)\\n- [国企和银行：面试都问些啥？如何准备？](https://mp.weixin.qq.com/s/34SdkDyMvpVmoCFEB4UF-g)\\n- [招银网络（银行科技岗）面试都问了些啥？](https://mp.weixin.qq.com/s/4hP8s7TzsOv_tdQtOdCdig)\\n- [准备提前批？还是去实习？还是准备秋招？](https://mp.weixin.qq.com/s/jy0g3ohLzbtD-6JeCeMVvw)\\n- [7面Google，面经分享](https://mp.weixin.qq.com/s/9Fb8w2XwkXQpj8agBtdmFg)\\n- [化学专业大二转码的抉择之路](https://mp.weixin.qq.com/s/j6poLkiomb80jTE7EaFVJA)\\n- [拿到腾讯实习Offer的经历分享](https://mp.weixin.qq.com/s/-27fvvzBpmwwuAFANRoeIA)\\n- [怎么准备国企和银行？](https://mp.weixin.qq.com/s/YP4qafQ8gPbB7W0CkfACug)\\n- [去银行当程序员是一种什么体验](https://mp.weixin.qq.com/s/u_jIpGfmH4BHYS7hIlQk9w)\\n\\n\\n## 城市/公司选择\\n\\n- [一二线城市知名IT互联网公司总名单](https://mp.weixin.qq.com/s/VFocc914mGTrDzodI-MF1A)\\n- [常见互联网公司职级和薪资一览](https://mp.weixin.qq.com/s/5gtu7B05EKbPDXvhha5uNQ)\\n- [常见互联网公司时薪排行榜](https://mp.weixin.qq.com/s/wvdzBTcLLaeEtCqZI6T_Qg)\\n\\n---\\n\\n- [北京有哪些知名的IT/互联网公司？](https://mp.weixin.qq.com/s/f8J0pW8Sdj9_PKO2kV3mqw)\\n- [成都有哪些知名的IT/互联网公司？](https://mp.weixin.qq.com/s/UDWHt3QwsZBfZ25-pddwhQ)\\n- [武汉有哪些知名的IT/互联网公司？](https://mp.weixin.qq.com/s/bjHmAtPrSKQCDjfr9Mu0_Q)\\n- [南京有哪些知名的IT/互联网公司？](https://mp.weixin.qq.com/s/kskE2wJx_QtT6vCgsrUgIA)\\n- [合肥有哪些知名的IT/互联网公司？](https://mp.weixin.qq.com/s/tBNWFJbkjkV0bEPh4t9VQg)\\n- [深圳有哪些知名的IT/互联网公司？](https://mp.weixin.qq.com/s/dtJBi4QXXTrGkKTPM0y7VA)\\n- [成都有哪些知名的IT/互联网公司？](https://mp.weixin.qq.com/s/t4L45znsZRmWQ7MIQQtvhg)\\n- [西安有哪些知名的IT/互联网公司？](https://mp.weixin.qq.com/s/eD3tjUC4qASHH0WSWhz57Q)\\n- [长沙有哪些知名的IT/互联网公司？](https://mp.weixin.qq.com/s/UQHJ-iZDvQb3RLwQsELbUQ)\\n- [武汉有哪些知名的IT/互联网公司？](https://mp.weixin.qq.com/s/6dh1jbmuDqnHBoM7beTQbg)\\n- [天津有哪些知名的IT/互联网公司？](https://mp.weixin.qq.com/s/Ks9XLLUh099wSHWG0OBf1g)\\n- [郑州有哪些知名的IT/互联网公司？](https://mp.weixin.qq.com/s/8-uZUrG8_ziR5tKl1K8YNw)\\n- [杭州有哪些知名的IT/互联网公司？](https://mp.weixin.qq.com/s/Bwu0MDQhZiaY0vj3HsEsLg)\\n- [广州有哪些知名的IT/互联网公司？](https://mp.weixin.qq.com/s/s5UhdFyj9-8bqwQyZUMvVA)\\n- [青岛有哪些知名的IT/互联网公司？](https://mp.weixin.qq.com/s/Miu3eC6hqJlK8fi8Qr-DtQ)\\n- [上海有哪些知名的IT/互联网公司？](https://mp.weixin.qq.com/s/zYI8qW3Zfu2ySeO-PDqwZA)\\n- [大连有哪些知名的IT/互联网公司？](https://mp.weixin.qq.com/s/12inr2oRTULf7NhYOBGMYw)\\n- [苏州有哪些知名的IT/互联网公司？](https://mp.weixin.qq.com/s/529Zv24uToDW4xxEOFdiqw)\\n\\n## 其他求职相关问题\\n\\n- [为什么有些大公司技术却弱爆了？](https://mp.weixin.qq.com/s/QUJzl1ZG77DDnQNK0OAsHg)\\n- [嵌入式行业到底有没有搞头？](https://mp.weixin.qq.com/s/iV7DMApxhEw5YL-upIowVA)\\n- [找工作时，公司所说的「给期权」到底是什么东西？](https://mp.weixin.qq.com/s/9XMAvP_t0B1Ev57-ZC42yw)\\n- [入职一家公司，应该选择新业务还是老业务？](https://mp.weixin.qq.com/s/cu7mDeU2q2uEG8Q0CPzDEA)\\n- [采访了一位技术总监：聊了聊跳槽的心态问题](https://mp.weixin.qq.com/s/NGJc71cW2TKEONe6jhIUSg)\\n- [程序员从技术→管理，要走哪些路？](https://mp.weixin.qq.com/s/4_MB3L511h7qoXNxPRdOvQ)\\n\\n\\n---\\n\\n<a name=\\\"视频教程\\\"></a>\\n\\n# **视频教程推荐**\\n\\n---\\n\\n对于学习编程的小伙伴来说，网上有海量现成的宝贵视频学习资源可供食用。\\n\\n所以该板块会持续甄选和更新互联网上那些优秀的、值得反复观看的技术视频教程。\\n\\n---\\n\\n- [数据结构和算法：《郝斌 数据结构入门》](https://www.bilibili.com/video/BV11s41167h6)\\n- [数据结构和算法：《数据结构-浙江大学》](https://www.bilibili.com/video/BV1JW411i731)\\n- [数据结构和算法：《数据结构与算法基础（青岛大学-王卓）》](https://www.bilibili.com/video/BV1nJ411V7bd)\\n- [数据结构和算法：《尚硅谷 Java数据结构与算法）》](https://www.bilibili.com/video/BV1E4411H73v)\\n- [计算机网络：《计算机网络微课堂》](https://www.bilibili.com/video/BV1c4411d7jb)\\n- [计算机网络：《2019 王道考研 计算机网络》](https://www.bilibili.com/video/BV19E411D78Q)\\n- [计算机网络：《韩立刚 计算机网络》](https://www.bilibili.com/video/BV1gV411h7r7)\\n- [计算机网络：《计算机网络（谢希仁第七版）》](https://www.bilibili.com/video/BV1H3411y7q6)\\n- [操作系统：《2020 南京大学  操作系统：设计与实现 (蒋炎岩) 》](https://www.bilibili.com/video/BV1N741177F5)\\n- [操作系统：《操作系统（哈工大李治军老师）》](https://www.bilibili.com/video/BV1d4411v7u7)\\n- [计算机组成原理：《计算机组成原理（哈工大刘宏伟）》](https://www.bilibili.com/video/BV1t4411e7LH)\\n- [编译原理：《编译原理（哈工大）》](https://www.bilibili.com/video/BV1zW411t7YE)\\n- 更多的视频教程资源会持续更新，敬请期待…\\n\\n\\n---\\n\\n<a name=\\\"资源下载\\\"></a>\\n\\n# **资源汇总和下载**\\n\\n---\\n\\n该版块会持续更新那些优秀的编程资源，**包括但不限于：** 各种硬核的PDF笔记、软件包、技术手册、自制文档、题解解析、简历模板、面试题文档 等等。\\n\\n---\\n\\n## 编程学习资源大整理\\n\\n前段时间我花了大把力气，把自用的编程学习资源做了个大整理。\\n\\n都是纯肝货，目录如下，有需要的可以自取。\\n\\n![](https://cdn.jsdelivr.net/gh/justacoder99/r2coding@master/img/rescollection.2twl61h5k0s0.jpeg)\\n\\n- 下载链接：https://pan.baidu.com/s/1jEjcF96iVAXEXaadE1V6RQ\\n- 提取码：f23d\\n\\n## PDF干货笔记下载\\n\\n- [下载 → LeetCode算法刷题Golang版答案PDF文档](https://mp.weixin.qq.com/s/EaDLaLy3YjrNiSoNofwMMA)\\n- [下载 → LeetCode算法刷题C++版答案PDF文档](https://mp.weixin.qq.com/s/qR6KTfldk41lsOj1Ghp6Og)\\n- [下载 → LeetCode算法刷题Java版答案PDF文档](https://mp.weixin.qq.com/s/kWTJ9640mPegr5wqVE0GMg)\\n- [下载 → 谷歌学长的数据结构+算法题代码笔记手册](https://mp.weixin.qq.com/s/gXH98f1p5cCYVETCn9w9kA)\\n- [下载 → 再肝两夜，写了个「服务器项目部署」实战PDF手册](https://mp.weixin.qq.com/s/JUJ6qu_ec3s1JmTxQt_V3g)\\n- [下载 → 熬10天夜，肝出了这个PDF版「软件安装手册」](https://mp.weixin.qq.com/s/YNOZSQ5smo1uGE5ZttUZ_w)\\n- [下载 → 熬了7天夜，羊哥肝了个Linux速查备忘手册！](https://mp.weixin.qq.com/s/GJYVt376C_g4406ux5uw0Q)\\n- [下载 → Java后端开发学习路线+知识点梳理总结](https://mp.weixin.qq.com/s/x9E7ogAxFNpODXkAXCZZ3w)\\n- [下载 → 前端开发学习路线+知识点梳理总结](https://mp.weixin.qq.com/s/xUKlD-Ro4x55NfANAwxJUw)\\n- [下载 → 大数据开发学习路线+知识点梳理总结](https://mp.weixin.qq.com/s/vBCwU-BCsGVNpjJM__LheQ)\\n- [下载 → 嵌入式开发学习路线+知识点梳理总结](https://mp.weixin.qq.com/s/nkBsUgbuMK3ArHfFc2417w)\\n- [下载 → C/C++后台开发学习路线+知识点梳理总结](https://mp.weixin.qq.com/s/ac8vgjob8nDqM1Q7FGLRiA)\\n- [下载 → 找工作简历模板集(word格式) ](https://mp.weixin.qq.com/s/EKBRCNr_3n0y8CCSUNPdPg)\\n- [下载 → 程序员写简历时的技术词汇拼写规范PDF手册](https://mp.weixin.qq.com/s/q5gPSIiJqVvbI6Xa4dMXwA)\\n- [下载 → Java基础核心知识大总结PDF文档](https://mp.weixin.qq.com/s/jn7oraFlhRkOmiv3rh74WA)\\n- [下载 → C/C++常见面试题（含答案）PDF文档](https://mp.weixin.qq.com/s/BRQ-3uvstdZPO-cnLGCVzA)\\n- [下载 → 设计模式学习笔记PDF文档](https://mp.weixin.qq.com/s/miV4SH1Eb_FMogQ2XYvPuA)\\n- [下载 → Java多线程+并发编程知识点详细总结PDF](https://mp.weixin.qq.com/s/EGQAuvITVJT3fZUdQG84sw)\\n- [下载 → 阿里Java开发手册PDF全套](https://mp.weixin.qq.com/s/J-vlX5tIuXWdglXWewK0FQ)\\n\\n\\n## 其他资源下载\\n\\n- [下载 → 我的浏览器收藏夹大公开（附浏览器收藏夹书签下载）](https://mp.weixin.qq.com/s/XUHnLCbq7mDWhOc9imTVzg)\\n- [下载 → 豆瓣9.1分的Pro Git学习手册YYDS！](https://mp.weixin.qq.com/s/xDYSG4uDz9rgNCuk0RxLjg)\\n- [下载 → 《Linux命令行大全》.pdf手册](https://mp.weixin.qq.com/s/3rV556_0piRNsSpDYwuZ8g)\\n\\n---\\n\\n# **编码之外**\\n\\n---\\n\\n诚然，程序员应该重视代码，但眼里也不应该只有代码，很多代码之外的东西也很精彩。工作也是为了更好的生活，多看看身边的事，多关心身边的人，终究我们还是要回归到平凡的生活中\\n\\n**我们所热爱的，就是自己的生活！**\\n\\n---\\n\\n## 码农生活\\n\\n- [办公室划水？嘿嘿，这事我擅长...](https://mp.weixin.qq.com/s/zRU-n-5VOgrMqG09477RyQ)\\n- [戴着耳机敲代码，我都听些啥？](https://mp.weixin.qq.com/s/7_2ibVNVMZLEYl89zT7sGQ)\\n- [程序员猪队友行为大赏，你遇到过哪些？](https://mp.weixin.qq.com/s/1dJO8VJ6GaZykv33IUslkw)\\n- [写给程序员看的买房+考公务员攻略](https://mp.weixin.qq.com/s/f8KtgdRx6ATbR-4RY_I_aA)\\n- [毕业租房避坑攻略（含购物清单）](https://mp.weixin.qq.com/s/9fyrQPqfXx2bhbXjyYdnaw)\\n- [加班严重时该如何自我提升？](https://mp.weixin.qq.com/s/oCQWlUkQ7ezgtYdono3BzA)\\n- [在腾讯待了9年还离了职](https://mp.weixin.qq.com/s/SclEMeRJTqSVq-HsXaLNTQ)\\n- [聊一聊自学计算机的辛酸史](https://mp.weixin.qq.com/s/AFnB33Rs7ahbjiX1CqfccQ)\\n- [一个算法工程师的日常](https://mp.weixin.qq.com/s/-vBrii3kn5lNn0Bj4rzAdg)\\n- [测试岗与开发岗的那些爱恨情仇](https://mp.weixin.qq.com/s/3Vf49cYXfwp6znt_SJhgsg)\\n- [采访了一位技术总监：聊了聊跳槽的心态问题](https://mp.weixin.qq.com/s/NGJc71cW2TKEONe6jhIUSg)\\n- [这就是架构师一天的生活，还羡慕不？](https://mp.weixin.qq.com/s/rMqSG84kNtLJ5Oiwk-S7Qw)\\n- [程序员是如何玩浪漫的？](https://mp.weixin.qq.com/s/vI7EGqo7YbljRdZn2nUSMQ)\\n- [假如曹操是一名程序员，你猜怎么着？](https://mp.weixin.qq.com/s/AE8dGz9asZ1de2-kvCiZwQ)\\n- [周末无聊，我都逛哪些资讯类网站充电呢？](https://mp.weixin.qq.com/s/yE_fShdcgE1e1bnpHiLWyA)\\n- [亲历分享：一行代码，百万人民币打水漂](https://mp.weixin.qq.com/s/dj3Z8-kgpCzzc-bQQgg__g)\\n- [程序员从技术→管理，要走哪些路？](https://mp.weixin.qq.com/s/4_MB3L511h7qoXNxPRdOvQ)\\n- [IT领域的2/8法则，扎心了](https://mp.weixin.qq.com/s/wd9QkLsrygO8ADW6heJg8w)\\n- [周一划水必备：程序员专属GIF动图批发](https://mp.weixin.qq.com/s/Gy-Qs80rHKDJwapCmYGGEg)\\n- [521坦白帖：当年念书时是怎么写情书的？](https://mp.weixin.qq.com/s/9DxslnAKgBHG85iZ8m6yYQ)\\n- [一位半路转行计算机的女生](https://mp.weixin.qq.com/s/xfKoK3cQvcz-WGh50LiSBg)\\n- [程序员界的孔乙己](https://mp.weixin.qq.com/s/dW81quoXMRA2ObwTzIv74g)\\n- [我的大学四年收获及工作感悟](https://mp.weixin.qq.com/s/x9EEDlGNIOPOL3v_qZiiAQ)\\n- [离职后，华为的哪些东西是自己最留恋的？](https://mp.weixin.qq.com/s/g5nb-yti5bv9_OCRqIjFCQ)\\n- [华为最美小姐姐，被外派到墨西哥后...](https://mp.weixin.qq.com/s/Dk-9se1eFl44NdmWB_sFOQ)\\n- [我在南大的七年](https://mp.weixin.qq.com/s/HrSitzmxTxWw4atXQHCa_A)\\n- [垃圾领导把我的功劳全抢走了！](https://mp.weixin.qq.com/s/gknm-6k1zLY-1Cey12whSw)\\n- [用随机梯度下降法来优化自己的人生！！](https://mp.weixin.qq.com/s/Rc2_rR9rJ7tx_LO_q80zuQ)\\n- [美团大佬分享：写给工程师的几条精进建议](https://mp.weixin.qq.com/s/gJby-f46_hv5Wjk3Eu5iaw)\\n- [我，生物专业出身，自学转到了互联网](https://mp.weixin.qq.com/s/yhY1VfuCEB0DSWYtBzMKDA)\\n- [坦白贴：十一在家我都逛哪些技术网站？](https://mp.weixin.qq.com/s/jboZwMaxfs1mOdf5mxPbeA)\\n- [在国外当程序员是一种什么样的体验](https://mp.weixin.qq.com/s/Qd3zNLGDYbifACJn82p1PA)\\n- [很佩服的一个Google大佬，离职了](https://mp.weixin.qq.com/s/LdTDhE8sUjLZf0My1AXK2g)\\n- [雷军：我的程序人生路](https://mp.weixin.qq.com/s/wxpJKTbivM63izuyHsneUw)\\n\\n## 读研深造\\n\\n- [整整5年了！老羊斗胆聊一聊和自己导师的相处](https://mp.weixin.qq.com/s/6h8GIqCdqs0pkNuwR-M7Yg)\\n- [学弟跨考浙大计算机的掏心窝子分享！](https://mp.weixin.qq.com/s/cgtbhh7lrhsHXquFz7d1Ow)\\n- [既然硕士毕业也去搞开发，那我还读个喵的研？](https://mp.weixin.qq.com/s/_Kt9OmaBVDDj6S7rsdC-Aw)\\n- [一篇所有研究生都该读的好文：阳光温热，科研静好！](https://mp.weixin.qq.com/s/kbRlOB9hdU4j54VGF1s8oQ)\\n- [如何优雅地向老师表达我这周任务没啥进展？](https://mp.weixin.qq.com/s/gbIGNXIkOpw8tQ5aIoJMtw)\\n- [好不容易读个研，遇到放羊的导师怎么办？](https://mp.weixin.qq.com/s/OkxMe3Eaywx-KF9tBmjf-Q)\\n- [研究生/专升本都扩招，我们没有理由放弃](https://mp.weixin.qq.com/s/MvZFLDHItPR7InzrtYRL5w)\\n- [本科、硕士、博士，究竟有何区别？](https://mp.weixin.qq.com/s/Oa-1F1h6FmgodjG__2AZ_Q)\\n- [一位博士的自白：毕业时想大哭一场](https://mp.weixin.qq.com/s/h6o5XpA8-M97MWILhdrO5A)\\n- [一个农村博士的独白：全家为什么只有我读到了博士](https://mp.weixin.qq.com/s/EhWWnpLuhLM3_lX8Ja3qMQ)\\n- [考研上岸哈工大的经历分享](https://mp.weixin.qq.com/s/hDR4FKDA4Hkc_yvXgyvI8A)\\n\\n## 闲聊唠嗑\\n\\n- [深夜闲聊：还敢无脑梭哈计算机么？](https://mp.weixin.qq.com/s/AAMmLDeZSLPkKzzGrkHd9g)\\n- [那些学计算机的女生后来都怎么样了？](https://mp.weixin.qq.com/s/xweKJoGKG5NUssZioROQZw)\\n- [程序员缺乏经验的7种表现](https://mp.weixin.qq.com/s/UT1muuGblZ6hFvLViti6OQ)\\n- [程序员的酒后真言，都不容易](https://mp.weixin.qq.com/s/oKFHpaItmlB57gCE0sbzig)\\n- [自学技术时，看书还是看视频？](https://mp.weixin.qq.com/s/1AabNVmQTyhlEnaghoyGOg)\\n- [学校出身一般，该怎么办](https://mp.weixin.qq.com/s/7oOoThASit_ipIgyYzuMfA)\\n- [如何写出让同事无法维护的代码？](https://mp.weixin.qq.com/s/8zP5DX79-aEuFF17MYnHtg)\\n- [六成大学生认为自己毕业10年内会年入百万？](https://mp.weixin.qq.com/s/bj6LG7bq1Og8-fplcLjROA)\\n- [拼多多和电网offer，要你会选哪个？](https://mp.weixin.qq.com/s/bWcoi4oEIq6_F_NSkO7lOA)\\n- [C语言，50岁了！永远滴神！](https://mp.weixin.qq.com/s/Bhj0hj43jW7Ua78QENeC1g)\\n- [围观Linus大佬吐槽桌面版Linux](https://mp.weixin.qq.com/s/9GoTYs9IQZ3q9saz8p8VbQ)\\n\\n\\n## 读书写作\\n\\n- [羊哥今年的闲读书单！](https://mp.weixin.qq.com/s/rk0eOgioOj7yw3EjfTt5zQ)\\n- [大公开：我技术文章里的动图是怎么做的？](https://mp.weixin.qq.com/s/40nmWT6DtPqcqblQuwv9Tw)\\n- [坚持写博客三年了，分享几个私藏小工具](https://mp.weixin.qq.com/s/T-b7GfBoMGRuOqtp3T_HaA)\\n- [白瞟七牛云作为个人博客免费图床](https://mp.weixin.qq.com/s/UU4Ha5bym4VhEDAlMZwVFQ)\\n\\n---\\n\\n- [在线画图工具ProcessOn](https://www.processon.com/)\\n- [在线画图工具Draw.io](https://app.diagrams.net/)\\n- [在线思维导图工具MindLine](http://www.mindline.cn/webapp)\\n- [在线字数统计工具](https://www.eteste.com/)\\n- [mdnice markdown排版工具](https://mdnice.com/)\\n- [md2all markdown排版工具](http://md.aclickall.com/)\\n- [在线代码截图工具](https://carbon.now.sh/)\\n\\n\\n## 摸鱼时间\\n\\n咳咳。。。\\n\\n  - [0x00000001](https://www.bilibili.com/)\\n  - [0x00000002](https://mo.fish/)\\n  - [0x00000003](http://www.mazegenerator.net/)\\n  - [0x00000004](https://duomoyu.com/)\\n  - [0x00000005](http://slither.io/)\\n  - [0x00000006](https://www.anyknew.com/#/)\\n  - [0x00000007](http://gogoame.sumbioun.com/)\\n  - [0x00000008](https://flipanim.com/)\\n  - [0x00000009](https://zty.pe/)\\n  - [0x0000000a](https://aidn.jp/mikutap/)\\n  - [0x0000000b](http://zoomquilt.org/)\\n  - [0x0000000c](https://lab.bangbang93.com/wsyw)\\n  - [0x0000000d](https://lmbtfy.cn/)\\n  - [0x0000000e](https://suulnnka.github.io/BullshitGenerator/index.html)\\n  - [0x0000000f](https://zzkia.noddl.me/)\\n  - [0x00000010](https://www.dgtle.com/)\\n  - [0x00000011](https://sspai.com/)\\n\\n---\\n\\n# **联系作者**\\n\\n---\\n\\n## 关于作者\\n\\n- 普通开发者，热情的学习者，狂热的数码迷\\n- 90后，硕士毕业于华中科技大学电信专业，现从事IT类工作\\n- 目前在南京栖息，天天被业务折腾得死去活来的同时依然保有对各项技术热忱的追求\\n- 参加工作以后越来越理解交流与分享的重要性，我在不停地汲取大家宝贵经验的同时，也想回馈自己的所学所感给读者\\n- 本仓库是作者自学编程以来所用资源和分享内容的聚合，旨在为编程自学者提供一系列清晰的学习路线/靠谱的资源/高效的工具/务实的技术文章，方便自己也方便他人。网站内容会保持持续更新，欢迎收藏品鉴\\n\\n---\\n\\n## 心路历程\\n\\n- [2021-12-23：我的小网站被打挂了。](https://mp.weixin.qq.com/s/VtgMAMRoox97p6e8hyONng)\\n- [2021-12-01：最近状态一般，聊聊正在做的一件小事](https://mp.weixin.qq.com/s/-yC_t4onUsopuIQdiFNq3w)\\n- [2021-10-14：我坚持两年了！](https://mp.weixin.qq.com/s/GPVeZtMokBI_LwmcM5XEtA)\\n- [2021-09-12：羊哥今年的书单！](https://mp.weixin.qq.com/s/rk0eOgioOj7yw3EjfTt5zQ)\\n- [2021-08-29：读了7年通信最后还是转了码，羊哥你后悔吗？](https://mp.weixin.qq.com/s/gU5jhu9wcZHTgGuawpKE8g)\\n- [2021-08-05：羊哥竟然翻出了当年的大学成绩单。。](https://mp.weixin.qq.com/s/yhOep3tFNpJ5-4YkDigVxw)\\n- [2021-07-16：羊嫂偷偷抹了两个小时眼泪](https://mp.weixin.qq.com/s/OQ5dNnxFKXVt7rgRxxygyw)\\n- [2021-06-23：还敢无脑梭哈计算机么？](https://mp.weixin.qq.com/s/AAMmLDeZSLPkKzzGrkHd9g)\\n- [2021-06-17：羊家坝村首席高考志愿填报推荐官](https://mp.weixin.qq.com/s/oqopuK0mMP-FAxiDvPUeCg)\\n- [2021-06-13：羊哥接到了百万大V的邀请！起飞了~](https://mp.weixin.qq.com/s/8CxIPP2Amb3HXPY7hKUWGA)\\n- [2021-06-06：整整5年了！老羊斗胆聊一聊和自己导师的相处](https://mp.weixin.qq.com/s/6h8GIqCdqs0pkNuwR-M7Yg)\\n- [2021-05-27：拜访了这位小哥的GitHub后，羊哥失眠了](https://mp.weixin.qq.com/s/-Xp84QH5zQvvHaGWTJF9MA)\\n- [2021-05-21：521坦白帖：当年念书时是怎么写情书的？](https://mp.weixin.qq.com/s/9DxslnAKgBHG85iZ8m6yYQ)\\n- [2021-05-09：卧槽，人品爆了 ...](https://mp.weixin.qq.com/s/q-fHPCz9YQzVDC4wC9P4YA)\\n- [2021-05-05：生产队的驴都不敢这么过五一](https://mp.weixin.qq.com/s/sYPGrLBhojhqIkVAKXLZNg)\\n- [2021-04-24：日子浑浑噩噩地过，这可能是我最开心的一周了](https://mp.weixin.qq.com/s/EfYQgGxOYUb6mLs4EBuCCw)\\n- [2021-03-28：痴声痴色痴梦痴情几辈痴人](https://mp.weixin.qq.com/s/VqVFhueNtm9jN1GrW4Ebsg)\\n- [2021-03-21：我和羊嫂的3平米小书房](https://mp.weixin.qq.com/s/KTD15ZQ4xdTJXt-MVWa7zg)\\n- [2021-02-28：哎，我也想有一个这样的老婆啊](https://mp.weixin.qq.com/s/-Odh3JZNzJzGLGLiCf_uzw)\\n- [2021-01-14：熬夜多疯狂，体检报告就有多刺激！我怂了](https://mp.weixin.qq.com/s/B9iPfm4DVAwHR1e-wWNPOg)\\n- [2021-01-10：去芜湖、看房子、拿体检报告，魔幻的2021开端~](https://mp.weixin.qq.com/s/v1TiNA7XJeMp92u-YLLxjg)\\n- [2020-12-13：今天的南京，很冷很冷](https://mp.weixin.qq.com/s/lfm_y0WskLrQJc55JYdu2Q)\\n- [2020-10-22：和字节跳动面试官学长聊了聊人生~](https://mp.weixin.qq.com/s/WDatlUIMnADEASTzBTQZQw)\\n- [2020-10-15：愿那只在天堂的猫，能够被温柔相待](https://mp.weixin.qq.com/s/ukyCJTXeD9ZoSaNK-WV0Ig)\\n- [2020-10-06：老家被拆了，我的少年记忆也无处安放了](https://mp.weixin.qq.com/s/9hw1FTUGZANgcecCFUDovQ)\\n- [2020-09-06：没有什么事是一顿撸串解决不了的~](https://mp.weixin.qq.com/s/QHvFgYQLvTrwAsxdWe_eAQ)\\n- [2020-08-08：实不相瞒，我就是鹤岗的女婿~](https://mp.weixin.qq.com/s/kXjD-lIZpVjSroKkGHA7SQ)\\n- [2020-07-18：最近厚着脸皮联系了不少同学](https://mp.weixin.qq.com/s/FlnZuzmZ9eNK1ahkvC98CA)\\n- [2020-07-03：自学党/野生猿，项目经验上哪搞？](https://mp.weixin.qq.com/s/-mFZnE8-DNG6XVM-t589-Q)\\n- [2020-06-21：既然硕士毕业也去搞开发，那我还读个喵的研？](https://mp.weixin.qq.com/s/_Kt9OmaBVDDj6S7rsdC-Aw)\\n- [2020-06-14：我的毕业季，没有一点点仪式感](https://mp.weixin.qq.com/s/0iSzqJBj7YHkijGxbFUqCQ)\\n- [2020-05-08：最近状态不咋好...](https://mp.weixin.qq.com/s/C9HuUYis2zu6ThJAjXRqpA)\\n- [2020-05-01：二线城市的程序员活得好吗？](https://mp.weixin.qq.com/s/gOo8ztVLdXp3m_rvBozQpQ)\\n- [2020-04-21：自学编程的八大误区！克服它！](https://mp.weixin.qq.com/s/r_vm7lA2Ul_ZFhkx60wplg)\\n- [2020-04-08：我的本科回忆录：从迷茫自卑到保送华科](https://mp.weixin.qq.com/s/t9F6Z-DrybWLUxVrPTRPJw)\\n- [2020-03-15：到底要不要考研？](https://mp.weixin.qq.com/s/pwInIR-h1gkPXGuu4u1aWw)\\n- [2020-02-23：实不相瞒，在家远程办公15天，我有点自闭](https://mp.weixin.qq.com/s/gJBlu5gXL5vqYWG6ggisRw)\\n- [2020-02-16：昨夜，我梦回武汉 . . .](https://mp.weixin.qq.com/s/lfGqTBuyRSiA9NL-8Na-xg)\\n- [2020-02-02：转行的路，走起来其实有点累...](https://mp.weixin.qq.com/s/FPreCde-JHl2D6HZDGK7qg)\\n- [2020-01-23：来B站一年，我活成了人的模样！](https://mp.weixin.qq.com/s/-RWgqMi2iKFUQGWbgyyo3w)\\n- [2019-10-28：快30岁的我，终于赚到人生第一个10W！](https://mp.weixin.qq.com/s/i-EFuFb7yPpoOidme18EWA)\\n- [2019-09-08：华科研究生学长想对导师们说的话！](https://mp.weixin.qq.com/s/TO9-kBWKFs2sV1z0Hw3qWw)\\n\\n---\\n\\n## 微信联系\\n\\n<a name=\\\"微信\\\"></a>  <a name=\\\"公众号\\\"></a>\\n\\n<p align=\\\"left\\\">\\n    <a href=\\\"https://mp.weixin.qq.com/s/ePhaYezFblgt0NgbvtWqww\\\" target=\\\"_blank\\\">\\n        <img src=\\\"https://cdn.jsdelivr.net/gh/justacoder99/r2coding@master/img/qrcode_for_gh_1537917051d0_258.nd3fymuhyts.jpeg\\\" width=\\\"\\\"/>\\n    </a>\\n</p>\\n\\n\\n\\n---\\n\\n# 持续更新中...\\n\\n[本仓库内容会持续保持更新 → 欢迎收藏品鉴！](https://mp.weixin.qq.com/s/ePhaYezFblgt0NgbvtWqww)\",\"articleCover\":\"\",\"articleTitle\":\"C++参考资料\",\"articleType\":1,\"categoryName\":\"编程语言基础\",\"isRecommend\":0,\"isTop\":0,\"status\":1,\"tagNameList\":[]}]','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',68,'2023-06-07 16:40:01');
INSERT INTO `t_operation_log` VALUES (1185,'文章模块','添加','/admin/article/add','com.ican.controller.ArticleController.addArticle','添加文章','[{\"articleContent\":\"---\\ntitle: 结构体字节大小计算手册\\ndate: 2023-04-01\\ncategory:\\n - 1编程语言基础\\n\\nfooter: <a href=\\\"https://beian.miit.gov.cn/#/Integrated/index\\\">渝ICP备2023001651号</a>\\n\\n---\\n\\n:::tip\\n结构体字节大小计算手册\\n:::\\n\\n<!-- more -->\\n\\n\\n结构体\\n1、结构体计算字节数规则\\n总结规则如下:\\n\\n+ 0:结构体变量的首地址能够被其最宽基本类型成员的大小所整除\\n+ 1: VC6和VC71默认的内存对齐方式是#pragam pack(8)\\n+ 2: 结构体中每个成员按其类型的对齐参数(通常是这个类型的大小)和指定对齐参数中较小的个对齐.\\n+ 3:结构体每 个成员相对于结构体首地址的偏移量都是成员大小的整数倍.\\n+ 4:结构体本身也存在着对齐要求规则，不能比它所有字段中要求最严格的那个宽松\\n+ 5:结构体的总大小为结构体最宽基本类型成员大小的整数倍.且应尽量节省内存。\\n+ 6: 在GCC中，对齐模数的准则是:对齐模数最大只能是4，也就是说，即使结构体中有\\n  double类型，对齐模数还是4，所以对齐模数只能是1，2，4。而且在上述的规则中，第3条里，offset必须是成员大小的整数倍:\\n    + (1):如果这个成员大小小于等于4则按照上述准则是可行的，\\n    + (2):如果成员的大小大于4，则结构体每个成员相对于结构体首地址的偏移量只能按照是4的整数倍来进行判断是否添加填充。\\n\\n2、位域\\n[参考链接](http://www.javashuo.com/article/p-pyhbyxqy-bh.html)\\n\\n1. 一个位域必须存储在同一个字节中，不能跨两个字节，故位域的长度不能大于一个字节的长度。\\n2. 取地址操做符&不能应用在位域字段上;\\n3. 位域字段不能是类的静态成员;\\n4. 位域字段在内存中的位置是按照从低位向高位的顺序放置的;\\n5. 位域的对齐\\n\\n>1. 若是相邻位域字段的类型相同，且其位宽之和小于类型的sizeof大小，则后面的字段将紧邻前一个字段存储，直到不能容纳为止；\\n>2. 若是相邻位域字段的类型相同，但其位宽之和大于类型的sizeof大小，则后面的字段将重新的存储单元开始，其偏移量为其类型大小的整数倍；\\n>3. 若是相邻的两个位域字段的类型不一样,则各个编译器的具体实现有差别,VC6采起不压缩方式,GCC和Dev-C++都采用压缩方式;\\n>4. 整个结构体的总大小为最宽基本类型成员大小的整数倍。\\n>5. 若是位域字段之间穿插着非位域字段，则不进行压缩；（不针对全部的编译器）\\n\\n1. 当要把某个成员说明成位域时,其类型只能是int,unsigned int与signed int三者之一(说明:int类型一般表明特定机器中整数的天然长度。short类型一般为16位,long类型一般为32位,int类型能够为16位或32位.各编译器能够根据硬件特性自主选择合适的类型长度.见The C Programming Language中文 P32)。\\n\\n\",\"articleCover\":\"\",\"articleTitle\":\"结构体字节大小计算手册\",\"articleType\":1,\"categoryName\":\"编程语言基础\",\"isRecommend\":0,\"isTop\":0,\"status\":1,\"tagNameList\":[]}]','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',35,'2023-06-07 16:40:21');
INSERT INTO `t_operation_log` VALUES (1186,'文章模块','添加','/admin/article/add','com.ican.controller.ArticleController.addArticle','添加文章','[{\"articleContent\":\"---\\ntitle: 内存分区问题\\ndate: 2023-04-01\\ncategory:\\n - 1编程语言基础\\n\\nfooter: <a href=\\\"https://beian.miit.gov.cn/#/Integrated/index\\\">渝ICP备2023001651号</a>\\n\\n---\\n\\n:::tip\\n内存分区问题\\n:::\\n\\n<!-- more -->\\n\\n## 1、自动存储、静态存储和动态存储\\n\\n(第四章内容)4.8.5\\n自动存储：用时创建，结束时销毁。一般存储在栈区。在c语言和C++11之前，auto关键字表示变量为自动存储类型，auto可缺省。在C++11新标准中，auto的意思改为了“自动推导变量类型”。\\n\\n静态存储：变量定义在函数外，或者用static关键字修饰时为静态存储。在c语言古老版本中，智能初始化静态数组和静态结构，在C++Release2.0及以后和ANSI C中，也可以初始化自动数组和自动结构。\\n\\n动态存储：用new/delete来管理堆区空间。\\n\\n\\n（第九章内容）9.2\\n\\n## 2、存储持续性、作用域和链接性\\n\\n注意，C++使用三种不同的方案来管理存储数据，这些方案的区别就在于数据保留在内存中的时间。但是在C++11新标准中，新增加了一种“线程存储持续性”：`当前，多核处理器很常见，这些CPU可同时处理多个执行任务。这让程序能够将计算放在可并行处理的不同线程中。如果变量是使用关键字thread_local 声明的，则其生命周期与所属的线程一样长。本书不探讨并行编程。`\\n\\n自动存储持续性：C++中有两种存储持续性为自动的变量：auto自动变量（栈）和寄存器变量(register)。不过register也只是建议编译器将这个变量存储在cpu的寄存器中，以提高对变量的访问速度，但具体是否实现有编译器决定。\\n\\n静态存储持续性：C++为静态存储持续性提供了3种链接性：外部链接性（可在其他文件中访问）、内部连接性（只能在当前文件中访问）、无连接性（只能在函数或当前块中访问）。这些变量在程序执行期间一直存在。\\n\\n原文：\\n\\n```cpp\\n参考：C++ Primer Plus第9.2章的内容和[CSDN](https://blog.csdn.net/EJoft/article/details/122703902)\\nC++为在内存中存储数据提供了多种选择，可以选择数据保存在内存中的时间长度（存储持续性 storage duration）以及程序哪一部分可以访问数据（作用域 scope 和链接 linkage）\\n\\nC++中有四种不同的方案来存储数据，这些方案的区别就在于数据保留在内存中的时间\\n\\n**自动存储持续性(Automatic Storage Duration)：**在函数定义中声明的变量（包括函数参数）在存储持续性上是自动的。它们在程序开始执行其所属的函数或者代码块时被创建，在执行完函数或代码块时，他们使用的内存被释放。C++有两种存储持续性为自动的变量：自动变量和寄存器变量。\\n静态存储持续性(Static Storage Duration)：在函数定义外定义的变量和使用关键字 static 定义的变量。它们在程序运行的运行的整个过程中都存在，C++有三种该变量。\\n线程存储持续性(C++11 Thread Storage Duration)：多核处理器很常见，这些CPU能同时处理多个执行任务，这让程序能将计算放在可并行处理的不同线程中。如果变量用 thread_local 声明，那么其生命周期和所属的线程一样长。\\n动态存储持续性(Dynamic Storage Duration)：用 new 运算符分配的内存将一直存在，直到使用 delete 运算符将其释放或程序结束为止，有时被称为 自由存储 (free store)或 堆 (heap)\\n\\n```\\n\\n表格总结：\\n![图1](https://s3.bmp.ovh/imgs/2022/08/11/86e4ae613499dbe6.png)\\n![图2](https://s3.bmp.ovh/imgs/2022/08/11/52776a151f9c0f98.png)\\n\\n[参考CSDN](https://blog.csdn.net/qq_40739219/article/details/121436579)\\n\\n## 3、C/C++内存分区\\n\\n局部变量：栈（即：我们常说的堆栈）\\nstatic变量：数据区、data区和.bss区\\n静态局部变量和全局变量：静态存储区\\n常量：位于常量区，ro.data区\\n\\n堆：一种内存管理机制，通过malloc、calloc或realloc申请内存，free释放内存（new/delete)\\n以下图片来源于《嵌入式linux与c语言内核》P92左右：\\n![图1](https://s3.bmp.ovh/imgs/2022/08/24/1cddf7efc782aa82.jpg)\\n![图2](https://s3.bmp.ovh/imgs/2022/08/24/2af970a315cb201d.jpg)\\n![图3](https://s3.bmp.ovh/imgs/2022/08/24/cee421c0402b884a.jpg)\\n\\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\\n\\n程序的内存五区:\\n\\n全局区（静态数据区），存放全局变量、静态变量。初始化的\\n全局变量和静态变量在一块区域.Data段， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域.bss段。 程序结束后由系统释放。注意，显式初始化的全局变量和静态变量存放在.Data段，未显式初始化的变量存放在.bss段，并由编译器自动初始化为0。\\n堆，程序员管理。\\n栈，存放程序局部变量。\\n文字常量区:—常量字符串就是放在这里的。 程序结束后由系统释放。还有const关键字修饰的值也是存放在此。\\n代码区.text:  存放函数体的二进制代码\\n\\n\\n\\n还有一种内存四分区: 将全局（静态）变量和常量结合到一起，归结为“数据区”。 \\n栈区: 系统使用\\n堆区: 程序员使用\\n数据区: 由全局变量/静态变量（.Data段和.bss段）和常量组成。\\n代码区（.text）:存放函数的二进制代码\",\"articleCover\":\"\",\"articleTitle\":\"内存分区问题\",\"articleType\":1,\"categoryName\":\"编程语言基础\",\"isRecommend\":0,\"isTop\":0,\"status\":1,\"tagNameList\":[]}]','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',32,'2023-06-07 16:40:38');
INSERT INTO `t_operation_log` VALUES (1187,'文章模块','添加','/admin/article/add','com.ican.controller.ArticleController.addArticle','添加文章','[{\"articleContent\":\"---\\ntitle: 综合资料（待完善待补充）\\ndate: 2022-10-30\\ncategory:\\n - 1编程语言基础\\n\\nfooter: <a href=\\\"https://beian.miit.gov.cn/#/Integrated/index\\\">渝ICP备2023001651号</a>\\n\\n---\\n\\n:::tip\\n综合资料（待完善待补充）\\n:::\\n\\n<!-- more -->\\n\\n\\n# 待完成待补充\\n\\n来源，参考：[公众号](https://mp.weixin.qq.com/s/joFBDntI9PmyVRiKPHwpRg)\\n\\n### 1、C/C++相关\\n\\n+ C++虚函数原理\\n+ 智能指针\\n+ c语言如何实现C++对象以及私有成员\\n+ C++多态实现\\n+ new和malloc的区别以及底层实现原理\\n+ STL中的vector怎么扩容\\n+ 虚函数指针的初始化过程\\n+ C++11原子变量介绍\\n+ C++11特性有哪些，说用过的\\n+ 怎么理解重载与重写\\n+ 怎么理解C++中的static关键字\\n+ vector和list 的区别\\n+ C++的内存分配\\n+ map与set的底层实现\\n+ 类静态变量的初始化\\n+ 析构函数可以是虚函数？为什么\\n+ 深拷贝与浅拷贝\\n+ 指针常量，常量指针的区别\\n\\n> c语言语法推荐书籍: 《c专家编程》《c与指针》\\n>\\n> C++语言语言推荐书籍:《C++ primer》《effect C++》\\n>\\n> C++语言stl底层原理：《STL源码剖析》\\n\\n\\n### 2、计算机网络\\n\\n+ 介绍下proactor和reactor\\n+ reactor的组成\\n+ TIME_WAIT危害\\n+ TIME_WAIT时长，为什么？\\n+ IP为什么要分片\\n+ 项目中说用到线程池，开多大，为什么运用线程池？\\n+ select和epoll区别\\n+ select什么情况返回0\\n+ epoll可读情况有哪些\\n+ 什么时候需要TCP四次挥手？\\n+ 如何设置非阻塞\\n+ 什么是零拷贝？\\n+ tcp与udp的区别以及应用场景\\n+ 如何设计一个可靠的udp\\n+ 粘包如何解决\\n+ 讲一下拥塞控制和流量控制\\n+ http和https区别\\n+ 是否了解中间人劫持原理\\n+ http协议格式，几种方法，功能是什么\\n+ chunked块了解？介绍下\\n+ 有chunked的时候contentlength是什么样子\\n+ 半连接在哪个阶段\\n+ 三次握手四次握手详细过程，越详细越好\\n+ libevent结构，内部实现\\n+ tcp的可靠性体现在哪里\\n+ ARP协议工作流程\\n+ epoll中的ET和LT模式\\n+ 介绍下滑动窗口\\n+ 指针与引用的区别\\n+ Accept发生在三次握手哪个阶段\\n+ Udp的接收缓冲区和发送缓冲区和tcp的区别\\n+ http长连接与短连接的区别\\n+ udp包长度\\n+ 一次url访问会经历哪些过程\\n+ 数据包乱序会处理？\\n+ seq为1000，发送了1000个数据，下一个seq是多少?\\n+ syn如果丢了，重传多少次\\n\\n> tcp/ip相关推荐书籍:《tcp/详解：1》\\n>\\n> 熟悉使用wireshark捕包工具，加深印象可以使用python的一个库，scapy/dpkt.\\n\\n\\n\\n### 3、数据结构相关\\n\\n+ hash处理冲突的方法\\n+ 二分查找及其变种\\n+ 数组与链表的区别\\n+ redis数据结构用过哪些，了解跳表？\\n+ 红黑树比平衡二叉树有哪些优点\\n+ 二叉树，b+树，hash，二叉查找树区别\\n+ 说说红黑树的特性\\n+ 各种树，排序的时间复杂度\\n+ 数据库索引，事务，事务级别\\n+ 不考虑事务的隔离性会出现什么问题\\n+ 事务隔离级别\\n+ 索引的类型\\n+ AC自动机时间复杂度\\n\\n> 数据结构书籍《大话数据结构》\\n>\\n> 极客时间王大佬/谭大佬专栏\\n\\n### 4、操作系统相关\\n\\n+ 进程与线程的区别\\n+ 多进程与多线程区别，应用场景\\n+ volatile和原子变量的区别\\n+ proc文件系统\\n+ 自旋锁与普通锁的区别\\n+ 虚拟内存\\n+ 进程的内存分布\\n+ 栈内存为什么由系统自动分配和释放\\n+ 守护进程如何创建\\n+ 进程间的通信方式及其区别，应用场景\\n+ 死锁条件和解除\\n+ 进程调度方式\\n+ 对编译连接的理解\\n+ 共享内存实现原理\\n+ 僵尸进程是什么，如何处理\\n+ 自旋锁在单cpu与多cpu下的使用\\n+ 用户态与内核态\\n\\n> 操作系统推荐书籍:《深入理解操作系统》，《Linux内核设计与实现》\\n\\n\\n\\n### 5、Linux基础知识及应用编程\\n\\n+ 如何查看进程打开的文件\\n+ 介绍下nm与ldd命令\\n+ shell命令查内存，端口 ，io访问量，读写速率\\n+ awk grep具体应用\\n+ 硬链接与软连接，目录可不可以用硬链接\\n+ 常见命令netstat iptable tcpdump top\\n+ makefile介绍下(cmake介绍下)\\n+ gdb查看堆栈中所有遍历\\n+ gdb查看shared_ptr指向的内容\\n+ gdb如何调试多进程多线程\\n+ g++和gcc编译出来有什么区别\\n+ 死锁怎么调试\\n+ core文件中是什么，gdb调试core文件\\n+ 如何读取一个10G文件，cat一个10g文件会发生什么\\n\\n> Linux基础命令推荐书籍:《Linux就该这么学》\\n>\\n> Linux应用编程推荐书籍：《后台开发核心技术与应用实践》《Linux多线程服务端编程》《高性能Linux服务器编程》 《linux环境编程:从应用到内核》《unix高级环境编程》\\n>\\n> 补充资料:gdb手册和makefile详解\\n\\n\",\"articleCover\":\"\",\"articleTitle\":\"综合资料（待完善待补充）\",\"articleType\":1,\"categoryName\":\"编程语言基础\",\"isRecommend\":0,\"isTop\":0,\"status\":1,\"tagNameList\":[]}]','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',35,'2023-06-07 16:40:55');
INSERT INTO `t_operation_log` VALUES (1188,'文章模块','添加','/admin/article/add','com.ican.controller.ArticleController.addArticle','添加文章','[{\"articleContent\":\"---\\ntitle: 大话数据结构和算法\\ndate: 2022-10-30\\ncategory:\\n - 2数据结构与算法\\n\\nfooter: <a href=\\\"https://beian.miit.gov.cn/#/Integrated/index\\\">渝ICP备2023001651号</a>\\n\\n---\\n\\n:::tip\\n大话数据结构和算法\\n:::\\n\\n<!-- more -->\\n\\n\\n注：内容来源于书籍《大话数据结构》，部分内容来源于网络补充。\\n\\n数据结构：使相互之间存在的一种或多种特定关系的数据元素的集合。从不同的角度来讨论，会有不同的分类。按照逻辑结构来分，有“集合结构、线性结构、树状结构和图形结构”，按照物理结构分类，有“顺序存储结构、链式存储结构”。\\n\\n算法：是解决特定问题求解步骤的描述，在计算机中表现为指令的优先序列，并且每条指令表示一个或多个操作。\\n\\n算法的五大基本特性：输入、输出、有穷性】确定性和可行性。\\n\\n算法设计的要求：正确性、可读性、健壮性、时间效率高和存储量低。\\n\\n## 一、算法优劣的度量\\n\\n算法优劣的度量有事前分析法和事后统计法。一般采用事前分析法，分析算法的时间效率和空间存储量。\\n\\n大O记法：T(n)=O(f(n))，一般说来，随着n的增大，T(n)增长最慢的算法为最优算法。\\n\\n> 推导大O阶：\\n>\\n> + 用常数1来取代运行时间中的所有加法常数\\n> + 在修改后的运行次数函数中，只保留最高阶项\\n> + 如果最高阶项存在且系数不为1，就像系数调整为1\\n\\n1、常数阶O(1)\\n\\n一般顺序结构的时间复杂度是O(1)。对于分支结构而言，无论是镇还是假，执行的次数都是恒定的，不会随着n的变大而发生变化，所以单纯的分支结构（不包含在循环结构里），其时间复杂度也是O(1)。\\n\\n```c\\nint sum=0,n=100  //执行一次\\nsum=(1+n)*n/2;   //执行一次\\n```\\n\\n2、线性阶O(n)\\n\\n一般循环结构都要重复执行n次，所以循环结构的时间复杂度为O(n)。一般分析算法的复杂度，主要就是分析循环结构的复杂度。\\n\\n```c\\nint i;\\nfor(i=0;i<n;i++)  //时间复杂度为n\\n{\\n//时间复杂度为1的代码序列\\n}\\n```\\n\\n3、对数阶O(logn)\\n\\n如果在循环中，对循环因子进行了处理，那这段代码的时间复杂度就会发生变化，比如：\\n\\n```c\\nint count=1;\\nwhile(count<n)\\n{\\ncount = count*2;\\n//时间复杂度为1的代码序列\\n}\\n```\\n\\n因为每次count乘以2之后，就距离n更近了一步，也就是说有多少个2相乘后大于n，则会退出循环，有2^x^=n可以得到x=log~2~n。所以该类算法的时间复杂度为log~2~n。\\n\\n4、平方阶\\n\\n1、简单循环结构的循环嵌套，其算法时间度一般为O(n^2^)。\\n2、如果外层循环改为了m，那么时间复杂度就该为了O(mxn);\\n3、有些排序和搜索算法会用到这种循环结构：\\n\\n```c\\nfor(i=0;i<n;i++)\\n{\\n\\tfor(j=i;j<n;j++)\\n\\t{\\n\\t//时间复杂度为1的程序代码片段\\n\\t}\\n}\\n```\\n\\n当i=0时，内循环了n次；当i=1时，内循环了n-1次，...，当i=n-1时，内循环了1次。综上，这个代码块的总运行时间为：n+(n-1)+(n-2)+...+1=(n+1)n/2=1/2(n^2^+n)。根据大O算法，推导出时间复杂度为O(n^2^)。\\n\\n下面这段代码相对而言更复杂：\\n\\n```c\\nn++;   //执行次数为1\\nfunction(n);//执行次数为n\\nint i,j;//执行次数为1\\nfor(i=0;i<n;i++)//执行次数为n*n\\n{\\n\\tfunction(i);\\n}\\nfor(i=0;i<n;i++)//执行次数为n*(n+1)/2\\n{\\n\\tfor(j=i;j<n;j++)\\n\\t{\\n\\t\\t//时间复杂度为1的代码\\n\\t}\\n}\\nvoid function(int n)\\n{\\n\\tfor(int i=0;i<n;i++)\\n\\t{\\n\\t\\t//时间复杂度为1的代码\\n\\t}\\n}\\n```\\n\\n综上，它的执行次数为1+n+1+n\\\\*n+n\\\\*(n+1)/2，时间复杂度为O(n^2^)。\\n![](https://s3.bmp.ovh/imgs/2022/11/05/dda3163c8daa0b01.png)\\n\\n算法的空间复杂度S(n)=O(f(n))，其中n为问题的规模，f(n)为语句关于n所占存储空间的函数。\\n\\n一般来说，一个程序在机器上执行时，出了需要存储程序本身的指令、常数、变量和输入数据外，还需要存储对数据操作的存储单元。若输入数据所占空间只取决于问题本身，和算法无关，这样只需要分析该算法在实现时所需的辅助单元即可。若算法执行时所需的辅助空间相对于输入数据量而言是个常数，则称此算法为原地工作，空间复杂度为O(1)。\\n\\n\\n\\n## 二、线性表（顺序存储结构和链式存储结构）\\n\\n线性表：零个或多个数据元素的有限序列。分为顺序存储结构（数组）和链式存储结构（链表）。\\n线性表的两个特点：1）有序；2）有限。有序是指，首元素无前驱结点，尾元素无后继节点，其余元素都有唯一的前驱结点和后继节点。有限是指元素个数是可以统计的。\\n\\n<font color=\'red\'>线性表的顺序存储结构</font>代码：\\n\\n```c\\n#define MAXSIZE 30\\ntypedef int ElemType\\ntypedef struct\\n{\\n\\tElemType data[MAXSIZE];\\n\\tint length;\\n}Sqlist;\\n```\\n\\n这里，我们可以发现描述顺序存储结构需要三个属性：\\n\\n+ 存储空间的起始位置，数组data\\n+ 线性表的最大存储容量；\\n+ 线性表当前的长度；\\n\\n通过上述分析，不难看出数组、链表(单链表、双向链表、循环链表)、栈、队列和字符串都是一种线性表结构。他们都有下面几种操作(除字符串以外)\\n\\n```c\\n1、初始化  InitList(*L)\\n2、验证是否为空：ListEmpty(L)\\n3、清空 ClearList(*L)\\n3.2 摧毁 DestroyList(*L)\\n\\n4、通过序号获取元素GetElem(L,i,*e)\\n5、通过元素查找序号LocateElem(L,e)\\n\\n6、增ListInsert(*L,i,e)\\n7、删ListDelete(*L,i,*e)\\n8、改Modify(*L,i,e)\\n9、统计长度ListLength(L)\\n\\n//细节\\n当然，各自的细节不一样。比如1、数组不需要清空和验证是否为空，还有通过元素获取序号、通过序号查询值也是不需要的。在插入上，单链表、循环链表、双向链表上有微小差异。2、栈只有查询栈顶元素，队列只有查询队首元素 3、注意区分线性表长度和数组长度（针对顺序存储结构），数组长度一般是指这个数据结构对象的容量，而线性表长度是指这个对象的实际存储数据的数量。4、关于字符串，它是一种特殊的线性表，他符合线性表的特征，它是线性表，他也有顺序存储和链式存储，不过其他几种线性表能关注单个元素的操作，比如查找、插入和删除，但是串中更多的查找子串、得到指定位置的子串和替换子串等操作。\\n\\n```\\n\\n\\n线性表顺序存储结构的优缺点：\\n\\n> 优点\\n>\\n> + 无需为表示表中元素之间的逻辑关系而增加额外的存储空间；\\n> + 可以快速地存储、查找表中任意位置的元素\\n>\\n> 缺点\\n>\\n> + 插入/删除元素的效率较低。特别是在首部插入和删除元素时，时间效率为O(n)，平均插入/删除的小绿尾O((n-1)/2)\\n> + 当线性表长度变化较大时，难以确定存储空间的容量\\n> + 造成存储空间的“碎片”\\n\\n<font color=\'red\'>线性表的链式存储结构</font>：\\n\\n顺序存储结构最大的缺点就是插入和删除元素的效率问题，而链式存储可以解决该问题。链式存储解除了空间上的连续性，使得元素存储自由化，就可以提高元素插入/删除的效率，但也带来了额外的空间消耗。\\n\\n除了其本身的信息之外，还需存储一个指向其直接后继的信息(即直接后继的存储位置)。\\n\\n链表的分类有很多种，可以分为有头结点、无头结点；可以分为单链表、双向链表、循环链表。双向链表是有头尾指针，可以前进也可以后退。循环链表是头尾相连的链表。双向循环链表指的是在循环链表和双向链表的基础上，将两种链表的最后一个结点指向第一个结点从而实现循环。\\n\\n```c\\ntypedef struct Node\\n{\\n\\tint data;\\n\\tstruct Node *next;\\n}List;\\n```\\n\\n1、从查找性能上看，顺序存储结构的性能为O(1)，链式存储的性能为O(n)；2、从插入/删除的性能上看，顺序存储结构的性能为O(n)，链式存储的性能为O(1)；3、从空间性能上看，顺序存储需要预先分配空间，分配大了就浪费，分配小了会溢出，而链式存储不需要提前分配空间。\\n\\n<font color=\'red\'>结论</font>：情况1：若线性表需要频繁查找，很少进行插入和删除操作时，宜采用顺序存储结构。若需要频繁插入和删除时，宜采用单链表结构。举个简单的例子，游戏开发中的玩家账号信息，只有注册时需要插入，平时一般是查询操作，最好采用顺序结构。游戏装备会频繁刷新，经常读写，最好采用链式结构。\\n\\n情况2：如果元素总数变化较大或者不知道有多少总数时，宜采用链式结构。\\n\\n补充一点，散列表（Hash哈希表）：一种由数组和链表组合起来的数据结构，（也可能是数组、链表和红黑树组合起来），它兼顾数组和链表的优点，有较好的查询性能和插入/删除性能。[参考CSDN博客](https://blog.csdn.net/heyuchang666/article/details/49996237)，哈希表的结构如图所示：\\n![](https://s3.bmp.ovh/imgs/2022/11/15/65762f5ec5f6d72a.png)\\n\\n\\n数组和链表的对比：\\n![](https://s3.bmp.ovh/imgs/2022/10/30/106260aed0a641e5.png)\\n\\n跳表：上表说过，链表的优点是可以更灵活的使用内存空间，长度可以动态变化，且插入/删除数据灵活。但是链表查询元素必须遍历链表，效率低。所以提出了一种跳表。在原链表的基础上，在新增一条或多条索引链表，加速对元素的查询。\\n![](https://s3.bmp.ovh/imgs/2022/10/30/1db5cfb2d228ca2b.png)\\n\\n### 2.2 链表小总结\\n\\n```c\\n//单链表插入元素\\n//在p节点后插入新节点new:\\nnew->next=p->next;\\np->next=new;\\n```\\n\\n普通链表、静态链表、循环链表、双向链表\\n\\n为了使空链表与非空链表处理 致，我们通常设一个头结点，当然 这并不是说，循环链表一定要头结点，这需要注意。\\n\\n普通链表，各节点之间通过指针相连，无需提前设计容量，无数据溢出风险。数据插入/删除效率高，但是遍历效率低。数组是查询效率高。对于遍历效率低的问题，可以使用循环链表解决。对于链表只能前进不能后退的问题，引入了双向链表。\\n\\n### 2.2.2 循环链表\\n\\n头尾相连的链表，为了使空链表的处理和非空链表的处理保持一致，通常要设置一个头结点。\\n\\n除了头结点，还需要一个指针。设置头指针还是尾指针？设置头指针：访问第一个元素，时间复杂度为O(1)，访问尾元素为O(n)。设置尾指针，访问尾元素，时间复杂度为O(1)，访问首元素为O(2)，即为`rear->next->next`（因为要跳过头结点）。\\n\\n有了尾指针，两个循环链表的结合也变得非常简单了，如下图所示。\\n![](https://s3.bmp.ovh/imgs/2022/12/15/c7b7bf6fb88cb300.png)\\n\\n```c\\np=rearA->next;\\nrearA->next=rearB->next->next;\\nq=rearB->next;\\nrearB->next=p;\\nfree(q);\\n```\\n\\n### 2.2.3 双向链表\\n\\n双向循环链表是从单链表里面扩展出来的，所以他的很多操作都与单链表相同。比如求长度、查元素位置和通过位置查元素等。只是涉及到插入和删除的时候，需要两个指针的参与。\\n\\n```c\\n有：p->next->prior=p=p->prior->next;\\n//双向链表的插入：\\n//在p节点后插入新节点e\\ne->next=p->next;\\ne->prior=p;\\np->next->prior=e;\\np->next=e;\\n//双向链表的插入-2 李慧芹方法\\ne->next=p->next;\\ne->prior=p;\\ne->next->prior=e;\\ne->prior->next=e;\\n//双向链表的删除  删除节点p\\np->prior->next=p->next;\\np->next->prior=p->prior;\\nfree(p);\\n\\n```\\n\\n\\n## 三、栈与队列\\n\\n栈是先进后出的FILO，队列是先进先出的FIFO。栈和队列都有链式结构和顺序结构的实现。虽然把栈和队列从第二章线性表中分离来讲，但是栈和队列也是一种线性表。\\n\\n特殊之处在于，栈和队列限制了元素的插入和删除的位置。对于该部分的重点只是在于：\\n\\n- [ ] 不同情况的出栈顺序，其出栈结果不同\\n- [ ] 栈和队列都有链式存储和顺序存储两种结构\\n- [ ] 两栈共享空间(一般是顺序存储结构)\\n- [ ] 栈的应用：浏览器网页的后退功能、word的后退功能、用栈实现递归(斐波那契数列)、用栈实现计算器(包含如何将中缀运算符转换成后缀元素安抚、后缀运算符的计算规则)\\n- [ ] 队列的应用：任务队列\\n- [ ] 队列的顺序存储的不足(循环队列)、链式队列\\n\\n### 3.1 栈的顺序存储和两栈共享空间\\n\\n顺序存储一般使用数组实现，栈底为a[0]元素。栈顶指针top随元素增减而变化。\\n\\n顺序存储的弊端在于长度固定，所以容量设置小了容易溢出，设置打了容易浪费。对于浪费这种情况，可以采用“两栈共享的方法”来解决。两个栈各占数组的一端，\\n\\n```c\\n1)当top1=-1时，栈1为空，当top2=n时，栈2位空\\n2)当top1为n-1，或top2位0，又或者top+1=top2时栈满\\n```\\n\\n事实上，使用这种数据结构的情况，一般是“当两个栈的空间需求为相反关系时，也就是一个栈增长同时另一个栈减小的情况”，比如投票、买卖股票。\\n\\n栈的链式存储，因为链表有头结点，栈有栈顶指针，所以索性就把这两个指针合二为一了。在（栈顶指针）头结点后插入元素。\\n\\n### 3.2 斐波那契数列\\n\\n其核心就是使用了递归。递归是自己调用自己，迭代是循环。\\n递归：自己调用自己，重复运行函数，选择结构，[优}结构简单，节省代码，[缺]费时费空间]\\n迭代：循环重复运行代码，循环结构，[优]占内存小  [缺]\\n这是斐波那契数列的公式：\\n$$\\nF(n)=\\\\left\\\\{\\\\begin{array}{l}\\n0, \\\\text { 当 } n=0 \\\\\\\\\\n1, \\\\text { 当 } n=1 \\\\\\\\\\nF(n-1)+F(n-2), \\\\text { 当 } n>1\\n\\\\end{array}\\\\right.\\n$$\\n\\n### 3.3 用栈实现计算器\\n\\n1、 用后缀运算符来计算\\n\\n后缀运算符又称逆波兰表示法， 它的特点是所有符号都是在要运算的数字后面出现，例如：\\n\\n```c\\n前缀模式：9+(3-1)*3+10/2\\n后缀模式：9 3 1 - * 3 + 10 2 / +\\n```\\n\\n计算机喜欢用后缀模式来处理运算符，是因为栈的结构。1）左括号进，直到遇到右括号才弹出。2）遇到数字进栈，遇到运算符取两个数字进行运算。注意，后缀运算符中只有数字和运算符了。\\n\\n还有一点是，在栈中数字从上往下依次为1和3，然后遇到减号，则1先弹出做减数，然后3后弹出做被减数，所以为：`3-1`。\\n\\n2、中缀转后缀表达式\\n\\n规则：从左到右遍历中缀表达式的每个数字和符号，若是数字就输出，即成为后缀表达式的一部分；若是符号，则判断其与楼顶符号的优先级，是右括号或优先级不高于栈顶符号(乘除优先加减)则栈顶元素依次弹出并输出，并将当前符号进栈，一直到最终输出后缀表达式为止。\\n\\n即：1）数字直接输出，2）符号考虑情况，要不要进栈。2.1 左括号直接进，2.2 右括号直接出，并且把左右括号之间的东西一起弹出  2.3 如果是运算符之间，要比较大小。外头的运算符大，不弹，直接进栈。2.4 否则，先把栈里面的小的或相同的弹出并输出，然后再把栈外新元素（运算符）入栈。\\n\\n### 顺序存储队列的不足\\n\\n1、一方面，顺序存储的通病就是在不知道最大长度的情况下，容量不好设置。设置大了浪费，小了就溢出。\\n\\n2、另一方面，插入和删除元素问题。更改一个，整个数组就要跟着动。影响效率。\\n\\n解决方案1：新增一个队头和队尾的指针，插入和删除只是这两指针在动。新问题：“假溢出”：数组前半部分空着，但是数据都在后面存着，数据插入时会出现溢出错误。\\n\\n解决方案2：循环队列\\n\\n特点就是头尾相连。\\n\\n问题又来了：如何判断队列是否为空？\\n\\n在前面带两个指针的队列，队头指向首元素，队尾指向尾元素的下一个。这样，队列为空是就是front=rear。那这里的循环队列呢？front=rear有可能是空，有可能是满队列。\\n\\n方案1：设置标志量flag。当队列为空时，flag=0,队列满时，flag=1\\n方案2：保留了个元素空间。当front=rear时，就是表示队列为空。当(rear+1)%QueueSize=front时，队列为满。\\n\\n计算队列长度的公式：(rear-front+QueueSize)%QueueSize\\n\\n\\n## 四、字符串\\n\\n字符串操作常见的有：生成字符串、复制字符串、清空字符串、字符串是否为空？、字符串长度、字符串比较和字符串拼接、子串、子串索引、替换子串、插入子串、删除子串\\n\\n其中的核心操作就是字符串的比较。这里一共提到了三种匹配操作：\\n1）朴素的模式匹配方法  \\n2）KMP模式匹配算法\\n3）改进的KMP模式匹配算法\\n\\n朴素的模式匹配方法：\\n\\n通过循环，将主串的每一个字符和测试串T的每个元素进行比较。采用双层循环结构。优点是想法简单，容易实现，缺点是算法效率低。\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n## 五、树\\n\\n> 完全二叉树：除了最后一层节点，其余层的节点数已经达到了最大值，且最后一层的节点是按照从左到右的顺序排列的。\\n>\\n> 满二叉树：除了最后一层，其余层的节点都有两个子节点。\\n>\\n> 二叉排序树：左节点的值一定小于根节点；右节点的值一定大于根节点。 \\n>\\n> 平衡二叉树：又称AVL树，它是一颗二叉平衡树，且具有以下性质：它是一颗空树或左右两个子树的高度差绝对值不超过1，并且左右两个子树都是一颗平衡二叉树。\\n>\\n> > 说明：平衡因子：左子树高度 - 右子树高度    \\n>\\n> 红黑树：一种自平衡二叉查找树，是一种特化的平衡二叉树。\\n\\n![](https://s3.bmp.ovh/imgs/2022/10/30/ad75abd7cfbc22ba.png)\\n\\n**二叉排序树**：\\n\\n二叉排序树：是一棵空树，或者：若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；它的左、右子树也分别为二叉排序树。\\n\\n二叉排序树意味着二叉树中的数据是排好序的，顺序为左结点<根节点<右结点，这表明二叉排序树的中序遍历结果是有序的。\\n\\n**平衡二叉树**：\\n平衡二叉树的产生是为了解决二叉排序树在插入时发生线性排列的现象。由于二叉排序树本身为有序，当插入一个有序程度十分高的序列时，生成的二叉排序树会持续在某个方向的字数上插入数据，导致最终的二叉排序树会退化为链表，从而使得二叉树的查询和插入效率恶化。\\n![](https://s3.bmp.ovh/imgs/2022/10/30/a88628b6aef2dec2.png)\\n\\n平衡二叉树的出现能够解决上述问题，但是在构造平衡二叉树时，却需要采用不同的调整方式，使得二叉树在插入数据后保持平衡。主要的四种调整方式有LL（左旋）、RR（右旋）、LR（先左旋再右旋）、RL（先右旋再左旋）。这里先给大家介绍下简单的单旋转操作，左旋和右旋。LR和RL本质上只是LL和RR的组合。\\n\\n> 在插入一个结点后应该沿搜索路径将路径上的结点平衡因子进行修改，当平衡因子大于1时，就需要进行平衡化处理。从发生不平衡的结点起，沿刚才回溯的路径取直接下两层的结点，如果这三个结点在一条直线上，则采用单旋转进行平衡化，如果这三个结点位于一条折线上，则采用双旋转进行平衡化。\\n\\n左旋：S为当前需要左旋的结点，E为当前结点的父节点。\\n![](https://s3.bmp.ovh/imgs/2022/10/30/d9a414037fcbe702.png)\\n左旋的操作可以用一句话简单表示：将当前结点S的左孩子旋转为当前结点父结点E的右孩子，同时将父结点E旋转为当前结点S的左孩子。\\n\\n二叉排序树：当插入的数据高度有序时，二叉树会退化成链表，从而使得二叉树的查询和插入效率恶化。\\n\\n平衡二叉树优化了查询效率问题。但是在构造平衡二叉树时，却需要采用不同的调整方式使得二叉树在插入数据后保持平衡。高度平衡带来的好处是能够提供更高的搜索效率，其最坏的查找时间复杂度都是O(logN)。\\n\\n平衡二叉树带来了插入效率低的问题。有没有一种方法可以兼顾插入效率和查询效率呢？--答案是红黑树。\\n\\n**红黑树**：\\n\\n平衡二叉树（AVL）为了追求高度平衡，需要通过平衡处理使得左右子树的高度差必须小于等于1。高度平衡带来的好处是能够提供更高的搜索效率，其最坏的查找时间复杂度都是O(logN)。但是由于需要维持这份高度平衡，所付出的代价就是当对树种结点进行插入和删除时，需要经过多次旋转实现复衡。这导致AVL的插入和删除效率并不高。\\n\\n为了解决这样的问题，能不能找一种结构能够兼顾搜索和插入删除的效率呢？这时候红黑树便申请出战了。\\n\\n红黑树的五个特性：\\n\\n> 1、每个结点要么是红的要么是黑的。\\n>\\n> 2、根结点是黑的。\\n>\\n> 3、每个叶结点（叶结点即指树尾端NIL指针或NULL结点）都是黑的。\\n>\\n> 4、如果一个结点是红的，那么它的两个儿子都是黑的。\\n>\\n> 5、对于任意结点而言，其到叶结点树尾端NIL指针的每条路径都包含相同数目的黑结点。\\n>\\n> ![](https://s3.bmp.ovh/imgs/2022/10/30/6810891e8e72ed25.png)\\n> 黑树通过将结点进行红黑着色，使得原本高度平衡的树结构被稍微打乱，平衡程度降低。红黑树不追求完全平衡，只要求达到部分平衡。这是一种折中的方案，大大提高了结点删除和插入的效率。C++中的STL就常用到红黑树作为底层的数据结构。\\n\\n红黑树VS平衡二叉树\\n![](https://s3.bmp.ovh/imgs/2022/10/30/285dcb87b89c0d04.png)\\n\\n除了上面所提及的树结构，还有许多广泛应用在数据库、磁盘存储等场景下的树结构。比如B树、B+树等。这里就先不介绍了诶，下次在讲述相关存储原理的时候将会着重介绍。（其实是因为懒）\\n\\n\\n\\n\\n## 六、堆与散列表（哈希表）\\n\\n### 6.1 堆\\n\\n了解完二叉树，再来理解堆就不是什么难事了。堆通常是一个可以被看做一棵树的数组对象。堆的具体实现一般不通过指针域，而是通过构建一个一维数组与二叉树的父子结点进行对应，因此堆总是一颗完全二叉树。\\n\\n对于任意一个父节点的序号n来说（这里n从0算），它的子节点的序号一定是2n+1，2n+2，因此可以直接用数组来表示一个堆。\\n\\n不仅如此，堆还有一个性质：堆中某个节点的值总是不大于或不小于其父节点的值。将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。\\n\\n![](https://s3.bmp.ovh/imgs/2022/10/30/a0e7cdbcd8e45b1d.png)\\n堆常用来实现优先队列，在面试中经常考的问题都是与排序有关，比如堆排序、topK问题等。由于堆的根节点是序列中最大或者最小值，因而可以在建堆以及重建堆的过程中，筛选出数据序列中的极值，从而达到排序或者挑选topK值的目的。\\n\\n### 6.2 哈希表\\n\\n散列表也叫哈希表，是一种通过键值对直接访问数据的机构。在初中，我们就学过一种能够将一个x值通过一个函数获得对应的一个y值的操作，叫做映射。散列表的实现原理正是映射的原理，通过设定的一个关键字和一个映射函数，就可以直接获得访问数据的地址，实现O(1)的数据访问效率。在映射的过程中，事先设定的函数就是一个映射表，也可以称作散列函数或者哈希函数。\\n![](https://s3.bmp.ovh/imgs/2022/10/30/3ba468006ba54746.png)\\n散列表的实现最关键的就是散列函数的定义和选择。一般常用的有以下几种散列函数：\\n\\n> 直接寻址法：取关键字或关键字的某个线性函数值为散列地址。\\n>\\n> 数字分析法：通过对数据的分析，发现数据中冲突较少的部分，并构造散列地址。例如同学们的学号，通常同一届学生的学号，其中前面的部分差别不太大，所以用后面的部分来构造散列地址。\\n>\\n> 平方取中法：当无法确定关键字里哪几位的分布相对比较均匀时，可以先求出关键字的平方值，然后按需要取平方值的中间几位作为散列地址。这是因为：计算平方之后的中间几位和关键字中的每一位都相关，所以不同的关键字会以较高的概率产生不同的散列地址。\\n>\\n> 取随机数法：使用一个随机函数，取关键字的随机值作为散列地址，这种方式通常用于关键字长度不同的场合。\\n>\\n> 除留取余法：取关键字被某个不大于散列表的表长 n 的数 m 除后所得的余数 p 为散列地址。这种方式也可以在用过其他方法后再使用。该函数对 m 的选择很重要，一般取素数或者直接用 n。\\n\\n确定好散列函数之后，通过某个key值的确会得到一个唯一的value地址。但是却会出现一些特殊情况。即通过不同的key值可能会访问到同一个地址，这个现象称之为冲突。\\n\\n冲突在发生之后，当在对不同的key值进行操作时会使得造成相同地址的数据发生覆盖或者丢失，是非常危险的。所以在设计散列表往往还需要采用冲突解决的办法。\\n\\n常用的冲突处理方式有很多，常用的包括以下几种：\\n\\n> 开放地址法（也叫开放寻址法）：实际上就是当需要存储值时，对Key哈希之后，发现这个地址已经有值了，这时该怎么办？不能放在这个地址，不然之前的映射会被覆盖。这时对计算出来的地址进行一个探测再哈希，比如往后移动一个地址，如果没人占用，就用这个地址。如果超过最大长度，则可以对总长度取余。这里移动的地址是产生冲突时的增列序量。\\n>\\n> 再哈希法：在产生冲突之后，使用关键字的其他部分继续计算地址，如果还是有冲突，则继续使用其他部分再计算地址。这种方式的缺点是时间增加了。\\n>\\n> 链地址法：链地址法其实就是对Key通过哈希之后落在同一个地址上的值，做一个链表。其实在很多高级语言的实现当中，也是使用这种方式处理冲突的。\\n>\\n> 公共溢出区：这种方式是建立一个公共溢出区，当地址存在冲突时，把新的地址放在公共溢出区里。\\n\\n目前比较常用的冲突解决方法是链地址法，一般可以通过数组和链表的结合达到冲突数据缓存的目的。\\n![](https://s3.bmp.ovh/imgs/2022/10/30/77f0d941522f5204.png)\\n\\n左侧数组的每个成员包括一个指针，指向一个链表的头。每发生一个冲突的数据，就将该数据作为链表的节点链接到链表尾部。这样一来，就可以保证冲突的数据能够区分并顺利访问。\\n\\n考虑到链表过长造成的问题，还可以使用红黑树替换链表进行冲突数据的处理操作，来提高散列表的查询稳定性。\\n\\n\\n\\n## 七、图\\n\\n图相较于上文的几个结构可能接触的不多，但是在实际的应用场景中却经常出现。比方说交通中的线路图，常见的思维导图都可以看作是图的具体表现形式。\\n\\n图结构一般包括顶点和边，顶点通常用圆圈来表示，边就是这些圆圈之间的连线。边还可以根据顶点之间的关系设置不同的权重，默认权重相同皆为1。此外根据边的方向性，还可将图分为有向图和无向图。\\n![](https://s3.bmp.ovh/imgs/2022/10/30/6895b3dbf5ae8d5f.png)\\n图结构用抽象的图线来表示十分简单，顶点和边之间的关系非常清晰明了。但是在具体的代码实现中，为了将各个顶点和边的关系存储下来，却不是一件易事。\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n## 八、算法：查找\\n\\n参考： https://blog.csdn.net/chenlong_cxy/article/details/116563972?spm=1001.2101.3001.6661.1&depth_1-\\n\\n参考：https://blog.csdn.net/heyuchang666/article/details/50041455?spm=1001.2101.3001.6650.1&depth_1-\\n\\n参考：https://blog.csdn.net/heyuchang666/article/details/47275047\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n## 九、算法：排序\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\",\"articleCover\":\"\",\"articleTitle\":\"大话数据结构和算法\",\"articleType\":1,\"categoryName\":\"数据结构与算法\",\"isRecommend\":0,\"isTop\":0,\"status\":1,\"tagNameList\":[]}]','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',47,'2023-06-07 16:41:44');
INSERT INTO `t_operation_log` VALUES (1189,'文章模块','添加','/admin/article/add','com.ican.controller.ArticleController.addArticle','添加文章','[{\"articleContent\":\"---\\ntitle: 进程与线程\\ndate: 2022-10-30\\ncategory:\\n - 3操作系统与计算机组成原理\\n\\nfooter: <a href=\\\"https://beian.miit.gov.cn/#/Integrated/index\\\">渝ICP备2023001651号</a>\\n\\n---\\n\\n:::tip\\n进程与线程\\n:::\\n\\n<!-- more -->\\n\\n\\n“进程是操作系统分配资源的单位，线程是调度的基本单位，线程之间共享进程资源。”\\n进程是拥有资源的最小单位，线程是参与内核调度的最小单位。\\n\\n## 1、同一进程的不同线程之间，共享的资源有：\\n\\n+ 可执行的指令\\n+ 静态数据\\n+ 进程中打开的文件描述符\\n+ 当前工作目录\\n+ 用户ID\\n+ 用户组\\n\\n## 2、同一进程的不同线程之间，私有的资源有：\\n\\n+ 线程ID\\n+ PC程序寄存器和 其他相关寄存器\\n+ 堆栈\\n+ 每个线程中的局部变量是私有的\\n+ 错误号\\n+ 优先级\\n+ 执行状态和属性\",\"articleCover\":\"\",\"articleTitle\":\"进程与线程\",\"articleType\":1,\"categoryName\":\"操作系统与计算机组成原理\",\"isRecommend\":0,\"isTop\":0,\"status\":1,\"tagNameList\":[]}]','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',33,'2023-06-07 16:59:04');
INSERT INTO `t_operation_log` VALUES (1190,'文章模块','添加','/admin/article/add','com.ican.controller.ArticleController.addArticle','添加文章','[{\"articleContent\":\"---\\ntitle: IP地址说明\\ndate: 2022-10-30\\ncategory:\\n - 4计算机网络\\n\\nfooter: <a href=\\\"https://beian.miit.gov.cn/#/Integrated/index\\\">渝ICP备2023001651号</a>\\n\\n---\\n\\n:::tip\\nIP地址说明\\n:::\\n\\n<!-- more -->\\n\\n\\n[参考资料](https://www.cnblogs.com/zpcdbky/p/16107981.html)\",\"articleCover\":\"\",\"articleTitle\":\"IP地址说明\",\"articleType\":1,\"categoryName\":\"计算机网络\",\"isRecommend\":0,\"isTop\":0,\"status\":1,\"tagNameList\":[\"IP\"]}]','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',27,'2023-06-07 16:59:38');
INSERT INTO `t_operation_log` VALUES (1191,'文章模块','添加','/admin/article/add','com.ican.controller.ArticleController.addArticle','添加文章','[{\"articleContent\":\"---\\ntitle: IPv4学习记录\\ndate: 2020-12-15\\ntag:\\n - tag3\\ncategory: \\n - 4计算机网络\\n\\nfooter: <a href=\\\"https://beian.miit.gov.cn/#/Integrated/index\\\">渝ICP备2023001651号</a>\\n\\n---\\n\\n:::tip\\nIPv4学习记录\\n:::\\n\\n<!-- more -->\\n\\n\\n[参考资料](https://space.bilibili.com/360996402/channel/seriesdetail?sid=1721882)  B站up主：湖科大教书匠，计算机网络微课堂，第47-53讲，加上第60讲。\\n1、第47讲：IPv4地址概述\\n2、第48讲：分类编址的IPv4地址（分为ABCDE五类）\\n3、第49讲：划分子网的IPv4地址\\n4、第50讲：无分类编址的IPv4地址（无分类域间路由选择CIDR、斜线记法）\\n5、第51讲：IP地址的应用规划\\n6、第52讲：IP数据包的发送和转发过程\\n7、第53讲：静态路由的配置及其可能产生的路由环路问题\\n8、第60讲：虚拟专用网络VPN和网络地址转换NAT\\n\\n1、IPv4地址概述\\n分为三个历史阶段：分类编址、划分子网和五分类编址三个阶段。\\n\\n2、分类编址的IPv4地址\\n![图1](https://s3.bmp.ovh/imgs/2022/10/11/7a8cc0531f1d06f7.png)\\n![图2](https://s3.bmp.ovh/imgs/2022/10/11/a1a7e6a41ac812a8.png)\\n![图3](https://s3.bmp.ovh/imgs/2022/10/11/76aa90cdc5048e17.png)\\n![图4](https://s3.bmp.ovh/imgs/2022/10/11/813f395e6ae9d19c.png)\\n![图5](https://s3.bmp.ovh/imgs/2022/10/11/859076c54f7efad2.png)\\n\\n3、划分子网\\n\\n将划分子网的IP地址与相对应的子网掩码进行逻辑与运算就可得到IPv4地址所在<font color=\'red\'>子网的网络地址</font>。\\n\\n网络地址：仅包含网络号，主机号全部清零后的IP地址\\n\\n给定一个分类的IP和对应的子网掩码，就可以知道子网划分的细节：\\n\\n+ 划分区子网的数量\\n+ 每个子网可分配IP的数量\\n+ 每个子网的网络地址和广播地址\\n+ 每个子网可分配的最小和最大地址\\n\\n例：已知某个网络的地址是218.75.230.0，使用子网掩码255.255.255.192对其进行子网划分，请给出划分细节。\\n解析：\\n\\n首先，A类网是1 ~ 126，127作为本地回环地址，不指派。B类网是128 ~ 191，C类网是192 ~ 223，D类网是组播地址，E类网保留未使用。还有0号开头的为网络IP地址，127开头的为本地回环测试地址，不对外使用。10/8开头的、172.16/12开头和192.168/16的IP自由分配，可做局域网IP使用。\\n![图](https://s3.bmp.ovh/imgs/2022/10/12/b3644b1fd443eb7a.png)\\n\\n前往[IANA官网](https://www.iana.org/assignments/iana-ipv4-special-registry/iana-ipv4-special-registry.xhtml)查看IPv4分配细节。\\n\\n其次，题中的218为C类地址，网络号占3个字节（24bits），主机号占一个字节（8bits），子网掩码没设定的话，默认为255.255.255.0，而题目中为255.255.255.192,其中192的二进制为1100 0000，即网络号由26位bits构成，主机号由6位bits构成，如果用CIDR斜线记法表示为218.75.230.0/26。\\n\\n可划分子网数量2^2^=4个子网，每个子网可分配IP地址数量为2^(8-2)^-2=2^6^-2=62个。\\n![图6](https://s3.bmp.ovh/imgs/2022/10/12/e689726999c60be1.png)\\n\\n4、无分类的IPv4地址\\n\\n划分子网划分子网在一定程度上缓解了因特网在发展中晕倒的瓶颈，但是数量巨大的C类网因为其地址空间太小而没有得到充分的利用。\\n\\n为此，因特网工程任务组有提出了采用无分类编制的方法解决IP地址紧张的问题。无分类域间路由选择CIDR\\n\\nCIDR消除了划分IP地址分类和划分子网的概念，可以更有效地分配IPv4的地址空间。CISR采用斜线记法，即在IP地址后面写上斜线，斜线后加上网络前缀的数量。\\n\\n我们只要知道CIDR地址块中的任何一个地址，就可以知道该地址块的全部细节：\\n\\n+ 地址块的最小地址\\n+ 地址块的最大地址\\n+ 地址块的地址数量\\n+ 地址块聚合某类网络（A类、B类或C类）的数量\\n+ 地址掩码（也可继续称为子网掩码）\\n\\n例：请给出CIDR地址块128.14.35.7/20的全部细节（最小地址，最大地址，地址数量，聚合C类网数量，地址掩码）\\n\\t解析：\\n20位网络号，所以子网掩码为255.255.240.0，(B类IP，16bits网络号，16bits主机号)\\nIPv4地址：128.14.35.7  =  <font color=\'red\'>1000 0000. 0000 1110. 0010 </font>0011. 0000 0111 \\n掩码：    255.255.240.0 =   1111 1111.  1111  1111. 1111  0000. 0000 0000\\n逻辑按位与的结果为：        <font color=\'red\'>1000 0000. 0000 1110. 0010</font> 0000. 0000 0000 = 128.14.32.0\\n\\n所以，总共有2^(32-20)^=4096个IP地址,因为是聚合C类网，主机号：网络号=24:8，所以，每个子网的IP地址数量为2^8^个地址，聚合C类网的数量为总IP地址数量除以单个子网IP地址数量，即为2^(32-20)^ / 2^8^ =2^12^ / 2^8^ = 2^4^=16个聚合C类子网。\\n将主机号全部取零，得到最小地址128.14.32.0；将主机号全部取1，得到最大地址128.14.47.255。\\n\\n无分类编址的IPv4地址还可以用来构成超网：路由聚合\\n举例：172.1.4.0/25  172.1.4.128/25   \\n\\t172.1.5.0/24 172.1.6.0/24  172.1.7.0/24\\n找网络号的共同前缀：主要在于第三个字节：\\n172.1.4.0/25  -->   172.1.0000  0100.0\\n172.1.4.128/25 -> 172.1.0000  0100.128\\n172.1.5.0/24  -->  172.1.0000   0101.0\\n172.1.6.0/24  -->  172.1.0000   0110.0\\n172.1.7.0/24  -->  172.1.0000   0111.0\\n找共同前缀----->   172.1.4.0/22\\n注意，<font color=\'red\'>在网关路由中，网络前缀越长，地址块越小，路由越具体</font>。若路由器查表转发分组时发现有多条路由可选，则选择网络前缀最长的那条，这称为<font color=\'red\'>最长前缀匹配</font>。\\n\\n举例：在子网192.168.4.0/30中，能接受目的地址为192.168.4.3的IP分组的最大主机数为：____\\n解析：\\n\\n子网192.168.4.0，即：192.168.0000 0100.0000 0000  ，其中192.168.4.0000 00位网络号，最后两位00表示主机号，所以主机数量为4，但是主机号为0的主机只能做源IP地址，不能做目的IP地址；主机号全为1的地址，只能做广播地址，所以符合条件的主机号为2。\\n\\n最长前缀匹配(最佳匹配)：使用 CIDR 时，路由表中的每个项目由 \\\"网络前缀\\\" 和 \\\"下一跳地址\\\" 组成。在查询路由表时可能会得到不止一个匹配结果。应当从匹配结果中选择具有最长网络前缀的路由，因为网络前缀越长，其地址块越小，因此路由就越具体。\\n\\n**路由聚合的优点**：减小路由规模，加快路由匹配速度；降低路由更新时的流量开销。\\n\\n注意：\\n\\n(1) 划分子网只是把IP地址的主机号这部分进行再划分，而不是改变IP地址原来的网络号。因此，从一个IP地址本身或IP数据报的首部，并无法判断源主机或目的主机所连接的网络是否进行了子网划分。\\n\\n(2) 对分类的IPv4地址进行子网划分时，子网号不能为全0或全1。但随着CIDR的广泛使用，现在全0和全1的子网号也可以使用了。\\n\\n(3) 无论是分类IPv4地址还是CIDR，其子网中的主机号为全0或全1的地址都不能被指派。\\n\\n5、IPv4的应用规划\\n定长的子网掩码FLSM  /  变长的子网掩码VLSM\\n举例：使用定长的子网掩码FLSM方式来将218.75.230.0进行子网划分：\\n![图](https://s3.bmp.ovh/imgs/2022/10/12/caf1ef498ee2d87c.png)\\n解析：\\n\\n题目内容如上图所示，用定长的子网掩码来进行子网划分，考虑到N2子网数最多，为28台，并且218为C类网络，网络号24位，主机号为8位。综上，从8个主机号中划分5个做主机号，可满足最多32个主机，符合题目要求；剩余3个做子网号，可满足最多8个子网，满足题目中5个子网的要求。最终，定长子网划分结果如下：\\n子网划分依据：  218.75.230. 000<font color=\'red\'>0   0000</font>\\nN1： 218.75.230.1 ~ ~ 218.75.230.9    （9个IP）\\nN2： 218.75.230.33 ~ ~ 218.75.230.60  (28个IP)\\nN3： 218.75.230.65 ~ ~ 218.75.230.79  （15个IP）\\nN4： 218.75.230.97 ~ ~ 218.75.230.109   (13个IP)\\nN5： 218.75.230.129 ~ ~ 218.75.230.132 （4个IP)\\n![](https://s3.bmp.ovh/imgs/2022/10/12/fe7eb0646e3b1f63.png)\\n\\n\\n![](https://s3.bmp.ovh/imgs/2022/10/12/11e458750a1cc671.png)\\n\\n显然，使用定长的子网掩码来进行分组会极大地浪费IP，故而采用变长的子网掩码分组，按需使用IP。\\n\\n使用变长的子网掩码VLSM  --- IP： 218.75.230.0/24\\n分析题目中各个局域网的情况：\\nN1：6台主机，一个路由器，一个网络IP(全0)，一个广播IP(全1)，一共9个IP\\nN2：25台主机，需要28个IP\\nN3：12台主机，需要15个IP\\nN4：10台主机，需要13个IP\\nN5：0个主机，两个路由器，一个网络地址，一个广播地址，一共4个IP\\n\\n分配结果：\\nN1：9个IP，用4个主机号表示，即：/28\\nN2：28个IP，用5个主机号表示，即：/27\\nN3：15个IP，用4个主机号表示，即：/28\\nN4：13个IP，用4个主机号表示，即：/28\\nN5：4个IP，用2个主机号表示，即：/30\\n最终，从地址块中划分出5个子网地址块：1个/27地址块，3个/28地址块，1个/30地址块。先从主机号最多的子网开始分配。\\nN2：28个IP，子网地址块218.75.230.0 ~ ~ 218.75.230.31\\nN1：9个IP，子网地址块218.75.230.32 ~ ~ 218.75.230.47\\nN3：15个IP，子网地址块218.75.230.48 ~ ~ 218.75.230.63\\nN4：13个IP，子网地址块218.75.230.64 ~ ~ 218.75.230.79\\nN5：4个IP，子网地址块218.75.230.80 ~ ~ 218.75.230.83\\n其他子网地址块待分配\\n![](https://s3.bmp.ovh/imgs/2022/10/12/d0e1a20bba0a0c96.png)\\n![](https://s3.bmp.ovh/imgs/2022/10/12/0d6b104fe4c200a5.png)\\n\\n6、第52讲：IP数据包的发送和转发过程\\n![](https://s3.bmp.ovh/imgs/2022/10/12/63899dae2a42cd37.png)\\nIP路由器工作在TCP/IP体系结构的网际层（或称IP层），TCP/IP体系结构的网际层并不负责可靠传输，也就是不能确保传输的IP分组不丢失。IP路由器会对收到的IP分组头进行差错校验，当发现错误是会丢弃并报告源主机。\\n\\n\\nIP数据报的发送和转发过程包含以下两部分：\\n主机发送IP数据报；路由器转发IP数据报。\\n![](https://s3.bmp.ovh/imgs/2022/10/12/aa24315f888d2a56.png)\\n\\n**FAQ**\\n1、怎么判断发送主机IP和目的主机IP处于同一网络？\\n答：发送主机将自身掩码与自身IP相与，得到自己所处的网络地址；然后发送主机将自己掩码与目的主机在相与，得到目的主机在该掩码下的网络地址。\\n\\n如果两个网络地址相同，则表示处于同一网段，同一网段的主机可以直接通信，这是“直接交付”。\\n\\n如果两个网络地址不同，则IP数据报先交给局域网的网关，听过路由表查询前往目的主机IP的下一跳，然后离开本局域网，前往下一跳的局域网，最终达到目的主机，这是“间接交付”。\\n\\n2、路由器怎么根据IP数据报的目的地址，在路由表中查找匹配的条目呢？\\n答：①路由器先从数据报中得到源地址和目的地址；\\n②路由器根据其接口以及用户手动配置的路由表，可以得到所有的目的网络（如下图所示）。\\n![](https://s3.bmp.ovh/imgs/2022/10/12/a72362ec7a303a1a.png)\\n③将目的地址与路由表中的地址掩码相与，得到目的网络地址，然后检查得到的这个目的网络地址与路由表中的目的网络地址是否相同，相同就转发。\\n![](https://s3.bmp.ovh/imgs/2022/10/12/1513533a674d6acf.png)\\n\\n![](https://s3.bmp.ovh/imgs/2022/10/12/1e84edfd2f92a8c6.png)\\n\\n注意！局域网下的广播数据包交付给路由器后，路由器不会转发。也正因此，路由器可以有效地遏制网络风暴。\\n\\n中继器和集线器工作在物理层，既不隔离冲突域，也不隔离广播域；\\n网桥和交换机（多端口网桥）工作在数据链路层，可以隔离冲突域，不能隔离广播域。\\n路由器工作在网络层，既隔离冲突域，也隔离广播域。\\n\\n7、第53讲：静态路由的配置及其可能产生的路由环路问题\\n略\\n注意，手动添加路由表时，可以指定笼统的目的网络（即多个网络IP，取其相同数据的位，然后后面用斜线加数字来表示），可以指定特定的主机路由，例如192.168.1.1/32，可以指定默认路由0.0.0.0。但是需要注意，网络前缀越长，路由越具体；网络前缀越短，路由越模糊。多条路由可选时。最长前缀匹配！\\n\\n8、第60讲：虚拟专用网络VPN和网络地址转换NAT\\n以下三个地址块可以设置为局域网IP：\\n![](https://s3.bmp.ovh/imgs/2022/10/12/f99009b18204f73f.png)\\nNAT：网络地址转换，当专用网内部的主机已经分配了本地IP，但又想和因特网上的主机通信时，可使用NAT方法。这种方法需要安装NAT软件，且该软件至少拥有一个有效的公网IP，当本地地址想与外界通信时，都要在NAT路由器上将本地地址转换成临时的公网全球IP地址。\\n\\n\",\"articleCover\":\"\",\"articleTitle\":\"IPv4学习记录\",\"articleType\":1,\"categoryName\":\"计算机网络\",\"isRecommend\":0,\"isTop\":0,\"status\":1,\"tagNameList\":[]}]','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',48,'2023-06-07 16:59:58');
INSERT INTO `t_operation_log` VALUES (1192,'文章模块','添加','/admin/article/add','com.ican.controller.ArticleController.addArticle','添加文章','[{\"articleContent\":\"---\\ntitle: UML图图示\\ndate: 2022-10-30\\ncategory:\\n - 5设计模式\\n\\nfooter: <a href=\\\"https://beian.miit.gov.cn/#/Integrated/index\\\">渝ICP备2023001651号</a>\\n\\n---\\n\\n:::tip\\nUML图图示\\n:::\\n\\n<!-- more -->\\n\\n\\n基本关系预览图如下：\\n![图1](https://s3.bmp.ovh/imgs/2022/08/26/b5cd7823d6081560.png)\\n\\n首先，一个矩形就表示一个类，分为三行。第一行为类名，如果为斜体就是抽象类，第二行为类的属性（变量），第三行为类的方法（函数）。第二行的属性名和第三行的方法名前，+表示public，-表示private，#表示protected。如下图所示。\\n![图2](https://s3.bmp.ovh/imgs/2022/08/26/31e4605813d2c887.jpg)\\n\\n然后，是接口。接口有两种表示方法。方法一：矩阵表示法。矩阵第一行顶端有《interface》,第一行还有接口的名称，第二行是接口的方法。方法二：棒棒糖表示法：圆圈旁为接口名称，接口方法在实现类中出现。见下图所示：\\n![图3](https://s3.bmp.ovh/imgs/2022/08/26/65811fa415ced78b.png)\\n\\n再然后，是类与类之间和类与接口之间的关系。类与类之间，有继承关系、关联关系、聚合关系、合成（组合）关系和依赖关系。类与接口之间有实现接口关系。\\n\\n|            关系            |     表示方式      |\\n| :------------------------: | :---------------: |\\n|          继承关系          |  空心三角形+实线  |\\n|          关联关系          |     实线箭头      |\\n|          聚合关系          | 空心菱形+实线箭头 |\\n|          组合关系          | 实心菱形+实线箭头 |\\n|          依赖关系          |     虚线箭头      |\\n| （类与接口）实现接口的关系 |  空心三角形+虚线  |\\n\\n1.1  类一类之间的继承关系。用**空心三角形+实线**来表示。\\n![图4](https://s3.bmp.ovh/imgs/2022/08/26/04d598806cfc056e.png)\\n1.2  类一类之间的关联关系。用**实心箭头**来表示。\\n\\n企鹅与气候有很大的关联，企鹅需要知道气候的变化，需要了解气候规律。所以，企鹅继承于鸟基类，且有一个私有属性：气候。\\n![图5](https://s3.bmp.ovh/imgs/2022/08/26/21502e3c6a8adcef.jpg)\\n1.3  类一类之间的聚合关系。用**空心的菱形+实线箭头**来表示。\\n\\n聚合表示一种弱的拥有关系。体现的是A对象可以包含B对象，但B对象不是A对象的一部分。大雁可以聚合起来，称为大雁群，也可以不聚合，称为单雁。\\n![图6](https://s3.bmp.ovh/imgs/2022/08/26/cb326bbfa3cfd4ac.jpg)\\n1.4  类一类之间的合成（组合）关系。用**实心菱形+实线箭头**来表示。\\n\\n合成关系与聚合关系不同，合成关系表示一种强的拥有关系。鸟拥有羽毛，这是必然的，他们两是整体与部分的关系，并且生命周期相同。合成关系用**实心菱形和实线箭头**来表示，另外，你会注意到合成关系的连线两端还有一个数字‘1’和\'2\'，这被称为基数，表明这一段的类可以有几个实例。很显然，一只鸟应该有两只翅膀。注意：关联关系、聚合关系也可以有基数。\\n![图7](https://s3.bmp.ovh/imgs/2022/08/26/454c5f84f6533087.png)\\n1.5  类一类之间的依赖关系。用**虚线箭头**来表示。\\n\\n依赖关系就如字面意思，动物依赖于水，依赖于氧气。依赖关系用**虚线箭头**表示。\\n![图8](https://s3.bmp.ovh/imgs/2022/08/26/1fe1c94bb8cb10bd.jpg)\\n2.1 类与接口之间的实现接口关系，用空心三角形+虚线表示。\\n\\n实现接口和继承很类似，继承关系是空心三角形+实线来表示的。注意，仅当用矩阵表示法来表示接口时采用空心三角形+虚线表示，用棒棒糖法来表示接口时，无需其他说明。\\n![图9](https://s3.bmp.ovh/imgs/2022/08/26/022180a1216da787.png)\\n\\n**总结**：\\n更一般地，一个小总结：继承关系/关联关系/聚合关系/合成关系/依赖关系，以及一个实现接口关系。\\n\\n继承关系就是在子类名的定义中，类名后加上：public 基类名。\\n\\n关联关系就是在类中定义一个私有属性，例如企鹅和气候有关联关系，那么就在企鹅类中定义一个气候的私有变量。\\n\\n聚合关系就是在B类中定义一个私有数组变量，该数组变量的类型是A类。\\n\\n合成关系就是在B类中定义一个A类的私有变量，并在B类的构造函数中完成A类对象的实例化。他们两同时生成，同时死亡。\\n\\n依赖关系：动物类的属性是有生命，方法是新陈代谢。氧气类和水类是与方法--新陈代谢有关，所以在动物类的新陈代谢方法里，氧气类和水类作为方法的形参进行传递。\\n\\n\",\"articleCover\":\"\",\"articleTitle\":\"UML图图示\",\"articleType\":1,\"categoryName\":\"设计模式\",\"isRecommend\":0,\"isTop\":0,\"status\":1,\"tagNameList\":[\"设计模式\"]}]','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',60,'2023-06-07 17:00:36');
INSERT INTO `t_operation_log` VALUES (1193,'文章模块','添加','/admin/article/add','com.ican.controller.ArticleController.addArticle','添加文章','[{\"articleContent\":\"---\\ntitle: 设计模式总结\\ndate: 2022-10-30\\ncategory:\\n - 5设计模式\\n\\nfooter: <a href=\\\"https://beian.miit.gov.cn/#/Integrated/index\\\">渝ICP备2023001651号</a>\\n\\n---\\n\\n:::tip\\n设计模式总结\\n:::\\n\\n<!-- more -->\\n\\n\\n由GoF提出的设计模式有23种，再加上一种简单工厂模式，一共有24种模式，并大致分为三类。内容参考了[BiliBili视频黑马程序员(学完c++提高后在学这个)](https://www.bilibili.com/video/BV1Mb411t7ut?p=11&vd_source=d0ee64ac63fa4af6553687c1e0a80570)，以及热心网友整理的学习笔记：[CSDN博客](https://blog.csdn.net/weixin_42636062/category_11313224.html)，此外，程杰的《大话设计模式》一书也给此次笔记整理提供了巨大的帮助。\\n\\n| 创建型模式                            | 描述 |\\n| ------------------------------------- | ---- |\\n| <font color=\'red\'>简单工厂模式</font> |      |\\n| <font color=\'red\'>工厂方法模式</font> |      |\\n| <font color=\'red\'>抽象工厂模式</font> |      |\\n| <font color=\'red\'>单例模式</font>     |      |\\n| 原型模式                              |      |\\n| 建造者模式                            |      |\\n\\n\\n结构型模式，就是让类和类进行组合，获得更大的结构。\\n\\n| 结构型模式                          | 描述 |\\n| ----------------------------------- | ---- |\\n| <font color=\'red\'>代理模式</font>   |      |\\n| <font color=\'red\'>装饰模式</font>   |      |\\n| <font color=\'red\'>外观模式</font>   |      |\\n| <font color=\'red\'>适配器模式</font> |      |\\n| 桥接模式                            |      |\\n| 组合模式                            |      |\\n| 享元模式（共享）                    |      |\\n\\n\\n行为型模式，用来对类或对象怎样交互和怎样分配职责进行描述。\\n\\n| 行为型模式                          | 描述 |\\n| ----------------------------------- | ---- |\\n| <font color=\'red\'>模板模式</font>   |      |\\n| <font color=\'red\'>命令模式</font>   |      |\\n| <font color=\'red\'>策略模式</font>   |      |\\n| <font color=\'red\'>观察者模式</font> |      |\\n| 职责链模式                          |      |\\n| 解释器模式                          |      |\\n| 迭代器模式                          |      |\\n| 中介者模式                          |      |\\n| 备忘录模式                          |      |\\n| 状态模式                            |      |\\n| 访问者模式                          |      |\\n\\n\",\"articleCover\":\"\",\"articleTitle\":\"设计模式总结\",\"articleType\":1,\"categoryName\":\"设计模式\",\"isRecommend\":0,\"isTop\":0,\"status\":1,\"tagNameList\":[]}]','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',34,'2023-06-07 17:00:53');
INSERT INTO `t_operation_log` VALUES (1194,'文章模块','添加','/admin/article/add','com.ican.controller.ArticleController.addArticle','添加文章','[{\"articleContent\":\"---\\ntitle: 代码随想录学习笔记[总结]\\ndate: 2023-04-12\\ncategory:\\n - 找工作相关\\nstar: true\\ncover: \\\"https://w.wallhaven.cc/full/72/wallhaven-7286w9.png\\\"\\narticle: true\\nfooter: <a href=\\\"https://beian.miit.gov.cn/#/Integrated/index\\\">渝ICP备2023001651号</a>\\n\\n---\\n\\n:::tip\\n这是在学习代码随想录网站上的知识时，所做的一部分笔记\\n:::\\n\\n<!-- more -->\\n\\n\\n代码随想录学习笔记--文章修订记录：\\n\\n+ 2023/04/11 第一版仍在撰写\\n\\n\\n[[TOC]]\\n\\n## 一、数组\\n\\n数组和链表是数组结构中的基本数据结构。数组的特点是查询方便，链表的特点是插入/删除方便。还有个特点是，数组一般长度固定，二链表长度可以扩展。在存储方面的特点是，数组元素连续存储，链表元素不连续。\\n\\n数组是存放在连续内存空间上的想同类型数据的集合。数组的特点是元素下标从0开始，元素存储空间连续。数组的元素不能删，只能覆盖。\\n\\n二维数组在内存中如何存储的？对于cpp而言，二维数组在内存空间中也是连续存储的。对于Java而言，同一行下的数组元素存储式连续的，二不同行之间的数据不是连续存储的。类似于哈希表一样，用链表将多个行数组串联起来。\\n\\n在数组部分的知识点有：\\n\\n+ 二分查找\\n+ 移除元素\\n+ 有序数组的平方\\n+ 长度最小的子数组\\n+ 螺旋矩阵2\\n\\n### 1.1 二分查找\\n\\n前提必须是有序、不重复数组才能使用二分查找（已经按照从小到大或者从大到小的顺序排好了）。通过将数组中间元素值作为分割点，将数组分割为两部分，来减小一半的搜索量。通过比较数组中间元素值和target值，来更新left和right索引值。\\n\\n这里强调无重复元素是因为一旦有重复元素就会使得二分查找的返回值不唯一。二分查找的关键在于边界条件的框定。区间的定义是不变量，在循环过程中要遵循循环不变量原则。如果一开始就定义区间为左闭右闭，那就在循环中移植保持这种状态不改变。\\n\\n1. 第一种写法：左闭右闭。定义target在[left,right]区间中，所以有以下两点：\\n\\n+ `while(left <= right) `要用` <=` ，因为`left == right`是有意义的；\\n+ `if (nums[middle] > target)` 目标值偏小，搜索区间选择左侧子空间。那么right要赋值为`middle-1`，因为当前这个`nums[middle]`一定不是target，那么接下来要查找的左侧子区间的右端下标位置就从`middle-1`开始。\\n\\n2. 第二种写法：左闭右开。定义target在[left,right )区间中，所以有以下两点：\\n\\n+ `while(left < right)` 要用 < ，因为`left == right`是没有意义的，数组值不能够取值right；\\n+ `if (nums[middle] > target) `目标值偏小，搜索区间选择左侧子空间。那么right要赋值为middle，因为当前这个`nums[middle]`不等于target，那么接下来要查找的左侧子区间的右端下标位置就从middle开始。\\n\\n### 1.2 移除元素\\n\\n**问题描述**：给你一个数组和一个val，你需要原地移除数组中所有值等于val的元素，并返回移除后数组的新长度。要求：不能使用额外的数组空间，你必须使用O(1)额外空间并原地修改输入数组。例如，给定数组nums=[0,1,2,3,0,2,1,0,9,8,0,3],val=0,则新数组为[1,2,3,2,1,9,8,3]，返回长度为8。当然，返回数组的元素是否需要保存原有的相对位置并未作出限制。\\n\\n如何解决呢？1）使用双层for循环的暴力解法可以解决。外层for循环用来遍历数组，内层for循环用来更新删除元素后面的数组元素，将后面的元素依次向前挪一位来覆盖待删除的元素。时间复杂度为O(n2)。\\n\\n```cpp\\nint removeElement(vector<int>&nums, int val) {\\n\\tint size = nums.size();\\n\\tfor (int i = 0; i < size; i++) {\\n\\t\\tif (val == nums[i]) {\\n\\t\\t\\tfor (int j = i; j < size-1; j++) {\\n\\t\\t\\t\\t\\tnums[j] = nums[j+1];\\n\\t\\t\\t}\\n\\t\\ti--; //因为下标i以后的数据往前挪了一位，所以i也往前挪一位\\n\\t\\tsize--;\\n\\t\\t}\\n\\t} \\n\\treturn size;\\n}\\n```\\n\\n//上述代码的时间复杂度为O(n^2)，空间复杂度为O(1)。\\n\\n2）使用双指针法。通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。**快指针**：遍历整个数组，用来寻找新数组的元素，新数组就是不含目标元素值的数组。**慢指针**：指向更新后的新数组最后元素的下标。\\n\\n```cpp\\nfor (int fastIndex = 0; fastIndex < nums.size(); fastIndex++) {\\n    if (val != nums[fastIndex]) {\\n    \\tnums[slowIndex++] = nums[fastIndex];\\n    }\\n}\\n```\\n\\n//上述代码的时间复杂度为O(n)，空间复杂度为O(1)。\\n\\n### 1.3 有序数组的平方\\n\\n在这部分，主要考虑不管是包含负数还是不包含负数，数组元素的平方最大值一定在两端，绝不会在中间。所以对于题目要求的给定一个非递减顺序排序的整数数组，返回每个元素的平方组成的新数组，要求也按照非递减的顺序排序。可以确定的是，平方后的元素最大值一定在两端，所以最后的结果数组可以先从nums.size()-1元素先填值，最后在填充nums[0]的值。综上所述，有：\\n\\n```cpp\\nvector<int> sortedSquares(vector<int>&A) {\\n\\tvector<int> result(A.size(),0);\\n\\tint k = A.size() – 1;\\n\\t//注意：这里要i <= j，因为最后要处理两个元素\\n\\tfor(int i = 0,int j = A.size()-1; i < A.size();i <= j) {\\n\\t\\tif (A[i]*A[i] > A[j]*A[j]) {\\n\\t\\t\\t\\tresult[k--] = A[i]*A[i];\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tresult[k--] = A[j]*A[j];\\n\\t\\t\\tj--;\\n\\t\\t}\\n\\t}\\n\\treturn result;\\n}\\n```\\n\\n双指针法的时间复杂度为O(n)。\\n\\n补充说明：暴力解法：先平方，再排序。\\n\\n```cpp\\nvector<int> sortedSquares(vector<int>& A) {\\n\\tfor(int i = 0; i < A.size();i++) {\\n\\tA[i]*=A[i];\\n\\t}\\n\\tsort(A.begin(),A,end()); //快速排序\\n\\treturn A;\\n}\\n```\\n\\n时间复杂度为`O(n+nlogn)`，可以说是`O(nlogn)`。\\n\\n### 1.4 长度最小的子数组\\n\\n**题目**：给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。例如输入：s = 7, nums = [2,3,1,2,4,3] 输出：2 解释：子数组 [4,3] 是该条件下的长度最小的子数组。\\n\\n先介绍暴力解法：使用双层for循环来求解。外层for[i]循环用来遍历整个数组，内层for[j]循环从i开始遍历，直至元素之和大于等于s后才停止，然后此时就计算单次数组长度subLength，并更新整体最小数组长度result。\\n\\n```cpp\\nint minSubArrayLen(int s, vector<int> &nums) {\\nint result = INT32_MAX;\\nint subLength = 0;\\nint sum = 0;\\nfor(int i = 0; i < nums.size(); i++) {\\n\\tsum = 0;\\n\\tfor(int j=i ; j< nums.size();j++) {\\n\\t\\tsum += nums[j];\\n\\t\\tif (sum >= s) {\\n\\t\\t\\tsubLength = j-i+1;\\n\\t\\t\\tresult = result < subLength ? result : subLength;\\n\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\nreturn result == INT32_MAX? 0 : result;\\n}\\n```\\n\\n前面讲了暴力算法是用两个for循环来实现的，外层的for[i]的作用是遍历整个数组并提供窗口的起始位置，内层for[j]的作用设置满足条件的窗口终止位置。这样的缺点就是时间复杂度高，为O(n2)。类似的，我们可以考虑用滑动窗口来替换一个for循环，降低时间复杂度。那个滑动窗口的起始点如何确定呢？\\n\\n接下来就开始介绍数组操作中另一个重要的方法：滑动窗口。所谓滑动窗口，**就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果**。\\n\\n在暴力解法中，是一个for循环滑动窗口的起始位置，一个for循环为滑动窗口的终止位置，用两个for循环完成了一个不断搜索区间的过程。那么滑动窗口如何用一个for循环来完成这个操作呢。首先要思考如果用一个for循环，那么应该表示滑动窗口的起始位置，还是终止位置。\\n\\n如果用for[i]来指定滑动窗口的起始位置，那最终就会陷入暴力算法的怪圈，所以for[i]应当是来指定滑动窗口的终止位置。\\n\\n> 滑动窗口的终止位置（如何移动）：由for[i]指定，就是遍历数组的指针\\n> 滑动窗口内的元素：满足其和大于等于s条件最短子数组\\n> 滑动窗口的起始条件（如何移动）：如果窗口内的元素之和大于等于s之后，需要向前进来缩小窗口内的值。\\n\\n下面这段代码就是滑动窗口，此代码的精髓就在于动态调节滑动窗口的起始位置：\\n\\n```cpp\\nwhile(sum >= s) {\\n\\tsubLength = j – i + 1; //取子序列的长度\\n\\tresult = result < subLength ? result : subLength;\\n\\tsum -= nums[i++]; //这里体现出滑动窗口的精髓之处，不断变更i（子序列的起始位置）\\n}\\n```\\n\\n使用滑动窗口法（单for循环）来解题：\\n\\n```cpp\\nint minSubArrayLen(int s,vector<int> &nums) {\\n\\tint subLength = 0;\\n\\tint result = INT32_MAX;\\n\\tint sum = 0;\\n\\tint i = 0; //窗口的起始位置\\n\\tfor(int j = 0; j < nums.size(); j++) {\\n\\t\\tsum+=nums[j];\\n\\t\\twhile (sum >= s) {\\n\\t\\t\\tsubLength = j – i + 1;\\n\\t\\t\\tresult = result < subLength ? result : subLength;\\n\\t\\t\\tsum-=nums[i++];// 这里体现出滑动窗口的精髓之处，不断变更i（子序列的起始位置）\\n\\t\\t}\\n\\t}\\n\\treturn result == INT32_MAX ? 0 : result;\\n}\\n```\\n\\n### 1.5 螺旋矩阵2\\n\\n**题目**：给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。例如，给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。\\n\\n这道题目可以说在面试中出现频率较高的题目，本题并不涉及到什么算法，就是模拟过程，但却十分考察对代码的掌控能力。\\n\\n在之前二分查找法中就提到过的循环不变量原则，这里同样适用。这里是模拟顺时针画矩阵的过程：\\n\\n+ 填充上行从左到右；\\n+ 填充右行从上到下；\\n+ 填充下行从右到左；\\n+ 填充左行从下到上；\\n\\n由外向内一圈一圈这样画下去。这里一圈下来，我们要画每四条边，这四条边怎么画，每画一条边都要坚持一致的左闭右开，或者左开右闭的原则，这样这一圈才能按照统一的规则画下来。下图是按照左闭右开的原则来画的。\\n\\n<div align=center>\\n<img src = \'https://s3.bmp.ovh/imgs/2023/03/24/eea1feac93f415db.png\' >\\n</div>\\n\\n最后，整体cpp代码如下所示：\\n\\n```cpp\\nvector<vector<int>> generateMatrix(int n) {\\n\\tvector<vector<int>> res(n, vector<int>(n, 0)); // 使用vector定义一个二维数组\\n\\tint startx = 0, starty = 0; // 定义每循环一个圈的起始位置\\n\\tint loop =n/2;//每个圈循环几次，例如n为奇数3，那么loop=1只是循环一圈，矩阵中间的值需要单独处理\\n\\tint mid = n / 2; // 矩阵中间的位置，例如：n为3， 中间的位置就是(1，1)，n为5，中间位置为(2, 2)\\n\\tint count = 1; // 用来给矩阵中每一个空格赋值\\n\\tint offset = 1; // 需要控制每一条边遍历的长度，每次循环右边界收缩一位\\n\\tint i,j;\\n\\twhile (loop --) {\\n\\t\\ti = startx;\\n\\t\\tj = starty;\\n\\t\\t// 下面开始的四个for就是模拟转了一圈\\n\\t\\t// 模拟填充上行从左到右(左闭右开)\\n\\t\\tfor (j = starty; j < n - offset; j++) {\\n\\t\\t\\tres[startx][j] = count++;\\n\\t\\t}\\n\\t\\t// 模拟填充右列从上到下(左闭右开)\\n\\t\\tfor (i = startx; i < n - offset; i++) {\\n\\t\\t\\tres[i][j] = count++;\\n\\t\\t}\\n\\t\\t// 模拟填充下行从右到左(左闭右开)\\n\\t\\tfor (; j > starty; j--) {\\n\\t\\t\\tres[i][j] = count++;\\n\\t\\t}\\n\\t\\t// 模拟填充左列从下到上(左闭右开)\\n\\t\\tfor (; i > startx; i--) {\\n\\t\\t\\tres[i][j] = count++;\\n\\t\\t}\\n\\t\\t// 第二圈开始的时候，起始位置要各自加1，例如：第一圈起始位置是(0, 0)，第二圈起始位置是(1, 1)\\n\\t\\tstartx++;\\n\\t\\tstarty++;\\n\\t\\t// offset 控制每一圈里每一条边遍历的长度\\n\\t\\toffset += 1;\\n\\t}\\n\\t// 如果n为奇数的话，需要单独给矩阵最中间的位置赋值\\n\\tif (n % 2) {\\n\\t\\t res[mid][mid] = count;\\n\\t}\\n\\treturn res;\\n}\\n```\\n\\n### 1.6 总结篇\\n\\n数组是非常基础的数据结构，它是存放在连续内存空间上的相同类型数据的集合。需要注意的是，数组下标从0开始，且数组内存空间地址都是连续的。正因为数组在内存空间上的地址是连续的，所以在增删元素时就难免需要移动其他元素。数组元素不能删除，只能覆盖。对于二维数组，在cpp中是连续存储的，而Java中单行数组是连续存储的，而行与行之间是连接在一个链表上，并非连续存储。所以Java的二维数组在内存中不是完全连续的地址空间，而是由（行数）条连续地址空间构成，每个连续地址空间的长度是列数。\\n\\n<div align=center>\\n<img src = \'https://s3.bmp.ovh/imgs/2023/03/24/f9f79f108b25c45d.png\' >\\n</div>\\n\\n数组基础的一些经典题目有二分查找、双指针法、滑动窗口法还有模拟行为。\\n\\n<div align=center>\\n<img src = \'https://s3.bmp.ovh/imgs/2023/03/24/65074287759d1295.png\' >\\n</div>\\n\\n## 二、链表\\n\\n链表与数组一样，都是线性结构，不过数组各个元素之间是连续存储，而链表是分散存储。也正因为该特性，链表在增删方面的效率要高于数组，但是相对的在查找方面的效率要低于数组。链表的种类有：单链表、双向链表、循环链表。循环链表可以用来解决约瑟夫环问题。\\n\\n约瑟夫环问题：0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。**例如**：0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。\\n\\n链表的定义(//单链表)：\\n\\n```cpp\\nstruct ListNode {\\n\\tint val;\\n\\tListNode *next;\\n\\tListNode(int x) : val(x),next(NULL) {} //节点的构造函数\\n}；\\n```\\n\\n注意，你也可以不定义构造函数，cpp会自动生成默认的构造函数，但该构造函数不会初始化任何成员变量。使用默认的构造函数来初始化节点：`ListNode* head = new ListNode(),head->val = 5`。使用自定的节点构造函数则为：`ListNode* head = new ListNode(5)`;所以，对于使用默认的构造函数，是不能再定义时直接赋值的。链表的头指针是一定存在的，它指向第一个节点，是链表的标志。头结点不一定存在，**但是如果头结点存在，那么操作第一个节点的增删就和其他节点的增删操作是一样的了**。如果在链表的listcreat创建函数中有开辟空间的操作，一般就是有头结点的（例如以前写的C语言链表操作）。在这里的cpp代码中链表的创建是通过结构体和new操作的，没有创建额外的空间，是没有头结点的。头结点就是在头指针和第一个节点之间，添加的节点值为无效值的节点。\\n\\n**链表的操作**：删除节点、增加节点。对于C/cpp的链表删除节点操作，最好要进行内存的手动释放，避免内存泄漏，而Java和Python无需手动释放。下面是单链表的添加节点和删除节点操作。\\n\\n<div align=center>\\n<img src = \'https://s3.bmp.ovh/imgs/2023/03/24/8564202a88941271.png\' >\\n</div>\\n\\nF节点为new节点，C节点为p，则**添加**新节点可以表达为1）`new->next=p->next;2）p->next=new`。\\n\\n<div align=center>\\n<img src = \'https://s3.bmp.ovh/imgs/2023/03/24/9cb09bc8cb8823ba.png\' >\\n</div>\\n\\n**删除**节点可以表达为：`if(p->next->val == val)，ListNode* tmp=p->next;1）p->next=p->next->next;2）delete tmp`;\\n\\n循环链表就是头尾相连的链表，将单链表的尾结点的next指针从NULL指向头结点，便使得整个单链表形成了一个环，这种头尾相接的单链表称为单循环链表，简称循环链表。为了使得空链表的处理与非空链表一致，我们通常设置一个头结点，但是不是说循环链表一定要头结点，这点要注意。\\n\\n其实，循环链表与单链表的差异就在循环的判断条件上，原来试试判断`p->next==NULL`，现在是判断`p->next`等于头结点，则循环结束。\\n\\n对循环链表进行改造，使用尾指针而非头指针，可以使得对尾结点的访问为O(1)，并且对头结点的访问也是O(1)。举个程序的例子，需要将两个循环链表合并为一个链表时，使用为指针就十分方便了。\\n\\n<div align=center>\\n<img src = \'https://s3.bmp.ovh/imgs/2023/03/24/ef20cbea2d6919e6.png\' >\\n</div>\\n<div align=center>\\n<img src = \'https://s3.bmp.ovh/imgs/2023/03/24/28e9daa9809379b3.png\' >\\n</div>\\n\\n使用以下代码块来实现：\\n\\n```cpp\\np=rearA->next; //保存A表的头结点，即①\\nrearA->next=rearB->next->next; //舍弃B表的头结点，将本是指向B表的第一个节点（不是头结点）赋值给rearA->next，即②\\nrearB->next=p; //将原来A表的头结点赋值给rearB->next，即③\\nfree(p); //释放p\\n```\\n\\n双向链表就是在单链表的基础上新增了一个向前的指针，有双指针prior和next，还可以组合成双向循环链表。另外，对于双向链表，节点后继的前驱、节点前驱的后继都是节点本身，如：`p->next->prior=p=p->prior->next`。下面开始介绍双向链表的插入和删除操作。\\n\\n我们假设存储元素e的新节点为s，要将新节点插入到节点p和p->next之间有以下几步，如下图所示。\\n\\n<div align=center>\\n<img src = \'https://s3.bmp.ovh/imgs/2023/03/24/cd2a6675b201a79d.png\' >\\n</div>\\n\\n代码块如下所示：\\n\\n```cpp\\ns->prior=p;\\ns->next=p->next;\\np->next->prior=s;\\np->next=s;\\n```\\n\\n关键点在于它们的顺序，由于最后三步都用到了p->next，所以如果第四步先执行会出错。注意：如果把第四步提前，会失去对a~i+1~节点的控制，造成插入节点出错的问题。\\n\\n<div align=center>\\n<img src = \'https://s3.bmp.ovh/imgs/2023/03/24/d5b28bb5a3bf7c52.png\' >\\n</div>\\n\\n代码块如下所示：\\n\\n```cpp\\np->prior-next=p->next; //仔细观察，删除节点p对外指向的指针不需要变动\\np->next->prior=p->prior;//主要变动指向节点p的指针，即ai-1->next和ai+1->prior\\nfree(p);\\n```\\n\\n### 2.1移除链表元素\\n\\n**题意**：删除链表中等于给定值 val 的所有节点\\n\\n注意：对于含头结点的节点删除，第一个节点的操作与其他节点的操作是一致的；对于不含头结点的节点删除，删除第一个节点的操作就是头指针后移+第一个节点内存释放。下面是cpp代码示例。\\n\\n**直接使用原来的链表进行节点删除操作**\\n\\n```cpp\\nListNode* removeElements(ListNode* head, int val) {\\n// 删除头结点\\nwhile (head != NULL && head->val == val) { // 注意这里不是if\\n\\tListNode* tmp = head;\\n\\thead = head->next;\\n\\tdelete tmp;\\n}\\n// 删除非头结点\\nListNode* cur = head;\\nwhile (cur != NULL && cur->next!= NULL) {\\n\\tif (cur->next->val == val) {\\n\\t\\tListNode* tmp = cur->next;\\n\\t\\tcur->next = cur->next->next;\\n\\t\\tdelete tmp;\\n} else {\\n\\tcur = cur->next;\\n\\t}\\n}\\nreturn head;\\n}\\n```\\n\\n**直接使用原来的链表进行节点删除操作**\\n\\n```cpp\\nListNode* removeElements(ListNode* head, int val) {\\n\\tListNode* dummyHead = new ListNode(0); // 设置一个虚拟头结点\\n\\tdummyHead->next = head; // 将虚拟头结点指向head，这样方面后面做删除操作\\n\\tListNode* cur = dummyHead;\\n\\twhile (cur->next != NULL) {\\n\\t\\tif(cur->next->val == val) {\\n\\t\\t\\tListNode* tmp = cur->next;\\n\\t\\t\\tcur->next = cur->next->next;\\n\\t\\t\\tdelete tmp;\\n\\t\\t} else {\\n\\t\\t\\tcur = cur->next;\\n\\t\\t}\\n\\t}\\n\\thead = dummyHead->next;\\n\\tdelete dummyHead;\\n\\treturn head;\\n}\\n```\\n\\n### 2.2 设计链表\\n\\n**题意**：设计一个基本的链表类，它应当具有以下功能：\\n\\n+ `get(index)`：获取链表中第index个节点的值。如果索引无效，则返回-1。\\n+ `addAtHead(val)`：在链表的第一个元素之前添加一个值为val的节点。插入后，新节点将成为链表的第一个节点。\\n+ `addAtTail(val)`：将值为val的节点追加到链表的最后一个元素。\\n+ `addAtIndex(index,val)`：在链表中的第index个节点之前添加值为val的节点。如果index等于链表的长度，则该节点将附加到链表的末尾。如果index大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。\\n+ `deleteAtIndex(index)`：如果索引index有效，则删除链表中的第index个节点。\\n\\n示例：\\n\\n<div align=center>\\n<img src = \'https://s3.bmp.ovh/imgs/2023/03/24/ee4506ef4a51361b.png\' >\\n</div>\\n\\n\\n这道题目设计链表的五个接口：\\n\\n+ 获取链表第index个节点的数值\\n+ 在链表的最前面插入一个节点\\n+ 在链表的最后面插入一个节点\\n+ 在链表第index个节点前面插入一个节点\\n+ 删除链表的第index个节点\\n\\n可以说这五个接口，已经覆盖了链表的常见操作，是练习链表操作非常好的一道题目。\\n\\n**链表操作的两种方式**\\n\\n1.\\t直接使用原来的链表进行操作\\n2.\\t设置一个虚拟的头结点在进行操作\\n\\n下面分别是cpp和C语言的链表设计：\\n\\n```cpp\\n/*************cpp实现链表设计****************/\\nclass MyLinkedList {\\npublic:\\n// 定义链表节点结构体\\nstruct LinkedNode {\\n\\tint val;\\n\\tLinkedNode* next;\\n\\tLinkedNode(int val):val(val), next(nullptr){}\\n};\\n// 初始化链表\\nMyLinkedList() {\\n\\t_dummyHead = new LinkedNode(0); // 这里定义的头结点是一个虚拟头结点，而不是真正的链表头结点\\n\\t_size = 0;\\n}\\n// 获取到第index个节点数值，如果index是非法数值直接返回-1， 注意index是从0开始的，第0个节点就是头结点\\nint get(int index) {\\n\\tif (index > (_size - 1) || index < 0) {\\n\\t\\treturn -1;\\n\\t}\\n\\tLinkedNode* cur = _dummyHead->next;\\n\\twhile(index--){ // 如果--index 就会陷入死循环\\n\\t\\tcur = cur->next;\\n\\t}\\n\\treturn cur->val;\\n}\\n// 在链表最前面插入一个节点，插入完成后，新插入的节点为链表的新的头结点\\nvoid addAtHead(int val) {\\n\\tLinkedNode* newNode = new LinkedNode(val);\\n\\tnewNode->next = _dummyHead->next;\\n\\t_dummyHead->next = newNode;\\n\\t_size++;\\n}\\n// 在链表最后面添加一个节点\\nvoid addAtTail(int val) {\\n\\tLinkedNode* newNode = new LinkedNode(val);\\n\\tLinkedNode* cur = _dummyHead;\\n\\twhile(cur->next != nullptr){\\n\\t\\tcur = cur->next;\\n\\t}\\n\\tcur->next = newNode;\\n\\t_size++;\\n}\\n// 在第index个节点之前插入一个新节点，例如index为0，那么新插入的节点为链表的新头节点。\\n// 如果index 等于链表的长度，则说明是新插入的节点为链表的尾结点\\n// 如果index大于链表的长度，则返回空\\n// 如果index小于0，则在头部插入节点\\nvoid addAtIndex(int index, int val) {\\n\\tif(index > _size) return;\\n\\tif(index < 0) index = 0;        \\n\\tLinkedNode* newNode = new LinkedNode(val);\\n\\tLinkedNode* cur = _dummyHead;\\n\\twhile(index--) {\\n\\tcur = cur->next;\\n\\t}\\n\\tnewNode->next = cur->next;\\n\\tcur->next = newNode;\\n\\t_size++;\\n}\\n//删除第index个节点，如果index大于等于链表的长度，直接return，注意index是从0开始的\\nvoid deleteAtIndex(int index) {\\n\\tif (index >= _size || index < 0) {\\n\\t\\treturn;\\n\\t}\\n\\tLinkedNode* cur = _dummyHead;\\n\\twhile(index--) {\\n\\t\\tcur = cur ->next;\\n\\t}\\n\\tLinkedNode* tmp = cur->next;\\n\\tcur->next = cur->next->next;\\n\\tdelete tmp;\\n\\t_size--;\\n}\\n\\n// 打印链表\\nvoid printLinkedList() {\\n\\tLinkedNode* cur = _dummyHead;\\n\\twhile (cur->next != nullptr) {\\n\\t\\tcout << cur->next->val << \\\" \\\";\\n\\t\\tcur = cur->next;\\n\\t}\\n\\tcout << endl;\\n}\\nprivate:\\n\\tint _size;\\n\\tLinkedNode* _dummyHead;\\n};\\n```\\n\\n下面是用C语言来实现链表：\\n\\n```c\\n/*************C语言实现链表设计****************/\\ntypedef struct MyLinkedList {\\n\\tint val;\\n\\tstruct MyLinkedList* next;\\n}MyLinkedList;\\n/**在这里初始化你的结构体数据**/\\nMyLinkedList* myLinkedListCreate() {\\n//这个题必须用虚拟头指针,参数都是一级指针,头节点确定后没法改指向了!!!\\n\\tMyLinkedList* head = (MyLinkedList *)malloc(sizeof (MyLinkedList));\\n\\thead->next = NULL;\\n\\treturn head;\\n}\\n/**根据索引获取到链表的值**/\\nint myLinkedListGet(MyLinkedList* obj, int index) {\\n\\tMyLinkedList *cur = obj->next;\\n\\tfor (int i = 0; cur != NULL; i++){\\n\\t\\tif (i == index){\\n\\t\\t\\treturn cur->val;\\n\\t\\t}\\n\\t\\telse{\\n\\t\\t\\tcur = cur->next;\\n\\t\\t}\\n\\t}\\n\\treturn -1;\\n}\\n/**在头节点前添加新节点**/\\nvoid myLinkedListAddAtHead(MyLinkedList* obj, int val) {\\n\\tMyLinkedList *nhead = (MyLinkedList *)malloc(sizeof (MyLinkedList));\\n\\tnhead->val = val;\\n\\tnhead->next = obj->next;\\n\\tobj->next = nhead;\\n}\\n/**在尾部插入新节点**/\\nvoid myLinkedListAddAtTail(MyLinkedList* obj, int val) {\\n\\tMyLinkedList *cur = obj;\\n\\twhile(cur->next != NULL){\\n\\t\\tcur = cur->next;\\n\\t}\\n\\tMyLinkedList *ntail = (MyLinkedList *)malloc(sizeof (MyLinkedList));\\n\\tntail->val = val;\\n\\tntail->next = NULL;\\n\\tcur->next = ntail;\\n}\\n/**在指定索引节点后插入，如果索引值为0表示头插，如果索引值大于长度就插入无效*/\\nvoid myLinkedListAddAtIndex(MyLinkedList* obj, int index, int val) {\\n\\tif (index == 0){\\n\\t\\tmyLinkedListAddAtHead(obj, val);\\n\\t\\treturn;\\n\\t}\\n\\tMyLinkedList *cur = obj->next;\\n\\tfor (int i = 1 ;cur != NULL; i++){\\n\\t\\tif (i == index){\\n\\t\\t\\tMyLinkedList* newnode = (MyLinkedList *)malloc(sizeof (MyLinkedList));\\n\\t\\t\\tnewnode->val = val;\\n\\t\\t\\tnewnode->next = cur->next;\\n\\t\\t\\tcur->next = newnode;\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\telse{\\n\\t\\t\\tcur = cur->next;\\n\\t\\t}\\n\\t}\\n}\\n/** 按索引来删除节点，删除索引值后的一个节点 **/\\nvoid myLinkedListDeleteAtIndex(MyLinkedList* obj, int index) {\\n\\tif (index == 0){\\n\\t\\tMyLinkedList *tmp = obj->next;\\n\\t\\tif (tmp != NULL){\\n\\t\\t\\tobj->next = tmp->next;\\n\\t\\t\\tfree(tmp);     \\n\\t \\t}\\n\\t\\treturn;\\n\\t}\\n\\tMyLinkedList *cur = obj->next;\\n\\tfor (int i = 1 ;cur != NULL && cur->next != NULL; i++){\\n\\t\\tif (i == index){\\n\\t\\t\\tMyLinkedList *tmp = cur->next;\\n\\t\\t\\tif (tmp != NULL) {\\n\\t\\t\\t\\tcur->next = tmp->next;\\n\\t\\t\\t\\tfree(tmp);\\n\\t\\t\\t}\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\telse{\\n\\t\\t\\tcur = cur->next;\\n\\t\\t}\\n\\t}\\n}\\nvoid myLinkedListFree(MyLinkedList* obj) {\\n\\twhile(obj != NULL){\\n\\t\\tMyLinkedList *tmp = obj;\\n\\t\\tobj = obj->next;\\n\\t\\tfree(tmp);\\n\\t}\\n}\\n/**\\n *你可以如此调用你的程序:\\n * MyLinkedList* obj = myLinkedListCreate();\\n * int param_1 = myLinkedListGet(obj, index);\\n * myLinkedListAddAtHead(obj, val);\\n * myLinkedListAddAtTail(obj, val);\\n * myLinkedListAddAtIndex(obj, index, val);\\n * myLinkedListDeleteAtIndex(obj, index);\\n * myLinkedListFree(obj);\\n*/\\n```\\n\\n### 2.3 翻转链表\\n\\n**题意**：翻转链表，即输入：1->2->3->4->5->NULL 输出: 5->4->3->2->1->NULL\\n**思路**：关键在于链表next指针的翻转。\\n\\n<div align=center>\\n<img src = \'https://s3.bmp.ovh/imgs/2023/03/24/abb4acd8d087c152.png\' >\\n</div>\\n\\n+ 首先定义一个cur指针，指向头结点，再定义一个pre指针，初始化为null。\\n+ 然后就要开始反转了，首先要把 cur->next 节点用tmp指针保存一下，也就是保存一下这个节点。\\n+ 为什么要保存一下这个节点呢，因为接下来要改变 cur->next 的指向了，将cur->next 指向pre ，此时已经反转了第一个节点了。\\n+ 接下来，就是循环走如下代码逻辑了，继续移动pre和cur指针。\\n+ 最后，cur 指针已经指向了null，循环结束，链表也反转完毕了。 此时我们return pre指针就可以了，pre指针就指向了新的头结点。\\n\\n<font color=\'orange\'>==1）下面是cpp双指针法的代码实现==</font>：\\n\\n```cpp\\nListNode* reverseList(ListNode* head) {\\n\\tListNode* tmp; //保存cur的下一个节点\\n\\tListNode* cur = head;\\n\\tListNode* pre = NULL;\\n\\twhile(cur) {\\n\\ttmp = cur->next;\\n\\tcur->next = pre; \\t// 翻转操作\\n\\tpre = cur;\\n\\tcur = tmp;\\n\\t}\\n\\treturn pre;\\n}\\n```\\n\\n<font color=\'orange\'>==2）下面是cpp递归法的实现==</font>：\\n\\n递归法相对抽象一些，但是其实和双指针法是一样的逻辑，同样是当cur为空的时候循环结束，不断将cur指向pre的过程。\\n关键是初始化的地方，可能有的同学会不理解，可以看到双指针法中初始化 cur = head，pre = NULL，在递归法中可以从如下代码看出初始化的逻辑也是一样的，只不过写法变了。**双指针法写出来之后，理解如下递归写法就不难了，代码逻辑都是一样的**。\\n\\n```cpp\\nListNode* reverse(ListNode* pre,ListNode* cur) {\\n\\tif(cur == NULL) return pre;\\n\\tListNode *tmp = cur->next;\\n\\tcur->next = pre;\\n\\treturn reverse(cur,tmp);\\n}\\nListNode* reverseList(ListNode* head) {\\n\\treturn reverse(NULL,head);\\n}\\n```\\n\\n我们可以发现，上面的递归写法和双指针法实质上都是从前往后翻转指针指向，其实还有另外一种与双指针法不同思路的递归写法：从后往前翻转指针指向。\\n\\n<font color=\'orange\'>==3）下面是从后往前翻转指针指向(十分精巧)==</font>：\\n\\n```cpp\\nListNode* reverseList() {\\n\\t//边缘条件检测\\n\\tif(head == NULL) return NULL;\\n\\tif(head->next == NULL ) return head;\\n\\t//递归调用\\n\\tListNode* last = reverseList(head->next);\\n\\thead->next->next = head;\\n\\thead->next = NULL;\\n\\treturn last;\\n}\\n```\\n\\n<font color=\'orange\'>==4）是用虚拟节点和头插法来解决链表翻转问题（不需要栈）==</font>：\\n\\n```cpp\\nListNode* reverseList(ListNode* head) {\\n\\tListNode* dumpyHead = new ListNode(-1);\\n\\tdumpyHead->next = NULL;\\n\\tListNode* cur = head;\\n\\twhile(cur!=NULL) {\\n\\t\\tListNode* tmp = cur->next;\\n\\t\\t//头插法：把第一个节点拆下来，插在虚拟头结点后头；把第二个节点拆下来，再插在虚拟头结点后头。就实现节点1和2的翻转，后面的类似操作即可。\\n\\t\\t//感觉和双指针法差不多，cur指向当前，tmp保存cur->next，然后cur指向pre，最后pre由cur更新，cur由tmp更新。而这里的虚拟头插法相当于把pre换成了虚拟头dumptHead。\\n\\t\\tcur->next = dumpyHead->next;\\n\\t\\tdumpyHead ->next = cur;\\n\\t\\tcur = tmp;\\n\\t}\\n\\treturn dumpyHead ->next;\\n}\\n```\\n\\n<font color=\'orange\'>==5）使用栈来解决链表翻转问题（本质也是和递归一样的）==</font>：\\n\\n首先把所有节点入栈，然后cur指向虚拟头结点，再然后循环出栈，每出来一个元素就把它加入到虚拟头结点为头结点的链表当中，最后返回即可。\\n\\n**采用这种方法需要注意一点。就是当整个出栈循环结束以后，cur正好指向原来链表的第一个结点，而此时结点1中的next指向的是结点2，因此最后还需要`cur.next = null`**。\\n\\n<div align=center>\\n<img src = \'https://s3.bmp.ovh/imgs/2023/03/24/f35d9150f6961bd6.png\' >\\n</div>\\n\\n\\n![](https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlHgdz7m76yDUi9PH/root/content)\\n\\n**注意**：代码随想录的上述原代码在力扣实际测试时，有些问题，更正为上述代码后正常运行（实际上网站提供的是Java代码，我改成了cpp，所以有些方法名不对头）。例如在STL中的栈名字叫stack而非Stack，且没有isEmpty()方法而是empty()方法。此外第三点就是pop()方法的返回值是void，要想获取栈顶值应当使用top()方法，在使用pop()方法弹出元素。\\n\\n### 2.4 两两交换链表中的节点\\n\\n**题目**：给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。*你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换*。\\n\\n示例：\\n\\n<div align=center>\\n<img src = \'https://s3.bmp.ovh/imgs/2023/03/24/a14cd19641a753e9.png\' >\\n</div>\\n\\n对于输入head=[1,2,3,4],输出为[2,1,4,3]\\n\\n**思路**：建议使用虚拟头结点，这样会方便很多，要不然每次针对头结点（没有前一个指针指向头结点），还要单独处理。\\n![两两交换链表中的节点--程序设计示意图](https://s3.bmp.ovh/imgs/2023/03/24/c5275104b2c0b5f5.png)\\n\\n仔细分析上述示意图，可以知道至少需要两个tmp临时指针来保存节点指针才能正确实现“每两个节点进行一次互换”的操作，cpp代码如下：\\n\\n```cpp\\nListNode* swapPairs(ListNode* head) {\\n\\tListNode* dummyHead = new ListNode(0);\\n\\tdummyHead->next = head;\\n\\tListNode* cur = dummyHead;//设置虚拟节点，并为cur指针赋初始值\\n\\twhile (cur->next!=NULL&&cur->next->next!=NULL) {\\n\\t\\tListNode* tmp = cur->next; //cur后的第一个节点\\n\\t\\tListNode* tmp2 = cur->next->next->next;//cur后的第三个节点\\n\\t\\t\\n\\t\\tcur->next = cur->next->next; //步骤一\\n\\t\\tcur->next->next = tmp; //步骤二\\n\\t\\tcur->next->next->next = tmp2; //步骤三\\n\\t\\t\\n\\t\\tcur = cur->next->next;\\n\\t}\\n\\treturn dummyHead->next;\\n\\t//时间复杂度O(n)，空间复杂度O(1)\\n}\\n```\\n\\n【关于<font color=\\\"red\\\">递归</font>】\\n\\n在代码随想录二叉树递归遍历那一章，讲了一下递归的三要素：\\n\\n1. **确定递归函数的参数和返回值**： 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。\\n\\n2. **确定终止条件**： 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。\\n\\n3. **确定单层递归的逻辑**： 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。\\n\\n下面以本次两两交换链表中的节点为例，再来强化一遍。本次递归程序设计中，1）递归的参数和返回值都是链表头指针。2）终止条件就是链表访问结束，有NULL。就是cur->next和cur->next->next为NULL。3）单层递归的逻辑，就是每两个节点为一对，1）本对的第一个节点指向下一对，2）对内，第二个节点指向第一个节点，3）第二个节点坐标作为一个结构体返回。下图是程序设计示意图。\\n\\n![程序设计示意图](https://s3.bmp.ovh/imgs/2023/03/24/67a571af0d281e5a.png)\\n\\nC语言实现两两交换链表中的节点（递归版本)\\n\\n```c\\n//单链表的格式为：\\ntypedef struct node {\\n\\tint val;\\n\\tstruct node *next;\\n}ListNode;\\n//递归版本 （该代码认为链表没有头结点，第一个head节点就是有效节点）\\nListNode* swapPairs(ListNode* head) {\\n//递归结束条件：头节点不存在或头节点的下一个节点不存在。此时不需要交换，直接返回head\\n\\tif (!head || !head->next)\\n\\t\\treturn head;\\n\\t//创建一个节点指针类型保存头结点下一个节点\\n\\tListNode* newHead = head->next;\\n\\t//更改头结点+2位节点后的值，并将头结点的next指针指向这个更改过的list\\n\\thead->next = swapPairs(newHead->next);\\n\\t//将新的头结点的next指针指向老的头节点\\n\\tnewHead->next = head;\\n\\treturn newHead;\\n}\\n```\\n\\nC语言实现两两交换链表中的节点（迭代版本）\\n\\n```c\\n//迭代版本\\nstruct ListNode* swapPairs(struct ListNode* head){\\n    //使用双指针避免使用中间变量\\n    typedef struct ListNode ListNode;\\n    ListNode *fakehead = (ListNode *)malloc(sizeof(ListNode));\\n    fakehead->next = head;\\n    ListNode* right = fakehead->next;\\n    ListNode* left = fakehead;\\n    while(left && right && right->next ){\\n        left->next = right->next;\\n        right->next = left->next->next;\\n        left->next->next = right;\\n        left = right;\\n        right = left->next;\\n    }\\n    return fakehead->next;\\n}\\n```\\n\\n### 2.5 删除链表的倒数第N个节点\\n\\n**题意**：删除链表的倒数第N个节点\\n\\n**思路**：采用双指针的方法来实现：定义两个指针，fast指针先走N+1步，然后slow指针再走。当fast指针走到NULL时，slow指针刚好就在待删除节点的前一个节点。\\n\\n### 2.6 链表相交\\n\\n**题意**：给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。\\n\\n题目数据 保证 整个链式结构中不存在环。注意，函数返回结果后，链表必须 保持其原始结构 。图示两个链表在节点 c1 开始相交：\\n![](https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlEiHrW36nF7-bhD4/root/content)\\n**思路**：采用双指针的方法来解决，考虑到两链表相交一定是在后面有相同点，所以1）将两链表尾端对齐，2）然后长链表的指针移动（两个链表长度之差的）距离，3）循环，判断什么时候两指针相等。此时我们就可以比较curA和curB是否相同，如果不相同，同时向后移动curA和curB，如果遇到curA == curB，则找到交点。如果`curA == NULL`则说明链表不相交思路如下图所示：\\n\\n![链表相交的思路](https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlEn2uZpsaGxK5jgn/root/content)\\n\\ncpp代码示例：\\n\\n```cpp\\nListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode* curA = headA;\\n        ListNode* curB = headB;\\n        int lenA = 0, lenB = 0;\\n        while (curA != NULL) { // 求链表A的长度\\n            lenA++;\\n            curA = curA->next;\\n        }\\n        while (curB != NULL) { // 求链表B的长度\\n            lenB++;\\n            curB = curB->next;\\n        }\\n        curA = headA;\\n        curB = headB;\\n        // 让curA为最长链表的头，lenA为其长度\\n        if (lenB > lenA) {\\n            swap (lenA, lenB);\\n            swap (curA, curB);\\n        }\\n        // 求长度差\\n        int gap = lenA - lenB;\\n        // 让curA和curB在同一起点上（末尾位置对齐）\\n        while (gap--) {\\n            curA = curA->next;\\n        }\\n        // 遍历curA 和 curB，遇到相同则直接返回\\n        while (curA != NULL) {\\n            if (curA == curB) {\\n                return curA;\\n            }\\n            curA = curA->next;\\n            curB = curB->next;\\n        }\\n        return NULL;\\n    }\\n```\\n\\n注意：时间复杂度是O(m+n)\\n\\n### 2.7 环形链表2\\n\\n**题意**：环形链表2，这题是给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。为了表示给定链表中的环，使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。【给定一个链表，判断是否有环，有环的话返回环的入口节点地址】\\n\\n**说明**：不允许修改给定的链表\\n\\n**示例**：输入：head = [3,2,0,-4], pos = 1 ; 输出 tail connects to node index 1 ; 解释：链表中有一个环，其尾部连接到第二个节点。本示例的图示如下：\\n\\n![示例](https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlEpR5iFQiiqqWqzH/root/content)\\n\\n**思路**：这道题不仅要考链表操作，还考察数学运算。主要考察两个知识点：\\n\\n+  判断链表是否有环；\\n+  如果有环，如何找到这个环的入口\\n\\n1）**判断链表是否有环**\\n\\n方法：可以使用快慢指针法，分别定义 fast 和 slow 指针，从头结点出发，fast指针每次移动两个节点，slow指针每次移动一个节点，如果 fast 和 slow指针在途中相遇 ，说明这个链表有环。\\n\\n原理：首先第一点：**fast指针一定先进入环中，如果fast指针和slow指针相遇的话，一定是在环中相遇，这是毋庸置疑的**。其实相对于slow来说，**fast是一个节点一个节点的靠近slow的，所以fast一定可以和slow重合**。\\n\\n![双指针法：判断是否有环](https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlEyj6F0jegrnBGxW/root/content)\\n\\n2）**如果有环，如何找到这个环的入口** （要用到数学知识了）\\n\\n**方法&&原理**：假设从头结点到环形入口节点 的节点数为x。 **环形入口**节点到 fast指针与slow指针**相遇节点**节点数为y。 从相遇节点 再到环形入口节点节点数为 z。 如图所示：\\n\\n![](https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlE0iChKekHjyQs1F/root/content)\\n\\n那么相遇时：slow指针走过的节点数位`x+y`，fast指针走过的节点数为：`x+y+n(y+z)`，n为fast指针在环内走了n圈才遇到slow指针， （y+z）为 一圈内节点的个数A。因为fast指针是一步走两个节点，slow指针一步走一个节点， 所以 fast指针走过的节点数 = slow指针走过的节点数 * 2：\\n\\n                                        `(x+y)*2 = x+y+n(y+z)`\\n\\n两边消掉一个`(x+y)`：即：`x+y = n (y+z)`\\n\\n因为要找环形的入口，那么要求的是x，因为x表示 头结点到 环形入口节点的的距离。\\n\\n所以要求x ，将x单独放在左面：x = n (y + z) - y ,\\n\\n再从n(y+z)中提出一个 （y+z）来，整理公式之后为如下公式：x = (n - 1) (y + z) + z 注意这里n一定是大于等于1的，因为 fast指针至少要多走一圈才能相遇slow指针。\\n\\n这个公式说明什么呢？\\n\\n**情况1）**：先拿n为1的情况来举例，意味着fast指针在环形里转了一圈之后，就遇到了 slow指针了。当 n为1的时候，公式就化解为 x = z，这就意味着，**从头结点出发一个指针，从相遇节点 也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是 环形入口的节点**。\\n\\n也就是在相遇节点处，定义一个指针index1，在头结点处定一个指针index2。让index1和index2同时移动，每次移动一个节点， 那么他们相遇的地方就是 环形入口的节点。如下面的动图所示：\\n\\n![](https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlE7bx0qLRJ9_JVDz/root/content)\\n\\n**情况2）**：那么 n如果大于1是什么情况呢，就是fast指针在环形转n圈之后才遇到 slow指针。\\n\\n其实这种情况和n为1的时候 效果是一样的，一样可以通过这个方法找到 环形的入口节点，只不过，index1 指针在环里 多转了(n-1)圈，然后再遇到index2，相遇点依然是环形的入口节点。\\n\\n代码如下：\\n\\n```cpp\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        ListNode* fast = head;\\n        ListNode* slow = head;\\n        while(fast != NULL && fast->next != NULL) {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            // 快慢指针相遇，此时从head 和 相遇点，同时查找直至相遇\\n            if (slow == fast) {\\n                ListNode* index1 = fast;\\n                ListNode* index2 = head;\\n                while (index1 != index2) {\\n                    index1 = index1->next;\\n                    index2 = index2->next;\\n                }\\n                return index2; // 返回环的入口\\n            }\\n        }\\n        return NULL;\\n    }\\n};\\n```\\n\\n**补充**：\\n\\n在推理过程中，大家可能有一个疑问就是：为什么第一次在环中相遇，slow的步数是 x+y 而不是 x + 若干环的长度 + y 呢？\\n\\n首先slow进环的时候，fast一定是先进环来了。如果slow进环入口，fast也在环入口，那么把这个环展开成直线，就是如下图的样子：\\n\\n![](https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlE_T1DmcUQ4sVEFJ/root/content)\\n\\n可以看出如果slow 和 fast同时在环入口开始走，一定会在环入口3相遇，slow走了一圈，fast走了两圈。重点来了，slow进环的时候，fast一定是在环的任意一个位置，如图：\\n\\n![](https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlFDmQaMBFYVeFEDo/root/content)\\n\\n那么fast指针走到环入口3的时候，已经走了k + n 个节点，slow相应的应该走了(k + n) / 2 个节点。\\n\\n因为k是小于n的（图中可以看出），所以(k + n) / 2 一定小于n。\\n\\n也就是说slow一定没有走到环入口3，而fast已经到环入口3了。\\n\\n这说明什么呢？\\n\\n在slow开始走的那一环已经和fast相遇了。\\n\\n那有同学又说了，为什么fast不能跳过去呢？ 在刚刚已经说过一次了，fast相对于slow是一次移动一个节点，所以不可能跳过去。\\n\\n### 2.8 总结篇\\n\\n在本章，主要讲了链表的基础知识，讲了链表的基本构造，还有移除链表元素、翻转链表（双指针法或递归法）、两两交换链表中的节点、删除链表的倒数第N个节点、链表相交（双指针法）、环形链表2等题目。上述问题都能通过双指针法解决：\\n\\n+ ** 翻转链表**：一个cur指向当前指针，一个pre在前一个指针，还需要tmp指针记录下一次cur跳转的位置。趁cur指向还没改变，先记录tmp即cur的下一跳。然后，原来是pre指向cur的，现在将cur指向pre即可，最后给cur、pre赋值，进行下一次循环；\\n+ **两两交换链表中的节点**：两两个节点一对来进行操作，但是为了和下一对联系起来，实际上操作时需要有三个节点参与。同时需要两个临时指针来记录节点1和节点3的地址。\\n\\n```cpp\\ntmp1 = cur->next;\\ntmp2 = cur->next->next->next;\\ncur->next = cur->next->next;\\ncur->next->next = tmp1;\\ncur->next->next->next = tmp2;\\n```\\n\\n+ **删除链表的倒数第N个节点**：双指针法，让fast指针先出发N+1步，然后slow指针再出发。当fast到达NULL时，slow刚好就在待删除节点的前一个位置；\\n+ **链表相交**：先求两个链表的长度，然后链表尾端对齐。长链表那个指针先移动两个链表长度之差的步数，然后两个链表指针在同时移动。当两个链表指针相等时，即为找到相交节点地址了；\\n+ **环形链表2**：思路是fast指针每次走两步，slow指针每次走一步，如果他两相遇了则存在环。然后，指针index1从头结点出发，指针index2从相遇节点出发，他们两个的再次相遇点就是环的入口节点地址了。\\n\\n另外，对于**反转链表**问题，建议先学透迭代法，然后再看递归法，因为递归法比较绕，如果迭代还写不明白，递归基本也写不明白了。\\n\\n最后，下图是对上述知识点的总结：\\n\\n![](https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlFEAlN4E-tIPYtjg/root/content)\\n\\n## 三、哈希表\\n\\n### 3.1 哈希表的理论基础\\n\\n哈希表，又或称散列表，它是**根据关键码的值而直接进行访问的数据结构**。它主要解决的问题就是元素的快速搜索，用来快速判断一个元素是否出现集合里。直白来讲，数组就是一张哈希表，哈希表的关键码就是数组索引下标，然后通过下标来直接访问数组元素。然后，将元素值映射到哈希表上与特定的关键码对应，就用到了**哈希函数**。\\n\\n特点：查找元素的速度很快，但是牺牲了空间来换取时间。\\n\\n哈希函数与哈希碰撞，哈希碰撞的解决方法有：拉链法和线性探测法。拉链法：多个元素在一个哈希值上冲突，就把这多个元素做成一个链表插在该位置上；线性探测法：当前位置冲突了，就顺次找下一个不冲突的位置，这种方法就要求哈希表长度必须大于数据个数才行。（略）\\n\\n常见的哈希结构：当我们想使用哈希法来解决问题的时候，我们一般会选择如下三种数据结构。\\n\\n+ 数组\\n+ set集合\\n+ map映射\\n\\n这里数据就没啥好说的了，我们来看看set和map。在cpp中，set 和 map 分别提供以下三种数据结构，其底层实现以及优劣如下表所示：\\n\\n| 集合               | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 | 增删效率 |\\n| ------------------ | -------- | -------- | ---------------- | ------------ | -------- | -------- |\\n| std::set           | 红黑树   | 有序     | 否               | 否           | O(log n) | O(log n) |\\n| std::multiset      | 红黑树   | 有序     | 是               | 否           | O(logn)  | O(logn)  |\\n| std::unordered_set | 哈希表   | 无序     | 否               | 否           | O(1)     | O(1)     |\\n\\nstd::unordered_set底层实现为哈希表，std::set 和std::multiset 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。\\n\\n| 映射               | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 | 增删效率 |\\n| ------------------ | -------- | -------- | ---------------- | ------------ | -------- | -------- |\\n| std::map           | 红黑树   | key有序  | key不可重复      | key不可修改  | O(logn)  | O(logn)  |\\n| std::multimap      | 红黑树   | key有序  | key可重复        | key不可修改  | O(log n) | O(log n) |\\n| std::unordered_map | 哈希表   | key无序  | key不可重复      | key不可修改  | O(1)     | O(1)     |\\n\\nstd::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）\\n\\n当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset。\\n\\n那么再来看一下map ，在map 是一个key value 的数据结构，map中，对key是有限制，对value没有限制的，因为key的存储方式使用红黑树实现的。\\n\\n其他语言例如：java里的HashMap ，TreeMap 都是一样的原理。可以灵活贯通。\\n\\n虽然std::set、std::multiset 的底层实现是红黑树，不是哈希表，std::set、std::multiset 使用红黑树来索引和存储，不过给我们的使用方式，还是哈希法的使用方式，即key和value。所以使用这些数据结构来解决映射问题的方法，我们依然称之为哈希法。 map也是一样的道理。\\n\\n这里在说一下，一些cpp的经典书籍上 例如STL源码剖析，说到了hash_set hash_map，这个与unordered_set，unordered_map又有什么关系呢？\\n\\n实际上功能都是一样一样的， 但是unordered_set在cpp11的时候被引入标准库了，而hash_set并没有，所以建议还是使用unordered_set比较好，这就好比一个是官方认证的，hash_set，hash_map 是cpp11标准之前民间高手自发造的轮子。\\n\\n![](https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlFLHzQIWbM3ru_iG/root/content)\\n\\n总结一下，**当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法**。\\n\\n但是哈希法也是**牺牲了空间换取了时间**，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。\\n\\n如果在做面试题目的时候遇到需要判断一个元素是否出现过的场景也应该第一时间想到哈希法！\\n\\n### 3.2 有效的字母异位词\\n\\n**题意**：给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。示例 1: 输入: s = \\\"anagram\\\", t = \\\"nagaram\\\" 输出: true。示例 2: 输入: s = \\\"rat\\\", t = \\\"car\\\" 输出: false。**说明**: 你可以假设字符串只包含小写字母。【字母异位词，即字母的种类和个数全部相同，只是字母的位置不相同的两个单词，可以用哈希表或map存储起来比较，得出结论】\\n\\n**思路**：1）暴力解法就是两层for循环；2）**数组其实就是一个简单哈希表**，而且这道题目中字母串只有小写字符，那么就可以定义一个数组record，来记录字符串s中字符的出现次数，定义数组长度为26。例如：对于字符串a=\\\"aea\\\"，有record[0]=2,record[4]=1；同样的，对于字符串b=\\\"eaa\\\"，也有record[0]=2,record[4]=1。所以字符串a和b是字母异位词。\\n\\n**步骤**：1）不需要记住具体是哪个字符a-z，只需要判断字符的相对位置，定义数组record[26]，字符\'a\'对应record[0]，字符record[25]对应\'z\'。2）在遍历字符串a时，只需要将record[a[i]-\'a\']元素值+1即可，并不需要记住字符a的ASCII值。这样就把字符串a中字符出现的次数统计出来了。\\n\\n3）在遍历字符串b，将record[b[i]-\'a\']的值-1，如果每一个数组元素的值不为0，那就是某个位多了一个字符或少了一个字符，则返回false，如果每一个数组元素都为0，满足题意返回true。\\n\\ncpp代码块如下所示：\\n\\n```cpp\\nbool isAnagram(string s, string t) {\\n    int record[26] = {0};\\n    for (int i = 0; i < s.size(); i++) {\\n        // 并不需要记住字符a的ASCII，只要求出一个相对数值就可以了\\n        record[s[i] - \'a\']++;\\n    }\\n    for (int i = 0; i < t.size(); i++) {\\n    \\trecord[t[i] - \'a\']--;\\n    }\\n    for (int i = 0; i < 26; i++) {\\n    \\tif (record[i] != 0) {\\n// record数组如果有的元素不为零0，说明字符串s和t 一定是谁多了字符或者谁少了字符。\\n    \\treturn false;\\n    \\t}\\n    }\\n// record数组所有元素都为零0，说明字符串s和t是字母异位词\\n    return true;\\n}\\n```\\n\\n### 3.3 两个数组的交集\\n\\n**题意**：编写一个函数，来判断两个数组的交集。注意：输出结果中的每个元素应当是唯一的，且不考虑输出结果的顺序。举例：输入nums1=[1,2,2,1]，nums2=[2,2]，输出：[2]；举例2：nums1=[4,9,5]，nums2=[9,4,9,8,4]，输出：[9,4]。\\n\\n**思路**：注意：前一题使用数组来做哈希表是因为题目限定了数值的大小，元素最大不会超过26。但是这里的话，1）**数值没有明显边界**，不建议使用数组。2）其次，**如果哈希值比较少、特别分散、跨度特别大**，也无法使用数组来做哈希表。\\n\\n此时就要使用另一种结构体了，set ，关于set，cpp 给提供了如下三种可用的数据结构：\\n\\n+ std::set\\n+ std::multiset\\n+ std::unordered_set\\n\\nstd::set和std::multiset底层实现都是红黑树，std::unordered_set的底层实现是哈希表， 使用unordered_set 读写效率是最高的，并不需要对数据进行排序，而且还不要让数据重复，所以选择unordered_set。这里主要是学会使用一种哈希数据结构：**unordered_set**。该数据结构无序、不允许重复。\\n\\n思路如下图所示：\\n\\n![](https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlFN3LVBY8kwU0hs1/root/content)\\n\\n```cpp\\nVector<int> intersection(vector<int>& nums1, vecotr<int>& nums2) {\\n\\tunordered_set<int> result_set; //存放结果，之所以用unordered_set是为了去重\\n\\t//第一步，将nums1将存入unordered_set中，这里是使用迭代器构造\\n\\tunordered_set<int> nums_set(nums1.begin(),nums1.end());\\n\\t//第二步，比较unordered_set和nums2\\n\\tfor (int num : nums2) {\\n\\t\\tif (nums_set.find(num) != nums_set.end()) {\\n\\t\\t\\tresult_set.insert(num);\\n\\t\\t}\\n\\t}\\n\\treturn vector<int>(result_set.begin(),result_set.end());\\n}\\n```\\n\\n无序集合unordered_set内部元素不可重复，没有顺序，值也不可修改。对于无序集合unordered_set，有以下几种初始化方法：\\n\\n+ 直接创建空的set：`unordered_set<int> set1;`\\n+ 拷贝构造：`unordered_set<int> set2(set1);`\\n+ 使用迭代器构造：`unordered_set<int> set3(set1.begin(),set1.end());`\\n+ 使用数组作为其初始值进行构造：`unordered_set<int> set4(arr,arr+5);`\\n+ 移动构造：`unordered_set<int> set5(move(set2));`\\n+ 使用初值列表来进行构造：`unordered_set<int> set6 {1,2,10,10};`\\n\\n**注意**：学到这，我们已经学习了unordered_set和数组两种哈希数据结构，但是要注意各自存在的缺点，数组对数据的长度有限制，且对于分布离散的数据而言存取效率低。而unordered_set内部元素不重复，不排序，十分适合需要数据去重的情况。但是相对于数组而言，不仅占用空间比数组大，而且速度要比数组慢，set把数值映射到key上都要做hash计算的。\\n\\n**说明**：后来力扣改了数据，对数组的长度做了限制，数据长度在0~1000，所以可以考虑用数组来做哈希算法。\\n\\n```cpp\\nvector<int> intersection(vector<int>&nums1,vector<int>&nums2) {\\n\\tunordered_set<int> result_set; //选择set是为了去重\\n\\tint hash[1005]={0};\\n\\tfor (int num : nums1) {\\n\\t\\thash[num] = 1;\\n\\t}\\n\\tfor (int num : nums2) {\\n\\t\\tif (hash[num] == 1) {\\n\\t\\t\\tresult_set.insert(num);\\n\\t\\t}\\n\\t}\\n\\treturn vector<int>(result_set.begin(),result_set.end());\\n}\\n```\\n\\n### 3.4 快乐数\\n\\n**题意**:编写一个算法来判断一个数是不是快乐数。**快乐数**：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为  1，那么这个数就是快乐数。\\n\\n如果是快乐数就返回True，否则返回False。\\n\\n**示例**：\\n`输入`：19\\n`输出`：true\\n`解释`：\\n1^2 + 9^2 = 82\\n8^2 + 2^2 = 68\\n6^2 + 8^2 = 100\\n1^2 + 0^2 + 0^2 = 1\\n\\n**思路**:这道题目看上去貌似一道数学问题，其实并不是！题目中说了会**无限循环**，那么也就是说**求和的过程中，sum会重复出现，这对解题很重要**！\\n\\n难点1）判断一个数是否重复出现？难点2）就是对一个数每个位上的操作，求和的过程。\\n\\n**当我们遇到需要快速判断一个元素是否存在与一个集合中时，就要用到哈希算法了**。所以这道题目使用哈希法，来判断这个sum是否重复出现，如果重复了就是return false， 否则一直找到sum为1为止。\\n\\n```cpp\\n//求每个位上的单数之和\\nint getSum(int n) {\\n\\tint sum = 0;\\n\\twhile (n) {\\n\\t\\tsum += (n % 10)*(n % 10);\\n\\t\\tn /= 10;\\n\\t}\\n\\treturn sum;\\n}\\n\\nbool isHappy(int n) {\\n\\tunordered_set<int> set;\\n\\tint n_temp = n;\\n\\twhile(1) {\\n\\t\\tint sum = getSum(n_temp);\\n\\t\\tif (sum == 1) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n        // 如果这个sum曾经出现过，说明已经陷入了无限循环了，立即return false\\n        if (set.find(sum) != set.end()) {\\n            return false;\\n        } else {\\n            set.insert(sum);\\n        }\\n\\t\\tn_temp = sum;\\n\\t}\\n}\\n```\\n\\n### 3.5 两数之和\\n\\n**题意**:给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那**两个**整数，并返回他们的数组下标。假设每种输入只会对应一个答案。注意，数组中同一个元素不能使用两遍。例如，给定 nums = [2, 7, 11, 15], target = 9，因为 nums[0] + nums[1] = 2 + 7 = 9，所以返回 [0, 1]。\\n\\n在强调一下**什么时候使用哈希法**，当我们需要查询一个元素是否出现过，或者一个元素是否在集合里的时候，就要第一时间想到哈希法。\\n\\n本题需要一个集合来存放我们遍历过的元素，然后在遍历数组的时候去询问这个集合，某元素是否遍历过，也就是是否出现在这个集合。\\n\\n因为本题中不仅要知道元素的值，还要记录元素的下标索引，所以用map更加合适。\\n\\n再来看一下使用数组和set来做哈希法的局限。\\n\\n+ **数组**的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。\\n+ **set**是一个集合，里面放的元素只能是一个key，而两数之和这道题目，不仅要判断y是否存在而且还要记录y的下标位置，因为要返回x 和 y的下标。所以set 也不能用。\\n\\ncpp中的map，有三种类型：\\n\\n| **映射**           | **底层实现** | **是否有序**                     | **数值是否可以重复**               | **能否更改数值** | **查询效率** | **增删效率** |\\n| ------------------ | ------------ | -------------------------------- | ---------------------------------- | ---------------- | ------------ | ------------ |\\n| std::map           | 红黑树       | key有序                          | key不可重复                        | key不可修改      | `O(logn)`    | `O(logn)`    |\\n| std::mutilmap      | 红黑树       | key有序                          | <font color=\\\"red\\\">key可重复</font> | key不可修改      | `O(logn)`    | `O(logn)`    |\\n| std::unordered_map | 红黑树       | <font color=\\\"red\\\">key无序</font> | key不可重复                        | key不可修改      | `O(1)`       | `O(1)`       |\\n\\n\\n这道题目中并不需要key有序，选择std::unordered_map 效率更高！ \\n\\n接下来需要明确两点：\\n\\n+ **map用来做什么**\\n+ **map中key和value分别表示什么**\\n\\nmap目的用来存放我们访问过的元素，因为遍历数组的时候，需要记录我们之前遍历过哪些元素和对应的下标，这样才能找到与当前元素相匹配的（也就是相加等于target）\\n\\nmap中key和value分别表示什么?这道题 我们需要处理数组的每个元素，判断这个元素是否出现过，如果出现过，返回这个元素的下标。那么判断元素是否出现，这个元素就要作为key，所以数组中的元素作为key，有key对应的就是value，value用来存下标。所以 map中的存储结构为`{key：数据元素，value：数组元素对应的下标}`。\\n\\n在遍历数组的时候，只需要向map去查询是否有和目前遍历元素匹配的数值，如果有，就找到的匹配对，如果没有，就把目前遍历的元素放进map中，因为map存放的就是我们访问过的元素。\\n\\n过程如下：\\n\\n![](https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlFS9JsCzF1wX-qId/root/content)\\n\\n![](https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlFUyAhmd6WUtK3mO/root/content)\\n\\n```cpp\\n//注意：map的key为元素值，value为元素下标\\nvector<int> twoSum(vector<int>& nums, int target) {\\n\\tstd::unordered_map <int,int> map;\\n\\tfor(int i = 0; i < nums.size(); i++) {\\n\\t\\t// 遍历当前元素，并在map中寻找是否有匹配的key。找到一个合适的，立即返回\\n        auto iter = map.find(target - nums[i]); \\n        if(iter != map.end()) {\\n        \\treturn {iter->second, i};\\n\\t\\t}\\n\\t\\t// 如果没找到匹配对，就把访问过的元素和下标加入到map中\\n\\t\\tmap.insert(pair<int, int>(nums[i], i)); \\n\\t}\\n\\t//循环结束后还没return说明没找到，就返回空vector\\n\\treturn {};\\n}\\n```\\n\\n**总结**:\\n本题其实有四个重点：\\n\\n+ 为什么会想到用哈希表\\n+ 哈希表为什么用map\\n+ 本题map是用来存什么的\\n+ map中的key和value用来存什么的\\n\\n本题的目的就是从一个数组中找到两个不同的元素，要求他们的和满足target。换句话说，我们拧着一个元素，然后在map中去找`target - 元素值`，如果找到了就直接返回。如果没找到，就将当前元素值存入map，然后进入下一次循环。最终循环结束后，没有返回return，说明没找到。\\n\\n### 3.6 四数相加2\\n\\n**题意**：给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -2^28 到 2^28 - 1 之间，最终结果不会超过 2^31 - 1 。\\n\\n例如：\\n\\n输入：\\n\\n+ A = [ 1, 2]  B = [-2,-1]  C = [-1, 2]  D = [ 0, 2]\\n\\n输出：\\n\\n+ 2\\n\\n**解释**：两个元组如下：\\n\\n1. (0, 0, 0, 1) -> A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0\\n2. (1, 1, 0, 0) -> A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0\\n\\n**思路**：本题是使用哈希法的经典题目，而后面的**三数之和**、**四数之和**并不适合使用哈希法。因为三数之和和四数之和这两道题目使用哈希法在不超时的情况下做到对结果去重是很困难的，很有多细节需要处理。\\n\\n而这道题目是四个独立的数组，只要找到A[i] + B[j] + C[k] + D[l] = 0就可以，不用考虑有重复的四个元素相加等于0的情况，所以相对于题目18. 四数之和，题目15.三数之和，还是简单了不少！\\n\\n如果本题想难度升级：就是给出一个数组（而不是四个数组），在这里找出四个元素相加等于0，答案中不可以包含重复的四元组，大家可以思考一下，后续的文章我也会讲到的。\\n\\n**本题解题步骤**：\\n\\n1. 首先定义 一个unordered_map，key放a和b两数之和，value 放a和b两数之和出现的次数。\\n2. 遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中。\\n3. 定义int变量count，用来统计 a+b+c+d = 0 出现的次数。\\n4. 在遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就用count把map中key对应的value也就是出现次数统计出来。\\n5. 最后返回统计值 count 就可以了\\n\\n```cpp\\n//这道题相对于“四数之和”，简单点在于不需要去重。本次时间复杂度为O(n^2)\\nint fourSumCount(vector<int>& A,vector<int>& B,vector<int>& C,vector<int>& D) {\\n\\tunordered_map<int,int> umap;\\n\\tfor (int a : A) {\\n\\t\\tfor (int b : B) {\\n\\t\\t\\tumap[a+b]++;\\n\\t\\t}\\n\\t}\\n\\tint count = 0;\\n\\tfor (int c : C) {\\n\\t\\tfor (int d : D) {\\n\\t\\t\\tif (umap.find(0-(c+d)) != umap.end()) {\\n\\t\\t\\t\\tcount += umap[0-(c+d)];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn count;\\n}\\n```\\n\\n### 3.7 赎金信\\n\\n**题意**：给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串 ransom 能不能由第二个字符串 magazines 里面的字符构成。如果可以构成，返回 true ；否则返回 false。\\n\\n(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。杂志字符串中的每个字符只能在赎金信字符串中使用一次。)\\n\\n注意：\\n\\n你可以假设两个字符串均只含有小写字母，下面三个是示例：\\n`canConstruct(\\\"a\\\", \\\"b\\\") -> false`\\n`canConstruct(\\\"aa\\\", \\\"ab\\\") -> false`\\n`canConstruct(\\\"aa\\\", \\\"aab\\\") -> true`\\n\\n**思路**：这道题和“有效的字母异位词”很像。**字母异位词**是字符串a和b的字符类型和数量应当完全相同，才能相互组成，而这里只需要保证字符串a中的字符类型和数量`<=`字符串b中的字符类型和数量，即字符串b完全能组成a，而a能否组成b不需要考虑。\\n\\n方法1：暴力解法，直接用双重for循环解决。外层循环是长字符串，内层循环是短字符串，每找到一个字符，就在对应位置删除掉短字符串上对应的字符，当短字符串长度为0时，返回true，否则返回false。\\n\\n```cpp\\nbool canConstruct(string ransomNote, string magazine) {\\n\\tfor (int i = 0; i < magazine.length(); i++) {\\n\\t\\tfor (int j = 0; j < ransomNote.lenth(); j++) {\\n\\t\\t\\tif (magazine[i] == ransomNote[j]) {\\n\\t\\t\\t\\transomNote.erase(ransomNote.begin()+j);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tif (ransomNote.length() == 0) {\\n\\t\\treturn true;\\n\\t}\\n\\treturn false;\\n//这里时间复杂度是比较高的O(n^2)，而且里面还有一个字符串删除也就是erase的操作，也是费时的\\n}\\n```\\n\\n方法2：哈希解法（大的是magazine，小的字符串是ransomNote）\\n\\n因为题目所只有小写字母，那可以采用空间换取时间的哈希策略， 用一个长度为26的数组还记录magazine里字母出现的次数。然后再用ransomNote去验证这个数组是否包含了ransomNote所需要的所有字母。一般来说，哈希数据结构的话，能用数组就用数组。使用map的空间消耗要比数组大一些的，因为map要维护红黑树或者哈希表，而且还要做哈希函数，是费时的！数据量大的话就能体现出来差别了。\\n\\n```cpp\\n//补充说明：string容器求长度用length()或size()方法都可以\\nbool canConstruct(string ransomNote, string magazine) {\\n\\tint record[26]={0};\\n\\tif (ransomNote.length() > magazine.length()) {\\n\\t\\treturn false;\\n\\t}\\n\\tfor (int i=0; i < magazine.length(); i++) {\\n\\t\\trecord[magazine[i]-\'a\']++;\\n\\t}\\n\\tfor (int j=0; j < ransomNote.length(); j++) {\\n\\t\\trecord[ransomNote[j] -\'a\']--;\\n\\t\\tif (record[ransomNote[j] -\'a\'] < 0) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n\\treturn true;\\n}\\n```\\n\\n### 3.8 三数之和\\n\\n**题意**：给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。 **注意**：答案中不可以包含重复的三元组。**再次注意**：注意[0,0,0,0]这组数据。\\n\\n示例：给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ]\\n\\n**回忆**：两数之和也是在一个数组中找到两个不同的元素，其和为target。该题的做法建立一个map数据结构，key为元素值，value为下标索引。然后遍历每个元素，在map中寻找是否存在[target-key]的值存在；如果存在就找到，直接返回；如果不存在就将当前元素存入map，继续遍历。遍历结束后仍为返回就return {}空vector。\\n\\n**解法1）哈希法**（不推荐）：\\n\\n两层for循环就可以确定 a 和b 的数值了，可以使用哈希法来确定 0-(a+b) 是否在 数组里出现过，其实这个思路是正确的，但是我们有一个非常棘手的问题，就是题目中说的不可以包含重复的三元组。把符合条件的三元组放进vector中，然后再去重，这样是非常费时的，很容易超时，也是这道题目通过率如此之低的根源所在。\\n\\n时间复杂度可以做到O(n^2)，但还是比较费时的，因为不好做剪枝操作。\\n\\n```cpp\\nvector<vector<int>> threeSum(vector<int>& nums) {\\n\\tvector<vector<int>> result;\\n\\tunordered_set<int> set;\\n\\tsort(nums.begin(),nums.end());\\n\\tfor (int i=0; i<nums.size();i++) {\\n\\t\\t// 排序之后如果第一个元素已经大于零，那么不可能凑成三元组\\n\\t\\tif (nums[i] > 0) {\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\tif (i > 0 && nums[i] == nums[i - 1]) { //三元组元素a去重\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\tfor (int j =i+1; j < nums.size();j++) {\\n\\t\\t\\tif ( j > i + 2 && nums[j] == nums[j-1] && nums[j-1] == nums[j-2]) {\\n\\t\\t\\t\\tcontinue; //三元组的元素b去重\\n\\t\\t\\t}\\n\\t\\tint c = 0 -(nums[i]+nums[j]);\\n\\t\\tif (set.find(c) != set.end()) {\\n\\t\\t\\tresult.push_back({nums[i],nums[j],c});\\n\\t\\t\\tset.erase(c);  //三元组去重c\\n\\t\\t} else {\\n\\t\\t\\tset.insert(nums[j]);\\n\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result;\\n} \\n```\\n\\n**解法2）双指针**：\\n\\n动画效果如下：\\n\\n![](https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlFh1FaSArZZ1UxyE/root/content)\\n\\n拿这个nums数组来举例，首先将数组排序，然后有一层for循环，i从下标0的地方开始，同时定一个下标left 定义在i+1的位置上，定义下标right 在数组结尾的位置上。依然还是在数组中找到 abc 使得a + b +c =0，我们这里相当于 a = nums[i]，b = nums[left]，c = nums[right]。\\n\\n接下来如何移动left 和right呢？1） 如果nums[i] + nums[left] + nums[right] > 0 就说明 此时三数之和大了，因为数组是排序后了，所以right下标就应该向左移动，这样才能让三数之和小一些。2）如果 nums[i] + nums[left] + nums[right] < 0 说明 此时 三数之和小了，left 就向右移动，才能让三数之和大一些，直到left与right相遇为止。时间复杂度：O(n^2)。\\n\\n```cpp\\nvector<vector<int>> threeSum(vector<int>& nums) {\\n\\tvector<vector<int>> result;\\n\\tsort(nums.begin(),nums.end());\\n\\tfor (int i = 0; i < nums.size(); i++) {\\n        // 排序之后如果第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，直接返回结果就可以了\\n        if (nums[i] > 0) {\\n            return result;\\n        }\\n        // 错误去重a方法，将会漏掉-1,-1,2 这种情况\\n        /*\\n        if (nums[i] == nums[i + 1]) {\\n        continue;\\n        }\\n        */\\n        // 正确去重a方法\\n        if (i > 0 && nums[i] == nums[i - 1]) {\\n        continue;\\n        }\\n        int left = i+1;\\n        int right = nums.size() -1;\\n        while (right > left) {\\n// 去重复逻辑如果放在这里，0，0，0 的情况，可能直接导致 right<=left 了，从而漏掉了 0,0,0 这种三元组\\t\\n\\t\\t\\t/*\\n\\t\\t\\twhile (right > left && nums[right] == nums[right - 1]) right--;\\n\\t\\t\\twhile (right > left && nums[left] == nums[left + 1]) left++;\\n\\t\\t\\t*/\\n\\t\\t\\tif (nums[i]+nums[left]+nums[right] > 0) right--;\\n\\t\\t\\telse if (nums[i]+nums[left]+nums[right] < 0) left++;\\n\\t\\t\\telse {\\n\\t\\t\\t\\tresult.push_back(vector<int>{nums[i],nums[left],nums[right]});\\n\\t\\t\\t\\t//去重逻辑应该放在找到一个三元组后，对b和c去重\\n\\t\\t\\t\\twhile(right > left && nums[right] == nums[right-1]) right--;\\n\\t\\t\\t\\twhile(right > left && nums[left] == nums[left+1]) left++;\\n\\t\\t\\t\\t找到答案时，双指针同时收缩\\n\\t\\t\\t\\tleft++;\\n\\t\\t\\t\\tright--;\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result;\\n} \\n```\\n\\n**去重逻辑的思考**：\\n\\n**a的去重**：\\n\\n说到去重，其实主要考虑三个数的去重。 a, b ,c, 对应的就是 nums[i]，nums[left]，nums[right]。\\n\\na 如果重复了怎么办，a是nums里遍历的元素，那么应该直接跳过去。但这里有一个问题，是判断 nums[i] 与 nums[i + 1]是否相同，还是判断 nums[i] 与 nums[i-1] 是否相同。有同学可能想，这不都一样吗。其实不一样！都是和 nums[i]进行比较，是比较它的前一个，还是比较他的后一个。如果我们的写法是：\\n\\n```cpp\\nif (nums[i] == nums[i+1]) {\\n\\tcontinue;\\n}\\n```\\n\\n那就我们就把三元组中出现重复元素的情况直接pass掉了。 例如{-1, -1 ,2} 这组数据，当遍历到第一个-1 的时候，判断下一个也是-1，那这组数据就pass了。这样就会出现漏判。**我们要做的是不能有重复的三元组，但三元组内的元素是可以重复的！** 那么应该这么写：\\n\\n```cpp\\nif (i > 0 && nums[i] == nums[i-1]) {\\n\\tcontinue;\\n}\\n```\\n\\n这么写就是当前使用 nums[i]，我们判断前一位是不是一样的元素，在看 {-1, -1 ,2} 这组数据，当遍历到 第一个 -1 的时候，只要前一位没有-1，那么 {-1, -1 ,2} 这组数据一样可以收录到结果集里。\\n\\n**b与c的去重**：\\n\\n类似于a的考虑，遍历b和c的时候，是不是也需要在每一步进行去重呢？代码如下：\\n\\n```cpp\\nwhile (eight > left) {\\n\\tif (nums[i] + nums[left] + nums[right] > 0) {\\n\\t\\tright--;\\n\\t\\t//while(left < right && nums[right]==nums[right+1]) right--;\\n\\t} else if (nums[i] + nums[left] + nums[right] < 0) {\\n\\t\\tleft++;\\n\\t\\t//while(left < eight && nums[left] == nums[left-1]) left++;\\n\\t} else {\\n\\t\\t//Todo\\n\\t}\\n}\\n```\\n\\n上文注释掉的部分就是思考的过程，似乎按照a的思路，在每次遍历的时候，需要与前一个已经遍历过的值进行比较，若相同就需要去重（不能与后一个值进行比较去重，不然会丢失诸如-1，-1，2这组值）。但仔细观察又会发现，b和c遍历的过程本身就是去重的过程，在遍历b和c时，如果三数之和大于0，则按照规则应该是右指针right左移++，类似的，下一次循环时，如果righ是重复值，也会走这个if语句，继续right++。所以遍历时就已经去重，不需要额外在用while来去重了（上述代码中被注释掉的部分）。\\n\\n**思考**：\\n\\n既然三数之和可以使用哈希法和双指针法，那我们之前讲过的两数之和可以使用双指针法吗？\\n\\n**回忆**：两数之和：从一个数组中找到两个不同的值，其和为target。只需要找到一组答案即可。**解法**：以元素值为map的key，以元素下标作为map的value，建立哈希数据结构unordered_map来求解。遍历整个数组，如果找到`map.find(target-nums[i])!=map.end()`，就直接返回`vector<int>{iter->second,i}`；如果未找到就将当前`nums[i]`和`i`存入`ma`p并进行下一次循环。循环结束后仍为`return`就直接返回空`vector{}`，表示未找到。\\n\\n本题三数之和也是从一个数组中找多个不同元素满足其和为target，但是本体的返回结果有多个且不允许重复。所以单纯使用哈希法来求解需要多考虑去重的问题，更麻烦。那两数之和能用双指针法求解吗？**不能**：因为两数之和返回的是元素下标，而在本题中使用双指针法必须对数组元素进行排序，一旦排序，下标就变了。如果两数之和的题目改成返回元素值那么就可以使用双指针法。\\n\\n### 3.9 四数之和\\n\\n**题意**：给定一个数组nums和一个target目标值，判断nums中是否存在四个元素满足其和为target，找出所有满足条件且不重复的四元组。\\n\\n**注意**：\\n\\n答案中不可以包含重复的四元组。示例： 给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。 满足要求的四元组集合为： [ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2] ]\\n\\n\\n**回忆**：前面两数之和、三数之和都是从一个数组中找到k个元素满足其和为target，两数之和是找到任意一对且返回元素下标；三数之和是找到全部且返回的是由元素组成的vector。还有四数之和2是从四个数组中分别找到四个数满足其和为target的条件，且返回的值是满足条件的元组个数。\\n\\n**回忆2**：四数之和2是采用的哈希法，a组和b组用双for循环和unordered_map来统计，c组和d组也用双for循环和unordered_map[0-(a+b)]来找符合条件的元组，并统计个数，最后的返回值是满足条件的元组个数。\\n\\n**思路**： \\n\\n\\n四数之和，和15.三数之和是一个思路，都是使用双指针法, 基本解法就是在15.三数之和的基础上再套一层for循环。\\n\\n```cpp\\nvector<vector<int>> fourSum(vector<int>& nums, int target) {\\n\\tvector<vector<int>> result;\\n\\tsort(nums.begin(),nums.end());\\n\\tfor (int k=0;k<nums.size();k++) {\\n\\t\\t//剪枝处理\\n\\t\\tif (nums[k]> target && nums[k]>=0){\\n\\t\\t\\tbreak;//这里使用break统一最后return处理\\n\\t\\t}\\n\\t\\t//对nums[k]去重\\n\\t\\tif(k>0&&nums[k] == nums[k-1]) {\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\t\\n\\t\\tfor(int i=k+1;i<nums.size();i++) {\\n\\t\\t\\t//2级剪枝处理\\n\\t\\t\\tif (nums[k]+nums[i]>target && nums[i]>=0) {\\n\\t\\t\\tbreak; //已经不满足条件了\\n\\t\\t\\t}\\n\\t\\t\\t//对nums[i]去重\\n\\t\\t\\tif (i>k+1;nms[i]==nums[i-1]) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tint left=i+1;\\n\\t\\t\\tint right = nums.size()-1;\\n\\t\\t\\twhile(right > left) {\\n\\t\\t\\t\\tif((long)nums[i]+nums[k]+nums[left]+nums[right] > target) {\\n\\t\\t\\t\\t\\tright--;\\n\\t\\t\\t\\t} else if((long)nums[i]+nums[k]+nums[left]+nums[right] < target) {\\n\\t\\t\\t\\t\\tleft++;\\n\\t\\t\\t\\t} else {\\n                    result.push_back(vector<int>{nums[i],nums[k],nums[left],nums[right]});\\n                    while(righ>left && nums[left] ==nums[left++]){\\n                        left++;\\n                    }\\n                    while(right>left && nums[right]== nums[right--]) {\\n                        right--;\\n                    }\\n                    right--;\\n                    left++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result;\\n}\\n```\\n\\n### 3.10 总结\\n\\n在哈希表这部分，我们主要介绍了数据、集合和映射三种哈希数据结构，并解决了字母异位词、两个数组交集、快乐数、四数相加2、书尽心和两数之和、三数之和、四数之和等问题。\\n\\n数组作为最基础最简单的哈希数据结构，应用简单且广泛，但也有它的局限性。首先，他只适合于数据长度有限且分布不要太过分散的情况。如果数据分散的太开，反而会造成效率和内存上的浪费。unordered_set（注：set和mutilset使用的是红黑树，unordered_set使用的是哈希表）就没有数据长度上的限制了，但是它的存储数据知识值类型，对于既要存储数组元素值又要存储数组下标的情况就得使用map映射了。类似的，只有unordered_map的底层是使用的哈希表，map和mutilmap使用的都是红黑树。使用map或set既要维护哈希表（或红黑树），又要去做哈希函数，所以效率上肯定是比不过数组的。综上，三种数据结构各有优劣，应该要视情况来选定。\\n\\n字母异位词和赎金信都是字母，而且还是小写字母，这样的话用长度为26的字符数组来做哈希算法的话就很容易了。这两者不同的是，字母异位是两个字符串的字符种类和数量要完全相同，而赎金信则是b的字符和数量要大于等于字符串a才行。\\n\\n快乐数是求一个数的每一位上数值的平方值和，其和是否为1，若不为1就再次进行计算。如果最终为1了就是快乐数，如果后面陷入了死循环就是非快乐数。这里的数据长度不固定，不能用数组，且数组为单一数值类型，还有解题的关键点在于从已有数据中找某个元素，因此选用哈希法解题，且使用unordered_set来解决。\\n\\n两个数组的交集，这题也是使用unordered_set来解题。先将nums1数组中的元素全部存入set中，然后在遍历数组nums2，查看nums2中的元素是否在set中，存在就加入result，最后再返回return result即可。\\n\\n四数相加2是从四个数组中找四个数，要找满足这四个数之和为target的元组个数。这里可以使用哈希法解决，且又要记录元素又要记录次数，所以采用unordered_map的数据结构。数组a和B使用双层for循环来统计（a+b)和的次数，如：`umap[a+b]++;`，初始化count值，然后数组c和d组成一个双层for循环，在umap中寻找满足元素值等于`target-(c+d)`的键值对，并用count变量将该键值对的值累加，最后返回count即可。\\n\\n两数之和、三数之和、四数之和都是从一个数组里面，找k个不重复的元素，要求其和为target。两数之和要求找出至少一队并返回该元组，三数之和、四数之和要求返回所有满足条件且不重复的元组集合。\\n\\n+ 两数之和因为只需找出一队，且返回的是元素下标，所以采用unordered_map来求解。遍历数组，如果在umap中找到了满足条件`umap.find(target-nums[i])`的元素，就返回`vector<int>{i,iter->second}`，否则就将当前元素存入umap:`map.insert(pair<int,int>(nums[i],i))`。\\n+ 三数之和可以使用哈希法，但是针对去重这个问题就比较麻烦。1）哈希法：第一层for，索引为i，从0到nums.size()-1;第二层for，索引为j，从i+1到nums.size()-1；然后在定义一个uset，从这个uset里面找满足条件`0-(nums[i]+nums[j])`的元素，找到了就插入到result中，代码片段如：`1/int c=0-nums[i]-nums[j]；2/if(uset.find(c)!=set.end()) 3/result.push_back({nums[i],nums[j],c});`(代码中还有对元素a,b,c的去重操作，这里未展示)。2）使用双指针法：使用双指针法的时间复杂度也是O(n^2)，但没有使用umap，少去了维护哈希表和做哈希映射的操作，更加高效。第一层for，索引为i，从0到nums.size()-1；定义left为i+1;定义right为nums.size()-1;然后第二层while(left<right)循环。在第二层循环中做这几样事：1/判断三数之和是否大于target，是的话就让right--；2/判断三数之和是否小于target，是的话就让left++；3/三数之和恰好等于target，满足题意，存入result(代码中还有对元素a,b,c的去重操作，这里未展示)。\\n+ 四数之和类似的道理，只不过增加了一层循环。第一层for，索引为i，从0到nums.size()-1；第二层for，索引为j，从i+1到nums.size()-1；然后定义left为j+1;定义right为nums.size()-1;然后第三层while(left<right)循环。\\n\\n## 四、字符串\\n\\n### 4.1 反转字符串1\\n\\n**题意**：对于用char[]给出的字符串，如果反转字符串，使用输入[\'H\',\'e\',\'l\',\'l\',\'o\']，输出[\'o\',\'l\',\'l\',\'e\',\'H\']?且要求不分配额外的内存空间。\\n\\n\\n**思路**：可以直接用库函数reverse()解决，但是有些场合不建议直接套用库函数。这里的反转字符串和反转链表很像，可以用双指针法解决。使用swap()函数来调换两个字符。\\n\\nswap有两种实现方式：1）使用tmp变量的值替换和2）通过为运算。\\n\\n```cpp\\n//1、值替换\\nint tmp=s[i];\\ns[i]=s[j];\\ns[j]=tmp;\\n//2、位运算\\ns[i] ^= s[j];\\ns[j] ^= s[i];\\ns[i] ^= s[j];\\n```\\n\\n最终的cpp代码如下：\\n\\n```cpp\\nvoid reverseString(vector<char>& s) {\\n\\tfor(int i=0,j=s.size()-1;i<s.size()/2;i++,j--) {\\n\\t\\tswap(nums[i],nums[j]);\\n\\t}\\n}\\n```\\n\\n### 4.2 反转字符串2\\n\\n**题意**： 给定一个字符串 s 和一个整数 k，从字符串开头算起, 每计数至 2k 个字符，就反转这 2k 个字符中的前 k 个字符。如果剩余字符少于 k 个，则将剩余字符全部反转。如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。\\n\\n示例：\\n\\n输入：s=\\\"abcdefg\\\",k=2\\n\\n输出：\\\"bacdfeg\\\"\\n\\n**思路**：这里的终点就是i+=(2\\\\*k)，i 每次移动 2 \\\\* k 就可以了，然后判断是否需要有反转的区间。\\n使用库函数reverse来求解（reverse函数不是本题的问题核心，可以使用）：\\n\\n```cpp\\nstring reverseStr(string s,int k) {\\n\\tfor (int i=0 ;i<s.zise();i+=2*k) {\\n\\t\\t//1. 每隔2k个字符的前k个字符进行反转\\n\\t\\t//2. 剩余字符小于2k但大于等于k个的，则反转前k个\\n\\t\\tif (i+k <= s.size()) {\\n\\t\\t\\treverse(s.begin()+i,s.begin()+i+k);\\n\\t\\t} else {\\n\\t\\t\\t//3. 剩余字符小于k，就全部翻转\\n\\t\\t\\treverse(s.begin()+i,s.end());\\n\\t\\t}\\n\\t}\\n\\treturn s;\\n}\\n```\\n\\n另一种方法是实现自己的reverse函数，下面的reverse函数时左闭右闭区间的，代码如下：\\n\\n```cpp\\nvoid reverse(string& s,int start,int end) {\\n\\tfor(int i=start,j=end;i<j;i++,j--)\\n\\t\\tswap(s[i],s[j]);\\n}\\nstring reverseStr(string s, int k) {\\n\\tfor (int i = 0; i < s.size(); i += (2 * k)) {\\n        // 1. 每隔 2k 个字符的前 k 个字符进行反转\\n        // 2. 剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符\\n        if (i + k <= s.size()) {\\n            reverse(s, i, i + k - 1);\\n            continue;\\n        }\\n        // 3. 剩余字符少于 k 个，则将剩余字符全部反转。\\n        reverse(s, i, s.size() - 1);\\n\\t}\\n\\treturn s;\\n}\\n```\\n\\n### 4.3 替换空格\\n\\n**题意**:将字符串中的空格替换成\\\"%20\\\"。\\n\\n**思路**：不使用额外的辅助空间。首先，扩充数组到每隔空格替换成\\\"%20\\\"之后的大小，然后从后往前替换空格，也就是双指针法。i指向新长度的末尾，j指向旧长度的末尾，过程如下：\\n\\n![](https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlFkgwS4cMqYe6Hq2/root/content)\\n\\n**其实很多数组填充类的问题，都可以先预先给数组扩容带填充后的大小，然后在从后向前进行操作**。\\n\\n这么做有两个好处：\\n\\n1. 不用申请新数组。\\n2. 从后向前填充元素，避免了从前向后填充元素时，每次添加元素都要将添加元素之后的所有元素向后移动的问题。\\n\\n```cpp\\nstring replaceSpace(string s){\\n\\tint count = 0; //统计空格的数量\\n\\tint sOldSize = s.size();\\n\\tfor(int i=0;i<sOldSize;i++) {\\n\\t\\tif(s[i] == \' \') count++;\\n\\t}\\n\\t//扩充字符串的大小，也就是每个空格替换成\\\"%20\\\"之后的大小\\n\\ts.resize(s.size()+count*2);\\n\\tint sNewSize = s.size();\\n\\t//从后往前将空格替换成\\\"%20\\\"\\n\\tfor(int i=sNewSize-1,j=sOldSize-1;j<i;i--,j--) {\\n\\t\\tif(s[j]!=\' \'){\\n\\t\\t\\ts[i]=s[j];\\n\\t\\t} else {\\n\\t\\t\\ts[i]=\'0\';\\n\\t\\t\\ts[i-1]=\'2\';\\n\\t\\t\\ts[i-2]=\'%\';\\n\\t\\t\\ti-=2;\\n\\t\\t}\\n\\t}\\n\\treturn s;//时间和空间复杂度都为O(1)\\n}\\n```\\n\\n### 4.4 翻转字符串里的单词\\n\\n+ 这是一道考察字符串操作的好题。\\n\\n**题意**：给定一个字符串，逐个翻转字符串中的每个单词。请注意，是反转单词，而非字符，示例：输入\\\"hello  world!  \\\"，输出：\\\"world! hello\\\"。说明：若两个单词之间有多个空格，应减少到只包含一个，若字符串末尾有多余的空格，也应该删掉。\\n\\n**思路**：这道题综合考察了字符串的许多操作。一些同学会使用split库函数，分隔单词，然后定义一个新的string字符串，最后再把单词倒序相加，那么这道题题目就是一道水题了，失去了它的意义。所以，提高一下本题的难度：**不要使用辅助空间，空间复杂度为O(1)**。\\n\\n想一下，我们将整个字符串都反转过来，那么单词的顺序指定是倒序了，只不过单词本身也倒序了，那么再把单词反转一下，单词不就正过来了。所以解题思路如下：\\n\\n+ 移除多余空格\\n+ 将整个字符串反转\\n+ 将每个单词反转\\n\\n举个例子，源字符串为：\\\"the sky is blue \\\":\\n\\n+ 移除多余空格 : \\\"the sky is blue\\\"\\n+ 字符串反转：\\\"eulb si yks eht\\\"\\n+ 单词反转：\\\"blue is sky the\\\"\\n\\n代码上的细节：\\n\\n1）移除多余空格：一些同学可能会上来写如下代码（使用erase的方法来删除空格，时间复杂度会很高）：\\n\\n```cpp\\nvoid removeExtraSpaces(string& s) {\\n\\tfor(int i=s.size()-1;i>0;i--) {\\n\\t\\tif(s[i]==s[i--]&&s[i]==\' \') {\\n\\t\\t\\ts.erase(s.begin()+i);\\n\\t\\t}\\n\\t}\\n\\t//删除字符串最后面的空格\\n\\tif(s.size()>0 && s[s.size()-1] ==\' \') {\\n\\t\\ts.erase(s.begin()+s.size()-1);\\n\\t}\\n\\t//删除最前面的空格\\n\\tif(s.size()>0 && s[0] == \' \') {\\n\\t\\ts.erase(s.begin());\\n\\t}\\n}\\n```\\n\\n**问题在哪**:上述代码一琢磨似乎时间复杂度为O(n)，但其实erase()的时间复杂度为也是O(n)，所以实际的时间复杂度就是O(n^2)。有的同学可能发现用erase来移除空格，在leetcode上性能也还行。主要是以下几点：\\n\\n+ leetcode上的测试集里，字符串的长度不够长，如果足够长，性能差距会非常明显。\\n+ leetcode的测程序耗时不是很准确的。\\n\\n2）使用双指针的方法按照去除最前面的空格、中间部分的空格和末尾空格的思路来写代码\\n\\n```cpp\\n//版本一 \\nvoid removeExtraSpaces(string& s) {\\n    int slowIndex = 0, fastIndex = 0; // 定义快指针，慢指针\\n    // 去掉字符串前面的空格\\n    while (s.size() > 0 && fastIndex < s.size() && s[fastIndex] == \' \') {\\n        fastIndex++;\\n    }\\n    for (; fastIndex < s.size(); fastIndex++) {\\n        // 去掉字符串中间部分的冗余空格\\n        if (fastIndex - 1 > 0\\n                && s[fastIndex - 1] == s[fastIndex]\\n                && s[fastIndex] == \' \') {\\n            continue;\\n        } else {\\n            s[slowIndex++] = s[fastIndex];\\n        }\\n    }\\n    if (slowIndex - 1 > 0 && s[slowIndex - 1] == \' \') { // 去掉字符串末尾的空格\\n        s.resize(slowIndex - 1);\\n    } else {\\n        s.resize(slowIndex); // 重新设置字符串大小\\n    }\\n}\\n```\\n\\n仔细考虑这个问题，是不是和数组操作的\\\"移除指定元素\\\"这个操作比较像？还是使用双指针法，将所有空格都视作需要被移除的对象，然后手动为每个单词后添加空格：\\n\\n```cpp\\n// 版本二 使用双指针法，快指针为索引，遍历所有元素，慢指针只接受满足条件的元素\\nvoid removeExtraSpaces(string& s) {//去除所有空格并在相邻单词之间添加空格, 快慢指针。\\n    int slow = 0;   //整体思想参考https://programmercarl.com/0027.移除元素.html\\n    for (int i = 0; i < s.size(); ++i) { \\n        if (s[i] != \' \') { //遇到非空格就处理，即删除所有空格。\\n            if (slow != 0) s[slow++] = \' \'; //手动控制空格，给单词之间添加空格。slow != 0说明不是第一个单词，需要在单词前添加空格。\\n            while (i < s.size() && s[i] != \' \') { //补上该单词，遇到空格说明单词结束。\\n                s[slow++] = s[i++];\\n            }\\n        }\\n    }\\n    s.resize(slow); //slow的大小即为去除多余空格后的大小。\\n}\\n```\\n\\n3）实现反转字符串的功能，这在上文已经讲了：\\n\\n```cpp\\n// 反转字符串s中左闭右闭的区间[start, end]\\nvoid reverse(string& s, int start, int end) {\\n    for (int i = start, j = end; i < j; i++, j--) {\\n        swap(s[i], s[j]);\\n    }\\n}\\n```\\n\\n综上，翻转字符串里的单词这道题的最终代码为：\\n\\n```cpp\\nvoid reverse(string& s, int start, int end){ //翻转，区间写法：左闭右闭 []\\n\\tfor (int i = start, j = end; i < j; i++, j--) {\\n\\t\\tswap(s[i], s[j]);\\n\\t}\\n}\\n\\nvoid removeExtraSpaces(string& s) {//去除所有空格并在相邻单词之间添加空格, 快慢指针。\\n\\tint slow = 0;   //整体思想参考https://programmercarl.com/0027.移除元素.html\\n\\tfor (int i = 0; i < s.size(); ++i) { //\\n\\t\\tif (s[i] != \' \') { //遇到非空格就处理，即删除所有空格。\\n\\t\\t\\tif (slow != 0) s[slow++] = \' \'; //手动控制空格，给单词之间添加空格。slow != 0说明不是第一个单词，需要在单词前添加空格。\\n\\t\\t\\twhile (i < s.size() && s[i] != \' \') { //补上该单词，遇到空格说明单词结束。\\n\\t\\t\\t\\ts[slow++] = s[i++];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\ts.resize(slow); //slow的大小即为去除多余空格后的大小。\\n}\\n\\nstring reverseWords(string s) {\\n\\tremoveExtraSpaces(s); //去除多余空格，保证单词之间之只有一个空格，且字符串首尾没空格。\\n\\treverse(s, 0, s.size() - 1);\\n\\tint start = 0; //removeExtraSpaces后保证第一个单词的开始下标一定是0。\\n\\tfor (int i = 0; i <= s.size(); ++i) {\\n\\t\\tif (i == s.size() || s[i] == \' \') { //到达空格或者串尾，说明一个单词结束。进行翻转。\\n\\t\\t\\treverse(s, start, i - 1); //翻转，注意是左闭右闭 []的翻转。\\n\\t\\t\\tstart = i + 1; //更新下一个单词的开始下标start\\n\\t\\t}\\n\\t}\\n\\treturn s;\\n}\\n```\\n\\n### 4.5 左旋转字符串\\n\\n**题意**：字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串\\\"abcdefg\\\"和数字2，该函数将返回左旋转两位得到的结果\\\"cdefgab\\\"。\\n\\n**思路**：如果能申请额外空间的话，就可以用提取子串的方法substr()将前n个字符提取出来，然后在追加到原字符串末尾就行了(但是substr()方法需要申请额外的空间)。为了让本题更有意义，提升一下本题难度：**不能申请额外空间，只能在本串上操作**。回顾上一题，翻转字符串里的单词，是使用整体反转+局部反转的方式来实现反转单词顺序的目的。这道题也类似，具体步骤为：\\n\\n1. 反转区间为前n的子串；\\n2. 反转区间为n到末尾的子串；\\n3. 反转整个字符串\\n\\n![](https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlFpfBs6U4gvnd_wZ/root/content)\\n\\ncpp代码如下所示：\\n\\n```cpp\\nstring reverseLeftWords(string s, int n) {\\n\\treverse(s.begin(), s.begin() + n);\\n\\treverse(s.begin() + n, s.end());\\n\\treverse(s.begin(), s.end());\\n\\treturn s;\\n }\\n```\\n\\n**总结**：\\n\\n此时我们已经反转过很多次字符串了，一起来回顾一下。\\n\\n在\\\"反转字符串1\\\"中，第一次降到反转一个字符串该怎么做，使用了双指针法。\\n\\n在\\\"反转字符串2\\\"中，对反转限定了条件，要求前2k个字符只翻转前k个，需要固定规律一段一段去处理字符串的时候，就要在for循环的表达式上去做文章。\\n\\n在\\\"反转字符串里的单词\\\"中，要对一句话里的单词顺序进行反转，发现先整体反转、在局部反转是个不错的思路。\\n\\n最后在讲到本题，本题是先局部反转再整体反转，也是一种新思路。\\n\\n最后补充说明一下，substr()这个方法和反转时间复杂度都是一样的，都是O(n)，但是substr()需要申请额外空间。\\n\\n\\n### 4.6 实现strStr()\\n\\n**题意**：实现 strStr() 函数。给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。例如：输入: haystack = \\\"hello\\\", needle = \\\"ll\\\" 输出: 2。说明: 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。\\n\\n**思路**：本题是KMP的经典题目。KMP的经典思想就是:**当出现字符串不匹配时，可以记录一部分之前已经匹配的文本内容，利用这些信息避免从头再去做匹配**。\\n\\n**KMP算法**：\\n字符串的匹配算法有两种：1）BF算法(Brute-Force，暴力解法)，就是目标串和模式串都从0开始比较，当遇到不匹配的字符时，模式串索引值j直接返回到起点0，而目标串的索引`i=i-j+2`。为什么加2呢？如下图所示，因为理论上模式串匹配完一次后，如果没匹配上，模式串j直接回到0，而目标串i回到遍历的下一个位置（下图中手写笔画的位置，也就是索引1的位置）。但是在上一次的匹配过程中，i已经走到了3号的位置，所以不仅是j要回头开头，i也要回溯。这也是暴力解法时间复杂度高的原因所在O(m\\\\*n)。\\n\\n![](https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlFxIwhkqFTYq0xCx/root/content)\\n\\n2）KMP算法原理：KMP算法就是让目标串的i不要回溯，向遍历指针一样一直往前走。并且分析模式串字符构成特点，尽量让j不要回到0处重复匹配来提高匹配效率。通过分析模式串的字符构成特点，来设计一个\\\"如果匹配失败就指示下次跳转的位置的数组\\\"，这个数组就是next[]数组。KMP的主要思想是**当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了**。\\n\\n前缀表：前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。前缀表是**记录下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。**\\n\\n前缀：是指不包含最后一个字符的所有以第一个字符开头的连续子串。\\n\\n后缀：是指不包含第一个字符的所有以最后一个字符结尾的连续子串。\\n\\n前缀表：要求的就是最大的相同前后缀的长度。\\n\\n**为什么一定要使用前缀表**：\\n\\n刚刚匹配的过程在下标5的地方遇到不匹配，模式串是指向f，如下图：\\n\\n![](https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlF2fBMmjPS2yUa3A/root/content)\\n\\n然后就找到了下标2，指向b，继续匹配：如图：\\n\\n![](https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlF5rdletPm7T6ZJH/root/content)\\n\\n以下这句话，对于理解为什么使用前缀表可以告诉我们匹配失败之后跳到哪里重新匹配 非常重要！\\n\\n**下标5之前这部分的字符串（也就是字符串`aabaa`）的最长相等的前缀 和 后缀字符串是 子字符串`aa` ，因为找到了最长相等的前缀和后缀，匹配失败的位置是后缀子串的后面，那么我们找到与其相同的前缀的后面重新匹配就可以了。**\\n\\n所以前缀表具有告诉我们当前位置匹配失败，跳到之前已经匹配过的地方的能力。\\n\\n前缀表与next数组：\\n\\n有的是直接把next数组做前缀表，有的是把next数组每一位减一后的数组做next数组，有的是把next数组统一右移一位做next数组。注意：这题的next数组是从下表索引0开始计算的，而很多课程或教材，例如《大话数据结构》是从数组下标1开始计算的。\\n\\n**时间复杂度分析**：\\n\\n暴力算法是O(m\\\\*n)，使用KMP算法是O(m+n)，不过KMP算法针对模式串中有较多重复字符时才能提高搜索效率，这点也需注意。\\n\\n**一、构造next数组**：\\n\\n**构造next数组其实就是计算模式串s，前缀表的过程**。 主要有如下三步：\\n\\n+ 初始化\\n+ 处理前后缀不相同的情况\\n+ 处理前后缀相同的情况\\n\\n接下来详细叙述一下（直接使用next数组做前缀表，且next数组从数组下标0开始）：\\n\\n1. 初始化\\n\\n定义两个指针i和j，j指向前缀末尾位置，i指向后缀末尾位置。然后还要对next数组进行初始化赋值，如下：\\n\\n```cpp\\nint j = 0;\\nnext[0] = 0;//next[i] 表示 i（包括i）之前最长相等的前后缀长度（其实就是j）所以初始化next[0] = j 。\\n```\\n\\n2. 处理前后缀不相同的情况\\n\\n遍历模式串的循环下标索引从1开始，因为下标为0时，显然最大公共前后缀为0，即next[0]的初始值；\\n`for(int i=1;i<s.size();i++) {`\\n如果 s[i] 与 s[j]不相同，也就是遇到前后缀末尾不相同的情况，就要向前回退。使用next数组来回退：`j=next[j-1]`。\\n\\n3. 处理前后缀相同的情况\\n   如果 s[i] 与 s[j + 1] 相同，那么就同时向后移动i 和j 说明找到了相同的前后缀，同时还要将j（前缀的长度）赋给next[i], 因为next[i]要记录相同前后缀的长度。\\n\\n```cpp\\nif(s[i] == s[j]) {\\n\\tj++;\\n}\\nnext[i]=j;\\n```\\n\\n**二、使用next数组来做匹配**：\\n\\n1. 目标串（主串）从0开始遍历字符串数组：\\n\\n```cpp\\nfor(int i=0;i<s.size();i++)\\n```\\n\\n2. 接下来就是`s[i]` 与 `t[j]` （因为j从0开始的） 进行比较。\\n\\n如果 `s[i]` 与 `t[j + 1]` 不相同，j就要从next数组里寻找下一个匹配的位置。\\n\\n```cpp\\nwhile(j>=0 && s[i]!=t[j]) {\\n\\tj=next[j];\\n}\\n```\\n\\n3. 如果s[i]和t[j]相同，那么i和j同时往后移动\\n\\n```\\nif (s[i] == t[j]) {\\n\\tj++;\\n}\\n```\\n\\n如何判断在文本串s里出现了模式串t呢，如果j指向了模式串t的末尾，那么就说明模式串t完全匹配文本串s里的某个子串了。\\n\\n本题要在文本串字符串中找出模式串出现的第一个位置 (从0开始)，所以返回当前在文本串匹配模式串的位置i 减去 模式串的长度，就是文本串字符串中出现模式串的第一个位置。\\n\\n代码如下：\\n\\n```cpp\\nif (j == (t.size() - 1) ) {\\n    return (i - t.size() + 1);\\n}\\n```\\n\\n所有代码如下：\\n\\n```cpp\\nvoid getNext(int* next, const string& s) {\\n\\tint j = 0;\\n\\tnext[0] = 0;\\n\\tfor(int i = 1; i < s.size(); i++) {\\n\\t\\twhile (j > 0 && s[i] != s[j]) {\\n\\t\\t\\tj = next[j - 1];\\n\\t\\t}\\n\\t\\tif (s[i] == s[j]) {\\n\\t\\t\\tj++;\\n\\t\\t}\\n\\t\\tnext[i] = j;\\n\\t}\\n}\\nint strStr(string haystack, string needle) {\\n\\tif (needle.size() == 0) {\\n\\t\\treturn 0;\\n\\t}\\n\\tint next[needle.size()];\\n\\tgetNext(next, needle);\\n\\tint j = 0;\\n\\tfor (int i = 0; i < haystack.size(); i++) {\\n\\t\\twhile(j > 0 && haystack[i] != needle[j]) {\\n\\t\\tj = next[j - 1];\\n\\t\\t}\\n\\t\\tif (haystack[i] == needle[j]) {\\n\\t\\t\\tj++;\\n\\t\\t}\\n\\t\\tif (j == needle.size() ) {\\n\\t\\t\\treturn (i - needle.size() + 1);\\n\\t\\t}\\n\\t}\\n\\treturn -1;\\n}\\n```\\n\\n**总结**：\\n\\n我们介绍了什么是KMP，KMP可以解决什么问题，然后分析KMP算法里的next数组，知道了next数组就是前缀表，再分析为什么要是前缀表而不是什么其他表。\\n\\n接着从给出的模式串中，我们一步一步的推导出了前缀表，得出前缀表无论是统一减一还是不减一得到的next数组仅仅是kmp的实现方式的不同。\\n\\n其中还分析了KMP算法的时间复杂度，并且和暴力方法做了对比。\\n\\n然后先用前缀表统一减一得到的next数组，求得文本串s里是否出现过模式串t，并给出了具体分析代码。\\n\\n又给出了直接用前缀表作为next数组，来做匹配的实现代码。\\n\\n**求next数组的小技巧（以下图为例）**：\\n\\n![](https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlGG-X8nEvHZ1plBp/root/content)\\n\\n第一个字符a，无前缀后缀，所以为0；\\n第二个字符串as，无最长公共前后缀，所以为0；\\n第三个字符串asd，无最长公共前后缀，所以为0；\\n...\\n第五个字符串asdfa,最长公共前后缀是a，所以是1；\\n类似的，第9个字符串asdfasdfa,（最长前缀是asdfasdf，最长后缀是sdfasdfa。不相同，所以不是8）最长公共前后缀asdfa：前缀是asdfa(从[0]到[4]),后缀是asdfa(从[4]到[8])，随意最长公共前后缀为5\\n...\\n上述计算结束后，每一位在统一减一，就可以得到上图中的next数组了。\\n\\n### 4.7 重复的子字符串\\n\\n**题意**：给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。示例：输入：\\\"abab\\\"，输出True.\\n**思路**：主要有三种方法：1）暴力解法：第一层循环遍历整个字符串，第二层来寻找最小子串，子串的起点始终为起点，终点为当前遍历点，然后看这个子串能否构成整个大串。2）移动匹配法；3）KMP算法。\\n\\n**移动匹配**：\\n\\n当一个字符串s：`abcabc`，内部由重复的子串组成，那么这个字符串的结构一定是由前后相同的子串组成。那么既然前面有相同的子串，后面有相同的子串，用 s + s，这样组成的字符串中，后面的子串做前串，前后的子串做后串，就一定还能组成一个s。**所以判断字符串s是否由重复子串组成，只要两个s拼接在一起，里面还出现一个s的话，就说明是由重复子串组成**。也就是说，假设字符串s由a和b组成，若`s=a+b`，当`a+b+a+b`中仍然存在一个s时，说明`s=b+a`，说明a和b是一样的，也就是说s可以由重复子串a(或b)构成。\\n\\n当然，我们在判断 s + s 拼接的字符串里是否出现一个s的的时候，**要刨除 s + s 的首字符和尾字符**，这样避免在s+s中搜索出原来的s，我们要保证搜索的是中间拼接出来的s。\\n\\n```cpp\\nbool repeatedSubstringPattern(string s) {\\n\\tstring t = s + s;\\n\\tt.erase(t.begin());//掐头去尾\\n\\tt.erase(t.end()-1);\\n\\tif(t.find(s) != std::string::npos)//std::string::npos\\n\\t\\treturn true;\\n\\treturn false;\\n}\\n```\\n\\n注：\\n\\n关于std::string::npos的使用说明：\\n\\n+ （1）它是一个常量静态成员值，对于 size_t 类型的元素具有最高可能值。\\n+ （2）它实际上意味着直到字符串的末尾。\\n+ （3）它用作字符串成员函数中长度参数的值。\\n+ （4）作为返回值，它通常用于表示没有匹配项。\\n+ （5）数据类型为size_t的话string:npos常量被定义为-1，因为size_t是无符号整数类型，-1是该类型的最大可能表示值。\\n\\n```cpp\\n//1、std::string::npos一般最常见用于表示未找到的情况\\nstring str = \\\"I am cver\\\";\\nsize_t index = str.find(\'.\');\\n//字符没找到\\nif (index == string::npos) {\\n\\tcout<<\\\"this does not contain any period!\\\"<<endl;\\n\\tcout<<index<<endl;\\n}\\n//2、作字符串成员函数中长度参数的值\\n#include <iostream>\\n#include <string>\\nusing namespace std;\\nint main()\\n{\\n\\tstring str = \\\"I am cver.\\\";\\n\\tsize_t index = str.find(\'.\'); \\n\\tif(index == string::npos)\\n\\t{\\n\\t\\tcout << \\\"This does not contain any period!\\\" << endl;\\n\\t\\tcout << index << endl;\\n\\t}\\n\\telse\\n\\t{\\n\\t\\tstr.replace(index, string::npos, \\\"!\\\"); //string& replace(int p0, int n0,const char *s);删除从p0开始的n0个字符，然后在p0处插入串s\\n\\t\\tcout << str << endl;\\n\\t\\tcout << index << endl;\\n\\t}\\t\\t\\n}\\n```\\n\\n不过这种解法还有一个问题，就是 我们最终还是要判断 一个字符串（s + s）是否出现过 s 的过程，大家可能直接用contains，find 之类的库函数。 却忽略了实现这些函数的时间复杂度（暴力解法是m * n，一般库函数实现为 O(m + n)）。如果我们做过 28.实现strStr (opens new window)题目的话，其实就知道，实现一个 高效的算法来判断 一个字符串中是否出现另一个字符串是很复杂的，这里就涉及到了KMP算法。\\n\\n**KMP**：\\n\\n<为什么使用MKP算法>？\\n\\n在一个串中查找是否出现过另一个串，这是KMP的看家本领。那么寻找重复子串怎么也涉及到KMP算法了呢？\\n\\n在由重复子串组成的字符串中，最长相等前后缀不包含的子串就是最小重复子串，这里拿字符串s：abababab 来举例，ab就是最小重复单位，如图所示：\\n\\n![](https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlF8PCVBCA1rDlM4M/root/content)\\n\\n<如何找到最小重复子串>？\\n\\n步骤一：因为 这是相等的前缀和后缀，t[0] 与 k[0]相同， t[1] 与 k[1]相同，所以 s[0] 一定和 s[2]相同，s[1] 一定和 s[3]相同，即：，s[0]s[1]与s[2]s[3]相同 。\\n\\n步骤二： 因为在同一个字符串位置，所以 t[2] 与 k[0]相同，t[3] 与 k[1]相同。\\n\\n步骤三： 因为 这是相等的前缀和后缀，t[2] 与 k[2]相同 ，t[3]与k[3] 相同，所以，s[2]一定和s[4]相同，s[3]一定和s[5]相同，即：s[2]s[3] 与 s[4]s[5]相同。\\n\\n步骤四：循环往复。\\n\\n所以字符串s，s[0]s[1]与s[2]s[3]相同， s[2]s[3] 与 s[4]s[5]相同，s[4]s[5] 与 s[6]s[7] 相同。\\n\\n正是因为 最长相等前后缀的规则，当一个字符串由重复子串组成的，最长相等前后缀不包含的子串就是最小重复子串。\\n\\n![](https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlGCHOJOsongi-3Eh/root/content)\\n\\n**简单推理**：\\n\\n这里再给出一个数学推导，就容易理解很多。\\n\\n假设字符串s使用多个重复子串构成（这个子串是最小重复单位），重复出现的子字符串长度是x，所以s是由n * x组成。\\n\\n因为字符串s的最长相同前后缀的长度一定是不包含s本身，所以 最长相同前后缀长度必然是m * x，而且 n - m = 1，（这里如果不懂，看上面的推理）\\n\\n所以如果 nx % (n - m)x = 0，就可以判定有重复出现的子字符串。\\n\\nnext 数组记录的就是最长相同前后缀 字符串：KMP算法精讲 (opens new window)这里介绍了什么是前缀，什么是后缀，什么又是最长相同前后缀)， 如果 next[len - 1] != -1，则说明字符串有最长相同的前后缀（就是字符串里的前缀子串和后缀子串相同的最长长度）。\\n\\n最长相等前后缀的长度为：next[len - 1] + 1。(这里的next数组是以统一减一的方式计算的，因此需要+1，两种计算next数组的具体区别看这里：字符串：KMP算法精讲 (opens new window))\\n\\n数组长度为：len。\\n\\n如果len % (len - (next[len - 1] + 1)) == 0 ，则说明数组的长度正好可以被 (数组长度-最长相等前后缀的长度) 整除 ，说明该字符串有重复的子字符串。\\n\\n**数组长度减去最长相同前后缀的长度相当于是第一个周期的长度，也就是一个周期的长度，如果这个周期可以被整除，就说明整个数组就是这个周期的循环。**\\n\\n例如下图：\\n\\n![](https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlGG-X8nEvHZ1plBp/root/content)\\n\\n`next[len - 1] = 7，next[len - 1] + 1 = 8`，8就是此时字符串asdfasdfasdf的最长相同前后缀的长度。\\n\\n`(len - (next[len - 1] + 1))` 也就是： 12(字符串的长度) - 8(最长公共前后缀的长度) = 4， 4正好可以被 12(字符串的长度) 整除，所以说明有重复的子字符串（asdf）。\\n\\ncpp代码实现：\\n\\n```cpp\\nvoid getNext (int* next, const string& s){\\n\\tnext[0] = 0;\\n\\tint j = 0;\\n\\tfor(int i = 1;i < s.size(); i++){\\n\\t\\t while(j > 0 && s[i] != s[j]) {\\n\\t\\t\\t j = next[j - 1];\\n\\t\\t}\\n\\t\\tif(s[i] == s[j]) {\\n\\t\\t\\tj++;\\n\\t\\t}\\n\\t\\tnext[i] = j;\\n\\t}\\n}\\nbool repeatedSubstringPattern (string s) {\\n\\tif (s.size() == 0) {\\n\\t\\treturn false;\\n\\t}\\n\\tint next[s.size()];\\n\\tgetNext(next, s);\\n\\tint len = s.size();\\n\\tif (next[len - 1] != 0 && len % (len - (next[len - 1] )) == 0) {\\n\\t\\treturn true;\\n\\t}\\n\\treturn false;\\n}\\n```\\n\\n### 4.8 总结\\n\\n**什么是字符串**：\\n\\n字符串是若干字符组成的有限序列，也可以理解为是一个字符数组，但是很多语言对字符串做了特殊的规定，接下来我来说一说C/cpp中的字符串。在C语言中，把一个字符串存入一个数组时，也把结束符 \'\\\\0\'存入数组，并以此作为该字符串是否结束的标志。\\n\\n在cpp中，提供一个string类，string类会提供 size接口，可以用来判断string类字符串是否结束，就不用\'\\\\0\'来判断是否结束。\\n\\n字符串的长度计算有`size()`也可以用`length()`，那么`vector<char>`和string的区别在哪？基本上没差别，不过string提供了更多的字符串处理的相关接口，例如string重载了+，而vector却没有。\\n\\n**双指针法**：\\n\\n在**反转字符串1**中，是反转字符串中的所有字符，可以使用双指针，两个指针一个从头开始，一个从未开始进行交换，以实现题目的功能。\\n\\n在**字符串：替换空格**中，我们需要将空格全部替换成指定的字符串，本题中是将空格替换成“%20”。**其实很多数组填充类的问题，都可以先预先给数组扩容带填充后的大小，然后在从后向前进行操作**。\\n\\n在**翻转字符串中的单词**中，与之前**移除数组元素**类似，双指针法，一个快指针做遍历，另一个慢指针来保留有用的元素。在这里，我们将空格全部当成需要移除的元素来处理，就与以前移除数组元素的操作相同了。然后，后面在对每个单词后面添加一个空格。这样就达到了“移除字符串中多余空格的目的”。\\n\\n需要注意的是，库函数erase()的时间复杂度为O(n)。\\n\\n**反转系列**：\\n\\n反转其实实在考察队代码的掌控能力。\\n\\n在**反转字符串2**中，每隔2k字符就翻转前k个字符，不足k的话就翻转全部字符。其实，当需要固定规律一段一段去处理字符串时，可以在for循环的表达式上坐坐文章。\\n\\n在**翻转字符串里的单词**中要求翻转字符串里面的单词，这道题目可以说是考察了字符串的多种操作，是考察字符串的一道好题。解法是：1）先去掉多余的空格；2）在整体反转，3）再局部反转。\\n\\n还有一个字符串的左转：剑指Offer58-II.左旋转字符串：给定字符串和一个数字，实现将数字前的字符移动到字符串末尾，如：输入\\\"abcdefg\\\"和2，得到\\\"cdefgab\\\"。这道题的思路是：1）先反转前n个字符，2）再反转n到末尾的字符，3）最后在反转整个字符串。而这三步骤，其核心就是”给定一个字符串，反转其全部字符“，就是本章节的第一题，使用双指针从头和从尾两端同时替换即可。\\n\\n**KMP系列**：\\n\\n问题1是实现子串问题，判断字符串2是不是字符串1的子串。采用KMP的方法，先对子串2进行分析，得到其next数组（该next数组反映了子串2的字符排列特点，可以在与主串的匹配查找过程中提供指针跳转的参考依据）。然后就是在next数组的基础上进行两字符串匹配的过程了。\\n\\n问题2是重复子串问题，就是说一个字符串能否由它的子串完整构成，例如主串\\\"abababab\\\"可以有子串\\\"ab\\\"完整构成。方法主要有移动匹配和KMP算法。移动构造：判断字符串s是否可以由子串构成，就1）构造s+s的字符串，2）刨除首字符和尾字符，3）判断剩余的字符中有无字符串s。有就是满足题意。\\n\\n```cpp\\nbool repeatSubstring(string s) {\\n\\tstring t = s + s;\\n\\tt.erase(t.begin());\\n\\tt.erase(t.end()-1);\\n\\tif(t.find(s) != std::string::npos) \\n\\t\\treturn true;\\n\\treturn false;\\n}\\n```\\n\\n注意，一般暴力解法的复杂度是O(N^2)，库函数（如contains、find)的复杂度是O(m+n)。\\n\\n## 五、双指针法\\n\\n本章节主要是复习前面的内容。双指针法在数组、链表和字符串中很常用。\\n\\n**数组**：\\n\\n1. 移除元素\\n\\n**链表**：\\n\\n1. 翻转链表\\n2. 删除链表的倒数第N个节点\\n3. 链表相交\\n4. 环形链表2\\n\\n**哈希表**：\\n\\n1. 三数之和\\n2. 四数之和\\n\\n**字符串**：\\n\\n1. 反转字符串(单个字符串内的全部字符)\\n2. 替换空格\\n3. 反转字符串中的单词\\n\\n**__总结__**：\\n在【数组篇】中有删除元素一节，一些同学可能会写出下列代码(伪代码)：\\n\\n```cpp\\nfor (int i = 0; i>array.size(); i++) {\\n\\tif (array[i] == target) {\\n\\t\\tarray.erase(i);\\n\\t}\\n}\\n```\\n\\n这个代码看着是只有O(n)的复杂度，其实是O(n^2)的复杂度，因为erase操作也是O(n)的操作。数组本身不能真正的删除元素，只能覆盖。\\n\\n在【链表篇】中，使用双指针法来翻转链表、确定单链表是否有环和环入口。\\n\\n在【哈希表篇】中，使用双指针法实现了N数之和。\\n\\n在【字符串篇】中，使用双指针法实现了反转字符串、替换空格和删除冗余空格。\\n\\n## 六、栈与队列\\n\\n\\n\\n\\n\\n\\n## 七、二叉树\\n\\n## 八、回溯算法\\n\\n## 九、贪心算法\\n\\n## 十、动态规划\\n\\n## 十一、单调栈\\n\\n## 十二、额外题目\\n\\n\",\"articleCover\":\"\",\"articleTitle\":\"代码随想录学习笔记_第一部分[总结]\",\"articleType\":1,\"categoryName\":\"找工作\",\"isRecommend\":0,\"isTop\":0,\"status\":1,\"tagNameList\":[\"找工作\"]}]','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',106,'2023-06-07 17:01:46');
INSERT INTO `t_operation_log` VALUES (1195,'文章模块','添加','/admin/article/add','com.ican.controller.ArticleController.addArticle','添加文章','[{\"articleContent\":\"---\\ntitle: markdown基本规则学习笔记\\ndate: 2021-2-15 20:00:01\\ntag:\\n - tag4\\ncategory: \\n - markdown基本规则\\npublish: true\\nfooter: <a href=\\\"https://beian.miit.gov.cn/#/Integrated/index\\\">渝ICP备2023001651号</a>\\n\\n---\\n\\n:::tip\\nMakeDown的基本书写规则\\n:::\\n\\n<!-- more -->\\n\\n\\n\\n@(示例笔记)[马克飞象|帮助|Markdown]\\n说明：TOC为table of contents，即目录表，语法为：`[[TOC]]`\\n\\n是撒啊阿萨\\n\\n飒飒飒订单\\n\\n\\n\\n[[TOC]]\\n\\n\\n<Boxx  changeTime=\\\"5000\\\" />\\n\\n\\n```yaml\\n插入名人名言：<Boxx />\\n\\n使用title和content属性自定义文字：<Boxx type=\'tip\' tilte=\'Haoxx\' content=\'勤能补拙，懒惰则一事无成\' />\\n```\\n\\n<Boxx type=\'tip\' tilte=\'Haoxx\' content=\'勤能补拙，懒惰则一事无成\'/>\\n\\nchangeTime=\\\"1000\\\" 指定更新时间，单位为ms\\n\\n<Boxx type=\\\"danger\\\" changeTime=\\\"5000\\\"    title=\\\"我是一个大大的且变化的 title\\\" content=\'文本\' />\\n\\n## 1、标题\\n\\n标题：一级标题用“#+**空格**+文字”的格式，二级标题用“##+**空格**+文字”的格式，以此类推。\\n\\n## 1.1 新增（vuepress中可用）\\n\\n你可以在标题中，使用这个Badge组件来为某些 API（标题） 添加一些状态：\\n\\n```yaml\\n### 标题名 <标题名 text=\\\"beta\\\" type=\\\"warning\\\"/> <标题名 text=\\\"默认主题\\\"/>\\n\\ntype可以换成tip、warning、danger  details\\n```\\n\\n## 2、粗体\\n\\n* 粗体\\n  粗体的格式是：前后各两个星号 `**测试**` ，效果为：**测试**\\n* 斜体\\n  斜体的格式是：前后各一个星号 `*测试*`，效果为：*测试*\\n* 分隔符\\n  分隔符的格式是：三个星号 `***` ,或者连续三个短横线`---`，效果为：\\n\\n***\\n\\n## 3、换行\\n\\n1. 段内换行\\n   段内换行使用“结尾空两个空格再回车”的方式。\\n\\n2. 段落换行\\n   向下空一行\\n\\n3. 空多行\\n   使用HTML的\\\\<br>标签来实现\\n\\n4. 附加说明\\n   在使用typora软件时，`三个换行`表示真正的换行；\\\"四个空格\\\"功能未知。\\n\\n   \\n\\n## 4、列表\\n\\n1. 无序列表\\n   一般用“\\\\*号+**空格**+内容”或者“+号+**空格**+内容”，再或者“-号+**空格**+内容”。\\n\\n&emsp;&emsp;<font color=\'red\'>怎么做</font>：`* 列表内容`或`+ 列表内容`或`- 列表内容` ，效果为：\\n\\n- 列表测试\\n\\n\\n2. 有序列表\\n   格式为：\\\"1.+空格+项目1\\\"\\n\\n&emsp;&emsp;<font color=\'red\'>怎么做</font>：`1. 有序列表`\\n\\n3. 列表嵌套\\n   在上层列表下“添加四个空格”即可。\\n\\n&emsp;&emsp;<font color=\'red\'>怎么做</font>：\\n\\n```markdown\\n- 列表1\\n[四个空格]- 列表1.1\\n```\\n\\n效果为：\\n\\n- 列表1\\n  - 列表1.1\\n\\n## 5、引用\\n\\n1. 引用\\n   “>”加上空格，就是引用。\\n2. 多层引用\\n   “>>”加上空格，就是多层引用。\\n\\n> 引用1\\n> 继续\\n\\n>> 二级引用\\n>\\n>>> 三级引用\\n\\n## 6、代码\\n\\n1. 段落文字中的代码\\n   文字中的代码，用反引号`printf(\\\"hello,world!\\\");`包裹。\\n2. 独立代码块\\n   独立的代码块用三个反引号包含，并指明类型，如：\\n\\n```c\\nprintf(\\\"hello,world!\\\");\\n```\\n\\n\\n\\n## 7、链接\\n\\n1. 方式1 []和（）\\n   格式为：\\\\[链接名](链接地址)\\n   圆括号中可以为网络地址，也可以为本地的绝对地址、相对地址。\\n   例如：[VSCode背景图](C:\\\\backgroud.jpg)  ，\\n   可以添加链接的标题：\\\\[VSCode背景图](C:\\\\backgroud.jpg \\\"链接的标题\\\") \\n2. 方式2 采用类似参考文献的格式\\n   类似于参考文献，\\\\[链接名][1]   ,然后在文件内容的最后面，写上[1]:链接地址\\n\\n\\n\\n## 8、图片\\n\\n图片的插入和链接类似，可以网络，也可以本地。\\n格式为：\\\\!\\\\[图片名](图片的地址)\\n例如：\\\\!\\\\[VSCode背景图](C:\\\\backgroud.jpg)\\n再比如：![网络图片](https://imgtu.com/i/ObErMq)\\n\\n## 9、表格\\n\\n表格用“|”来分隔。&emsp;&emsp;<font color=\'red\'>怎么做</font>：\\n\\n```markdown\\n|表头1|表头2|\\n|---|:----:|\\n|单元格1|单元格2|\\n```\\n\\n效果如下所示：\\n\\n| 表头1   |  表头2  |\\n| ------- | :-----: |\\n| 单元格1 | 单元格2 |\\n\\n注意：（空一行表示表格结束）短横线做分割线，至少要三个。\\n说明：用冒号:来设置左右对齐方式，如`左对齐：\\\":单元格\\\" `；`右对齐 “单元格:”`；`居中： “:单元格:”`。\\n\\n\\n\\n## 10、markdown高级\\n\\n1、支持使用HTML标签\\n除了用过的`<br>`表示换行以外，`<kbd>`表示用小框框把指定文字框起来，如<kbd>测试</kbd>\\n其他的还有，如 \\\\<kbd>  \\\\<b> \\\\<i> \\\\<em> \\\\<sup>  \\\\<sub>,还有\\\\<img src = https://xx.png alt=\\\"我的图片\\\" style=\\\"zoom:33%\\\">\\\\</img>\\n2、双`$`符号\\n`$$`符号用来表示公式，格式如：\\n\\n```latex\\n$$\\n-xxx-\\n$$\\n```\\n\\n此外，行间公式`$a+b=c$`  ，或者块级公式：\\n`$$ a+b=c $$`\\n\\n## 11、markdown语法的后续补充\\n\\n(1)、**高亮**格式： ==高亮的内容==  ，说明：该部分内容在“typora->文件->偏好设置->Markdown->Markdown扩展语法”中的对应选项要先勾选上才会生效。\\n\\n&emsp;&emsp;<font color=\'red\'>怎么做</font>：`==高亮的内容== `\\n\\n(2)、**删除线**：~~alt+shift+5~~  ，文字的前后加上两个波浪号。\\n\\n&emsp;&emsp;<font color=\'red\'>怎么做</font>：`~~alt+shift+5~~`\\n\\n(3)、**加粗**：前后两个星号,ctrl+B\\n\\n&emsp;&emsp;<font color=\'red\'>怎么做</font>：`**ctrl+b**`\\n\\n(4)、**斜体**：前后一个星号,ctrl+I\\n\\n&emsp;&emsp;<font color=\'red\'>怎么做</font>：`*ctrl+b*`\\n\\n(5)、**下划线**：<u>ctrl+u</u>   前后加上\\\\<u>和\\\\</u>\\n\\n&emsp;&emsp;<font color=\'red\'>怎么做</font>：`<u>ctrl+u</u>`\\n\\n(6)、**表格** ctrl+t\\n\\n&emsp;&emsp;<font color=\'red\'>怎么做</font>：1) 使用`ctrl+t`弹出表格创建提示框； 2) 使用以下语法来创建表格：\\n\\n```markdown\\n|英文代码|对应颜色|----|英文代码|对应颜色|\\n|:-----|:-----:|:--:|:----:|:-----:|  //表头和内容的分割符号\\n\\n//其中：|:--:|表示居中对齐，|:--|表示左对齐\\n\\n|red|红色|----|purple|紫色|\\n|green|绿色|----|skyblue|天蓝色|\\n|blue|蓝色|----|lightgreen|淡绿色|\\n|Gold|金色|----|grey|灰色|\\n|Orange|橙色|----|blueviolet|深紫罗兰色|\\n```\\n\\n效果为：\\n\\n| 英文代码 | 对应颜色 | ---- |  英文代码  |  对应颜色  |\\n| :------- | :------: | :--: | :--------: | :--------: |\\n| red      |   红色   | ---- |   purple   |    紫色    |\\n| green    |   绿色   | ---- |  skyblue   |   天蓝色   |\\n| blue     |   蓝色   | ---- | lightgreen |   淡绿色   |\\n| Gold     |   金色   | ---- |    grey    |    灰色    |\\n| Orange   |   橙色   | ---- | blueviolet | 深紫罗兰色 |\\n\\n(7)、**流程图**\\n\\n&emsp;&emsp;<font color=\'red\'>怎么做</font>： 使用以下语法来创建表格：\\n\\n```markdown\\n//[这里有三个反引号]flow\\nst=>start: Start\\ne=>end\\nop=>operation: My Operation\\ncond=>condition: Yes or No?\\n\\nst->op->cond\\ncond(yes)->e\\ncond(no)->op\\n[这里有三个反引号]\\n```\\n\\n下面就是上述代码的渲染效果了：\\n\\n```flow\\nst=>start: Start\\ne=>end\\nop=>operation: My Operation\\ncond=>condition: Yes or No?\\n\\nst->op->cond\\ncond(yes)->e\\ncond(no)->op\\n```\\n\\n(8)、**时序图**\\n\\n&emsp;&emsp;<font color=\'red\'>怎么做</font>： 使用以下语法来创建表格：\\n\\n```markdown\\n[这里有三个反引号]sequence\\nAlice->Bob: Hello Bob, how are you?\\nNote right of Bob: Bob thinks\\nBob-->Alice: I am good thanks!\\n[这里有三个反引号]\\n```\\n\\n下面就是上述代码的渲染效果了：\\n\\n```sequence\\nAlice->Bob: Hello Bob, how are you?\\nNote right of Bob: Bob thinks\\nBob-->Alice: I am good thanks!\\n```\\n\\n(9)、**复选框**\\n\\n&emsp;&emsp;<font color=\'red\'>怎么做</font>： 使用`- []`和`- [x]`语法来创建复选框，实现todo-list功能。\\n\\n- [x] 已完成事项\\n- [ ] 代办事项 \\n\\n(10)、**上下标**\\n\\n&emsp;&emsp;<font color=\'red\'>怎么做</font>： 上标：`x^2^`，下标：`H~2~O`。\\n\\n效果如下：\\n\\n上标： x^2^\\n下标：H~2~O\\n\\n(11)、**链接和脚注**\\n\\n链接在前面已经说过了，这里简单再提一下：\\\\[链接名](链接地址)\\n\\n&emsp;&emsp;<font color=\'red\'>怎么做</font>：脚注的格式是： \\n\\n```markdown\\n在待脚注的位置写上A`[^1]`。是多少\\n\\n然后在后文，空一行，再加上：B`[^1]:脚注的内容`\\n\\n这部分脚注B的内容会被移动到文章的最末尾显示，并且会在A处留校一个可以跳转的链接，同时B处也有往回跳转的链接。主要注意的是，上述A和B仅是为了方便说明，实际使用是不要加上这两个字符。\\n\\n```\\n\\n下面是脚注的效果：\\n\\n脚注的格式是： 在待脚注的位置写上[^1]。是多少\\n\\n[^1]: 示例：脚注的内容\\n\\n(12)、**实现空格**\\n\\n&emsp;&emsp;<font color=\'red\'>怎么做</font>：用该字符`&emsp;`来实现一个空字符，对于某些需要首行缩进两个字符的情况，使用两个字符来实现：`&emsp;&emsp;`\\n\\n\\n\\n## 12、修改字体颜色\\n\\n格式为：`<font color=\'orange\'>并发</font>`\\n效果为：<font color=\'blueviolet\'>测试</font>\\n里面可以找找好看的颜色对应的标签名：[配色网](https://www.flatuicolorpicker.com/)\\n常用的标签如下表格所示：\\n\\n| 英文代码 | 对应颜色 | ---- |  英文代码  |  对应颜色  |\\n| :------: | :------: | :--: | :--------: | :--------: |\\n|   red    |   红色   | ---- |   purple   |    紫色    |\\n|  green   |   绿色   | ---- |  skyblue   |   天蓝色   |\\n|   blue   |   蓝色   | ---- | lightgreen |   淡绿色   |\\n|   Gold   |   金色   | ---- |    grey    |    灰色    |\\n|  Orange  |   橙色   | ---- | blueviolet | 深紫罗兰色 |\\n\\n**说明**：标签首字母的大写可以不用大写，但是为了单词的可读性，建议首字母大写，如BlueViolet。\\n\\n\\n## 13、分割线\\n\\n可以在一行中用三个以上的减号来建立一个分隔线，同时需要在分隔线的上面空一行。\\n\\n## 14、makedown在vuepress中的扩展语法--之容器\\n\\n::: info\\n信息容器。\\n:::\\n\\n::: note\\n注释容器。\\n:::\\n\\n::: tip\\n提示容器\\n:::\\n\\n::: warning\\n警告容器\\n:::\\n\\n::: danger\\n危险容器\\n:::\\n\\n::: details\\n详情容器\\n:::\\n\\n\\n::: theorem 牛顿第一定律\\n假若施加于某物体的外力为零，则该物体的运动速度不变。\\n:::\\n\\n\\n::: right\\n来自 [维基百科](https://zh.wikipedia.org/wiki/%E7%89%9B%E9%A1%BF%E8%BF%90%E5%8A%A8%E5%AE%9A%E5%BE%8B)\\n:::\\n\\n补充说明，对于badge标签，支持的类型有：类型: \\\"tip\\\" | \\\"warning\\\" | \\\"danger\\\" | \\\"info\\\" | \\\"note\\\"，默认值为info\\n\\n## 15、流程图\\n\\n下面这个流程图的代码为：\\n\\n```markdown\\n[这里有三个反引号]flow\\ncond=>condition: Process?\\nprocess=>operation: Process\\ne=>end: End\\n\\ncond(yes)->process->e\\ncond(no)->e\\n[这里有三个反引号]\\n```\\n\\n效果为：\\n\\n```flow\\ncond=>condition: Process?\\nprocess=>operation: Process\\ne=>end: End\\n\\ncond(yes)->process->e\\ncond(no)->e\\n```\",\"articleCover\":\"\",\"articleTitle\":\"markdown基本规则学习笔记\",\"articleType\":1,\"categoryName\":\"markdown\",\"isRecommend\":0,\"isTop\":0,\"status\":1,\"tagNameList\":[\"markdown\"]}]','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',31,'2023-06-07 17:02:26');
INSERT INTO `t_operation_log` VALUES (1196,'文章模块','添加','/admin/article/add','com.ican.controller.ArticleController.addArticle','添加文章','[{\"articleContent\":\"---\\ntitle: markdown之frontmatter设置\\ndate: 2021-2-15 20:00:01\\ntag:\\n - tag4\\ncategory: \\n - markdown基本规则\\npublish: true\\nfooter: <a href=\\\"https://beian.miit.gov.cn/#/Integrated/index\\\">渝ICP备2023001651号</a>\\n\\n---\\n\\n:::tip\\n这篇文档主要是总结文章的前页（frontmatter）参数设置。参考了vuepress-theme-hope官网上的资料[点击查看](https://theme-hope.vuejs.press/zh/config/frontmatter/info.html)\\n:::\\n\\n<!-- more -->\\n\\n## 注意！\\n\\n文章的前页使用yaml语言来设计的，其格式为`选项:[空格]选项值`。\\n\\n## 基本设置\\n\\n建议的选项有：\\n\\n- title：文章标题（当前页面内容标题，默认为 Markdown 文件中的第一个 h1 标签内容。）\\n- description：当前页面内容描述，字符串类型\\n  -icon：图标，字符串，[图标指南](https://theme-hope.vuejs.press/zh/guide/interface/icon.html) ，一共有三类图标，我们在主题配置文件中选择的是Iconfont，所以在[这个图标网站](https://www.iconfont.cn/)上去找我们需要的图标名。\\n- author：作者，字符串类型\\n- isOriginal：是否原创，布尔，默认为false\\n- date：时间，注意格式为`YYYY-MM-DD` 或`YYYY-MM-DD hh:mm:ss`\\n- category：分类，字符串或字符串数组\\n- tag：标签，字符串或字符串数组\\n- sticky：是否在列表中指定，类型为`boolean | number`，当填入数字时，取值越大排名越靠前，默认为false\\n- star：是否收藏进博客的文章列表，类型为`boolean | number`，当填入数字时，取值越大排名越靠前，默认为false\\n\\n## 其他设置--信息类的frontmatter\\n\\n下面这些是扩展性设置\\n\\n- article：是否将该文章添加至文章列表中，布尔，默认为true\\n- timeline：是否将该文章添加至时间线中。布尔，默认为true\\n- image：设置预览图 (分享图)，请填入绝对路径，字符串\\n- banner：设置横幅图片 (宽屏分享图)，请填入绝对路径，字符串\\n\\n## 其他设置--布局的frontmatter\\n\\n下面这些是扩展性设置\\n\\n- pageview：是否开启浏览量显示，布尔，默认为true\\n- comment：是否开启评论显示，布尔，默认为true\\n- breadcrumb：是否开启路径导航\\n- breadcrumbIcon：是否开启路径导航图标\\n- navbar：导航栏配置，填入 false 会禁用导航栏\\n- sidebar：侧边栏配置选项。支持 \\\"heading\\\" 或 false\\n- headerDepth：标题渲染深度，默认为2\\n- index：是否在侧边栏中索引当前页面，布尔，默认为true\\n- order：指定当前页面在侧边栏中的排序\\n  - 当填写正数的时候，页面将排在靠前的位置，数字越小出现的位置越前。\\n  - 当填写负数的时候，页面将排在靠后的位置，数字越大出现的位置越前（比如 -1 在 -2 之后）。\\n- lastUpdated：是否显示最后更新时间，默认值: 主题选项中的值\\n- editLink：是否显示编辑链接，布尔，默认值: 主题选项中的值\\n- contributors：是否显示贡献者，布尔，默认值: 主题选项中的值\\n- footer：设置页脚内容。\\n  - 设置为 false 以禁用页脚\\n  - 设置为 \\\"\\\" 以移除默认的页脚内容，\\n  - 设置为 true 以使用默认页脚。\\n\\n更多详情请看 [页面 → 页脚支持](https://theme-hope.vuejs.press/zh/guide/layout/footer.html)\\n\\n- copyright：设置版权信息，更多详情请看[页面，页脚支持](https://theme-hope.vuejs.press/zh/guide/layout/footer.html)\\n\\n## 文档主页的frontmatter设置\\n\\n## 博客主页的frontmatter设置\\n\\n## 某些插件的frontmatter设置\\n\\n版权页copyroght2插件，feed2插件，sitmap2插件\\n\",\"articleCover\":\"\",\"articleTitle\":\"markdown之脚注设置\",\"articleType\":1,\"categoryName\":\"markdown\",\"isRecommend\":0,\"isTop\":0,\"status\":1,\"tagNameList\":[\"脚注设计\"]}]','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',24,'2023-06-07 17:03:20');
INSERT INTO `t_operation_log` VALUES (1197,'文章模块','添加','/admin/article/add','com.ican.controller.ArticleController.addArticle','添加文章','[{\"articleContent\":\"# 网站导航记录\\n\\n来源于：CodeSheep的github：https://github.com/rd2coding/Road2Coding\\n\\n1、数据结构\\n\\nhttps://mp.weixin.qq.com/s/f9dfQQbpKjMopH6m2Gjiiw\\n\\n2、编程自学网站\\n\\nhttps://mp.weixin.qq.com/s/jFc-6QK2Mv1zHuhuFrqhog\\n\\n3、Linux系统性能监控小工具\\n\\ntop、htop、iftop等等\\nhttps://mp.weixin.qq.com/s/zWIv5yBTD0Tvt8txb8znrA\\n\\n4、程序员命令行生产力！：终端和命令\\n\\nhttps://mp.weixin.qq.com/s/k19ZT_yH4lzNLUYkH2GUJA\\n\\nCLI指的是： command-line  interface\\n\\n5、git官方中文说明文档\\n\\nhttps://developers.weixin.qq.com/miniprogram/dev/framework/\\n\\n6、微信小程序官方开发文档\\n\\nhttps://developers.weixin.qq.com/miniprogram/dev/framework/\\n\\n\\n\\n\\n\\n\",\"articleCover\":\"\",\"articleTitle\":\"部分有用的网站记录\",\"articleType\":1,\"categoryName\":\"其他\",\"isRecommend\":0,\"isTop\":0,\"status\":1,\"tagNameList\":[\"其他\"]}]','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',39,'2023-06-07 17:04:31');
INSERT INTO `t_operation_log` VALUES (1198,'文章模块','添加','/admin/article/add','com.ican.controller.ArticleController.addArticle','添加文章','[{\"articleContent\":\"![](https://files.mdnice.com/logo.svg)\\n\\n请使用 **Chrome** 浏览器。\\n\\n请阅读下方文本熟悉工具使用方法，本文可直接拷贝到微信中预览。点击[墨滴官网](https://mdnice.com/)查看更多信息，注意：需要注册登录后才能看到编辑页面。其他微信公众号编辑工具（包含无需注册的）详见：[知乎文章](https://zhuanlan.zhihu.com/p/385098206)\\n\\n\\n[TOC]\\n\\n\\n## 1 Markdown Nice 简介\\n\\n- 支持自定义样式的 Markdown 编辑器\\n- 支持微信公众号、知乎和稀土掘金\\n- 欢迎扫码回复「排版」加入推文群\\n\\n![](https://files.mdnice.com/pic/cd3ca20c-896f-4cfc-9bdd-c4c58e69ba26.jpg)\\n\\n## 2 主题\\n\\n**https://product.mdnice.com/themes/**\\n\\n欢迎提交主题，提供更多文章示例~~\\n\\n## 3 通用语法\\n\\n### 3.1 标题\\n\\n在文字写书写不同数量的`#`可以完成不同的标题，如下：\\n\\n# 一级标题\\n\\n## 二级标题\\n\\n### 三级标题\\n\\n### 3.2 无序列表\\n\\n无序列表的使用，在符号`-`后加空格使用。如下：\\n\\n- 无序列表 1\\n- 无序列表 2\\n- 无序列表 3\\n\\n如果要控制列表的层级，则需要在符号`-`前使用空格。如下：\\n\\n- 无序列表 1\\n- 无序列表 2\\n  - 无序列表 2.1\\n  - 无序列表 2.2\\n\\n**由于微信原因，最多支持到二级列表**。\\n\\n### 3.3 有序列表\\n\\n有序列表的使用，在数字及符号`.`后加空格后输入内容，如下：\\n\\n1. 有序列表 1\\n2. 有序列表 2\\n3. 有序列表 3\\n\\n### 3.4 粗体和斜体\\n\\n粗体的使用是在需要加粗的文字前后各加两个`*`。\\n\\n而斜体的使用则是在需要斜体的文字前后各加一个`*`。\\n\\n如果要使用粗体和斜体，那么就是在需要操作的文字前后加三个`*`。如下：\\n\\n**这个是粗体**\\n\\n_这个是斜体_\\n\\n**_这个是粗体加斜体_**\\n\\n### 3.5 链接\\n\\n微信公众号仅支持公众号文章链接，即域名为`https://mp.weixin.qq.com/`的合法链接。使用方法如下所示：\\n\\n对于该论述，欢迎读者查阅之前发过的文章，[你是《未来世界的幸存者》么？](https://mp.weixin.qq.com/s/s5IhxV2ooX3JN_X416nidA)\\n\\n### 3.6 引用\\n\\n引用的格式是在符号 `>` 后面书写文字，文字的内容可以包含标题、链接、图片、粗体和斜体等。\\n\\n一级引用如下：\\n\\n> ### 一级引用示例\\n>\\n> 读一本好书，就是在和高尚的人谈话。 **——歌德**\\n>\\n> [Markdown Nice最全功能介绍](https://mp.weixin.qq.com/s/lM808MxUu6tp8zU8SBu3sg)\\n>\\n> ![这里写图片描述](https://files.mdnice.com/pic/cd3ca20c-896f-4cfc-9bdd-c4c58e69ba26.jpg)\\n\\n当使用多个 `>` 符号时，就会变成多级引用\\n\\n二级引用如下：\\n\\n>> ### 二级引用示例\\n>\\n>> 读一本好书，就是在和高尚的人谈话。 **——歌德**\\n>\\n>> [Markdown Nice最全功能介绍](https://mp.weixin.qq.com/s/lM808MxUu6tp8zU8SBu3sg)\\n>\\n>> ![这里写图片描述](https://files.mdnice.com/pic/cd3ca20c-896f-4cfc-9bdd-c4c58e69ba26.jpg)\\n\\n三级引用如下：\\n\\n>>> ### 三级引用示例\\n>\\n>>> 读一本好书，就是在和高尚的人谈话。 **——歌德**\\n>\\n>>> [Markdown Nice最全功能介绍](https://mp.weixin.qq.com/s/lM808MxUu6tp8zU8SBu3sg)\\n>\\n>>> ![这里写图片描述](https://files.mdnice.com/pic/cd3ca20c-896f-4cfc-9bdd-c4c58e69ba26.jpg)\\n\\n### 3.7 分割线\\n\\n可以在一行中用三个以上的减号来建立一个分隔线，同时需要在分隔线的上面空一行。如下：\\n\\n---\\n\\n### 3.8 删除线\\n\\n删除线的使用，在需要删除的文字前后各使用两个`~`，如下：\\n\\n~~这是要被删除的内容。~~\\n\\n### 3.9 表格\\n\\n可以使用冒号来定义表格的对齐方式，如下：\\n\\n| 姓名       | 年龄 |         工作 |\\n| :--------- | :--: | -----------: |\\n| 小可爱     |  18  |     吃可爱多 |\\n| 小小勇敢   |  20  |   爬棵勇敢树 |\\n| 小小小机智 |  22  | 看一本机智书 |\\n\\n宽度过长的表格可以滚动，可在自定义主题中调节宽度：\\n\\n| 姓名       | 年龄 |         工作 |      邮箱       |    手机     |\\n| :--------- | :--: | -----------: | :-------------: | :---------: |\\n| 小可爱     |  18  |     吃可爱多 | lovely@test.com | 18812345678 |\\n| 小小勇敢   |  20  |   爬棵勇敢树 | brave@test.com  | 17712345678 |\\n| 小小小机智 |  22  | 看一本机智书 | smart@test.com  | 16612345678 |\\n\\n### 3.10 图片\\n\\n插入图片，如果是行内图片则无图例，否则有图例，格式如下：\\n\\n![这里写图片描述](https://files.mdnice.com/pic/cd3ca20c-896f-4cfc-9bdd-c4c58e69ba26.jpg)\\n\\n可以通过在图片尾部添加宽度和高度控制图片大小，用法如下：\\n\\n![同时设置宽度和高度](https://files.mdnice.com/logo.png =150x150)\\n\\n![只设置宽度，推荐使用百分比](https://files.mdnice.com/logo.png =40%x)\\n\\n该语法比较特殊，其他 Markdown 编辑器不完全通用。\\n\\n支持 jpg、png、gif、svg 等图片格式，**其中 svg 文件仅可在微信公众平台中使用**，svg 文件示例如下：\\n\\n![](https://files.mdnice.com/i-am-svg.svg)\\n\\n- 支持图片**拖拽和截图粘贴**到编辑器中上传，上传时使用当前选择的图床。\\n- 可使用**格式->图片**上传本地图片，网站目前支持「图壳」图床，失败率低，但是只可保存一天用于排版\\n\\n**注：仅支持 https 的图片，图片粘贴到微信、知乎或掘金时会自动上传其服务器，不必担心使用上述图床会导致图片丢失**。\\n\\n图片还可以和链接嵌套使用，能够实现推荐卡片的效果，用法如下：\\n\\n[![Markdown Nice 最全功能介绍](https://files.mdnice.com/dance.gif)](https://mp.weixin.qq.com/s/lM808MxUu6tp8zU8SBu3sg)\\n\\n## 4. 特殊语法\\n\\n### 4.1 脚注\\n\\n> 支持平台：微信公众号、知乎。\\n\\n脚注与链接的区别如下所示：\\n\\n```markdown\\n链接：[文字](链接)\\n脚注：[文字](脚注解释 \\\"脚注名字\\\")\\n```\\n\\n有人认为在[大前端时代](https://en.wikipedia.org/wiki/Front-end_web_development \\\"Front-end web development\\\")的背景下，移动端开发（Android、IOS）将逐步退出历史舞台。\\n\\n[全栈工程师](是指掌握多种技能，并能利用多种技能独立完成产品的人。 \\\"什么是全栈工程师\\\")在业务开发流程中起到了至关重要的作用。\\n\\n脚注内容请拉到最下面观看。\\n\\n### 4.2 代码块\\n\\n> 支持平台：微信公众号、知乎。\\n\\n如果在一个行内需要引用代码，只要用反引号引起来就好，如下：\\n\\nUse the `printf()` function.\\n\\n在需要高亮的代码块的前一行及后一行使用三个反引号，同时**第一行反引号后面表示代码块所使用的语言**，如下：\\n\\n```java\\n// FileName: HelloWorld.java\\npublic class HelloWorld {\\n  // Java 入口程序，程序从此入口\\n  public static void main(String[] args) {\\n    System.out.println(\\\"Hello,World!\\\"); // 向控制台打印一条语句\\n  }\\n}\\n```\\n\\n支持以下语言种类：\\n\\n```\\nbash\\nclojure，cpp，cs，css\\ndart，dockerfile, diff\\nerlang\\ngo，gradle，groovy\\nhaskell\\njava，javascript，json，julia\\nkotlin\\nlisp，lua\\nmakefile，markdown，matlab\\nobjectivec\\nperl，php，python\\nr，ruby，rust\\nscala，shell，sql，swift\\ntex，typescript\\nverilog，vhdl\\nxml\\nyaml\\n```\\n\\n如果想要更换代码主题，可在上方挑选，不支持代码主题自定义。\\n\\n其中**微信代码主题与微信官方一致**，有以下注意事项：\\n\\n- 带行号且不换行，代码大小与官方一致\\n- 需要在代码块处标志语言，否则无法高亮\\n- 粘贴到公众号后，用鼠标点代码块内外一次，完成高亮\\n\\ndiff 不能同时和其他语言的高亮同时显示，且需要调整代码主题为微信代码主题以外的代码主题才能看到 diff 效果，使用效果如下:\\n\\n```diff\\n+ 新增项\\n- 删除项\\n```\\n\\n**其他主题不带行号，可自定义是否换行，代码大小与当前编辑器一致**\\n\\n### 4.3 数学公式\\n\\n> 支持平台：微信公众号、知乎。\\n\\n行内公式使用方法，比如这个化学公式：$\\\\ce{Hg^2+ ->[I-] HgI2 ->[I-] [Hg^{II}I4]^2-}$\\n\\n块公式使用方法如下：\\n\\n$$H(D_2) = -\\\\left(\\\\frac{2}{4}\\\\log_2 \\\\frac{2}{4} + \\\\frac{2}{4}\\\\log_2 \\\\frac{2}{4}\\\\right) = 1$$\\n\\n矩阵：\\n\\n$$\\n  \\\\begin{pmatrix}\\n  1 & a_1 & a_1^2 & \\\\cdots & a_1^n \\\\\\\\\\n  1 & a_2 & a_2^2 & \\\\cdots & a_2^n \\\\\\\\\\n  \\\\vdots & \\\\vdots & \\\\vdots & \\\\ddots & \\\\vdots \\\\\\\\\\n  1 & a_m & a_m^2 & \\\\cdots & a_m^n \\\\\\\\\\n  \\\\end{pmatrix}\\n$$\\n\\n公式由于微信不支持，目前的解决方案是转成 svg 放到微信中，无需调整，矢量不失真。\\n\\n目前测试如果公式量过大，在 Chrome 下会存在粘贴后无响应，但是在 Firefox 中始终能够成功。\\n\\n### 4.4 TOC\\n\\n> 支持平台：微信公众号、知乎。\\n\\nTOC 全称为 Table of Content，列出全部标题。由于示例标题过多，需要使用将下方代码段去除即可。\\n\\n```\\n[TOC]\\n```\\n\\n由于微信只支持到二级列表，本工具仅支持二级标题和三级标题的显示。\\n\\n### 4.5 注音符号\\n\\n> 支持平台：微信公众号。\\n\\n支持注音符号，用法如下：\\n\\nMarkdown Nice 这么好用，简直是{喜大普奔|hē hē hē hē}呀！\\n\\n### 4.6 横屏滑动幻灯片\\n\\n> 支持平台：微信公众号。\\n\\n通过`<![](url),![](url)>`这种语法设置横屏滑动滑动片，具体用法如下：\\n\\n<![蓝1](https://files.mdnice.com/blue.jpg),![绿2](https://files.mdnice.com/green.jpg),![红3](https://files.mdnice.com/red.jpg)>\\n\\n### 4.7 容器块\\n\\n> 支持平台：微信公众号。\\n\\n通过`::: block-1`开头，`:::`结尾，来设置容器块，容器块内可以使用任意 markdown 语法，容器块内显示样式可自定义，不会被外部干扰\\n\\n目前仅支持三种容器块，`block-1`、`block-2`和`block-3`\\n\\n::: block-1\\n\\n### 容器块 1 示例\\n\\n> 读一本好书，就是在和高尚的人谈话。 **——歌德**\\n> :::\\n\\n::: block-2\\n\\n### 容器块 2 示例\\n\\n> 读一本好书，就是在和高尚的人谈话。 **——歌德**\\n> :::\\n\\n::: block-3\\n\\n### 容器块 3 示例\\n\\n> 读一本好书，就是在和高尚的人谈话。 **——歌德**\\n> :::\\n\\n### 4.8 分列\\n\\n> 支持平台：微信公众号。\\n\\n对于需要 2 列展示的内容，可以通过分列语法实现，可以设置左右比例，不设置时默认各为50%，示例如下：\\n\\n:::: column\\n::: column-left\\n\\n**左边的内容**\\n\\n![左边的图片](https://files.mdnice.com/blue.jpg)\\n\\n:::\\n::: column-right\\n\\n**右边的内容**\\n\\n![右边的图片](https://files.mdnice.com/green.jpg)\\n\\n:::\\n::::\\n\\n设置百分比示例如下：\\n\\n:::: column\\n::: column-left 30%\\n\\n**左边的内容**\\n\\n![左边的图片](https://files.mdnice.com/blue.jpg)\\n\\n:::\\n::: column-right 70%\\n\\n**右边的内容**\\n\\n![右边的图片](https://files.mdnice.com/green.jpg)\\n\\n:::\\n::::\\n\\n## 5 其他语法\\n\\n### 5.1 HTML\\n\\n支持原生 HTML 语法，请写内联样式，如下：\\n\\n<span style=\\\"display:block;text-align:right;color:orangered;\\\">橙色居右</span>\\n<span style=\\\"display:block;text-align:center;color:orangered;\\\">橙色居中</span>\\n\\n### 5.2 UML\\n\\n不支持，推荐使用开源工具`https://draw.io/`制作后再导入图片\\n\\n### 5.3 更多文档\\n\\n更多文档请参考 [mdnice 产品主页](https://product.mdnice.com/articles/ \\\"更多文档\\\")\",\"articleCover\":\"\",\"articleTitle\":\"微信公众号写文章工具墨滴\",\"articleType\":1,\"categoryName\":\"博客相关\",\"isRecommend\":0,\"isTop\":0,\"status\":1,\"tagNameList\":[\"博客相关\"]}]','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',35,'2023-06-07 17:05:28');
INSERT INTO `t_operation_log` VALUES (1199,'文章模块','添加','/admin/article/add','com.ican.controller.ArticleController.addArticle','添加文章','[{\"articleContent\":\"# docker记录\\n\\n## 安装\\n\\n镜像  容器  仓库\\n略\\n\\n## 常用命令\\n\\ndocker rm container-id 删除指定 id 的容器\\n\\ndocker stop/start container-id 停止/启动指定 id 的容器\\n\\ndocker rmi image-id 删除指定 id 的镜像\\n\\ndocker volume ls 查看 volume 列表\\n\\ndocker network ls 查看网络列表\\n\\n镜像相关：\\n\\n导出镜像：docker iamge save centos:7.2.1511 > centos-7.2.1511.tgz\\n\\n导入镜像： docker image load -i centos-7.2.1511.tgz\\n\\n查看镜像详细信息：docker image inspect 镜像-ID\\n\\ndocker images 查看镜像列表\\n\\ndocker search XX 默认在本地，没有的话去docker hub上搜索\\n\\n容器相关：\\ndocker ps 查看当前运行中的容器(-a查看所有容器记录，包括死了的)\\n用镜像启动一个容器：docker run -d -p 80:80 nginx (-d表示后台运行，-p表示端口映射)\\n查看容器信息：docker container inspect 容器ID\\n进入容器空间1：docker run -it centos bash  （从镜像到容器）\\n进入容器空间2：docker exec -it 容器ID bash （从终端进入到一个活着的容器，比如后台容器）\\n\\n\\n容器端口映射：\\n\\n| 命令                              | 解释                              |\\n| --------------------------------- | --------------------------------- |\\n| -**p hostPort:containerPort**     | 端口映射-p 8080:80                |\\n| **-p ip:hostPort:containerPort**  | 配置监听地址-p 10.0.0.100:8080:80 |\\n| **p ip::containerPort**           | 随机分配端口 -p 10.0.0.100：：80  |\\n| **-p hostPort:containerPort:udp** | 指定协议 -p 8080:80:tcp           |\\n| **-p 81:80 -p 443:443**           | 指定多个                          |\\n\\n\\n\\n\\n## 写自己的镜像 Dockerfile\\n\\n```Dockerfile\\nFROM node:11\\nMAINTAINER easydoc.net\\n\\n# 复制代码\\nADD . /app\\n\\n# 设置容器启动后的默认运行目录\\nWORKDIR /app\\n\\n# 运行命令，安装依赖\\n# RUN 命令可以有多个，但是可以用 && 连接多个命令来减少层级。\\n# 例如 RUN npm install && cd /app && mkdir logs\\nRUN npm install --registry=https://registry.npm.taobao.org\\n\\n# CMD 指令只能一个，是容器启动后执行的命令，算是程序的入口。\\n# 如果还需要运行其他命令可以用 && 连接，也可以写成一个shell脚本去执行。\\n# 例如 CMD cd /app && ./start.sh\\nCMD node app.js\\n\\n```\\n\\n说明：\\nFROM 这个镜像的妈妈是谁？（指定基础镜像）\\nMAINTAINER告诉别人，谁负责养他？（指定维护者信息，可以没有）\\nRUN 你想让他干啥（在命令前加上RUN即可）\\nADD 给他一点创业资金（copy文件，会自动解压）\\nWORKDIR 我是cd，今天刚化了妆（设置当前工作目录）\\nVILUME 给他一个存放行李的地方（设置卷，挂载主机目录）\\nEXPOSE 他要打开的门是什么（指定对外的端口）\\nCMD 奔跑吧，兄弟 （指定容器启动后要干的事情）\\n**Docker的其他命令**：\\n\\n> CPOY 复制文件\\n>\\n> ENV 环境变量\\n>\\n> ENTRYPOINT 容器启动后执行的命令\\n\\n### Build为镜像（安装包）和运行\\n\\n编译 `docker build -t test:v1 .`\\n\\n> -t 设置镜像名字和版本号\\n\\n运行`docker run -p 8080:8080 --name test-hello test:v1`\\n\\n> -p 映射容器内端口到宿主机\\n>\\n> --name 容器名字\\n>\\n> -d 后台运行\\n\\n## 目录挂载\\n\\n现存问题：\\n\\n+ 使用 Docker 运行后，我们改了项目代码不会立刻生效，需要重新build和run，很是麻烦。\\n+ 容器里面产生的数据，例如 log 文件，数据库备份文件，容器删除后就丢失了。\\n\\n**目录挂载**以解决上述问题\\n\\n几种挂载方式：\\n\\n+ bind mount 直接把宿主机目录映射到容器内，适合挂代码目录和配置文件。可挂到多个容器上\\n+ volume 由容器创建和管理，创建在宿主机，所以删除容器不会丢失，官方推荐，更高效，Linux 文件系统，适合存储数据库数据。可挂到多个容器上\\n+ tmpfs mount 适合存储临时文件，存宿主机内存中。不可多容器共享。\\n\\n### 挂载演示\\n\\n`bind mount` 方式用绝对路径 -v D:/code:/app\\n\\n`volume` 方式，只需要一个名字 -v db-data:/app\\n\\n\\n## 2023/04/29 学习容器技术\\n\\n一种环境隔离的虚拟化技术，相比于传统的虚拟化技术，它拥有利用系统资源更高效、启动时间更快、持续交付和部署等特点。\\n\\n\\n\\n## 2023/06/06 使用\\n\\n在配置和使用[ttkican_Blog-master博客](https://github.com/ttkican/Blog)时的一些命令记录\\n\\n### 1、docker 与docker-compose的安装\\n\\n### 2、下载镜像\\n\\n```dockerfile\\ndocker pull 镜像名:属性\\ndocker pull canal/canal-server:latest\\n```\\n\\n### 3、运行镜像\\n\\n```dockerfile\\ndocker run --name canal -d canal/canal-server:latest\\n```\\n\\n注意：镜像只有一个，下载的就是镜像。但是可以用该镜像运行若干个不同的容器\\n\\n### 4、docker容器的操作：\\n\\n```bash\\n# 1) 查看正在运行的容器\\ndocker ps \\n# 1.2) 查看已经下载的镜像\\ndocker images\\n# 2）查看所有容器\\ndocker ps -a\\n# 3) 停止指定容器\\ndocker stop 容器名或容器ID\\n# 4）启动容器\\ndocker start 容器名和容器ID\\n# 5）进入容器终端，以mysql容器举例\\ndocker exec -it mysql bash\\n# 上述命令中 -it 表示以交互式的方式， bash 表示以bash终端的方式来交互\\n# 6）容器与本地Linux之间的文件拷贝\\ndocker cp /home/ubuntu/xxx.sql mysql:/\\ndocker cp mysql:/xx.sql /home/ubuntu/\\n# 7) 容器的删除和镜像的删除\\ndocker rm 容器名或容器ID\\ndocker rmi 镜像名或镜像ID\\n# 8) 使用docker-compose和对应的docker-compose.yml来启动docker容器\\ndocker-compose up -d --build  # 在有docker-compose.yml的同级目录下运行哦\\n# 9) 查看docker网络\\ndocker network ls\\n# 查看上述命令的输出，例如我在docker-compose.yml中设置了网络名为：blog-net，然后就能在docker network ls下看到有个NAME为docker_blog-net的网络，然后其NETWORK_ID为d32231f3430c，在然后使用ifconfig命令查看docker虚拟网卡(是类似于br-xxx这种，这里是br-d32231f3430c，而不是下面的veth8fad9XX等)，就知道了该docker网络下的IP为172.20.0.1，后面其他同docker network下的容器想要和mysql容器和redis容器通信的话就填172.20.0.1。注意：docker容器下的127.0.0.1是容器内部自身的回环地址，其他容器肯定访问不到。\\n```\\n\\ndocker-compose.yml文件示例：\\n\\n```dockerfile\\nversion: \\\"3\\\"\\nservices:\\n  blog-service:\\n    build: .\\n    image: blog-springboot:latest\\n    container_name: blog-springboot\\n    restart: always\\n    depends_on:\\n      - mysql\\n      - redis\\n      - rabbitmq\\n    volumes:\\n      - \\\"/usr/local/upload:/usr/local/upload\\\"\\n    ports:\\n      - \\\"8080:8080\\\"\\n    networks:\\n      - blog-net\\n  mysql:\\n    image: mysql:${MYSQL_VERSION}\\n    container_name: mysql\\n    restart: always\\n    environment:\\n      MYSQL_ROOT_PASSWORD: ${MYSQL_ROOT_PASSWORD}\\n      TZ: Asia/Shanghai\\n    ports:\\n      - \\\"3306:3306\\\"\\n    networks:\\n      - blog-net\\n  redis:\\n    image: redis:${REDIS_VERSION}\\n    container_name: redis\\n    restart: always\\n    command: --requirepass \\\"${REDIS_PASSWORD}\\\"\\n    ports:\\n      - \\\"6379:6379\\\"\\n    networks:\\n      - blog-net\\n  rabbitmq:\\n    image: rabbitmq:${RABBITMQ_VERSION}\\n    container_name: rabbitmq\\n    restart: always\\n    environment:\\n      RABBITMQ_DEFAULT_USER: ${RABBITMQ_USER}\\n      RABBITMQ_DEFAULT_PASS: ${RABBITMQ_PASSWORD}\\n    ports:\\n      - \\\"5672:5672\\\"\\n      - \\\"15672:15672\\\"\\n    networks:\\n      - blog-net\\n  elasticsearch:\\n    image: elasticsearch:${ELASTICSEARCH_VERSION}\\n    container_name: elasticsearch\\n    restart: always\\n    environment:\\n      discovery.type: \\\"single-node\\\"\\n      ES_JAVA_OPTS: \\\"-Xms64m -Xmx128m\\\"\\n      http.cors.enabled: \\\"true\\\"\\n      http.cors.allow-origin: \\\"*\\\"\\n      xpack.security.enabled: \\\"true\\\"\\n      ELASTIC_PASSWORD: \\\"${ELASTICSEARCH_PASSWORD}\\\"\\n    ports:\\n      - \\\"9200:9200\\\"\\n      - \\\"9300:9300\\\"\\n    networks:\\n      - es-net\\n      - blog-net\\n  kibana:\\n    image: kibana:${ELASTICSEARCH_VERSION}\\n    container_name: kibana\\n    volumes:\\n      - \\\"/usr/local/kibana/kibana.yml:/usr/share/kibana/config/kibana.yml\\\"\\n    depends_on:\\n      - elasticsearch\\n    ports:\\n      - \\\"5601:5601\\\"\\n    networks:\\n      - es-net\\n      - blog-net\\n  canal_server:\\n    image: canal/canal-server:${CANAL_VERSION}\\n    container_name: canal\\n    volumes:\\n      - \\\"/usr/local/canal/instance.properties:/home/admin/canal-server/conf/example/instance.properties\\\"\\n      - \\\"/usr/local/canal/canal.properties:/home/admin/canal-server/conf/canal.properties\\\"\\n    ports:\\n      - \\\"11111:11111\\\"\\n    networks:\\n      - blog-net\\n  nginx:\\n    image: nginx:${NGINX_VERSION}\\n    container_name: nginx\\n    restart: always\\n    volumes:\\n      - \\\"/usr/local/nginx/nginx.conf:/etc/nginx/nginx.conf\\\"\\n      - \\\"/etc/ssl/certs:/etc/ssl/certs\\\"\\n      - \\\"/usr/local/vue:/usr/local/vue\\\"\\n      - \\\"/usr/local/upload:/usr/local/upload\\\"\\n    privileged: true\\n    ports:\\n      - \\\"443:443\\\"\\n      - \\\"80:80\\\"\\n    networks:\\n      - blog-net\\nnetworks:\\n  es-net:\\n    driver: bridge\\n  blog-net:\\n    driver: bridge\\n```\\n\\n对应的启动脚本：\\n\\n```bash\\n#!/bin/bash\\n# 文件名：blog-start.sh\\n# 打包之后上传的jar包路径\\nSOURCE_PATH=/usr/local/docker\\n# docker的镜像和容器名称都命名为这个\\nSERVER_NAME=blog-springboot\\nTAG=latest\\n# 容器id\\nCID=$(docker ps | grep \\\"$SERVER_NAME\\\" | awk \'{print $1}\')\\n# 镜像id\\nIID=$(docker images | grep \\\"$SERVER_NAME\\\" | awk \'{print $3}\')\\nif [ -n \\\"$CID\\\" ]; then\\n  echo \\\"存在容器$SERVER_NAME, CID-$CID\\\"\\n  docker stop $CID\\n  docker rm $CID\\nfi\\n# 构建docker镜像\\nif [ -n \\\"$IID\\\" ]; then\\n  echo \\\"存在$SERVER_NAME:$TAG镜像，IID=$IID\\\"\\n  docker rmi $IID\\nfi\\n# 重新构建镜像并运行\\ndocker-compose up -d --build\\n```\\n\\n\\n\\n\\n\\n\\n\\n\",\"articleCover\":\"\",\"articleTitle\":\"docker使用记录\",\"articleType\":1,\"categoryName\":\"Linux运维\",\"isRecommend\":0,\"isTop\":0,\"status\":1,\"tagNameList\":[\"Linux运维\"]}]','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',71,'2023-06-07 17:06:23');
INSERT INTO `t_operation_log` VALUES (1200,'文章模块','添加','/admin/article/add','com.ican.controller.ArticleController.addArticle','添加文章','[{\"articleContent\":\"# GDB调试手册\\n\\n前提：gcc在编译时需要加上-g参数\\n\\n总结：\\n\\n> 说明：gdb -c /tmp/core-tuxclocker-19395-1584497577 xx(可执行程序名)\\n>\\n> <font color=\'red\'>list</font>命令(简写为l)查看源码\\n>\\n> <font color=\'red\'>layout src</font>显示源代码窗口 （ctrl + x + a 以关闭源代码界面）\\n>\\n> 运行程序命令<font color=\'red\'>run</font>(简写为r)\\n>\\n> 设置断点命令<font color=\'red\'>break</font>(简写为b) +行号  或b 函数名\\n>\\n> 查看断点信息：<font color=\'red\'> info b </font>\\n>\\n> 清除断点<font color=\'red\'>clear</font>(简写为c) +行号\\n>\\n> 单步调试：继续执行到下一个断点<font color=\'red\'>continue</font>(简写为c)；单步执行，跳过子函数<font color=\'red\'>next</font>(简写为n)；单步执行，进入子函数<font color=\'red\'>strp</font>(简写为s)\\n>\\n> 查看变量<font color=\'red\'>print 变量名</font>\\n>\\n> 运行至函数结束<font color=\'red\'>finish</font>\\n>\\n> 退出<font color=\'red\'>quit</font>\\n\\n```c\\n/*”核心文件已转储“的错误原因解析：\\n\\n原因一：内存访问越界\\n\\n  a) 使用错误的下标，导致数组访问越界；\\n\\n原因二：多线程程序使用了线程不安全的函数\\n\\n原因三：多线程读写的数据没有加锁保护；\\n\\n原因四：非法指针\\n\\n  a) 使用空指针，\\n\\n  b) 随意使用指针转换；\\n\\n原因五：堆栈溢出*/\\n```\\n\\n```c\\nlayout：用于分割窗口，可以一边查看代码，一边测试。主要有以下几种用法：\\nlayout src：显示源代码窗口\\nlayout asm：显示汇编窗口\\nlayout regs：显示源代码/汇编和寄存器窗口\\nlayout split：显示源代码和汇编窗口\\nlayout next：显示下一个layout\\nlayout prev：显示上一个layout\\nCtrl + L：刷新窗口\\nCtrl + x，再按1：单窗口模式，显示一个窗口\\nCtrl + x，再按2：双窗口模式，显示两个窗口\\n\\nCtrl + x，再按a：回到传统模式，即退出layout，回到执行layout之前的调试窗口。\\n\\n```\\n\\n##  一、基础入门\\n\\n```sh\\ngdb hello  #hello为程序名\\n```\\n\\n1.1 参数-q，可以再启动时不打印gdb的默认参数\\n\\n2 参看源码\\n\\n命令list (简写l)可以查看源码，默认显示10行，通过回车键不断查看剩余代码\\n\\n3 运行程序\\n\\n命令run  (简写r)用于运行代码，在程序结束或者遇到断点处停下\\n\\n4 设置断点\\n\\n运行break (简写b)命令可以在指定行设置一个断点，断点调试是程序调试里面使用频率最高的技巧\\n\\n使用方法：“b”命令后面加上相应的行号\\n\\n设置好断点后，执行一下命令查看断点信息：info b\\n![](https://s3.bmp.ovh/imgs/2022/11/12/9d9d4ba1565c9ad2.png)\\n\\n5 单步调试\\n\\n+ continue (简写c)：继续执行，到下一个断点处（或运行结束）。\\n+ next (简写n)：单步执行，跳过子函数\\n+ strp (简写s)：单步执行，进入子函数\\n\\n6 查看变量\\n\\n使用print (简写p)指令来查看变量的值，用法为\\\"print 变量名\\\"。\\n\\n7 清除断点\\n\\nclear + 行号以清除断点。\\n\\n8 运行至函数结束\\n\\n使用finish命令来运行程序至函数结束\\n\\n9 显示源代码窗口\\n\\n程序运行后，使用命令“layout src”可以显示源代码窗口，当前执行代码会高亮\\n\\n10 退出gdb\\n\\n执行quit (简写q)会退出gdb调试\\n\\n\\n11 附加说明\\n\\ncgdb是gdb的终端界面增强版，它有上下两栏窗口，上栏的窗口支持vi编辑器的语法， 可以方便的使用它来进行字符串定位等功能。在gdb下使用“layout src”时，界面往往容易花屏， 而cgbd更加的稳定可靠。还有一点，cgdb会给不同符号的不同类型辅以不同的颜色。\\n\\n使用`sudo apt install cgdb`来安装该软件。\\n\\n## 二、 gdb调试之函数调用栈——backtrace\\n\\n在写代码的时候，我们会封装很多函数，而这些函数之中又会调用其他的函数，当程序每次调用函数的时候，就会跳转到函数的地方去执行，那么这期间就有很多信息产生了，比如：调用函数的地方，函数的参数，被调用函数的变量等，这些信息其实是存储在栈中的，其实更确切地说，这些信息是存储在函数调用信息帧中的，每个函数及其变量都被分配了一个帧（frame），这些函数信息帧就组成了函数调用栈。我们使用 gdb 调试工具就可以查看函数调用栈的内容信息，可以清晰地看到各个函数的调用顺序以及各函数的输入形参值，是分析程序的执行流程和输入依赖的重要手段。\\n\\ngdb提供了一些指令可以查看这些帧中的信息，当查询函数变量的信息时，gdb就是从这个被选中的帧内获取信息，但是查看被选中帧外的变量信息是非法的，当程序运行停止的时候，gdb会自动选择当前被调用的函数帧，并且打印简单帧信息。\\n\\n2、gdb中函数调用栈的指令\\n\\n+ 2.1 查看栈信息\\n\\n> <font color=\'red\'>bt</font>：bt是` backtrace` 指令的缩写，显示所有的函数调用栈的信息，栈中的每个函数都被分配了一个编号，最近被调用的函数在 0 号帧中（栈顶），并且每个帧占用一行。\\n>\\n> <font color=\'red\'>bt n</font>：显示函数调用栈从栈顶算起的n帧信息（n 表示一个正整数）。\\n>\\n> <font color=\'red\'>bt -n</font>：显示函数调用栈从栈底算起的n帧信息。\\n>\\n> <font color=\'red\'>bt full</font>：显示栈中所有信息如：函数参数，本地变量等。\\n>\\n> <font color=\'red\'>bt full n</font>：显示函数调用栈从栈顶算起的n帧的所有信息。\\n>\\n> <font color=\'red\'>bt full -n</font>：显示函数调用栈从栈底算起的n帧的所有信息。\\n\\n+ 2.2 查看帧信息\\n\\n上面的bt指令主要是查看栈的信息，而每一帧都会有详细的信息，这些函数调用信息帧包括：调用函数的地方，函数的参数等。如果想查看栈中某一帧的信息，首先要做的是切换当前栈。这时候需用用到 frame 指令（缩写形式为 f）。\\n\\n> <font color=\'red\'>f  n</font> ： 它的功能是切换到编号为 n 的栈帧（n 表示一个正整数），并显示相关信息。\\n\\n![](https://s3.bmp.ovh/imgs/2022/11/13/a89a6a826e86a4be.png)\\n\\n+ 2.3 up/down指令\\n\\n除了使用 frame 指令切换栈帧外，还可以使用 up 和 down 指令。\\n\\n> <font color=\'red\'>down n</font> ： 表示往栈顶方向下移 n 层（n 表示一个正整数，默认值为 1）。\\n>\\n> <font color=\'red\'>up  n</font> ： 表示往栈底方向上移 n 层。\\n\\n\\n+ 2.4 查看更详细的帧信息\\n\\ninfo 指令是一个很强大的指令，使用它可以查看各种变量的值，如果我们希望看到详细的函数调用信息帧的信息，如：函数地址、调用函数的地址、被调用函数的地址、当前函数由哪种编程语言编写、函数参数地址及形参值、局部变量的地址、当前桢中存储的寄存器等，可以使用以下指令：\\n\\n> <font color=\'red\'>info frame</font> ：指令的缩写形式为 `i f` ，查看函数调用帧的所有信息。\\n>\\n> <font color=\'red\'>info args</font> ：查看函数变量的值。(与print args功能是一样的)\\n>\\n> <font color=\'red\'>info locals</font> ：查看函数变量的值。\\n\\n![](https://s3.bmp.ovh/imgs/2022/11/13/7c7dafcff67e8f53.png)\\n\\n这里面有很多信息：\\n\\n> + 当前桢的地址：0x7fffffffe030。\\n>\\n> + ip的值：0x400b58，此处引申介绍一下rip是什么：它是指令地址寄存器，用来存储 CPU 即将要执行的指令地址。每次 CPU 执行完相应的汇编指令之后，rip 寄存器的值就会自行累加，rip 无法直接赋值。\\n>\\n> + 当前桢函数：test1 (backtrace.c:9)。\\n>\\n> + 调用者的rip值：saved rip = 0x400bbe。\\n>\\n> + 调用者的帧地址：0x7fffffffe060。\\n>\\n> + 源代码所用的程序的语言: source language c。\\n>\\n> + 当前桢的参数的地址及值：Arglist at 0x7fffffffe020, args: arg=1。\\n>\\n> + 当前帧中局部变量的地址：Locals at 0x7fffffffe020, Previous frame’s sp is 0x7fffffffe030。\\n>\\n> + 当前桢中存储的寄存器：rbp at 0x7fffffffe020, rip at 0x7fffffffe028。\\n\\n除此之外 info 指令还可以查看当前寄存器的值：\\n\\n> <font color=\'red\'>info registers</font>：查看寄存器的情况（除了浮点寄存器）。\\n>\\n> <font color=\'red\'>info all-registers</font>：查看所有寄存器的情况（包括浮点寄存器）。\\n\\n### 2.2 gdb调试递归函数\\n\\n本小节的主题是教大家用gdb去调试递归函数，因为一步步去调试太麻烦了，也没法打断点，因为打断点每次递归时都会停下来，实在是难以调试，那么强大如gdb调试工具，对这种递归函数的调试也是轻而易举的。\\n\\n我们用递归算法计算斐波拉契数列，这是在大学C语言课本中的非常有名的递归算法——计算斐波拉契数列，我们回顾一下是什么是斐波拉契数列：斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。\\n\\n代码示例：\\n\\n```c\\nint fibonacci(int n) {\\n if (n == 1 || n == 2) {\\n return 1;\\n }\\n return fibonacci(n - 1) + fibonacci(n - 2);\\n}\\nint main()\\n{\\n\\tint n = 10;\\n\\tint ret = 0;\\n\\tret = fibonacci(n);\\n\\tprintf(\\\"fibonacci(%d)=%d\\\\n\\\", n, ret);\\n\\treturn 0;\\n}\\n```\\n\\n变异后用gdb调试：比如我想让递归调用，n=5时停下来，则有：\\n\\n```c\\ngdb ./test\\n(gdb) b fibonacci if n==5\\n```\\n\\n## 三、跟踪系统调用——strace\\n\\n\\n\\n\\n## GDB调试多线程\",\"articleCover\":\"\",\"articleTitle\":\"GDB调试\",\"articleType\":1,\"categoryName\":\"编程语言基础\",\"isRecommend\":0,\"isTop\":0,\"status\":1,\"tagNameList\":[]}]','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',28,'2023-06-07 17:06:52');
INSERT INTO `t_operation_log` VALUES (1201,'文章模块','添加','/admin/article/add','com.ican.controller.ArticleController.addArticle','添加文章','[{\"articleContent\":\"# git提交命令\\n\\n[参考链接](https://blog.csdn.net/m0_46698504/article/details/129260726)\\n\\n\\n\\n## 1、设置用户名和邮箱\\n\\n```bash\\ngit config --global user.name \\\"HaoY\\\"\\ngit config --global user.email \\\"508506630@qq.com\\\"\\n# 查看git的配置\\ngit config --list\\n# 使用代理\\ngit clone https://github.com/twbs/bootstrap.git --config \\\"http.proxy=127.0.0.1:7890\\\"  \\n# 查看clash日志，有github相关字样\\n\\n#ubuntu系统设置git的全局代理\\n# 设置的是http的代理 fastgithub的端口是38457\\ngit config --global http.proxy \\\"http://127.0.0.1:7890\\\"     # 设置的是http的代理\\ngit config --global https.proxy \\\"http://127.0.0.1:7890\\\"    # 设置的是https的代理(clash和fastgithub不用设置这个)\\n# 清除代理\\ngit config --global --unset http.proxy\\n```\\n\\n## 2、在gitee上创建并初始化一个仓库\\n\\n在网站上手动进行\\n\\n## 3、将该仓库拉取到本地\\n\\n```git\\ngit clone https://xx.git\\n//此时该目录下会生成一个.git隐藏目录\\n//可以用vscode打开该目录，采用图形化界面来操作了\\n```\\n\\n## 4、将工程文件或目录放置到上述目录下，并上传\\n\\n使用此命令随时查看工作状态：\\n\\n`git status`\\n\\n1）添加文件到缓冲区\\n\\n`git add *  //或者git add 文件名/目录名`\\n\\n2）上传到git的本地版本库中，并做记录\\n\\n`git commit -m \\\"第一次提交\\\"`\\n\\n3）先做分支初始化，再上传到远程服务器中\\n\\n`git init`\\n\\n`git push origin`\\n\\n## 5、补充说明\\n\\n要么当前.git目录下的config文件文件如下：\\n\\n![](https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlHCHfRyOUR24-TBS/root/content)\\n\\n否则，.config文件中没有说明url的话，你可以这样(直接通过git push -f 命令指定仓库也是可以的)，下面是deploy.sh文件的部分内容：\\n\\n```bash\\ntimes=$(date \\\"+%Y-%m-%d__%H:%M:%S\\\")\\ngit init\\ngit add -A\\ngit commit -m $times\\ngit branch -M main\\ngit push -f git@github.com:XiaoYuer2022/XiaoYuer2022.github.io.git main\\n```\\n\\n## 6、git清空仓库\\n\\n```bash\\ngit status\\n# 创建一个新文件夹,或者手动删除本地所有文件在推送\\ngit add .\\ngit commit -m \\\"仓库已经清空\\\"\\n\\ngit push -f git@github.com:XiaoYuer2022/XiaoYuer2022.github.io.git main\\n\\n# 要么直接git push -f 或者下面两行\\n\\n#添加远程仓库(已添加可以跳过)\\ngit remote add origin git@github.com:username/repositoryname\\n#推送到远程仓库\\ngit push -u origin master\\n\\n# 强制推送\\ngit push --force origin main 或者 git push --force origin master\\n\\n# 从远端服务器拉取到本地\\ngit pull origin master\\n# 或者：\\n1）git fetch origin    # 下载最新代码，origin是远端仓库地址\\n2）git diff  HEAD origin/master # HEAD是本地分支，查看两者差异\\n3）git pull  # 合并\\n```\\n\\n手动删除文件的命令是：\\n\\n```bash\\ngit rm -r *\\n```\\n\\n恢复：\\n\\n```bash\\n# 把删除的文件恢复到最新版本 \\ngit checkout\\n```\\n\\n## 7、初始创建一个仓库后\\n\\n```git\\ngit init\\ngit add README.md\\ngit commit -m \\\"first commit\\\"\\ngit branch -M main\\ngit remote add origin git@github.com:XiaoYuer2022/chat.git\\ngit push -u origin main\\n```\\n\\n特别说明：除第一次上传外，后续都不需要`git remote add origin git@github.com:XiaoYuer2022/chat.git`命令了。\\n\\n## 8、使用代理\\n\\n```bash\\n# 使用代理\\ngit clone https://github.com/twbs/bootstrap.git --config \\\"http.proxy=127.0.0.1:7890\\\"  \\n# 查看clash日志，有github相关字样\\n```\\n\\n## 9、添加远端仓库\\n\\n```git\\ngit remote add origin git@github.com:XiaoYuer2022/TinyWebServer2023.git\\n## 如果重复的话,1)更改远端仓库：\\ngit remote set-url origin git@github.com:XiaoYuer2022/TinyWebServer2023.git\\n\\n```\\n\\n## 10、从远端github仓库更新代码\\n\\n```git\\ngit pull\\n```\",\"articleCover\":\"\",\"articleTitle\":\" git提交命令\",\"articleType\":1,\"categoryName\":\"Linux运维\",\"isRecommend\":0,\"isTop\":0,\"status\":1,\"tagNameList\":[\"git\"]}]','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',108,'2023-06-07 17:07:21');
INSERT INTO `t_operation_log` VALUES (1202,'文章模块','添加','/admin/article/add','com.ican.controller.ArticleController.addArticle','添加文章','[{\"articleContent\":\"---\\ntitle: 关于cron和anacron的说明\\ndate: 2023-4-12\\ntags:\\n - cron和anacron\\ncategories:\\n - 未分类\\n\\n---\\n\\n用户自己建立的cronttab文件在这个目录下：/var/spool/cron (要创建一份个人 crontab 文件，只要输入： crontab -e)\\n\\n比较这个目录/var/spool/anacron/下的cron.daily cron.weekly cron.monthly与当前系统的时间，来判断定时任务是否需要执行。\\n\\n1、关于run-parts命令\\n\\n对于ubuntu来说，run-parts是个二进制文件，位于/bin/run-parts;对于centos来说，他是一个脚本。它的后面接一个目录名，功能就是运行这个\\n\\n目录下的第一层目录中的所有脚本文件。 就是遍历目标文件夹，执行第一层目录下的可执行权限的文件。\\n\\n参数 --test : run-parts --test /目录名 //打印会被run-parts运行的脚本的名称，但不会实际的运行这些脚本。\\n\\n参数 --list : run-parts --list /目录名 //打印所有匹配的文件名，不局限于可执行，没有执行权限的文件也会打印，但不会实际的去执行。\\n\\n该选项不能与–test一起使用。\\n\\n参数 --report : run-parts --report /目录名 //类似于–verbose，但只打印会生成输出的脚本的名称。脚本的名称被打印到脚本首先产生输出的STDUT或STDRR中的任何一个\\n\\n其它参数，略\\n\\n2、关于test命令\\n\\n在脚本中常用test测试命令。其中在crontab中的test -x 文件名 是在测试该文件是否具有可执行权限。\\n\\n3、cron和anacron的说明 /etc/anacrontab 和 /etc/crontab\\n\\n我们用 cron.daily 工作来说明一下 /etc/anacrontab 的执行过程:\\n\\n读取 /var/spool/anacron/cron.daily 文件中 anacron 上一次执行的时间。\\n\\n和当前时间比较，如果两个时间的差值超过 1 天，就执行 cron.daily 工作。\\n\\n只能在 03：00-22：00 执行这个工作。\\n\\n执行工作时强制延迟时间为 5 分钟，再随机延迟 0～45 分钟。\\n\\n使用 nice 命令指定默认优先级，使用 run-parts 脚本执行 /etc/cron.daily 目录中所有的可执行文件。\\n\\n大家会发现，/etc/cron.{daily，weekly，monthly} 目录中的脚本在当前的 Linux 中是被 anacron 调用的，不再依靠 cron 服务。不过，anacron 不用设置多余的配置，我们只需要把需要定时执行的脚本放入 /etc/cron.{daily，weekly，monthly} 目录中，就会每天、每周或每月执行，而且也不再需要启动 anacron 服务了。如果需要进行修改，则只需修改 /etc/anacrontab 配置文件即可。\\n\\n// /etc/crontab\\n\\n11 17 \\\\* \\\\* \\\\* \\\\* root cd / && run-parts --report /etc/cron.hourly\\n\\n12 25 6 \\\\* \\\\* \\\\* root test -x /usr/sbin/anacron \\\\|\\\\| ( cd / && run-parts --report /etc/cron.daily )\\n\\n13 47 6 \\\\* \\\\* 7 root test -x /usr/sbin/anacron \\\\|\\\\| ( cd / && run-parts --report /etc/cron.weekly )\\n\\n14 52 6 1 \\\\* \\\\* root test -x /usr/sbin/anacron \\\\|\\\\| ( cd / && run-parts --report /etc/cron.monthly )\\n\\n// /etc/anacrontab\\n\\nperiod delay job-identifier command\\n\\n10 \\\\# These replace cron\'s entries\\n\\n11 1 5 cron.daily run-parts --report /etc/cron.daily \\\\#每天开机 5 分钟后就检查 /etc/cron.daily 目录内的文件是否被执行，如果今天没有被执行，那就执行\\n\\n12 7 10 cron.weekly run-parts --report /etc/cron.weekly \\\\#每隔 7 天开机后 25 分钟检查 /etc/cron.weekly 目录内的文件是否被执行，如果一周内没有被执行，就会执行\\n\\n13 @monthly 15 cron.monthly run-parts --report /etc/cron.monthly \\\\#每隔一个月开机后 45 分钟检查 /etc/cron.monthly 目录内的文件是否被执行，如果一个月内没有被执行，那就执行\\n\\n//注：把5/10/45全改为0,anacron或cron的定时任务就会按照你指定的准确时间运行，否则默认会有一定的延迟\\n\\n4、cron和anacron的比较\\n\\n下面是 cron 以及 anacron 的比较，帮助你理解何时用他们其中一个。\\n\\n| cron                           | anacron                                                      |\\n| ------------------------------ | ------------------------------------------------------------ |\\n| 它是守护进程                   | 它不是守护进程                                               |\\n| 适合服务器                     | 适合桌面/笔记本电脑                                          |\\n| 可以让你以分钟级运行计划任务   | 只能让你以天为基础来运行计划任务                             |\\n| 关机时不会执行计划任务         | 如果计划任务到期，机器是关机的，那么它会在机器下次开机后执行计划任务 |\\n| 普通用户和 root 用户都可以使用 | 只有 root 用户可以使用（使用特定的配置启动普通任务）         |\",\"articleCover\":\"\",\"articleTitle\":\"关于cron和anacron的说明\",\"articleType\":1,\"categoryName\":\"Linux运维\",\"isRecommend\":0,\"isTop\":0,\"status\":1,\"tagNameList\":[]}]','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',22,'2023-06-07 17:08:02');
INSERT INTO `t_operation_log` VALUES (1203,'文章模块','添加','/admin/article/add','com.ican.controller.ArticleController.addArticle','添加文章','[{\"articleContent\":\"# clash使用指南\\n\\n在Linux终端运行好clash代理后，还需要这样做：\\n\\n## 1、用git工具\\n\\n```bash\\ngit config --global user.name \\\"HaoY\\\"\\ngit config --global user.email \\\"508506630@qq.com\\\"\\n# 查看git的配置\\ngit config --list\\n# 使用代理\\ngit clone https://github.com/twbs/bootstrap.git --config \\\"http.proxy=127.0.0.1:7890\\\"  \\n# 查看clash日志，有github相关字样\\n\\n#ubuntu系统设置git的全局代理\\n# 设置的是http的代理 fastgithub的端口是38457\\ngit config --global http.proxy \\\"http://127.0.0.1:7890\\\"     # 设置的是http的代理\\ngit config --global https.proxy \\\"http://127.0.0.1:7890\\\"    # 设置的是https的代理(clash和fastgithub不用设置这个)\\n# 清除代理\\ngit config --global --unset http.proxy\\n```\\n\\n## 2、用npm\\n\\n```bash\\n# 使用代理\\nnpm config set proxy http://127.0.0.1:7890 \\n# 下载模块\\nnpm install pm2 -g \\n# 取消代理\\nnpm config delete proxy  #取消代理设置\\n```\\n\\n## 3、设置shell的环境变量：例如APT/curl/wget\\n\\n```bash\\n# 使用代理\\nexport http_proxy=\\\"127.0.0.1:7890\\\"\\n# 取消代理\\nexport http_proxy=\\\"\\\"\\n```\\n\\n## 4、SSH 通过代理连接服务器\\n\\n略\",\"articleCover\":\"\",\"articleTitle\":\"clash使用指南\",\"articleType\":1,\"categoryName\":\"Linux运维\",\"isRecommend\":0,\"isTop\":0,\"status\":1,\"tagNameList\":[]}]','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',23,'2023-06-07 17:08:20');
INSERT INTO `t_operation_log` VALUES (1204,'文章模块','添加','/admin/article/add','com.ican.controller.ArticleController.addArticle','添加文章','[{\"articleContent\":\"# 常用命令\\n\\n参考：[CSDN网页](https://blog.csdn.net/weixin_46085718/article/details/127727204)\\n\\n1、ubuntu检查电脑上是否安装了mysql:\\n`dpkg -l|grep mysql` 或`netstat -tap|grep mysql`或`systemctl status mysql.service`\\n\\n2、登录mysql (账号root，密码为1)\\n`mysql -u root -p` 回车后，输入密码\\n\\n3、查看数据库命令(分号结尾)\\n`show databases;`\\n\\n4、创建数据库，创建一个node的数据库\\n`CREATE DATABASE IF NOT EXISTS node DEFAULT CHARSET utf8 COLLATE utf8_general_ci;`\\n\\n5、退出数据库\\n`exit`\\n\\n6、数据库的初始化命令 （脱出mysql后使用）\\n`mysql_secure_installation`\\n\\n7、配置mysql的远程访问\\n\\n1) 打开文件`vim /etc/mysql/mysql.conf.d/mysqld.cnf`，然后注释掉`#bind-address  = 127.0.0.1`\\n\\n2) 在[mysqld]条目下方，添加： \\n\\n```\\n[mysqld]\\nskip-grant-tables\\n```\\n\\n3) 在windows上使用Navicat软件来远程管理数据库\\n\\n## 进阶命令\\n\\n通过mysql -h 或man mysql查询\\n资料参考：[csdn](https://dablelv.blog.csdn.net/article/details/52106044?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2-52106044-blog-125246185.pc_relevant_multi_platform_whitelistv3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2-52106044-blog-125246185.pc_relevant_multi_platform_whitelistv3)\\n\\n这个连接里面的内容比较多，可以多看看\\n\\n\\n## 创建新用户\\n\\n1、创建新用户，并允许远程访问：\\n\\n```bash\\nCREATE USER \'<username>\'@\'%\' IDENTIFIED BY \'<password>\';\\n```\\n\\n2、允许新用户访问所有数据库：\\n\\n```bash\\nGRANT ALL PRIVILEGES ON *.* TO \'<username>\'@\'%\';\\n```\\n\\n只允许新用户访问指定数据库：\\n\\n```bash\\nGRANT ALL PRIVILEGES ON 指定数据库名.* TO \'<username>\'@\'%\';\\n```\\n\\n3、刷新权限\\n\\n```bash\\nFLUSH PRIVILEGES;\\n```\",\"articleCover\":\"\",\"articleTitle\":\"MySql常用命令\",\"articleType\":1,\"categoryName\":\"Linux运维\",\"isRecommend\":0,\"isTop\":0,\"status\":1,\"tagNameList\":[\"MySql\"]}]','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',29,'2023-06-07 17:08:52');
INSERT INTO `t_operation_log` VALUES (1205,'文章模块','添加','/admin/article/add','com.ican.controller.ArticleController.addArticle','添加文章','[{\"articleContent\":\"# 终端美化记录\\n\\n## 一、ubuntu安装zsh、powerlevel10k\\n\\n参考[csdn的教程](https://blog.51cto.com/sddai/3030120)：\\n\\n[ohmyzsh的github](https://github.com/ohmyzsh/ohmyzsh)\\n\\n[powerlevel10k的github](https://github.com/romkatv/powerlevel10k)\\n\\npowerline这个不需要安装（powerlevel10k就是基于powerline的）：\\n\\n[powerline的github](https://github.com/powerline/powerline)\\n\\n1、安装zsh\\n\\n```bash\\nsudo apt-get install zsh\\n```\\n\\n2、安装oh-my-zsh\\n\\n```bash\\n# 或者去仓库手动下载，然后运行install.sh\\nsh -c \\\"$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\\\"\\n```\\n\\n3、安装自动跳转插件和语法高亮插件、语法历史记录插件\\n\\n说明：zsh插件的位置在`/root/.oh-my-zsh//plugins`目录下。\\n\\n```bash\\nsudo apt-get install autojump\\n# 配置教程：cat /usr/share/doc/autojump/README.Debian\\nvim .zshrc\\n#在最后一行加入，注意点后面是一个空格\\n. /usr/share/autojump/autojump.sh\\nsource ~/.zshrc\\n```\\n\\n语法高亮：\\n\\n```bash\\n> git clone https://github.com/zsh-users/zsh-syntax-highlighting.git\\n> echo \\\"source ${(q-)PWD}/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh\\\" >> ${ZDOTDIR:-$HOME}/.zshrc\\n> source ~/.zshrc\\n```\\n\\nzsh-autosuggestions语法历史记录插件：\\n\\n```bash\\n> git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions\\n> plugins=(zsh-autosuggestions)\\n```\\n\\n4、安装powerlevel10k命令行显示主题：\\n\\n```bash\\n# 1） 安装Meslo字体\\n## 1.1）下载字体\\nhttps://github.com/ryanoasis/nerd-fonts/tree/master/patched-fonts/Meslo/M/Regular\\n## 1.2）安装字体\\n# 将*.ttf字体文件放在/usr/share/fonts/custom目录下，该目录是自己新建的，然后\\ncd /usr/share/fonts/agave\\nsudo mkfontscale # 生成核心字体信息\\nsudo mkfontdir # 生成字体文件夹\\nsudo fc-cache -fv # 刷新系统字体缓存\\n# 2）安装powerlevel10k\\n## 2.1）下载\\ngit clone --depth=1 https://gitee.com/romkatv/powerlevel10k.git ${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/themes/powerlevel10k\\n## 2.2）安装\\nSet ZSH_THEME=\\\"powerlevel10k/powerlevel10k\\\" in ~/.zshrc.\\n## 说明：或者手动从github上下载powerlebel10k，然后放在/root/.oh-my-zsh/custom/themes目录下，最后在.zshrc中设置主题即可\\n```\\n\\n### 1.1 powerlevel10k的配置\\n\\n见github仓库。  另外，您参考[CSDN的教程:powerlevel10k 颜色和图标的自定义设置](https://blog.csdn.net/qq_36835255/article/details/128101588)\\n\\n## 二、windows的powershell安装oh-my-posh\\n\\n1、查看官网：[oh-my-posh](https://ohmyposh.dev/)\\n\\n如果官网打不开的话就直接百度搜：oh my posh\\n\\n按照教程一步一步来：\\n\\n```powershell\\n# 0、安装MesloLGMNerdFontXXX.ttf字体(三个字体)在windows设置中安装\\nhttps://github.com/ryanoasis/nerd-fonts/tree/master/patched-fonts/Meslo/M/Regular\\n# 1、安装oh-my-posh\\nwinget install JanDeDobbeleer.OhMyPosh -s winget\\n# 2、更新\\nwinget upgrade JanDeDobbeleer.OhMyPosh -s winget\\n# 3、查看当前终端名\\noh-my-posh get shell\\n# 4、打开配置文件\\n## 4.1 查看配置文件是否存在：\\nTest-Path $profile\\n## 4.2 若不存在，就查看默认的配置文件路径：\\necho $profile\\n## 4.3 然后手动创建该路径和对应的配置文件\\n# windowsPowerShell配置文件：C:\\\\Users\\\\50850\\\\Documents\\\\WindowsPowerShell\\\\Microsoft.PowerShell_profile.ps1\\n# PowerShell配置文件：C:\\\\Users\\\\50850\\\\Documents\\\\PowerShell\\\\Microsoft.PowerShell_profile.ps1\\n# 5、在配置文件中写入：\\noh-my-posh init pwsh --config \\\"C:\\\\Users\\\\50850\\\\Documents\\\\WindowsPowerShell\\\\jandedobbeleer.omp.json\\\" | Invoke-Expression\\n## 5.1 说明该json文件原路径是在：C:\\\\Users\\\\50850\\\\AppData\\\\Local\\\\Programs\\\\oh-my-posh\\\\themes\\n## 5.2 请移动到自定义的位置，在更改\\n# 6、重启powershell，配置完成\\n# 7、补充，在vscode的powershell中的设置\\n#参考：https://blog.csdn.net/dietime1943/article/details/122968934\\n\\n```\\n\\n### 2.1 oh-my-posh的配置\\n\\n参考文档：[CSDN的教程](https://blog.csdn.net/qq_36835255/article/details/128101588)\\n\\n\\n2、自定义设置\\n\\n主要是对这个json文件进行修改，相关键名和参数值请参考官网。就当前配置而言，重点是更改blocks里面的东西。主要分为三块，由三个大括号包裹。type和alignment是配置提示符在终端的位置，newline选项相当于换行。\\n\\n然后的话，重点就在于segments数组的设置了：\\n\\n```markdown\\n\\\"segments\\\": [\\n        {\\n          \\\"background\\\": \\\"#101010\\\",\\n          \\\"foreground\\\": \\\"#ffffff\\\",\\n          \\\"leading_diamond\\\": \\\"\\\\ue0b6\\\",\\n          \\\"trailing_diamond\\\": \\\"\\\\ue0b4\\\",\\n          \\\"style\\\": \\\"diamond\\\",\\n          \\\"template\\\": \\\"\\\\uf007 {{ .UserName }}\\\",\\n          \\\"type\\\": \\\"session\\\"\\n        },\\n        {\\n        ...\\n        }\\n]\\n```\\n\\n上述代码块是其中的一部分，他是设置了提示符中“用户名”相关的设置。1）前景颜色、背景颜色，当类型为`\\\"style\\\"=\\\"diamond\\\"`时，可以设置前后的字符，2）然后template键值里设置了用户名的值和表示形式。3）最后，有关字符的代码，可以查看网站：[nerdfonts](https://www.nerdfonts.com/cheat-sheet)。\\n\\n\\n## 三、ubuntu安装lunar_vim插件管理器\\n\\n参考官网：[lunarvim](https://www.lunarvim.org/docs/installation) ，我感觉有点麻烦。\\n\\n\\n\\n\\n## 四、vim插件安装和配置\\n\\n使用的是程序员卡尔的配置[程序员卡尔的github仓库](https://github.com/youngyangyang04/PowerVim)\\n\\n\\n# 五、tmux的学习记录\\n\\n正在计划中...\\n\\n- [x] 完善tmux终端管理器的学习笔记\",\"articleCover\":\"\",\"articleTitle\":\"Linux / Windows终端美化记录\",\"articleType\":1,\"categoryName\":\"Linux运维\",\"isRecommend\":0,\"isTop\":0,\"status\":1,\"tagNameList\":[]}]','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',23,'2023-06-07 17:09:56');
INSERT INTO `t_operation_log` VALUES (1206,'文章模块','添加','/admin/article/add','com.ican.controller.ArticleController.addArticle','添加文章','[{\"articleContent\":\"---\\ntitle: C++ STL常用容器知识点说明\\ndate: 2023-4-12\\ntags:\\n - C++ STL\\ncategories:\\n - 未分类\\n\\n---\\n\\n# 0、总体概述\\n\\nSTL就是标准模板库，从广义上分为容器、算法和迭代器。当然，具体细分的话，STL大体分为六大组件，分别是:容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器。\\n\\n1.  容器：各种数据结构，如vector、list、deque、set、map等,用来存放数据。\\n2.  算法：各种常用的算法，如sort、find、copy、for_each等\\n3.  迭代器：扮演了容器与算法之间的胶合剂。\\n4.  仿函数：行为类似函数，可作为算法的某种策略。\\n5.  适配器：一种用来修饰容器或者仿函数或迭代器接口的东西。\\n6.  空间配置器：负责空间的配置与管理。\\n\\n容器：就是将运用最广泛的一些数据结构实现出来，常用的数据结构：数组, 链表,树, 栈, 队列, 集合, 映射表等。这些容器分为序列式容器（值有顺序）和关联式容器（值之间有关联）。\\n\\n算法：有限的步骤，解决逻辑或数学上的问题，这一门学科我们叫做算法(Algorithms)。分为质变算法和非质变算法。质变算法：是指运算过程中会更改区间内的元素的内容。例如拷贝，替换，删除等等。非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等。\\n\\n# 0.1、迭代器\\n\\n迭代器：容器和算法的粘合剂。提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。迭代器使用非常类似于指针，初学阶段我们可以先理解迭代器为指针。\\n\\n![](media/589080628386800bbe32bb04420e0977.png)\\n\\n常用的容器中迭代器种类为双向迭代器，和随机访问迭代器。vector的begin和end是随机访问迭代器。\\n\\n![](media/105c3ca0ae4de6b12b6147b916a61af1.png)\\n\\n# 一、STL容器\\n\\n这是STL常用容器知识点总结。（1）是构造函数；（2）是赋值；（3）是（string）查找、大小/容量与交换；（4）插入与删除；（5）数据存取；第六部分，其它补充内容。容器最常用的是vector和list\\n\\n## 1、构造函数\\n\\n|        | （1）构造函数                                                |\\n| ------ | ------------------------------------------------------------ |\\n| string | 1、无参构造string(); 2、拷贝构造string(const string& str); 3、字符串构造string(const char\\\\* s)； 4、n个字符构造string(int n, char c); |\\n| vector | 1、无参构造vector\\\\<T\\\\> v; 2、拷贝构造vector(const vector \\\\&vec); 3、（迭代器）区间拷贝构造vector(v.begin(), v.end()); 4、n个元素构造vector(n, elem); |\\n| deque  | 1、无参构造deque\\\\<T\\\\> deq; 2、拷贝构造deque(const deque \\\\&deq); 3、（迭代器）区间拷贝构造deque(beg, end); 4、n个元素构造deque(n, elem); |\\n| stack  | 1、无参构造stack\\\\<T\\\\> stk; 2、拷贝构造 stack(const stack \\\\&stk); |\\n| queue  | 1、无参构造 queue\\\\<T\\\\> que; 2、拷贝构造 queue(const queue \\\\&que); |\\n| List   | 1、无参构造list\\\\<T\\\\> lst; 2、拷贝构造 list(const list \\\\&lst); 3、（迭代器）区间拷贝构造 list(beg,end); 4、n个元素构造list(n, elem); |\\n| set    | 1、无参构造 set\\\\<T\\\\> st; 2、拷贝构造 set(const set \\\\&st);    |\\n| map    | 1、无参构造 map\\\\<T1,T2\\\\> mp; 2、拷贝构造 map(const map \\\\&mp); |\\n\\n## 2、赋值\\n\\n|        | （2）赋值                                                    |\\n| ------ | ------------------------------------------------------------ |\\n| string | - string& operator=(const char\\\\* s); //char\\\\*类型字符串 赋值给当前的字符串 - string& operator=(const string \\\\&s); //把字符串s赋给当前的字符串 - string& operator=(char c); //字符赋值给当前的字符串 - string& assign(const char \\\\*s); //把字符串s赋给当前的字符串 - string& assign(const char \\\\*s, int n); //把字符串s的前n个字符赋给当前的字符串 - string& assign(const string \\\\&s); //把字符串s赋给当前字符串 - string& assign(int n, char c); //用n个字符c赋给当前字符串 |\\n| vector | - vector& operator=(const vector \\\\&vec);//重载等号操作符 - assign(beg, end); //将[beg, end)区间中的数据拷贝赋值给本身。 - assign(n, elem); //将n个elem拷贝赋值给本身。 |\\n| deque  | - deque& operator=(const deque \\\\&deq); //重载等号操作符 - assign(beg, end); //将[beg, end)区间中的数据拷贝赋值给本身。 - assign(n, elem); //将n个elem拷贝赋值给本身。 |\\n| stack  | stack& operator=(const stack \\\\&stk); //重载等号操作符        |\\n| queue  | queue& operator=(const queue \\\\&que); //重载等号操作符        |\\n| List   | - assign(beg, end); //将[beg, end)区间中的数据拷贝赋值给本身。 - assign(n, elem); //将n个elem拷贝赋值给本身。 - list& operator=(const list \\\\&lst); //重载等号操作符 |\\n| set    | set& operator=(const set \\\\&st); //重载等号操作符             |\\n| map    | map& operator=(const map \\\\&mp); //重载等号操作符             |\\n\\n## 3、(string)查找、大小/容量与交换\\n\\n|        | **（3）（string）查找、容量/大小与交换**                     |\\n| ------ | ------------------------------------------------------------ |\\n| string | --查找 - int find(const string& str, int pos = 0) const; //查找str第一次出现位置,从pos开始查找 - int find(const char\\\\* s, int pos = 0) const; //查找s第一次出现位置,从pos开始查找 - int find(const char\\\\* s, int pos, int n) const;//从pos位置查找s的前n个字符第一次位置 - int find(const char c, int pos = 0) const; //查找字符c第一次出现位置 -int rfind(const string& str, int pos = npos) const;//查找str最后一次位置,从pos开始查找 -int rfind(const char\\\\* s, int pos = npos) const;//查找s最后一次出现位置,从pos开始查找 - int rfind(const char\\\\* s, int pos, int n) const; //从pos查找s的前n个字符最后一次位置 - int rfind(const char c, int pos = 0) const; //查找字符c最后一次出现位置 --容量/大小 无 --交换 - string& replace(int pos, int n, const string& str); //替换从pos开始n个字符为字符串str - string& replace(int pos, int n,const char\\\\* s); //替换从pos开始的n个字符为字符串s |\\n| vector | --查找 无 --容量/大小 - empty(); //判断容器是否为空 - capacity(); //容器的容量 - size(); //返回容器中元素的个数 - resize(int num); //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。//如果容器变短，则末尾超出容器长度的元素被删除。 -resize(int num, elem);//重新指定容器的长度为num，若容器变长，则以elem值填充新位置。//如果容器变短，则末尾超出容器长度的元素被删除 reserve(int len);//容器预留len个元素长度，预留位置不初始化，元素不可访问。自定义容器的容量 --交换 swap(vec); // 将vec与本身的元素互换 |\\n| deque  | --查找 无 --容量/大小 - deque.empty(); //判断容器是否为空 - deque.size(); //返回容器中元素的个数 - deque.resize(num); //重新指定容器的长度为num,若容器变长，则以默认值填充新位置。//如果容器变短，则末尾超出容器长度的元素被删除。 - deque.resize(num, elem); //重新指定容器的长度为num,若容器变长，则以elem值填充新位置。//如果容器变短，则末尾超出容器长度的元素被删除。 --交换 无 |\\n| stack  | --大小 - empty(); //判断堆栈是否为空 - size(); //返回栈的大小 |\\n| queue  | --大小 - empty(); //判断堆栈是否为空 - size(); //返回栈的大小 |\\n| List   | --大小 - size();//返回容器中元素的个数 - empty();//判断容器是否为空 - resize(num); //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。//如果容器变短，则末尾超出容器长度的元素被删除。 -resize(num, elem); //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。//如果容器变短，则末尾超出容器长度的元素被删除。 --交换 - swap(lst); //将lst与本身的元素互换。 |\\n| set    | --大小 - size(); //返回容器中元素的数目 - empty(); //判断容器是否为空 --交换 - swap(st); //交换两个集合容器 |\\n| map    | --大小 - size(); //返回容器中元素的数目 - empty(); //判断容器是否为空 --交换 - swap(st); //交换两个集合容器 |\\n\\n## 4、插入/删除\\n\\n|        | **（4）插入/删除**                                           |\\n| ------ | ------------------------------------------------------------ |\\n| string | - string& insert(int pos, const char\\\\* s); //插入字符串 - string& insert(int pos, const string& str); //插入字符串 - string& insert(int pos, int n, char c); //在指定位置插入n个字符c - string& erase(int pos, int n = npos); //删除从Pos开始的n个字符 |\\n| vector | - push_back(ele); //尾部插入元素ele - pop_back(); //删除最后一个元素 - insert(const_iterator pos, ele); //迭代器指向位置pos插入元素ele - insert(const_iterator pos, int count,ele);//迭代器指向位置pos插入count个元素ele - erase(const_iterator pos); //删除迭代器指向的元素 - erase(const_iterator start, const_iterator end);//删除迭代器从start到end之间的元素 - clear(); //删除容器中所有元素 |\\n| deque  | 两端插入操作： - push_back(elem); //在容器尾部添加一个数据 - push_front(elem); //在容器头部插入一个数据 - pop_back(); //删除容器最后一个数据 - pop_front(); //删除容器第一个数据 指定位置操作： - insert(pos,elem); //在pos位置插入一个elem元素的拷贝，返回新数据的位置。 - insert(pos,n,elem); //在pos位置插入n个elem数据，无返回值。 - insert(pos,beg,end); //在pos位置插入[beg,end)区间的数据，无返回值。 - clear(); //清空容器的所有数据 - erase(beg,end); //删除[beg,end)区间的数据，返回下一个数据的位置。 - erase(pos); //删除pos位置的数据，返回下一个数据的位置。 |\\n| stack  | 无                                                           |\\n| queue  | 无                                                           |\\n| List   | - push_back(elem);//在容器尾部加入一个元素 - pop_back();//删除容器中最后一个元素 - push_front(elem);//在容器开头插入一个元素 - pop_front();//从容器开头移除第一个元素 - insert(pos,elem);//在pos位置插elem元素的拷贝，返回新数据的位置。 - insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值。 - insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值。 - clear();//移除容器的所有数据 - erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置。 - erase(pos);//删除pos位置的数据，返回下一个数据的位置。 - remove(elem);//删除容器中所有与elem值匹配的元素。 |\\n| set    | - insert(elem); //在容器中插入元素。 - clear(); //清除所有元素 - erase(pos); //删除pos迭代器所指的元素，返回下一个元素的迭代器。 - erase(beg, end); //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。 - erase(elem); //删除容器中值为elem的元素。 |\\n| map    | - insert(elem); //在容器中插入元素。 - clear(); //清除所有元素 - erase(pos); //删除pos迭代器所指的元素，返回下一个元素的迭代器。 - erase(beg, end); //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。 - erase(key); //删除容器中值为key的元素。 |\\n\\n## 5、数据存取\\n\\n|        | **（5）数据存取**                                            |\\n| ------ | ------------------------------------------------------------ |\\n| string | - char& operator[](int n); //通过[]方式取字符 - char& at(int n); //通过at方法获取字符 |\\n| vector | - at(int idx); //返回索引idx所指的数据 - operator[]; //返回索引idx所指的数据 - front(); //返回容器中第一个数据元素 - back(); //返回容器中最后一个数据元素 |\\n| deque  | - at(int idx); //返回索引idx所指的数据 - operator[]; //返回索引idx所指的数据 - front(); //返回容器中第一个数据元素 - back(); //返回容器中最后一个数据元素 |\\n| stack  | - push(elem); //向栈顶添加元素 - pop(); //从栈顶移除第一个元素 - top(); //返回栈顶元素 |\\n| queue  | - push(elem); //往队尾添加元素 - pop(); //从队头移除第一个元素 - back(); //返回最后一个元素 - front(); //返回第一个元素 |\\n| List   | - front(); //返回第一个元素。 - back(); //返回最后一个元素。 |\\n| set    | 无                                                           |\\n| map    | 无                                                           |\\n\\n## 6、第六部分：补充内容\\n\\n注意：栈stack只有栈顶可以访问，所以不支持遍历行为；队列只有队头队尾才能被外界访问，因此队列也不支持遍历行为；\\n\\nvector很像数组，常称为单端数组，他和数组的最大区别是数组等长，而vector可以动态扩展长度。deque是双端数组，可以头/尾插入或删除，deque可以动态扩展长度。在头插入上，vector效率低，deque头插入效率高；另一方面，vector访问元素的速度要比deque快，这与vector/deque内部的实现有关。\\n\\nString、vector和deque的迭代器支持随机访问；stack/queue不提供迭代器，不支持随机访问；list容器的迭代器是双向迭代器，不支持随机访问\\n\\n注：随机访问迭代器 ：读写操作，可以以跳跃的方式访问任意数据，功能最强的迭代器\\n\\n**[string容器]**\\n\\n►string字符串的拼接\\n\\n\\\\- string& operator+=(const char\\\\* str); //重载+=操作符\\n\\n\\\\- string& operator+=(const char c); //重载+=操作符\\n\\n\\\\- string& operator+=(const string& str); //重载+=操作符\\n\\n\\\\- string& append(const char \\\\*s); //把字符串s连接到当前字符串结尾\\n\\n\\\\- string& append(const char \\\\*s, int n); //把字符串s的前n个字符连接到当前字符串结尾\\n\\n\\\\- string& append(const string \\\\&s); //同operator+=(const string& str)\\n\\n\\\\- string& append(const string \\\\&s, int pos, int n);//字符串s中从pos开始的n个字符连接到字符串结尾\\n\\n►string字符串的比较，按照字符的ASCII码值进行比较，相等返回0，大于返回1，小于返回-1\\n\\n\\\\- int compare(const string \\\\&s) const; //与字符串s比较\\n\\n\\\\- int compare(const char \\\\*s) const; //与字符串s比较\\n\\n►string字符串的子串\\n\\nstring substr(int pos = 0, int n = npos) const; //返回由pos开始的n个字符组成的字符串\\n\\n**[vector容器]**\\n\\n无\\n\\n**[deque容器]**\\n\\n**►deque排序**\\n\\nsort(iterator beg, iterator end) //对beg和end区间内元素进行排序\\n\\n[stack容器]\\n\\n无\\n\\n**[queue容器]**\\n\\n无\\n\\n**[list容器]**\\n\\n►list的翻转和排序\\n\\n\\\\- reverse(); //反转链表\\n\\n\\\\- sort(); //链表排序\\n\\n**[set容器]**\\n\\n►set的查找和统计\\n\\n\\\\- find(key); //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();\\n\\n\\\\- count(key); //统计key的元素个数\\n\\n►set的排序（默认为从小到大，可以使用仿函数来更改排序规则）\\n\\nclass MyCompare\\n\\n{\\n\\npublic:\\n\\nbool operator()(int v1, int v2) {\\n\\nreturn v1 \\\\> v2;\\n\\n}\\n\\n};\\n\\nset\\\\<int,MyCompare\\\\> s2; //自定义排序规则\\n\\n**[map容器]**\\n\\n►map的查找和统计\\n\\n\\\\- find(key); //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();\\n\\n\\\\- count(key); //统计key的元素个数\\n\\n►map的排序（使用自定义规则进行排序）\\n\\nclass MyCompare {\\n\\npublic:\\n\\nbool operator()(int v1, int v2) {\\n\\nreturn v1 \\\\> v2;\\n\\n}\\n\\n};\\n\\nmap\\\\<int, int, MyCompare\\\\> m; //自定义排序规则\\n\\n自定义函数用于排序的例子：\\n\\n**b**ool myCompare(int val1 , int val2)\\n\\n{\\n\\nreturn val1 \\\\> val2;\\n\\n}\\n\\n# 二、STL常用函数对象\\n\\n**1、函数对象**\\n\\n定义：重载函数调用操作符的类，其对象常称为函数对象。函数对象使用重载的（）号时，行为类似于函数调用，因此也称为仿函数。\\n\\n本质：函数对象（仿函数）是一个类，不是一个函数\\n\\n1.  函数对象的调用\\n\\n特点：\\n\\n函数对象在使用时，可以像普通函数那样调用，可以有参数，可以有返回值\\n\\n函数对象超出普通函数的概念，函数对象可以有自己的状态\\n\\n函数对象可以作为参数传递\\n\\n总结：仿函数写法非常灵活，可以作为参数进行传递。\\n\\n**2、谓语**\\n\\n返回值是bool类型的仿函数称为谓语，如果operator()接受一个参数，就是一元谓语；接受2个参数，就是二元谓语。\\n\\n**3、内建函数对象**\\n\\nSTL内建了一些函数对象，分为算术仿函数，关系仿函数，逻辑仿函数。\\n\\n这些仿函数所产生的对象，用法和普通函数一致，不过需要引入头文件\\\\<functional\\\\>\\n\\n3.1算术仿函数\\n\\n\\\\- template\\\\<class T\\\\> T plus\\\\<T\\\\> //加法仿函数\\n\\n\\\\- template\\\\<class T\\\\> T minus\\\\<T\\\\> //减法仿函数\\n\\n\\\\- template\\\\<class T\\\\> T multiplies\\\\<T\\\\> //乘法仿函数\\n\\n\\\\- template\\\\<class T\\\\> T divides\\\\<T\\\\> //除法仿函数\\n\\n\\\\- template\\\\<class T\\\\> T modulus\\\\<T\\\\> //取余仿函数%\\n\\n\\\\- template\\\\<class T\\\\> T negate\\\\<T\\\\> //取反仿函数\\n\\n3.2 关系仿函数 （谓语）\\n\\n\\\\- template\\\\<class T\\\\> bool equal_to\\\\<T\\\\> //等于\\n\\n\\\\- template\\\\<class T\\\\> bool not_equal_to\\\\<T\\\\> //不等于\\n\\n\\\\- template\\\\<class T\\\\> bool greater\\\\<T\\\\> //大于\\n\\n\\\\- template\\\\<class T\\\\> bool greater_equal\\\\<T\\\\> //大于等于\\n\\n\\\\- template\\\\<class T\\\\> bool less\\\\<T\\\\> //小于\\n\\n\\\\- template\\\\<class T\\\\> bool less_equal\\\\<T\\\\> //小于等于\\n\\n3.3 逻辑仿函数（应用较少） （谓语）\\n\\n\\\\- template\\\\<class T\\\\> bool logical_and\\\\<T\\\\> //逻辑与\\n\\n\\\\- template\\\\<class T\\\\> bool logical_or\\\\<T\\\\> //逻辑或\\n\\n\\\\- template\\\\<class T\\\\> bool logical_not\\\\<T\\\\> //逻辑非\\n\\n# 三、STL常用算法\\n\\n使用STL算法，需要包含头\\\\<algorithm\\\\>\\n\\n1、遍历算法\\n\\n**（1）for_each遍历容器**\\n\\n►for_each(iterator beg, iterator end, \\\\_func);\\n\\nfor_each是最常用的遍历算法，需要熟练掌握。功能函数有打印函数（自定义函数）、打印函数（类内函数，即仿函数）、算术操作函数或逻辑函数\\n\\n**（2）transform 搬运容器到另一个容器中**\\n\\n►transform(iterator beg1, iterator end1, iterator beg2, \\\\_func);\\n\\n源容器的起点，源容器的终点，目标容器的起点，功能函数同上。注意：搬运的目标函数必须提前开辟空间，否则不能正常搬运。\\n\\n2、查找算法\\n\\n►find(iterator beg, iterator end, value); //按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置，返回值类型是 ‘容器’\\\\<数据类型\\\\>::iterator it\\n\\n►find_if(iterator beg, iterator end, \\\\_Pred); //按条件查找元素(按值查找元素)，找到返回指定位置迭代器，找不到返回结束迭代器位置._Pred是函数或者谓词（谓词是返回bool类型的仿函数）\\n\\n► adjacent_find(iterator beg, iterator end); //查找相邻重复元素,返回相邻元素的第一个位置的迭代器\\n\\n► bool binary_search(iterator beg, iterator end, value); //二分查找法。查到返回true，否则返回false。注意在无序序列中不能用\\n\\n► count(iterator beg, iterator end, value); //统计指定元素出现的个数\\n\\n注意：统计自定义数据类型时，需要重载==\\n\\n► count_if(iterator beg, iterator end, \\\\_Pred); //按条件统计元素个数，_Pred是指返回值为bool类型的仿函数\\n\\n3、排序算法\\n\\n► sort(iterator beg, iterator end, \\\\_Pred); //对容器内元素进行排序\\n\\nsort属于开发中最常用的算法之一，需熟练掌握\\n\\n► random_shuffle(iterator beg, iterator end); //随机洗牌，指定范围内的元素随机调整次序\\n\\nrandom_shuffle洗牌算法比较实用，使用时记得加随机数种子\\n\\n► merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest); // 容器元素合并，并存储到另一容器中。Beg1/end1容器1的起止迭代器，beg2/end2容器2的起止迭代器，dest是目标容器的开始迭代器\\n\\n注意：两个容器必须是有序的，目标容器必须提前开辟空间\\n\\n► reverse(iterator beg, iterator end); // 反转指定范围的元素\\n\\n4、常用拷贝和替换算法\\n\\n► copy(iterator beg, iterator end, iterator dest); //容器内指定范围的元素拷贝到另一容器中\\n\\n► replace(iterator beg, iterator end, oldvalue, newvalue); //将容器内指定范围的旧元素修改为新元素\\n\\nreplace会替换区间内满足条件的元素\\n\\n► replace_if(iterator beg, iterator end, \\\\_pred, newvalue); // 容器内指定范围满足条件的元素替换为新元素\\n\\n按条件替换元素，满足条件的替换成指定元素。总结：replace_if按条件查找，可以利用仿函数灵活筛选满足的条件\\n\\n► swap(container c1, container c2); // 互换两个容器的元素\\n\\n总结：swap交换容器时，注意交换的容器要同种类型\\n\\n5、常用算术生成算法\\n\\n注意：算术生成算法属于小型算法，使用时包含的头文件为 \\\\#include \\\\<numeric\\\\>\\n\\n► accumulate(iterator beg, iterator end, value); // 计算容器元素累计总和，返回值为int\\n\\n► fill(iterator beg, iterator end, value); // 向容器中添加元素\\n\\n6、常用集合算法\\n\\n三个函数的返回值均是dest容器最后一个元素的迭代器iterator\\n\\n► set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest); // 求两个容器的交集\\n\\n注意:两个集合必须是有序序列。\\n\\n总结：-求交集的两个集合必须的有序序列\\n\\n\\\\- 目标容器开辟空间需要从两个容器中取小值\\n\\n\\\\- set_intersection返回值既是交集中最后一个元素的位置\\n\\n► set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest); //求两个容器的并集\\n\\n注意:两个集合必须是有序序列\\n\\n总结：- 求并集的两个集合必须的有序序列\\n\\n\\\\- 目标容器开辟空间需要两个容器相加\\n\\n\\\\- set_union返回值既是并集中最后一个元素的位置\\n\\n► set_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest); // 求两个容器的差集\\n\\n注意:两个集合必须是有序序列\\n\\n总结：- 求差集的两个集合必须的有序序列\\n\\n\\\\- 目标容器开辟空间需要从两个容器取较大值\\n\\n\\\\- set_difference返回值既是差集中最后一个元素的位置\",\"articleCover\":\"\",\"articleTitle\":\"C++STL常用容器知识点说明\",\"articleType\":1,\"categoryName\":\"编程语言基础\",\"isRecommend\":0,\"isTop\":0,\"status\":1,\"tagNameList\":[\"STL\"]}]','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',24,'2023-06-07 17:10:32');
INSERT INTO `t_operation_log` VALUES (1207,'文章模块','修改','/admin/article/update','com.ican.controller.ArticleController.updateArticle','修改文章','[{\"articleContent\":\"# docker记录\\n\\n## 安装\\n\\n镜像  容器  仓库\\n略\\n\\n## 常用命令\\n\\ndocker rm container-id 删除指定 id 的容器\\n\\ndocker stop/start container-id 停止/启动指定 id 的容器\\n\\ndocker rmi image-id 删除指定 id 的镜像\\n\\ndocker volume ls 查看 volume 列表\\n\\ndocker network ls 查看网络列表\\n\\n镜像相关：\\n\\n导出镜像：docker iamge save centos:7.2.1511 > centos-7.2.1511.tgz\\n\\n导入镜像： docker image load -i centos-7.2.1511.tgz\\n\\n查看镜像详细信息：docker image inspect 镜像-ID\\n\\ndocker images 查看镜像列表\\n\\ndocker search XX 默认在本地，没有的话去docker hub上搜索\\n\\n容器相关：\\ndocker ps 查看当前运行中的容器(-a查看所有容器记录，包括死了的)\\n用镜像启动一个容器：docker run -d -p 80:80 nginx (-d表示后台运行，-p表示端口映射)\\n查看容器信息：docker container inspect 容器ID\\n进入容器空间1：docker run -it centos bash  （从镜像到容器）\\n进入容器空间2：docker exec -it 容器ID bash （从终端进入到一个活着的容器，比如后台容器）\\n\\n\\n容器端口映射：\\n\\n| 命令                              | 解释                              |\\n| --------------------------------- | --------------------------------- |\\n| -**p hostPort:containerPort**     | 端口映射-p 8080:80                |\\n| **-p ip:hostPort:containerPort**  | 配置监听地址-p 10.0.0.100:8080:80 |\\n| **p ip::containerPort**           | 随机分配端口 -p 10.0.0.100：：80  |\\n| **-p hostPort:containerPort:udp** | 指定协议 -p 8080:80:tcp           |\\n| **-p 81:80 -p 443:443**           | 指定多个                          |\\n\\n\\n\\n\\n## 写自己的镜像 Dockerfile\\n\\n```Dockerfile\\nFROM node:11\\nMAINTAINER easydoc.net\\n\\n# 复制代码\\nADD . /app\\n\\n# 设置容器启动后的默认运行目录\\nWORKDIR /app\\n\\n# 运行命令，安装依赖\\n# RUN 命令可以有多个，但是可以用 && 连接多个命令来减少层级。\\n# 例如 RUN npm install && cd /app && mkdir logs\\nRUN npm install --registry=https://registry.npm.taobao.org\\n\\n# CMD 指令只能一个，是容器启动后执行的命令，算是程序的入口。\\n# 如果还需要运行其他命令可以用 && 连接，也可以写成一个shell脚本去执行。\\n# 例如 CMD cd /app && ./start.sh\\nCMD node app.js\\n\\n```\\n\\n说明：\\nFROM 这个镜像的妈妈是谁？（指定基础镜像）\\nMAINTAINER告诉别人，谁负责养他？（指定维护者信息，可以没有）\\nRUN 你想让他干啥（在命令前加上RUN即可）\\nADD 给他一点创业资金（copy文件，会自动解压）\\nWORKDIR 我是cd，今天刚化了妆（设置当前工作目录）\\nVILUME 给他一个存放行李的地方（设置卷，挂载主机目录）\\nEXPOSE 他要打开的门是什么（指定对外的端口）\\nCMD 奔跑吧，兄弟 （指定容器启动后要干的事情）\\n**Docker的其他命令**：\\n\\n> CPOY 复制文件\\n>\\n> ENV 环境变量\\n>\\n> ENTRYPOINT 容器启动后执行的命令\\n\\n### Build为镜像（安装包）和运行\\n\\n编译 `docker build -t test:v1 .`\\n\\n> -t 设置镜像名字和版本号\\n\\n运行`docker run -p 8080:8080 --name test-hello test:v1`\\n\\n> -p 映射容器内端口到宿主机\\n>\\n> --name 容器名字\\n>\\n> -d 后台运行\\n\\n## 目录挂载\\n\\n现存问题：\\n\\n+ 使用 Docker 运行后，我们改了项目代码不会立刻生效，需要重新build和run，很是麻烦。\\n+ 容器里面产生的数据，例如 log 文件，数据库备份文件，容器删除后就丢失了。\\n\\n**目录挂载**以解决上述问题\\n\\n几种挂载方式：\\n\\n+ bind mount 直接把宿主机目录映射到容器内，适合挂代码目录和配置文件。可挂到多个容器上\\n+ volume 由容器创建和管理，创建在宿主机，所以删除容器不会丢失，官方推荐，更高效，Linux 文件系统，适合存储数据库数据。可挂到多个容器上\\n+ tmpfs mount 适合存储临时文件，存宿主机内存中。不可多容器共享。\\n\\n### 挂载演示\\n\\n`bind mount` 方式用绝对路径 -v D:/code:/app\\n\\n`volume` 方式，只需要一个名字 -v db-data:/app\\n\\n\\n## 2023/04/29 学习容器技术\\n\\n一种环境隔离的虚拟化技术，相比于传统的虚拟化技术，它拥有利用系统资源更高效、启动时间更快、持续交付和部署等特点。\\n\\n\\n\\n## 2023/06/06 使用\\n\\n在配置和使用[ttkican_Blog-master博客](https://github.com/ttkican/Blog)时的一些命令记录\\n\\n### 1、docker 与docker-compose的安装\\n\\n### 2、下载镜像\\n\\n```dockerfile\\ndocker pull 镜像名:属性\\ndocker pull canal/canal-server:latest\\n```\\n\\n### 3、运行镜像\\n\\n```dockerfile\\ndocker run --name canal -d canal/canal-server:latest\\n```\\n\\n注意：镜像只有一个，下载的就是镜像。但是可以用该镜像运行若干个不同的容器\\n\\n### 4、docker容器的操作：\\n\\n```bash\\n# 1) 查看正在运行的容器\\ndocker ps \\n# 1.2) 查看已经下载的镜像\\ndocker images\\n# 2）查看所有容器\\ndocker ps -a\\n# 3) 停止指定容器\\ndocker stop 容器名或容器ID\\n# 4）启动容器\\ndocker start 容器名和容器ID\\n# 5）进入容器终端，以mysql容器举例\\ndocker exec -it mysql bash\\n# 上述命令中 -it 表示以交互式的方式， bash 表示以bash终端的方式来交互\\n# 6）容器与本地Linux之间的文件拷贝\\ndocker cp /home/ubuntu/xxx.sql mysql:/\\ndocker cp mysql:/xx.sql /home/ubuntu/\\n# 7) 容器的删除和镜像的删除\\ndocker rm 容器名或容器ID\\ndocker rmi 镜像名或镜像ID\\n# 8) 使用docker-compose和对应的docker-compose.yml来启动docker容器\\ndocker-compose up -d --build  # 在有docker-compose.yml的同级目录下运行哦\\n# 9) 查看docker网络\\ndocker network ls\\n# 查看上述命令的输出，例如我在docker-compose.yml中设置了网络名为：blog-net，然后就能在docker network ls下看到有个NAME为docker_blog-net的网络，然后其NETWORK_ID为d32231f3430c，在然后使用ifconfig命令查看docker虚拟网卡(是类似于br-xxx这种，这里是br-d32231f3430c，而不是下面的veth8fad9XX等)，就知道了该docker网络下的IP为172.20.0.1，后面其他同docker network下的容器想要和mysql容器和redis容器通信的话就填172.20.0.1。注意：docker容器下的127.0.0.1是容器内部自身的回环地址，其他容器肯定访问不到。\\n```\\n\\ndocker-compose.yml文件示例：\\n\\n```dockerfile\\nversion: \\\"3\\\"\\nservices:\\n  blog-service:\\n    build: .\\n    image: blog-springboot:latest\\n    container_name: blog-springboot\\n    restart: always\\n    depends_on:\\n      - mysql\\n      - redis\\n      - rabbitmq\\n    volumes:\\n      - \\\"/usr/local/upload:/usr/local/upload\\\"\\n    ports:\\n      - \\\"8080:8080\\\"\\n    networks:\\n      - blog-net\\n  mysql:\\n    image: mysql:${MYSQL_VERSION}\\n    container_name: mysql\\n    restart: always\\n    environment:\\n      MYSQL_ROOT_PASSWORD: ${MYSQL_ROOT_PASSWORD}\\n      TZ: Asia/Shanghai\\n    ports:\\n      - \\\"3306:3306\\\"\\n    networks:\\n      - blog-net\\n  redis:\\n    image: redis:${REDIS_VERSION}\\n    container_name: redis\\n    restart: always\\n    command: --requirepass \\\"${REDIS_PASSWORD}\\\"\\n    ports:\\n      - \\\"6379:6379\\\"\\n    networks:\\n      - blog-net\\n  rabbitmq:\\n    image: rabbitmq:${RABBITMQ_VERSION}\\n    container_name: rabbitmq\\n    restart: always\\n    environment:\\n      RABBITMQ_DEFAULT_USER: ${RABBITMQ_USER}\\n      RABBITMQ_DEFAULT_PASS: ${RABBITMQ_PASSWORD}\\n    ports:\\n      - \\\"5672:5672\\\"\\n      - \\\"15672:15672\\\"\\n    networks:\\n      - blog-net\\n  elasticsearch:\\n    image: elasticsearch:${ELASTICSEARCH_VERSION}\\n    container_name: elasticsearch\\n    restart: always\\n    environment:\\n      discovery.type: \\\"single-node\\\"\\n      ES_JAVA_OPTS: \\\"-Xms64m -Xmx128m\\\"\\n      http.cors.enabled: \\\"true\\\"\\n      http.cors.allow-origin: \\\"*\\\"\\n      xpack.security.enabled: \\\"true\\\"\\n      ELASTIC_PASSWORD: \\\"${ELASTICSEARCH_PASSWORD}\\\"\\n    ports:\\n      - \\\"9200:9200\\\"\\n      - \\\"9300:9300\\\"\\n    networks:\\n      - es-net\\n      - blog-net\\n  kibana:\\n    image: kibana:${ELASTICSEARCH_VERSION}\\n    container_name: kibana\\n    volumes:\\n      - \\\"/usr/local/kibana/kibana.yml:/usr/share/kibana/config/kibana.yml\\\"\\n    depends_on:\\n      - elasticsearch\\n    ports:\\n      - \\\"5601:5601\\\"\\n    networks:\\n      - es-net\\n      - blog-net\\n  canal_server:\\n    image: canal/canal-server:${CANAL_VERSION}\\n    container_name: canal\\n    volumes:\\n      - \\\"/usr/local/canal/instance.properties:/home/admin/canal-server/conf/example/instance.properties\\\"\\n      - \\\"/usr/local/canal/canal.properties:/home/admin/canal-server/conf/canal.properties\\\"\\n    ports:\\n      - \\\"11111:11111\\\"\\n    networks:\\n      - blog-net\\n  nginx:\\n    image: nginx:${NGINX_VERSION}\\n    container_name: nginx\\n    restart: always\\n    volumes:\\n      - \\\"/usr/local/nginx/nginx.conf:/etc/nginx/nginx.conf\\\"\\n      - \\\"/etc/ssl/certs:/etc/ssl/certs\\\"\\n      - \\\"/usr/local/vue:/usr/local/vue\\\"\\n      - \\\"/usr/local/upload:/usr/local/upload\\\"\\n    privileged: true\\n    ports:\\n      - \\\"443:443\\\"\\n      - \\\"80:80\\\"\\n    networks:\\n      - blog-net\\nnetworks:\\n  es-net:\\n    driver: bridge\\n  blog-net:\\n    driver: bridge\\n```\\n\\n对应的启动脚本：\\n\\n```bash\\n#!/bin/bash\\n# 文件名：blog-start.sh\\n# 打包之后上传的jar包路径\\nSOURCE_PATH=/usr/local/docker\\n# docker的镜像和容器名称都命名为这个\\nSERVER_NAME=blog-springboot\\nTAG=latest\\n# 容器id\\nCID=$(docker ps | grep \\\"$SERVER_NAME\\\" | awk \'{print $1}\')\\n# 镜像id\\nIID=$(docker images | grep \\\"$SERVER_NAME\\\" | awk \'{print $3}\')\\nif [ -n \\\"$CID\\\" ]; then\\n  echo \\\"存在容器$SERVER_NAME, CID-$CID\\\"\\n  docker stop $CID\\n  docker rm $CID\\nfi\\n# 构建docker镜像\\nif [ -n \\\"$IID\\\" ]; then\\n  echo \\\"存在$SERVER_NAME:$TAG镜像，IID=$IID\\\"\\n  docker rmi $IID\\nfi\\n# 重新构建镜像并运行\\ndocker-compose up -d --build\\n```\\n\\n\\n\\n\\n\\n\\n\\n\",\"articleCover\":\"https://upload.haoxx.site/config/27c7f38a329c07159a80315712680ea5.jpg\",\"articleTitle\":\"docker使用记录\",\"articleType\":1,\"categoryName\":\"Linux运维\",\"id\":95,\"isRecommend\":0,\"isTop\":0,\"status\":1,\"tagNameList\":[\"Docker\"]}]','PUT','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',35,'2023-06-07 17:11:52');
INSERT INTO `t_operation_log` VALUES (1208,'网站配置模块','修改','/admin/site/update','com.ican.controller.SiteConfigController.updateSiteConfig','更新网站配置','[{\"aboutMe\":\"🍀个人简介\\n\\nXX\",\"aliCode\":\"https://upload.haoxx.site/cloud/images/image_2.jpg\",\"articleCover\":\"https://upload.haoxx.site/config/27c7f38a329c07159a80315712680ea5.jpg\",\"authorAvatar\":\"https://upload.haoxx.site/config/5bbb6dc8be42f3e96dbcc7d7529dc402.gif\",\"bilibili\":\"https://space.bilibili.com/505715511\",\"commentCheck\":0,\"createSiteTime\":\"2023-06-06\",\"emailNotice\":1,\"gitee\":\"https://gitee.com/wu_shengdong\",\"github\":\"https://github.com/ICAN1999\",\"id\":1,\"isMusic\":0,\"isReward\":0,\"loginList\":\",gitee\",\"messageCheck\":0,\"musicId\":\"7611185981\",\"qq\":\"1632167813\",\"recordNumber\":\"渝ICP备2023001651号-2\",\"siteAddress\":\"https://www.haoxx.site\",\"siteAuthor\":\"小鱼\",\"siteIntro\":\"网站介绍\",\"siteName\":\"HaoXX`s Blog\",\"siteNotice\":\"个人学习资料记录\",\"socialList\":\"gitee,bilibili,github,qq\",\"touristAvatar\":\"https://upload.haoxx.site/config/0b04691f25e400a708caba867be171d0.jpg\",\"userAvatar\":\"https://upload.haoxx.site/config/e94fc60e58a570ecc3e9ddcb334fdb2b.jpg\",\"weiXinCode\":\"https://upload.haoxx.site/cloud/images/image_1.jpg\"}]','PUT','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',11,'2023-06-07 17:12:47');
INSERT INTO `t_operation_log` VALUES (1209,'网站配置模块','修改','/admin/site/update','com.ican.controller.SiteConfigController.updateSiteConfig','更新网站配置','[{\"aboutMe\":\"🍀个人简介\\n\\n普通人\",\"aliCode\":\"https://upload.haoxx.site/cloud/images/image_2.jpg\",\"articleCover\":\"https://upload.haoxx.site/config/27c7f38a329c07159a80315712680ea5.jpg\",\"authorAvatar\":\"https://upload.haoxx.site/config/5bbb6dc8be42f3e96dbcc7d7529dc402.gif\",\"bilibili\":\"https://space.bilibili.com/505715511\",\"commentCheck\":0,\"createSiteTime\":\"2023-06-06\",\"emailNotice\":1,\"gitee\":\"https://gitee.com/wu_shengdong\",\"github\":\"https://github.com/ICAN1999\",\"id\":1,\"isMusic\":0,\"isReward\":0,\"loginList\":\",gitee\",\"messageCheck\":0,\"musicId\":\"7611185981\",\"qq\":\"1632167813\",\"recordNumber\":\"渝ICP备2023001651号-2\",\"siteAddress\":\"https://www.haoxx.site\",\"siteAuthor\":\"小鱼\",\"siteIntro\":\"网站介绍\",\"siteName\":\"HaoXX`s Blog\",\"siteNotice\":\"个人学习资料记录\",\"socialList\":\"gitee,bilibili,github,qq\",\"touristAvatar\":\"https://upload.haoxx.site/config/0b04691f25e400a708caba867be171d0.jpg\",\"userAvatar\":\"https://upload.haoxx.site/config/e94fc60e58a570ecc3e9ddcb334fdb2b.jpg\",\"weiXinCode\":\"https://upload.haoxx.site/cloud/images/image_1.jpg\"}]','PUT','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',17,'2023-06-07 17:13:36');
INSERT INTO `t_operation_log` VALUES (1210,'网站配置模块','修改','/admin/site/update','com.ican.controller.SiteConfigController.updateSiteConfig','更新网站配置','[{\"aboutMe\":\"🍀个人简介\\n\\n普通人\",\"aliCode\":\"https://upload.haoxx.site/cloud/images/image_2.jpg\",\"articleCover\":\"https://upload.haoxx.site/config/27c7f38a329c07159a80315712680ea5.jpg\",\"authorAvatar\":\"https://upload.haoxx.site/config/5bbb6dc8be42f3e96dbcc7d7529dc402.gif\",\"bilibili\":\"https://space.bilibili.com/505715511\",\"commentCheck\":0,\"createSiteTime\":\"2023-06-06\",\"emailNotice\":1,\"gitee\":\"https://gitee.com/wu_shengdong\",\"github\":\"https://github.com/XiaoYuer2022\",\"id\":1,\"isMusic\":0,\"isReward\":0,\"loginList\":\",gitee\",\"messageCheck\":0,\"musicId\":\"7611185981\",\"qq\":\"1632167813\",\"recordNumber\":\"渝ICP备2023001651号-2\",\"siteAddress\":\"https://www.haoxx.site\",\"siteAuthor\":\"小鱼\",\"siteIntro\":\"网站介绍\",\"siteName\":\"HaoXX`s Blog\",\"siteNotice\":\"个人学习资料记录\",\"socialList\":\"gitee,bilibili,github,qq\",\"touristAvatar\":\"https://upload.haoxx.site/config/0b04691f25e400a708caba867be171d0.jpg\",\"userAvatar\":\"https://upload.haoxx.site/config/e94fc60e58a570ecc3e9ddcb334fdb2b.jpg\",\"weiXinCode\":\"https://upload.haoxx.site/cloud/images/image_1.jpg\"}]','PUT','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',12,'2023-06-07 17:13:47');
INSERT INTO `t_operation_log` VALUES (1211,'网站配置模块','修改','/admin/site/update','com.ican.controller.SiteConfigController.updateSiteConfig','更新网站配置','[{\"aboutMe\":\"🍀个人简介\\n\\n普通人\",\"aliCode\":\"https://upload.haoxx.site/cloud/images/image_2.jpg\",\"articleCover\":\"https://upload.haoxx.site/config/27c7f38a329c07159a80315712680ea5.jpg\",\"authorAvatar\":\"https://upload.haoxx.site/config/5bbb6dc8be42f3e96dbcc7d7529dc402.gif\",\"bilibili\":\"https://space.bilibili.com/505715511\",\"commentCheck\":0,\"createSiteTime\":\"2023-06-06\",\"emailNotice\":1,\"gitee\":\"https://gitee.com/wu_shengdong\",\"github\":\"https://github.com/XiaoYuer2022\",\"id\":1,\"isMusic\":0,\"isReward\":0,\"loginList\":\",gitee\",\"messageCheck\":0,\"musicId\":\"7611185981\",\"qq\":\"508506630\",\"recordNumber\":\"渝ICP备2023001651号-2\",\"siteAddress\":\"https://www.haoxx.site\",\"siteAuthor\":\"小鱼\",\"siteIntro\":\"网站介绍\",\"siteName\":\"HaoXX`s Blog\",\"siteNotice\":\"个人学习资料记录\",\"socialList\":\"gitee,bilibili,github,qq\",\"touristAvatar\":\"https://upload.haoxx.site/config/0b04691f25e400a708caba867be171d0.jpg\",\"userAvatar\":\"https://upload.haoxx.site/config/e94fc60e58a570ecc3e9ddcb334fdb2b.jpg\",\"weiXinCode\":\"https://upload.haoxx.site/cloud/images/image_1.jpg\"}]','PUT','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',25,'2023-06-07 17:13:52');
INSERT INTO `t_operation_log` VALUES (1212,'文章模块','添加','/admin/article/add','com.ican.controller.ArticleController.addArticle','添加文章','[{\"articleContent\":\"---\\ntitle: 进程与线程笔记\\ndate: 2023-4-12\\ntags:\\n - 进程与线程\\ncategories:\\n - 未分类\\n\\n---\\n\\n# 一、创建进程/线程：\\n\\n1、进程创建pid_t fork(void); 说明：fork - create a child process\\n\\n包含头：\\\\#include \\\\<unistd.h\\\\>\\n\\n返回值：创建成功，则在父进程中返回子进程的PID，在子进程中返回0。创建失败，在父进程中返回-1。\\n\\n2、进程创建pid_t vfork(void); 说明：vfork - create a child process and block parent\\n\\n包含头：\\\\#include \\\\<sys/types.h\\\\>\\n\\n\\\\#include \\\\<unistd.h\\\\>\\n\\n3、线程创建int pthread_create(pthread_t \\\\*thread, const pthread_attr_t \\\\*attr,\\n\\nvoid \\\\*(\\\\*start_routine) (void \\\\*), void \\\\*arg);\\n\\n包含头：\\\\#include \\\\<pthread.h\\\\>\\n\\n注意; Compile and link with -pthread.\\n\\n返回值：创建成功返回0，否则返回错误值。\\n\\n参数：\\n\\n1.  pthread_t \\\\*thread：传递一个 pthread_t 类型的指针变量，也可以直接传递某个 pthread_t 类型变量的地址。pthread_t 是一种用于表示线程的数据类型，每一个 pthread_t 类型的变量都可以表示一个线程。\\n2.  const pthread_attr_t \\\\*attr：用于手动设置新建线程的属性，例如线程的调用策略、线程所能使用的栈内存的大小等。大部分场景中，我们都不需要手动修改线程的属性，将 attr 参数赋值为 NULL，pthread_create() 函数会采用系统默认的属性值创建线程。\\n3.  void \\\\*(\\\\*start_routine) (void \\\\*)：以函数指针的方式指明新建线程需要执行的函数，该函数的参数最多有 1 个（可以省略不写），形参和返回值的类型都必须为 void\\\\* 类型。void\\\\* 类型又称空指针类型，表明指针所指数据的类型是未知的。使用此类型指针时，我们通常需要先对其进行强制类型转换，然后才能正常访问指针指向的数据。\\n4.  void \\\\*arg：指定传递给 start_routine 函数的实参，当不需要传递任何数据时，将 arg 赋值为 NULL 即可。\\n\\n\\\\*\\\\*如果成功创建线程，pthread_create() 函数返回数字 0，反之返回非零值。各个非零值都对应着不同的宏，指明创建失败的原因，常见的宏有以下几种：\\n\\nEAGAIN：系统资源不足，无法提供创建线程所需的资源。\\n\\nEINVAL：传递给 pthread_create() 函数的 attr 参数无效。\\n\\nEPERM：传递给 pthread_create() 函数的 attr 参数中，某些属性的设置为非法操作，程序没有相关的设置权限。\\n\\n\\\\*\\\\*以上这些宏都声明在 \\\\<errno.h\\\\> 头文件中，如果程序中想使用这些宏，需提前引入此头文件。\\n\\n\\\\*\\\\*示例：\\n\\nvoid \\\\*receive(void \\\\*pth_arg) {}\\n\\npthread_t id;\\n\\npthread_create(&id,NULL,receive,(void\\\\*)cfd);\\n\\n# 二、创建和使用进程/线程时的一些问题：\\n\\n## 1、fork()和vfork()函数的区别：\\n\\n![](media进程与线程笔记/d9b061df62171b02e7a445e1d176c593.png)\\n\\n为什么会有vfork，因为以前的fork 很傻， 它创建一个子进程时，将会创建一个新的地址\\n\\n空间，并且拷贝父进程的资源，而往往在子进程中会执行exec 调用，这样，前面的拷贝工\\n\\n作就是白费力气了，这种情况下，聪明的人就想出了vfork，它产生的子进程刚开始暂时与\\n\\n父进程共享地址空间（其实就是线程的概念了），因为这时候子进程在父进程的地址空间中\\n\\n运行，所以子进程不能进行写操作，并且在儿子 霸占着老子的房子时候，要委屈老子一\\n\\n下了，让他在外面歇着（阻塞），一旦儿子执行了exec 或者exit 后，相 于儿子买了自己的\\n\\n房子了，这时候就相于分家了。\\n\\n参考： <https://blog.csdn.net/jianchi88/article/details/6985326>\\n\\n在代码中获得当前进程pid的函数为：getpid()；\\n\\n在代码中获得当前进程父进程pid的函数为：getppid()。\\n\\n## 2、fork()功能简介：\\n\\n![](media进程与线程笔记/d1f2e482b131c2aac315142934b97807.png)\\n\\n![](media进程与线程笔记/dffc560d52616dd91c7a30860543c238.png)\\n\\n参考：https://blog.csdn.net/qq_38410730/article/details/81193118\\n\\n![](media进程与线程笔记/a480238e9c3785af646f9d776e569797.png)\\n\\n![](media进程与线程笔记/c2a7079ed0d2e0959a02775cfc93798f.png)\\n\\n这里需要注明一点：**父子进程的调度的顺序是由调度器决定的，与进程的创建顺序无关。**\\n\\n**\\\\*\\\\***还记得之前的图吗？子进程与父进程共享程序代码，而数据区、栈区、系统栈区相互独立。因此，父进程的代码实际上父、子进程要各执行一次。为了让父子进程执行不同的程序，有两种办法：1是在if(pid==0)中执行子程序特有的程序，2在子进程中调用execv()函数集。\\n\\n在实际应用中，通常调用execv()的都是子进程。人们之所以创建一个子进程，其目的就是执行一个与父进程代码不同的程序，而系统调用execv()就是子进程执行一个新程序的手段之一。子进程调用execv()之后，系统会立即为子进程加载可执行文件分配私有程序内存空间，从此子进程也成为一个真正的进程。\\n\\n如果说子进程是父进程的“儿子”，那么子进程在调用execv()之前，它所具有的单独用户堆栈和数据区也仅相当于它的私有“房间”；但因它还没有自己的“住房”，因此也只能寄住在“父亲”家，而不能“自立门户”，尽管它有自己的“户口”（进程控制块）。\\n\\n![](media进程与线程笔记/c9dd37b5aeb33abe47b944c4fa8bed5f.png)\\n\\n![](media进程与线程笔记/ebe07dbeff2c5d9943d4d094dca4ca93.png) \\n\\n![](media进程与线程笔记/af808190d54947777f6c8ee2e8d91687.png)\\n\\n![](media进程与线程笔记/36cf0a7153422dfaf17386b3796366c4.png)\\n\\n调用exec系列函数的前后，父子进程的关系变化如下图所示：\\n\\n![](media进程与线程笔记/02a6d45da336592e5cb66280578c295e.png) \\n\\n![](media进程与线程笔记/6d0a2a04a3119ad47edcabd7349d4673.png)\\n\\n为了避免子进程成为孤儿进程，父进程应该要等子进程结束并销毁子进程后才可以退出。因此，父进程中应设置系统调用wait()，子进程中应设置退出函数exit()。\\n\\n![](media进程与线程笔记/f58553028c983dc7f5284ea0f6ff8f10.png)\\n\\n![](media进程与线程笔记/5cb46546d42be10317ef6f30ce6d2fa3.png)\\n\\n![](media进程与线程笔记/ef46427ce1d4b7268ae4baed43486364.png)\\n\\n![](media进程与线程笔记/dcb7db7fed64b2b783a84f14c2324fc0.png)\\n\\n## 3、vfork()的进一步说明：\\n\\n![](media进程与线程笔记/5529093d85e5635aa1effa437df22107.png)\\n\\n## 4、线程的基本使用：\\n\\n![](media进程与线程笔记/5f24fbd285b131e20cf48c931def0d45.png)\\n\\n参考资料：https://blog.csdn.net/yi_chengyu/article/details/120412980\\n\\n![](media进程与线程笔记/b329e9b72442e377d0ab3e954626d92a.png)\\n\\n## 5、线程与进程\\n\\n![](media进程与线程笔记/eeec806437bfc7f6d52f615ef7078477.png)\\n\\n![](media进程与线程笔记/6f23ed4e0dfc3ec691de15324db383a4.png)\\n\\n![](media进程与线程笔记/ae2a762c612c3978c89eac5acbea13ad.png)\\n\\n## 6、fork与vfork\\n\\n![](media进程与线程笔记/ae42db34e057eaba61295c7337e7c546.png)\\n\\n![](media进程与线程笔记/5341a44ed914b07567b7dc18abdb8390.png)\",\"articleCover\":\"\",\"articleTitle\":\"进程与线程笔记\",\"articleType\":1,\"categoryName\":\"未分类\",\"isRecommend\":0,\"isTop\":0,\"status\":1,\"tagNameList\":[\"进程与线程\",\"操作系统\"]}]','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',48,'2023-06-07 18:18:00');
INSERT INTO `t_operation_log` VALUES (1213,'文章模块','添加','/admin/article/add','com.ican.controller.ArticleController.addArticle','添加文章','[{\"articleContent\":\"---\\ntitle: 进程间通信学习内容\\ndate: 2023-4-12\\ntags:\\n - 进程间通信\\ncategories:\\n - 未分类\\n\\n---\\n\\n![](media进程间通信学习内容/84e8bfe1bdfb66b1da75e06ca2c9fc33.png)![](media进程间通信学习内容/43d8a1d63838b68102c493a773adb831.png)![](media进程间通信学习内容/20ec88f94bff808a8bcdbbd7e00c08cd.png)\\n\\n## 一、定义介绍\\n\\n1. **管道：**管道是Linux 中进程间通信的一种方式，它把一个程序的输出直接连接到另一个程序的输入。Linux 的管道主要包括两种：无名管道和命名管道。\\n\\n   1. **管道（无名管道）**\\n\\n      **（1）无名管道**\\n\\n无名管道有几个重要的限制：\\n\\n无名管道是半双工的，数据只能在一个方向上流动，A进程传给B进程，不能反向传递管道只能用于父子进程或兄弟进程之间的通信，即具有亲缘关系的进程。\\n\\n无名管道的特点：\\n\\n1）无名管道是半双工的\\n\\n2）无名管道没有名字：只能用于父子进程或者兄弟进程之间（具有亲缘关系的进程）。\\n\\n3）无名管道不是普通的文件，并且只存在与内存中。\\n\\n4）无名管道的缓冲区是有限的，该缓冲区的大小为4Kbyte。\\n\\n1.  **命名管道：**命名管道是一种特殊类型的文件，它在系统中以文件形式存在。这样克服了无名管道的弊端，他可以允许没有亲缘关系的进程间通信。\\n\\n命名管道特点：\\n\\n1）FIFO在文件系统中作为一个特殊的文件而存在。\\n\\n2）虽然FIFO文件存在于文件系统中，但FIFO中的内容却存放在内存中，在Linux中，该缓冲区的大小为4Kbyte。\\n\\n3）FIFO有名字，不同的进程可以通过该命名管道进行通信\\n\\n4）FIFO所传送的数据是无格式的。\\n\\n5）从FIFO读数据是一次性操作，数据一旦被读，它就从FIFO中被抛弃，释放空间以便写更多的数据。\\n\\n6）当共享FIFO的进程执行完所有的I/O操作以后，FIFO将继续保存在文件系统中以便以后使用。\\n\\n1.  **信号：**信号是软件层次上对中断机制的一种模拟，是一种异步通信方式，进程不必通过任何操作来等待信号的到达。信号可以在用户空间进程和内核之间直接交互，内核可以利用信号来通知用户空间的进程发生了哪些系统事件。\\n\\n信号的来源有两种：硬件来源（如键盘ctrl+c），软件来源（kill, raise, alarm和setitimer以及sigqueue函数，当然还包括一些非法操作）；\\n\\n操作系统对信号的处理方式：1）忽略；有两个信号是不能忽略的：SIGKLL和SIGSTOP；2）捕捉，执行对应的信号处理程序；3）缺省，执行默认操作。\\n\\n1.  **消息队列：**消息队列是内核地址空间中的内部链表，具有特定的格式,存放在内存中并由消息队列标识符标识，并且允许一个或多个进程向它写入与读取消息。消息队列通过Linux内核在各个进程直接传递内容，消息顺序地发送到消息队列中，并以几种不同的方式从队列中获得，每个消息队列可以用IPC标识符唯一地进行识别。\\n\\n消息队列克服了信号承载信息量少的问题，管道只能承载无格式字符流。\\n\\n1.  **信号量：**信号量实质上就是一个标识可用资源数量的计数器，它的值总是非负整数。它们常常被用作一个锁机制，在某个进程正在对特定的资源进行操作时，信号量可以防止另一个进程去访问它。\\n\\n信号量可细分为：二值信号量和计数信号量\\n\\n信号量是一种特殊的变量，它只取正整数值并且只允许对这个值进行两种操作：等待（wait）和信号（signal）。（P、V操作，P用于申请资源，V用于释放资源）。\\n\\n1.  **共享内存：**共享内存是在多个进程之间共享内存区域的一种进程间的通信方式，使得多个进程可以直接读写同一块内存空间，它是针对其他通信机制运行效率较低而设计的。共享内存由IPC为进程创建的一个特殊地址范围，为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间。进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率。\\n\\n需要注意的是：共享内存并未提供同步机制，在一个进程结束对共享内存的写操作之前，并无自动机制可以阻止另二个进程开始对它进行读取。所以，我们通常需要用其他的机制来同步对共享内存的访问。\\n\\n1.  **内存映射：**内存映射，是将一个文件映射到一块内存的方法。内存映射文件与虚拟内存有些类似，通过内存映射文件可以保留一个地址的区域，同时将物理存储器提交给此区域，内存文件映射的物理存储器来自一个已经存在于磁盘上的文件，而且在对该文件进行操作之前必须首先对文件进行映射。使用内存映射文件处理存储于磁盘上的文件时，将不必再对文件执行I/O操作。每一个使用该机制的进程通过把同一个共享的文件映射到自己的进程地址空间来实现多个进程间的通信（这里类似于共享内存，只要有一个进程对这块映射文件的内存进行操作，其他进程也能够马上看到）。\\n2.  **套接字socket：**套接字是更为基础的进程间通信机制，与其他方式不同的是，套接字可用于不同机器之间的进程间通信。在Linux中，套接字是基于网络的，它也有自己的家族名字--AF_INET。\\n\\n## 二、详细函数接口说明\\n\\n参考资料：知识点讲解<https://blog.csdn.net/a987073381/article/details/52006729>\\n\\n代码示例：<https://blog.csdn.net/zqixiao_09/article/details/50485047> （上）\\n\\n（下，缺个消息队列）[https://blog.csdn.net/zqixiao_09/article/details/50498874?utm_medium=distribute.pc_relevant.none-task-blog-2\\\\~default\\\\~baidujs_title\\\\~default-0.no_search_link&spm=1001.2101.3001.4242.1](https://blog.csdn.net/zqixiao_09/article/details/50498874?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-0.no_search_link&spm=1001.2101.3001.4242.1)\\n\\n消息队列：<https://blog.csdn.net/qq_27664167/article/details/81712887>\\n\\n1、管道\\n\\n1.1无名管道\\n\\n![](media进程间通信学习内容/05438e1a57a775323713c45100ac9b5f.png)\\n\\n![](media进程间通信学习内容/630cb06c3086ffba6fb203a5a3ae317b.png)\\n\\n通过使用底层的read和write调用来访问数据。向file_descriptor[1]写数据，从file_descriptor[0]中读数据。写入与读取的顺序原则是先进先出。\\n\\n1.2 命名管道\\n\\n命名管道是一种特殊类型的文件，它在系统中以文件形式存在。这样克服了无名管道的弊端，他可以允许没有亲缘关系的进程间通信。\\n\\n![](media进程间通信学习内容/47fae86680ce79a7ed24d7237c1d16dc.png)\\n\\n编程示例：\\n\\n\\\\#include \\\\<sys/types.h\\\\>\\n\\n\\\\#include \\\\<sys/stat.h\\\\>\\n\\nint mkfifo(const char \\\\*filename,mode_t mode); //建立一个名字为filename的命名管道，参数mode为该文件的权限（mode%\\\\~umask），若成功则返回0，否则返回-1，错误原因存于errno中。\\n\\neg.mkfifo( \\\"/tmp/cmd_pipe\\\", S_IFIFO \\\\| 0666 );\\n\\n具体操作方法只要创建了一个命名管道然后就可以使用open、read、write等系统调用来操作。创建可以手工创建或者程序中创建。\\n\\nint mknod(const char \\\\*path, mode_t mode, dev_t dev); //第一个参数表示你要创建的文件的名称，第二个参数表示文件类型，第三个参数表示该文件对应的设备文件的设备号。只有当文件类型为 S_IFCHR 或 S_IFBLK 的时候该文件才有设备号，创建普通文件时传入0即可。\\n\\neg.mknod(FIFO_FILE,S_IFIFO\\\\|0666,0);\\n\\n![](media进程间通信学习内容/c0bdec69bc1cc87001a1903296feba86.png)\\n\\n2、信号\\n\\n信号机制是unix系统中最为古老的进程之间的通信机制，用于一个或几个进程之间传递异步信号。信号可以有各种异步事件产生，比如键盘中断等。shell也可以使用信号将作业控制命令传递给它的子进程。\\n\\n在此列出几个简单使用方法定义：\\n\\n![](media进程间通信学习内容/a55a1d964faddbc271c37e56f0588cde.png)\\n\\n3、消息队列\\n\\nMsgget() msgsnd() msgrcv() msgctl()\\n\\n4、信号量（Semaphore）\\n\\nSemget() semop() sembuf\\n\\n5、共享内存（Share Memory）\\n\\nShmget() shmat() shmdt()\\n\\n6、内存映射（Memory Map）\\n\\n\\\\*mmap() munmap() msync()\\n\\n7、套接字\\n\\n套接字的创建和使用与管道是有区别的，套接字 明确地将客户端与服务器 区分开来，可以实现多个客户端连到同一服务器。\\n\\n服务器套接字连接过程描述：\\n\\n首先，服务器应用程序用socket创建一个套接字，它是系统分配服务器进程的类似文件描述符的资源。 接着，服务器调用bind给套接字命名。这个名字是一个标示符，它允许linux将进入的针对特定端口的连接转到正确的服务器进程。 然后，系统调用listen函数开始接听，等待客户端连接。listen创建一个队列并将其用于存放来自客户端的进入连接。 当客户端调用connect请求连接时，服务器调用accept接受客户端连接，accept此时会创建一个新套接字，用于与这个客户端进行通信。\\n\\n客户端套接字连接过程描述：\\n\\n客户端首先调用socket创建一个未命名套接字，让后将服务器的命名套接字作为地址来调用connect与服务器建立连接。\\n\\n只要双方连接建立成功，我们就可以像操作底层文件一样来操作socket套接字实现通信。\\n\\n1.  管道\\n\\n管道实际是用于进程间通信的一段共享内存，创建管道的进程称为管道服务器，连接到一个管道的进程为管道客户机。一个进程在向管道写入数据后，另一进程就可以从管道的另一端将其读取出来。\\n\\n管道的特点：\\n\\n1)、管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道；\\n\\n2)、 只能用于父子进程或者兄弟进程之间（ 具有亲缘关系的进程）。 比如fork或exec创建的新进程， 在使用exec创建新进程时，需要将管道的文件描述符作为参数传递给exec创建的新进程。 当父进程与使用fork创建的子进程直接通信时，发送数据的进程关闭读端，接受数据的进程关闭写端。\\n\\n3)、单独构成一种独立的文件系统：管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在与内存中。\\n\\n4)、数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。\\n\\n通过使用底层的read和write调用来访问数据。 向 file_descriptor[1]写 数据，从 file_descriptor[0]中 读数据。写入与读取的顺序原则是 先进先出。\\n\\n![](media进程间通信学习内容/3a10aa097584f54f8b871ad0fc8668e6.png)\\n\\n1.  命名管道mkfifo\\n2.  信号signal\\n3.  消息队列 （本质是 链表）\\n4.  信号量\\n5.  共享内存：（需要信号量辅助读写的先后顺序）效率最高。\\n\\n采用共享内存通信的一个显而易见的好处就是**效率高**，因为进程可以直接读写内存，而**不需要任何数据的拷贝**。对于像管道和消息队列等通信方式，则需要在内核和用户控件进行四次数据的拷贝，而**共享内存只拷贝两次数据：一次从输入文件到共享区，另一次从共享内存区到输出文件**。实际上，进程之间在共享内存时，并不总是读写少量数据后就解除映射，有新的通信时，再重新建立共享内存区域。而是保持共享区域，知道通信完毕为止，这样，数据内同一直保存在共享内存中，并没有写回文件。共享内存中的内容往往是在接触映射时才写回文件的。因此，采用共享内存的通信方式效率是最高的。\\n\\n共享内存最大不足之处在意，由于多个进程对同一块内存区域具有访问的权限，**各个进程之间的同步问题显得尤为重要**。必须控制同一时刻只有一个进程对共享内存区域写入数据，否则会造成数据的混乱。同步控制问题可以由信号量来解决；\",\"articleCover\":\"\",\"articleTitle\":\"进程间通信\",\"articleType\":1,\"categoryName\":\"未分类\",\"isRecommend\":0,\"isTop\":0,\"status\":1,\"tagNameList\":[]}]','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',26,'2023-06-07 18:18:42');
INSERT INTO `t_operation_log` VALUES (1214,'文章模块','修改','/admin/article/update','com.ican.controller.ArticleController.updateArticle','修改文章','[{\"articleContent\":\"---\\ntitle: 进程与线程笔记\\ndate: 2023-4-12\\ntags:\\n - 进程与线程\\ncategories:\\n - 未分类\\n---\\n# 一、创建进程/线程：\\n\\n1、进程创建pid_t fork(void); 说明：fork - create a child process\\n\\n包含头：\\\\#include \\\\<unistd.h\\\\>\\n\\n返回值：创建成功，则在父进程中返回子进程的PID，在子进程中返回0。创建失败，在父进程中返回-1。\\n\\n2、进程创建pid_t vfork(void); 说明：vfork - create a child process and block parent\\n\\n包含头：\\\\#include \\\\<sys/types.h\\\\>\\n\\n\\\\#include \\\\<unistd.h\\\\>\\n\\n3、线程创建int pthread_create(pthread_t \\\\*thread, const pthread_attr_t \\\\*attr,\\n\\nvoid \\\\*(\\\\*start_routine) (void \\\\*), void \\\\*arg);\\n\\n包含头：\\\\#include \\\\<pthread.h\\\\>\\n\\n注意; Compile and link with -pthread.\\n\\n返回值：创建成功返回0，否则返回错误值。\\n\\n参数：\\n\\n1.  pthread_t \\\\*thread：传递一个 pthread_t 类型的指针变量，也可以直接传递某个 pthread_t 类型变量的地址。pthread_t 是一种用于表示线程的数据类型，每一个 pthread_t 类型的变量都可以表示一个线程。\\n2.  const pthread_attr_t \\\\*attr：用于手动设置新建线程的属性，例如线程的调用策略、线程所能使用的栈内存的大小等。大部分场景中，我们都不需要手动修改线程的属性，将 attr 参数赋值为 NULL，pthread_create() 函数会采用系统默认的属性值创建线程。\\n3.  void \\\\*(\\\\*start_routine) (void \\\\*)：以函数指针的方式指明新建线程需要执行的函数，该函数的参数最多有 1 个（可以省略不写），形参和返回值的类型都必须为 void\\\\* 类型。void\\\\* 类型又称空指针类型，表明指针所指数据的类型是未知的。使用此类型指针时，我们通常需要先对其进行强制类型转换，然后才能正常访问指针指向的数据。\\n4.  void \\\\*arg：指定传递给 start_routine 函数的实参，当不需要传递任何数据时，将 arg 赋值为 NULL 即可。\\n\\n\\\\*\\\\*如果成功创建线程，pthread_create() 函数返回数字 0，反之返回非零值。各个非零值都对应着不同的宏，指明创建失败的原因，常见的宏有以下几种：\\n\\nEAGAIN：系统资源不足，无法提供创建线程所需的资源。\\n\\nEINVAL：传递给 pthread_create() 函数的 attr 参数无效。\\n\\nEPERM：传递给 pthread_create() 函数的 attr 参数中，某些属性的设置为非法操作，程序没有相关的设置权限。\\n\\n\\\\*\\\\*以上这些宏都声明在 \\\\<errno.h\\\\> 头文件中，如果程序中想使用这些宏，需提前引入此头文件。\\n\\n\\\\*\\\\*示例：\\n\\nvoid \\\\*receive(void \\\\*pth_arg) {}\\n\\npthread_t id;\\n\\npthread_create(&id,NULL,receive,(void\\\\*)cfd);\\n\\n# 二、创建和使用进程/线程时的一些问题：\\n\\n## 1、fork()和vfork()函数的区别：\\n\\n![](https://haoxx.top/images/files/media_jx_note/d9b061df62171b02e7a445e1d176c593.png)\\n\\n为什么会有vfork，因为以前的fork 很傻， 它创建一个子进程时，将会创建一个新的地址\\n\\n空间，并且拷贝父进程的资源，而往往在子进程中会执行exec 调用，这样，前面的拷贝工\\n\\n作就是白费力气了，这种情况下，聪明的人就想出了vfork，它产生的子进程刚开始暂时与\\n\\n父进程共享地址空间（其实就是线程的概念了），因为这时候子进程在父进程的地址空间中\\n\\n运行，所以子进程不能进行写操作，并且在儿子 霸占着老子的房子时候，要委屈老子一\\n\\n下了，让他在外面歇着（阻塞），一旦儿子执行了exec 或者exit 后，相 于儿子买了自己的\\n\\n房子了，这时候就相于分家了。\\n\\n参考： <https://blog.csdn.net/jianchi88/article/details/6985326>\\n\\n在代码中获得当前进程pid的函数为：getpid()；\\n\\n在代码中获得当前进程父进程pid的函数为：getppid()。\\n\\n## 2、fork()功能简介：\\n\\n![](https://haoxx.top/images/files/media_jx_note/d1f2e482b131c2aac315142934b97807.png)\\n\\n![](https://haoxx.top/images/files/media_jx_note/dffc560d52616dd91c7a30860543c238.png)\\n\\n参考：https://blog.csdn.net/qq_38410730/article/details/81193118\\n\\n![](https://haoxx.top/images/files/media_jx_note/a480238e9c3785af646f9d776e569797.png)\\n\\n![](https://haoxx.top/images/files/media_jx_note/c2a7079ed0d2e0959a02775cfc93798f.png)\\n\\n这里需要注明一点：**父子进程的调度的顺序是由调度器决定的，与进程的创建顺序无关。**\\n\\n**\\\\*\\\\***还记得之前的图吗？子进程与父进程共享程序代码，而数据区、栈区、系统栈区相互独立。因此，父进程的代码实际上父、子进程要各执行一次。为了让父子进程执行不同的程序，有两种办法：1是在if(pid==0)中执行子程序特有的程序，2在子进程中调用execv()函数集。\\n\\n在实际应用中，通常调用execv()的都是子进程。人们之所以创建一个子进程，其目的就是执行一个与父进程代码不同的程序，而系统调用execv()就是子进程执行一个新程序的手段之一。子进程调用execv()之后，系统会立即为子进程加载可执行文件分配私有程序内存空间，从此子进程也成为一个真正的进程。\\n\\n如果说子进程是父进程的“儿子”，那么子进程在调用execv()之前，它所具有的单独用户堆栈和数据区也仅相当于它的私有“房间”；但因它还没有自己的“住房”，因此也只能寄住在“父亲”家，而不能“自立门户”，尽管它有自己的“户口”（进程控制块）。\\n\\n![](https://haoxx.top/images/files/media_jx_note/c9dd37b5aeb33abe47b944c4fa8bed5f.png)\\n\\n![](https://haoxx.top/images/files/media_jx_note/ebe07dbeff2c5d9943d4d094dca4ca93.png) \\n\\n![](https://haoxx.top/images/files/media_jx_note/af808190d54947777f6c8ee2e8d91687.png)\\n\\n![](https://haoxx.top/images/files/media_jx_note/36cf0a7153422dfaf17386b3796366c4.png)\\n\\n调用exec系列函数的前后，父子进程的关系变化如下图所示：\\n\\n![](https://haoxx.top/images/files/media_jx_note/02a6d45da336592e5cb66280578c295e.png) \\n\\n![](https://haoxx.top/images/files/media_jx_note/6d0a2a04a3119ad47edcabd7349d4673.png)\\n\\n为了避免子进程成为孤儿进程，父进程应该要等子进程结束并销毁子进程后才可以退出。因此，父进程中应设置系统调用wait()，子进程中应设置退出函数exit()。\\n\\n![](https://haoxx.top/images/files/media_jx_note/f58553028c983dc7f5284ea0f6ff8f10.png)\\n\\n![](https://haoxx.top/images/files/media_jx_note/5cb46546d42be10317ef6f30ce6d2fa3.png)\\n\\n![](https://haoxx.top/images/files/media_jx_note/ef46427ce1d4b7268ae4baed43486364.png)\\n\\n![](https://haoxx.top/images/files/media_jx_note/dcb7db7fed64b2b783a84f14c2324fc0.png)\\n\\n## 3、vfork()的进一步说明：\\n\\n![](https://haoxx.top/images/files/media_jx_note/5529093d85e5635aa1effa437df22107.png)\\n\\n## 4、线程的基本使用：\\n\\n![](https://haoxx.top/images/files/media_jx_note/5f24fbd285b131e20cf48c931def0d45.png)\\n\\n参考资料：https://blog.csdn.net/yi_chengyu/article/details/120412980\\n\\n![](https://haoxx.top/images/files/media_jx_note/b329e9b72442e377d0ab3e954626d92a.png)\\n\\n## 5、线程与进程\\n\\n![](https://haoxx.top/images/files/media_jx_note/eeec806437bfc7f6d52f615ef7078477.png)\\n\\n![](https://haoxx.top/images/files/media_jx_note/6f23ed4e0dfc3ec691de15324db383a4.png)\\n\\n![](https://haoxx.top/images/files/media_jx_note/ae2a762c612c3978c89eac5acbea13ad.png)\\n\\n## 6、fork与vfork\\n\\n![](https://haoxx.top/images/files/media_jx_note/ae42db34e057eaba61295c7337e7c546.png)\\n\\n![](https://haoxx.top/images/files/media_jx_note/5341a44ed914b07567b7dc18abdb8390.png)\\n\",\"articleCover\":\"https://upload.haoxx.site/config/27c7f38a329c07159a80315712680ea5.jpg\",\"articleTitle\":\"进程间通信笔记\",\"articleType\":1,\"categoryName\":\"未分类\",\"id\":104,\"isRecommend\":0,\"isTop\":0,\"status\":1,\"tagNameList\":[]}]','PUT','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',19,'2023-06-07 18:39:40');
INSERT INTO `t_operation_log` VALUES (1215,'文章模块','修改','/admin/article/update','com.ican.controller.ArticleController.updateArticle','修改文章','[{\"articleContent\":\"---\\ntitle: 进程与线程笔记\\ndate: 2023-4-12\\ntags:\\n - 进程与线程\\ncategories:\\n - 未分类\\n---\\n# 一、创建进程/线程：\\n\\n1、进程创建pid_t fork(void); 说明：fork - create a child process\\n\\n包含头：\\\\#include \\\\<unistd.h\\\\>\\n\\n返回值：创建成功，则在父进程中返回子进程的PID，在子进程中返回0。创建失败，在父进程中返回-1。\\n\\n2、进程创建pid_t vfork(void); 说明：vfork - create a child process and block parent\\n\\n包含头：\\\\#include \\\\<sys/types.h\\\\>\\n\\n\\\\#include \\\\<unistd.h\\\\>\\n\\n3、线程创建int pthread_create(pthread_t \\\\*thread, const pthread_attr_t \\\\*attr,\\n\\nvoid \\\\*(\\\\*start_routine) (void \\\\*), void \\\\*arg);\\n\\n包含头：\\\\#include \\\\<pthread.h\\\\>\\n\\n注意; Compile and link with -pthread.\\n\\n返回值：创建成功返回0，否则返回错误值。\\n\\n参数：\\n\\n1.  pthread_t \\\\*thread：传递一个 pthread_t 类型的指针变量，也可以直接传递某个 pthread_t 类型变量的地址。pthread_t 是一种用于表示线程的数据类型，每一个 pthread_t 类型的变量都可以表示一个线程。\\n2.  const pthread_attr_t \\\\*attr：用于手动设置新建线程的属性，例如线程的调用策略、线程所能使用的栈内存的大小等。大部分场景中，我们都不需要手动修改线程的属性，将 attr 参数赋值为 NULL，pthread_create() 函数会采用系统默认的属性值创建线程。\\n3.  void \\\\*(\\\\*start_routine) (void \\\\*)：以函数指针的方式指明新建线程需要执行的函数，该函数的参数最多有 1 个（可以省略不写），形参和返回值的类型都必须为 void\\\\* 类型。void\\\\* 类型又称空指针类型，表明指针所指数据的类型是未知的。使用此类型指针时，我们通常需要先对其进行强制类型转换，然后才能正常访问指针指向的数据。\\n4.  void \\\\*arg：指定传递给 start_routine 函数的实参，当不需要传递任何数据时，将 arg 赋值为 NULL 即可。\\n\\n\\\\*\\\\*如果成功创建线程，pthread_create() 函数返回数字 0，反之返回非零值。各个非零值都对应着不同的宏，指明创建失败的原因，常见的宏有以下几种：\\n\\nEAGAIN：系统资源不足，无法提供创建线程所需的资源。\\n\\nEINVAL：传递给 pthread_create() 函数的 attr 参数无效。\\n\\nEPERM：传递给 pthread_create() 函数的 attr 参数中，某些属性的设置为非法操作，程序没有相关的设置权限。\\n\\n\\\\*\\\\*以上这些宏都声明在 \\\\<errno.h\\\\> 头文件中，如果程序中想使用这些宏，需提前引入此头文件。\\n\\n\\\\*\\\\*示例：\\n\\nvoid \\\\*receive(void \\\\*pth_arg) {}\\n\\npthread_t id;\\n\\npthread_create(&id,NULL,receive,(void\\\\*)cfd);\\n\\n# 二、创建和使用进程/线程时的一些问题：\\n\\n## 1、fork()和vfork()函数的区别：\\n\\n![](https://haoxx.top/images/files/media_jx_note/d9b061df62171b02e7a445e1d176c593.png)\\n\\n为什么会有vfork，因为以前的fork 很傻， 它创建一个子进程时，将会创建一个新的地址\\n\\n空间，并且拷贝父进程的资源，而往往在子进程中会执行exec 调用，这样，前面的拷贝工\\n\\n作就是白费力气了，这种情况下，聪明的人就想出了vfork，它产生的子进程刚开始暂时与\\n\\n父进程共享地址空间（其实就是线程的概念了），因为这时候子进程在父进程的地址空间中\\n\\n运行，所以子进程不能进行写操作，并且在儿子 霸占着老子的房子时候，要委屈老子一\\n\\n下了，让他在外面歇着（阻塞），一旦儿子执行了exec 或者exit 后，相 于儿子买了自己的\\n\\n房子了，这时候就相于分家了。\\n\\n参考： <https://blog.csdn.net/jianchi88/article/details/6985326>\\n\\n在代码中获得当前进程pid的函数为：getpid()；\\n\\n在代码中获得当前进程父进程pid的函数为：getppid()。\\n\\n## 2、fork()功能简介：\\n\\n![](https://haoxx.top/images/files/media_jx_note/d1f2e482b131c2aac315142934b97807.png)\\n\\n![](https://haoxx.top/images/files/media_jx_note/dffc560d52616dd91c7a30860543c238.png)\\n\\n参考：https://blog.csdn.net/qq_38410730/article/details/81193118\\n\\n![](https://haoxx.top/images/files/media_jx_note/a480238e9c3785af646f9d776e569797.png)\\n\\n![](https://haoxx.top/images/files/media_jx_note/c2a7079ed0d2e0959a02775cfc93798f.png)\\n\\n这里需要注明一点：**父子进程的调度的顺序是由调度器决定的，与进程的创建顺序无关。**\\n\\n**\\\\*\\\\***还记得之前的图吗？子进程与父进程共享程序代码，而数据区、栈区、系统栈区相互独立。因此，父进程的代码实际上父、子进程要各执行一次。为了让父子进程执行不同的程序，有两种办法：1是在if(pid==0)中执行子程序特有的程序，2在子进程中调用execv()函数集。\\n\\n在实际应用中，通常调用execv()的都是子进程。人们之所以创建一个子进程，其目的就是执行一个与父进程代码不同的程序，而系统调用execv()就是子进程执行一个新程序的手段之一。子进程调用execv()之后，系统会立即为子进程加载可执行文件分配私有程序内存空间，从此子进程也成为一个真正的进程。\\n\\n如果说子进程是父进程的“儿子”，那么子进程在调用execv()之前，它所具有的单独用户堆栈和数据区也仅相当于它的私有“房间”；但因它还没有自己的“住房”，因此也只能寄住在“父亲”家，而不能“自立门户”，尽管它有自己的“户口”（进程控制块）。\\n\\n![](https://haoxx.top/images/files/media_jx_note/c9dd37b5aeb33abe47b944c4fa8bed5f.png)\\n\\n![](https://haoxx.top/images/files/media_jx_note/ebe07dbeff2c5d9943d4d094dca4ca93.png) \\n\\n![](https://haoxx.top/images/files/media_jx_note/af808190d54947777f6c8ee2e8d91687.png)\\n\\n![](https://haoxx.top/images/files/media_jx_note/36cf0a7153422dfaf17386b3796366c4.png)\\n\\n调用exec系列函数的前后，父子进程的关系变化如下图所示：\\n\\n![](https://haoxx.top/images/files/media_jx_note/02a6d45da336592e5cb66280578c295e.png) \\n\\n![](https://haoxx.top/images/files/media_jx_note/6d0a2a04a3119ad47edcabd7349d4673.png)\\n\\n为了避免子进程成为孤儿进程，父进程应该要等子进程结束并销毁子进程后才可以退出。因此，父进程中应设置系统调用wait()，子进程中应设置退出函数exit()。\\n\\n![](https://haoxx.top/images/files/media_jx_note/f58553028c983dc7f5284ea0f6ff8f10.png)\\n\\n![](https://haoxx.top/images/files/media_jx_note/5cb46546d42be10317ef6f30ce6d2fa3.png)\\n\\n![](https://haoxx.top/images/files/media_jx_note/ef46427ce1d4b7268ae4baed43486364.png)\\n\\n![](https://haoxx.top/images/files/media_jx_note/dcb7db7fed64b2b783a84f14c2324fc0.png)\\n\\n## 3、vfork()的进一步说明：\\n\\n![](https://haoxx.top/images/files/media_jx_note/5529093d85e5635aa1effa437df22107.png)\\n\\n## 4、线程的基本使用：\\n\\n![](https://haoxx.top/images/files/media_jx_note/5f24fbd285b131e20cf48c931def0d45.png)\\n\\n参考资料：https://blog.csdn.net/yi_chengyu/article/details/120412980\\n\\n![](https://haoxx.top/images/files/media_jx_note/b329e9b72442e377d0ab3e954626d92a.png)\\n\\n## 5、线程与进程\\n\\n![](https://haoxx.top/images/files/media_jx_note/eeec806437bfc7f6d52f615ef7078477.png)\\n\\n![](https://haoxx.top/images/files/media_jx_note/6f23ed4e0dfc3ec691de15324db383a4.png)\\n\\n![](https://haoxx.top/images/files/media_jx_note/ae2a762c612c3978c89eac5acbea13ad.png)\\n\\n## 6、fork与vfork\\n\\n![](https://haoxx.top/images/files/media_jx_note/ae42db34e057eaba61295c7337e7c546.png)\\n\\n![](https://haoxx.top/images/files/media_jx_note/5341a44ed914b07567b7dc18abdb8390.png)\\n\",\"articleCover\":\"https://upload.haoxx.site/config/27c7f38a329c07159a80315712680ea5.jpg\",\"articleTitle\":\"进程与线程笔记\",\"articleType\":1,\"categoryName\":\"未分类\",\"id\":103,\"isRecommend\":0,\"isTop\":0,\"status\":1,\"tagNameList\":[]}]','PUT','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',38,'2023-06-07 18:40:50');
INSERT INTO `t_operation_log` VALUES (1216,'文章模块','修改','/admin/article/recycle','com.ican.controller.ArticleController.updateArticleDelete','回收或恢复文章','[{\"idList\":[104],\"isDelete\":1}]','PUT','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',30,'2023-06-07 18:42:00');
INSERT INTO `t_operation_log` VALUES (1217,'文章模块','删除','/admin/article/delete','com.ican.controller.ArticleController.deleteArticle','删除文章','[[104]]','DELETE','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',11,'2023-06-07 18:42:03');
INSERT INTO `t_operation_log` VALUES (1218,'文章模块','添加','/admin/article/add','com.ican.controller.ArticleController.addArticle','添加文章','[{\"articleContent\":\"---\\ntitle: 进程间通信学习内容\\ndate: 2023-4-12\\ntags:\\n - 进程间通信\\ncategories:\\n - 未分类\\n---\\n\\n![](https://haoxx.top/images/files/media_jx_content//84e8bfe1bdfb66b1da75e06ca2c9fc33.png)\\n\\n![](https://haoxx.top/images/files/media_jx_content//43d8a1d63838b68102c493a773adb831.png)\\n\\n![](https://haoxx.top/images/files/media_jx_content//20ec88f94bff808a8bcdbbd7e00c08cd.png)\\n\\n## 一、定义介绍\\n\\n1.  **管道：**管道是Linux 中进程间通信的一种方式，它把一个程序的输出直接连接到另一个程序的输入。Linux 的管道主要包括两种：无名管道和命名管道。\\n    1.  **管道（无名管道）**\\n\\n        **（1）无名管道**\\n\\n无名管道有几个重要的限制：\\n\\n无名管道是半双工的，数据只能在一个方向上流动，A进程传给B进程，不能反向传递管道只能用于父子进程或兄弟进程之间的通信，即具有亲缘关系的进程。\\n\\n无名管道的特点：\\n\\n1）无名管道是半双工的\\n\\n2）无名管道没有名字：只能用于父子进程或者兄弟进程之间（具有亲缘关系的进程）。\\n\\n3）无名管道不是普通的文件，并且只存在与内存中。\\n\\n4）无名管道的缓冲区是有限的，该缓冲区的大小为4Kbyte。\\n\\n1.  **命名管道：**命名管道是一种特殊类型的文件，它在系统中以文件形式存在。这样克服了无名管道的弊端，他可以允许没有亲缘关系的进程间通信。\\n\\n命名管道特点：\\n\\n1）FIFO在文件系统中作为一个特殊的文件而存在。\\n\\n2）虽然FIFO文件存在于文件系统中，但FIFO中的内容却存放在内存中，在Linux中，该缓冲区的大小为4Kbyte。\\n\\n3）FIFO有名字，不同的进程可以通过该命名管道进行通信\\n\\n4）FIFO所传送的数据是无格式的。\\n\\n5）从FIFO读数据是一次性操作，数据一旦被读，它就从FIFO中被抛弃，释放空间以便写更多的数据。\\n\\n6）当共享FIFO的进程执行完所有的I/O操作以后，FIFO将继续保存在文件系统中以便以后使用。\\n\\n1.  **信号：**信号是软件层次上对中断机制的一种模拟，是一种异步通信方式，进程不必通过任何操作来等待信号的到达。信号可以在用户空间进程和内核之间直接交互，内核可以利用信号来通知用户空间的进程发生了哪些系统事件。\\n\\n信号的来源有两种：硬件来源（如键盘ctrl+c），软件来源（kill, raise, alarm和setitimer以及sigqueue函数，当然还包括一些非法操作）；\\n\\n操作系统对信号的处理方式：1）忽略；有两个信号是不能忽略的：SIGKLL和SIGSTOP；2）捕捉，执行对应的信号处理程序；3）缺省，执行默认操作。\\n\\n1.  **消息队列：**消息队列是内核地址空间中的内部链表，具有特定的格式,存放在内存中并由消息队列标识符标识，并且允许一个或多个进程向它写入与读取消息。消息队列通过Linux内核在各个进程直接传递内容，消息顺序地发送到消息队列中，并以几种不同的方式从队列中获得，每个消息队列可以用IPC标识符唯一地进行识别。\\n\\n消息队列克服了信号承载信息量少的问题，管道只能承载无格式字符流。\\n\\n1.  **信号量：**信号量实质上就是一个标识可用资源数量的计数器，它的值总是非负整数。它们常常被用作一个锁机制，在某个进程正在对特定的资源进行操作时，信号量可以防止另一个进程去访问它。\\n\\n信号量可细分为：二值信号量和计数信号量\\n\\n信号量是一种特殊的变量，它只取正整数值并且只允许对这个值进行两种操作：等待（wait）和信号（signal）。（P、V操作，P用于申请资源，V用于释放资源）。\\n\\n1.  **共享内存：**共享内存是在多个进程之间共享内存区域的一种进程间的通信方式，使得多个进程可以直接读写同一块内存空间，它是针对其他通信机制运行效率较低而设计的。共享内存由IPC为进程创建的一个特殊地址范围，为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间。进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率。\\n\\n需要注意的是：共享内存并未提供同步机制，在一个进程结束对共享内存的写操作之前，并无自动机制可以阻止另二个进程开始对它进行读取。所以，我们通常需要用其他的机制来同步对共享内存的访问。\\n\\n1.  **内存映射：**内存映射，是将一个文件映射到一块内存的方法。内存映射文件与虚拟内存有些类似，通过内存映射文件可以保留一个地址的区域，同时将物理存储器提交给此区域，内存文件映射的物理存储器来自一个已经存在于磁盘上的文件，而且在对该文件进行操作之前必须首先对文件进行映射。使用内存映射文件处理存储于磁盘上的文件时，将不必再对文件执行I/O操作。每一个使用该机制的进程通过把同一个共享的文件映射到自己的进程地址空间来实现多个进程间的通信（这里类似于共享内存，只要有一个进程对这块映射文件的内存进行操作，其他进程也能够马上看到）。\\n2.  **套接字socket：**套接字是更为基础的进程间通信机制，与其他方式不同的是，套接字可用于不同机器之间的进程间通信。在Linux中，套接字是基于网络的，它也有自己的家族名字--AF_INET。\\n\\n## 二、详细函数接口说明\\n\\n参考资料：知识点讲解<https://blog.csdn.net/a987073381/article/details/52006729>\\n\\n代码示例：<https://blog.csdn.net/zqixiao_09/article/details/50485047> （上）\\n\\n（下，缺个消息队列）[https://blog.csdn.net/zqixiao_09/article/details/50498874?utm_medium=distribute.pc_relevant.none-task-blog-2\\\\~default\\\\~baidujs_title\\\\~default-0.no_search_link&spm=1001.2101.3001.4242.1](https://blog.csdn.net/zqixiao_09/article/details/50498874?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-0.no_search_link&spm=1001.2101.3001.4242.1)\\n\\n消息队列：<https://blog.csdn.net/qq_27664167/article/details/81712887>\\n\\n1、管道\\n\\n1.1无名管道\\n\\n![](https://haoxx.top/images/files/media_jx_content//05438e1a57a775323713c45100ac9b5f.png)\\n\\n![](https://haoxx.top/images/files/media_jx_content//630cb06c3086ffba6fb203a5a3ae317b.png)\\n\\n通过使用底层的read和write调用来访问数据。向file_descriptor[1]写数据，从file_descriptor[0]中读数据。写入与读取的顺序原则是先进先出。\\n\\n1.2 命名管道\\n\\n命名管道是一种特殊类型的文件，它在系统中以文件形式存在。这样克服了无名管道的弊端，他可以允许没有亲缘关系的进程间通信。\\n\\n![](https://haoxx.top/images/files/media_jx_content//47fae86680ce79a7ed24d7237c1d16dc.png)\\n\\n编程示例：\\n\\n\\\\#include \\\\<sys/types.h\\\\>\\n\\n\\\\#include \\\\<sys/stat.h\\\\>\\n\\nint mkfifo(const char \\\\*filename,mode_t mode); //建立一个名字为filename的命名管道，参数mode为该文件的权限（mode%\\\\~umask），若成功则返回0，否则返回-1，错误原因存于errno中。\\n\\neg.mkfifo( \\\"/tmp/cmd_pipe\\\", S_IFIFO \\\\| 0666 );\\n\\n具体操作方法只要创建了一个命名管道然后就可以使用open、read、write等系统调用来操作。创建可以手工创建或者程序中创建。\\n\\nint mknod(const char \\\\*path, mode_t mode, dev_t dev); //第一个参数表示你要创建的文件的名称，第二个参数表示文件类型，第三个参数表示该文件对应的设备文件的设备号。只有当文件类型为 S_IFCHR 或 S_IFBLK 的时候该文件才有设备号，创建普通文件时传入0即可。\\n\\neg.mknod(FIFO_FILE,S_IFIFO\\\\|0666,0);\\n\\n![](https://haoxx.top/images/files/media_jx_content//c0bdec69bc1cc87001a1903296feba86.png)\\n\\n2、信号\\n\\n信号机制是unix系统中最为古老的进程之间的通信机制，用于一个或几个进程之间传递异步信号。信号可以有各种异步事件产生，比如键盘中断等。shell也可以使用信号将作业控制命令传递给它的子进程。\\n\\n在此列出几个简单使用方法定义：\\n\\n![](https://haoxx.top/images/files/media_jx_content//a55a1d964faddbc271c37e56f0588cde.png)\\n\\n3、消息队列\\n\\nMsgget() msgsnd() msgrcv() msgctl()\\n\\n4、信号量（Semaphore）\\n\\nSemget() semop() sembuf\\n\\n5、共享内存（Share Memory）\\n\\nShmget() shmat() shmdt()\\n\\n6、内存映射（Memory Map）\\n\\n\\\\*mmap() munmap() msync()\\n\\n7、套接字\\n\\n套接字的创建和使用与管道是有区别的，套接字 明确地将客户端与服务器 区分开来，可以实现多个客户端连到同一服务器。\\n\\n服务器套接字连接过程描述：\\n\\n首先，服务器应用程序用socket创建一个套接字，它是系统分配服务器进程的类似文件描述符的资源。 接着，服务器调用bind给套接字命名。这个名字是一个标示符，它允许linux将进入的针对特定端口的连接转到正确的服务器进程。 然后，系统调用listen函数开始接听，等待客户端连接。listen创建一个队列并将其用于存放来自客户端的进入连接。 当客户端调用connect请求连接时，服务器调用accept接受客户端连接，accept此时会创建一个新套接字，用于与这个客户端进行通信。\\n\\n客户端套接字连接过程描述：\\n\\n客户端首先调用socket创建一个未命名套接字，让后将服务器的命名套接字作为地址来调用connect与服务器建立连接。\\n\\n只要双方连接建立成功，我们就可以像操作底层文件一样来操作socket套接字实现通信。\\n\\n1.  管道\\n\\n管道实际是用于进程间通信的一段共享内存，创建管道的进程称为管道服务器，连接到一个管道的进程为管道客户机。一个进程在向管道写入数据后，另一进程就可以从管道的另一端将其读取出来。\\n\\n管道的特点：\\n\\n1)、管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道；\\n\\n2)、 只能用于父子进程或者兄弟进程之间（ 具有亲缘关系的进程）。 比如fork或exec创建的新进程， 在使用exec创建新进程时，需要将管道的文件描述符作为参数传递给exec创建的新进程。 当父进程与使用fork创建的子进程直接通信时，发送数据的进程关闭读端，接受数据的进程关闭写端。\\n\\n3)、单独构成一种独立的文件系统：管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在与内存中。\\n\\n4)、数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。\\n\\n通过使用底层的read和write调用来访问数据。 向 file_descriptor[1]写 数据，从 file_descriptor[0]中 读数据。写入与读取的顺序原则是 先进先出。\\n\\n![](https://haoxx.top/images/files/media_jx_content//3a10aa097584f54f8b871ad0fc8668e6.png)\\n\\n1.  命名管道mkfifo\\n2.  信号signal\\n3.  消息队列 （本质是 链表）\\n4.  信号量\\n5.  共享内存：（需要信号量辅助读写的先后顺序）效率最高。\\n\\n采用共享内存通信的一个显而易见的好处就是**效率高**，因为进程可以直接读写内存，而**不需要任何数据的拷贝**。对于像管道和消息队列等通信方式，则需要在内核和用户控件进行四次数据的拷贝，而**共享内存只拷贝两次数据：一次从输入文件到共享区，另一次从共享内存区到输出文件**。实际上，进程之间在共享内存时，并不总是读写少量数据后就解除映射，有新的通信时，再重新建立共享内存区域。而是保持共享区域，知道通信完毕为止，这样，数据内同一直保存在共享内存中，并没有写回文件。共享内存中的内容往往是在接触映射时才写回文件的。因此，采用共享内存的通信方式效率是最高的。\\n\\n共享内存最大不足之处在意，由于多个进程对同一块内存区域具有访问的权限，**各个进程之间的同步问题显得尤为重要**。必须控制同一时刻只有一个进程对共享内存区域写入数据，否则会造成数据的混乱。同步控制问题可以由信号量来解决；\\n\",\"articleCover\":\"\",\"articleTitle\":\"进程和线程间通信学习内容\",\"articleType\":1,\"categoryName\":\"操作系统与计算机组成原理\",\"isRecommend\":0,\"isTop\":0,\"status\":1,\"tagNameList\":[]}]','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',28,'2023-06-07 18:43:08');
INSERT INTO `t_operation_log` VALUES (1219,'文章模块','修改','/admin/article/update','com.ican.controller.ArticleController.updateArticle','修改文章','[{\"articleContent\":\"---\\ntitle: 进程与线程笔记\\ndate: 2023-4-12\\ntags:\\n - 进程与线程\\ncategories:\\n - 未分类\\n---\\n# 一、创建进程/线程：\\n\\n1、进程创建pid_t fork(void); 说明：fork - create a child process\\n\\n包含头：\\\\#include \\\\<unistd.h\\\\>\\n\\n返回值：创建成功，则在父进程中返回子进程的PID，在子进程中返回0。创建失败，在父进程中返回-1。\\n\\n2、进程创建pid_t vfork(void); 说明：vfork - create a child process and block parent\\n\\n包含头：\\\\#include \\\\<sys/types.h\\\\>\\n\\n\\\\#include \\\\<unistd.h\\\\>\\n\\n3、线程创建int pthread_create(pthread_t \\\\*thread, const pthread_attr_t \\\\*attr,\\n\\nvoid \\\\*(\\\\*start_routine) (void \\\\*), void \\\\*arg);\\n\\n包含头：\\\\#include \\\\<pthread.h\\\\>\\n\\n注意; Compile and link with -pthread.\\n\\n返回值：创建成功返回0，否则返回错误值。\\n\\n参数：\\n\\n1.  pthread_t \\\\*thread：传递一个 pthread_t 类型的指针变量，也可以直接传递某个 pthread_t 类型变量的地址。pthread_t 是一种用于表示线程的数据类型，每一个 pthread_t 类型的变量都可以表示一个线程。\\n2.  const pthread_attr_t \\\\*attr：用于手动设置新建线程的属性，例如线程的调用策略、线程所能使用的栈内存的大小等。大部分场景中，我们都不需要手动修改线程的属性，将 attr 参数赋值为 NULL，pthread_create() 函数会采用系统默认的属性值创建线程。\\n3.  void \\\\*(\\\\*start_routine) (void \\\\*)：以函数指针的方式指明新建线程需要执行的函数，该函数的参数最多有 1 个（可以省略不写），形参和返回值的类型都必须为 void\\\\* 类型。void\\\\* 类型又称空指针类型，表明指针所指数据的类型是未知的。使用此类型指针时，我们通常需要先对其进行强制类型转换，然后才能正常访问指针指向的数据。\\n4.  void \\\\*arg：指定传递给 start_routine 函数的实参，当不需要传递任何数据时，将 arg 赋值为 NULL 即可。\\n\\n\\\\*\\\\*如果成功创建线程，pthread_create() 函数返回数字 0，反之返回非零值。各个非零值都对应着不同的宏，指明创建失败的原因，常见的宏有以下几种：\\n\\nEAGAIN：系统资源不足，无法提供创建线程所需的资源。\\n\\nEINVAL：传递给 pthread_create() 函数的 attr 参数无效。\\n\\nEPERM：传递给 pthread_create() 函数的 attr 参数中，某些属性的设置为非法操作，程序没有相关的设置权限。\\n\\n\\\\*\\\\*以上这些宏都声明在 \\\\<errno.h\\\\> 头文件中，如果程序中想使用这些宏，需提前引入此头文件。\\n\\n\\\\*\\\\*示例：\\n\\nvoid \\\\*receive(void \\\\*pth_arg) {}\\n\\npthread_t id;\\n\\npthread_create(&id,NULL,receive,(void\\\\*)cfd);\\n\\n# 二、创建和使用进程/线程时的一些问题：\\n\\n## 1、fork()和vfork()函数的区别：\\n\\n![](https://haoxx.top/images/files/media_jx_note/d9b061df62171b02e7a445e1d176c593.png)\\n\\n为什么会有vfork，因为以前的fork 很傻， 它创建一个子进程时，将会创建一个新的地址\\n\\n空间，并且拷贝父进程的资源，而往往在子进程中会执行exec 调用，这样，前面的拷贝工\\n\\n作就是白费力气了，这种情况下，聪明的人就想出了vfork，它产生的子进程刚开始暂时与\\n\\n父进程共享地址空间（其实就是线程的概念了），因为这时候子进程在父进程的地址空间中\\n\\n运行，所以子进程不能进行写操作，并且在儿子 霸占着老子的房子时候，要委屈老子一\\n\\n下了，让他在外面歇着（阻塞），一旦儿子执行了exec 或者exit 后，相 于儿子买了自己的\\n\\n房子了，这时候就相于分家了。\\n\\n参考： <https://blog.csdn.net/jianchi88/article/details/6985326>\\n\\n在代码中获得当前进程pid的函数为：getpid()；\\n\\n在代码中获得当前进程父进程pid的函数为：getppid()。\\n\\n## 2、fork()功能简介：\\n\\n![](https://haoxx.top/images/files/media_jx_note/d1f2e482b131c2aac315142934b97807.png)\\n\\n![](https://haoxx.top/images/files/media_jx_note/dffc560d52616dd91c7a30860543c238.png)\\n\\n参考：https://blog.csdn.net/qq_38410730/article/details/81193118\\n\\n![](https://haoxx.top/images/files/media_jx_note/a480238e9c3785af646f9d776e569797.png)\\n\\n![](https://haoxx.top/images/files/media_jx_note/c2a7079ed0d2e0959a02775cfc93798f.png)\\n\\n这里需要注明一点：**父子进程的调度的顺序是由调度器决定的，与进程的创建顺序无关。**\\n\\n**\\\\*\\\\***还记得之前的图吗？子进程与父进程共享程序代码，而数据区、栈区、系统栈区相互独立。因此，父进程的代码实际上父、子进程要各执行一次。为了让父子进程执行不同的程序，有两种办法：1是在if(pid==0)中执行子程序特有的程序，2在子进程中调用execv()函数集。\\n\\n在实际应用中，通常调用execv()的都是子进程。人们之所以创建一个子进程，其目的就是执行一个与父进程代码不同的程序，而系统调用execv()就是子进程执行一个新程序的手段之一。子进程调用execv()之后，系统会立即为子进程加载可执行文件分配私有程序内存空间，从此子进程也成为一个真正的进程。\\n\\n如果说子进程是父进程的“儿子”，那么子进程在调用execv()之前，它所具有的单独用户堆栈和数据区也仅相当于它的私有“房间”；但因它还没有自己的“住房”，因此也只能寄住在“父亲”家，而不能“自立门户”，尽管它有自己的“户口”（进程控制块）。\\n\\n![](https://haoxx.top/images/files/media_jx_note/c9dd37b5aeb33abe47b944c4fa8bed5f.png)\\n\\n![](https://haoxx.top/images/files/media_jx_note/ebe07dbeff2c5d9943d4d094dca4ca93.png) \\n\\n![](https://haoxx.top/images/files/media_jx_note/af808190d54947777f6c8ee2e8d91687.png)\\n\\n![](https://haoxx.top/images/files/media_jx_note/36cf0a7153422dfaf17386b3796366c4.png)\\n\\n调用exec系列函数的前后，父子进程的关系变化如下图所示：\\n\\n![](https://haoxx.top/images/files/media_jx_note/02a6d45da336592e5cb66280578c295e.png) \\n\\n![](https://haoxx.top/images/files/media_jx_note/6d0a2a04a3119ad47edcabd7349d4673.png)\\n\\n为了避免子进程成为孤儿进程，父进程应该要等子进程结束并销毁子进程后才可以退出。因此，父进程中应设置系统调用wait()，子进程中应设置退出函数exit()。\\n\\n![](https://haoxx.top/images/files/media_jx_note/f58553028c983dc7f5284ea0f6ff8f10.png)\\n\\n![](https://haoxx.top/images/files/media_jx_note/5cb46546d42be10317ef6f30ce6d2fa3.png)\\n\\n![](https://haoxx.top/images/files/media_jx_note/ef46427ce1d4b7268ae4baed43486364.png)\\n\\n![](https://haoxx.top/images/files/media_jx_note/dcb7db7fed64b2b783a84f14c2324fc0.png)\\n\\n## 3、vfork()的进一步说明：\\n\\n![](https://haoxx.top/images/files/media_jx_note/5529093d85e5635aa1effa437df22107.png)\\n\\n## 4、线程的基本使用：\\n\\n![](https://haoxx.top/images/files/media_jx_note/5f24fbd285b131e20cf48c931def0d45.png)\\n\\n参考资料：https://blog.csdn.net/yi_chengyu/article/details/120412980\\n\\n![](https://haoxx.top/images/files/media_jx_note/b329e9b72442e377d0ab3e954626d92a.png)\\n\\n## 5、线程与进程\\n\\n![](https://haoxx.top/images/files/media_jx_note/eeec806437bfc7f6d52f615ef7078477.png)\\n\\n![](https://haoxx.top/images/files/media_jx_note/6f23ed4e0dfc3ec691de15324db383a4.png)\\n\\n![](https://haoxx.top/images/files/media_jx_note/ae2a762c612c3978c89eac5acbea13ad.png)\\n\\n## 6、fork与vfork\\n\\n![](https://haoxx.top/images/files/media_jx_note/ae42db34e057eaba61295c7337e7c546.png)\\n\\n![](https://haoxx.top/images/files/media_jx_note/5341a44ed914b07567b7dc18abdb8390.png)\\n\",\"articleCover\":\"https://upload.haoxx.site/config/27c7f38a329c07159a80315712680ea5.jpg\",\"articleTitle\":\"进程与线程笔记\",\"articleType\":1,\"categoryName\":\"操作系统与计算机组成原理\",\"id\":103,\"isRecommend\":0,\"isTop\":0,\"status\":1,\"tagNameList\":[]}]','PUT','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',24,'2023-06-07 18:43:21');
INSERT INTO `t_operation_log` VALUES (1220,'相册模块','上传','/admin/album/upload','com.ican.controller.AlbumController.uploadAlbumCover','上传相册封面','下载.jpg','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/24319fa48171a24c8adf1eb0c6680f17.jpg\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',44,'2023-06-07 19:14:22');
INSERT INTO `t_operation_log` VALUES (1221,'相册模块','修改','/admin/album/update','com.ican.controller.AlbumController.updateAlbum','修改相册','[{\"albumCover\":\"https://upload.haoxx.site/photo/24319fa48171a24c8adf1eb0c6680f17.jpg\",\"albumDesc\":\"存放了文章中的部分图片\",\"albumName\":\"文章内置图片册\",\"id\":2,\"status\":1}]','PUT','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',27,'2023-06-07 19:14:26');
INSERT INTO `t_operation_log` VALUES (1222,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','3a10aa097584f54f8b871ad0fc8668e6.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/3a10aa097584f54f8b871ad0fc8668e6.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',48,'2023-06-07 19:15:01');
INSERT INTO `t_operation_log` VALUES (1223,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','47fae86680ce79a7ed24d7237c1d16dc.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/47fae86680ce79a7ed24d7237c1d16dc.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',53,'2023-06-07 19:15:01');
INSERT INTO `t_operation_log` VALUES (1224,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','20ec88f94bff808a8bcdbbd7e00c08cd.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/20ec88f94bff808a8bcdbbd7e00c08cd.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',53,'2023-06-07 19:15:01');
INSERT INTO `t_operation_log` VALUES (1225,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','c0bdec69bc1cc87001a1903296feba86.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/c0bdec69bc1cc87001a1903296feba86.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',21,'2023-06-07 19:15:01');
INSERT INTO `t_operation_log` VALUES (1226,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','630cb06c3086ffba6fb203a5a3ae317b.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/630cb06c3086ffba6fb203a5a3ae317b.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',28,'2023-06-07 19:15:01');
INSERT INTO `t_operation_log` VALUES (1227,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','84e8bfe1bdfb66b1da75e06ca2c9fc33.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/84e8bfe1bdfb66b1da75e06ca2c9fc33.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',23,'2023-06-07 19:15:01');
INSERT INTO `t_operation_log` VALUES (1228,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','43d8a1d63838b68102c493a773adb831.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/b7cc08bb88c6ef808f23b3202d5763eb.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',32,'2023-06-07 19:15:01');
INSERT INTO `t_operation_log` VALUES (1229,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','a55a1d964faddbc271c37e56f0588cde.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/a55a1d964faddbc271c37e56f0588cde.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',18,'2023-06-07 19:15:03');
INSERT INTO `t_operation_log` VALUES (1230,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','05438e1a57a775323713c45100ac9b5f.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/05438e1a57a775323713c45100ac9b5f.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',12,'2023-06-07 19:15:03');
INSERT INTO `t_operation_log` VALUES (1231,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','3a10aa097584f54f8b871ad0fc8668e6.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/3a10aa097584f54f8b871ad0fc8668e6.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',3,'2023-06-07 19:16:33');
INSERT INTO `t_operation_log` VALUES (1232,'照片模块','添加','/admin/photo/add','com.ican.controller.PhotoController.addPhoto','添加照片','[{\"albumId\":2,\"photoUrlList\":[\"https://upload.haoxx.site/photo/3a10aa097584f54f8b871ad0fc8668e6.png\"]}]','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',51,'2023-06-07 19:16:34');
INSERT INTO `t_operation_log` VALUES (1233,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','20ec88f94bff808a8bcdbbd7e00c08cd.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/20ec88f94bff808a8bcdbbd7e00c08cd.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',10,'2023-06-07 19:16:39');
INSERT INTO `t_operation_log` VALUES (1234,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','43d8a1d63838b68102c493a773adb831.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/b7cc08bb88c6ef808f23b3202d5763eb.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',6,'2023-06-07 19:16:39');
INSERT INTO `t_operation_log` VALUES (1235,'照片模块','添加','/admin/photo/add','com.ican.controller.PhotoController.addPhoto','添加照片','[{\"albumId\":2,\"photoUrlList\":[\"https://upload.haoxx.site/photo/20ec88f94bff808a8bcdbbd7e00c08cd.png\",\"https://upload.haoxx.site/photo/b7cc08bb88c6ef808f23b3202d5763eb.png\"]}]','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',14,'2023-06-07 19:16:40');
INSERT INTO `t_operation_log` VALUES (1236,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','47fae86680ce79a7ed24d7237c1d16dc.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/47fae86680ce79a7ed24d7237c1d16dc.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',3,'2023-06-07 19:16:48');
INSERT INTO `t_operation_log` VALUES (1237,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','84e8bfe1bdfb66b1da75e06ca2c9fc33.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/84e8bfe1bdfb66b1da75e06ca2c9fc33.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',4,'2023-06-07 19:16:48');
INSERT INTO `t_operation_log` VALUES (1238,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','630cb06c3086ffba6fb203a5a3ae317b.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/630cb06c3086ffba6fb203a5a3ae317b.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',3,'2023-06-07 19:16:48');
INSERT INTO `t_operation_log` VALUES (1239,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','05438e1a57a775323713c45100ac9b5f.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/05438e1a57a775323713c45100ac9b5f.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',4,'2023-06-07 19:16:48');
INSERT INTO `t_operation_log` VALUES (1240,'照片模块','添加','/admin/photo/add','com.ican.controller.PhotoController.addPhoto','添加照片','[{\"albumId\":2,\"photoUrlList\":[\"https://upload.haoxx.site/photo/47fae86680ce79a7ed24d7237c1d16dc.png\",\"https://upload.haoxx.site/photo/84e8bfe1bdfb66b1da75e06ca2c9fc33.png\",\"https://upload.haoxx.site/photo/630cb06c3086ffba6fb203a5a3ae317b.png\",\"https://upload.haoxx.site/photo/05438e1a57a775323713c45100ac9b5f.png\"]}]','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',24,'2023-06-07 19:16:50');
INSERT INTO `t_operation_log` VALUES (1241,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','c0bdec69bc1cc87001a1903296feba86.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/c0bdec69bc1cc87001a1903296feba86.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',3,'2023-06-07 19:17:00');
INSERT INTO `t_operation_log` VALUES (1242,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','a55a1d964faddbc271c37e56f0588cde.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/a55a1d964faddbc271c37e56f0588cde.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',3,'2023-06-07 19:17:00');
INSERT INTO `t_operation_log` VALUES (1243,'照片模块','添加','/admin/photo/add','com.ican.controller.PhotoController.addPhoto','添加照片','[{\"albumId\":2,\"photoUrlList\":[\"https://upload.haoxx.site/photo/c0bdec69bc1cc87001a1903296feba86.png\",\"https://upload.haoxx.site/photo/a55a1d964faddbc271c37e56f0588cde.png\"]}]','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',9,'2023-06-07 19:17:01');
INSERT INTO `t_operation_log` VALUES (1244,'文件模块','删除','/admin/file/delete','com.ican.controller.BlogFileController.deleteFile','删除文件','[[129]]','DELETE','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',23,'2023-06-07 19:20:21');
INSERT INTO `t_operation_log` VALUES (1245,'文件模块','删除','/admin/file/delete','com.ican.controller.BlogFileController.deleteFile','删除文件','[[130,131,132,133,134,135,136,137]]','DELETE','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',22,'2023-06-07 19:20:33');
INSERT INTO `t_operation_log` VALUES (1246,'照片模块','删除','/admin/photo/delete','com.ican.controller.PhotoController.deletePhoto','删除照片','[[10,11,12,13,14,15,16,17,18]]','DELETE','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',20,'2023-06-07 19:20:43');
INSERT INTO `t_operation_log` VALUES (1247,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','3a10aa097584f54f8b871ad0fc8668e6.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/3a10aa097584f54f8b871ad0fc8668e6.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',41,'2023-06-07 19:20:55');
INSERT INTO `t_operation_log` VALUES (1248,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','47fae86680ce79a7ed24d7237c1d16dc.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/47fae86680ce79a7ed24d7237c1d16dc.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',18,'2023-06-07 19:20:55');
INSERT INTO `t_operation_log` VALUES (1249,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','20ec88f94bff808a8bcdbbd7e00c08cd.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/20ec88f94bff808a8bcdbbd7e00c08cd.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',36,'2023-06-07 19:20:55');
INSERT INTO `t_operation_log` VALUES (1250,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','43d8a1d63838b68102c493a773adb831.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/b7cc08bb88c6ef808f23b3202d5763eb.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',26,'2023-06-07 19:20:55');
INSERT INTO `t_operation_log` VALUES (1251,'照片模块','添加','/admin/photo/add','com.ican.controller.PhotoController.addPhoto','添加照片','[{\"albumId\":2,\"photoUrlList\":[\"https://upload.haoxx.site/photo/3a10aa097584f54f8b871ad0fc8668e6.png\",\"https://upload.haoxx.site/photo/47fae86680ce79a7ed24d7237c1d16dc.png\",\"https://upload.haoxx.site/photo/20ec88f94bff808a8bcdbbd7e00c08cd.png\",\"https://upload.haoxx.site/photo/b7cc08bb88c6ef808f23b3202d5763eb.png\"]}]','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',24,'2023-06-07 19:20:56');
INSERT INTO `t_operation_log` VALUES (1252,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','630cb06c3086ffba6fb203a5a3ae317b.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/630cb06c3086ffba6fb203a5a3ae317b.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',13,'2023-06-07 19:21:07');
INSERT INTO `t_operation_log` VALUES (1253,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','84e8bfe1bdfb66b1da75e06ca2c9fc33.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/84e8bfe1bdfb66b1da75e06ca2c9fc33.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',16,'2023-06-07 19:21:07');
INSERT INTO `t_operation_log` VALUES (1254,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','a55a1d964faddbc271c37e56f0588cde.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/a55a1d964faddbc271c37e56f0588cde.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',18,'2023-06-07 19:21:07');
INSERT INTO `t_operation_log` VALUES (1255,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','05438e1a57a775323713c45100ac9b5f.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/05438e1a57a775323713c45100ac9b5f.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',13,'2023-06-07 19:21:07');
INSERT INTO `t_operation_log` VALUES (1256,'照片模块','添加','/admin/photo/add','com.ican.controller.PhotoController.addPhoto','添加照片','[{\"albumId\":2,\"photoUrlList\":[\"https://upload.haoxx.site/photo/630cb06c3086ffba6fb203a5a3ae317b.png\",\"https://upload.haoxx.site/photo/84e8bfe1bdfb66b1da75e06ca2c9fc33.png\",\"https://upload.haoxx.site/photo/a55a1d964faddbc271c37e56f0588cde.png\",\"https://upload.haoxx.site/photo/05438e1a57a775323713c45100ac9b5f.png\"]}]','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',17,'2023-06-07 19:21:08');
INSERT INTO `t_operation_log` VALUES (1257,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','c0bdec69bc1cc87001a1903296feba86.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/c0bdec69bc1cc87001a1903296feba86.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',14,'2023-06-07 19:21:12');
INSERT INTO `t_operation_log` VALUES (1258,'照片模块','添加','/admin/photo/add','com.ican.controller.PhotoController.addPhoto','添加照片','[{\"albumId\":2,\"photoUrlList\":[\"https://upload.haoxx.site/photo/c0bdec69bc1cc87001a1903296feba86.png\"]}]','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',10,'2023-06-07 19:21:12');
INSERT INTO `t_operation_log` VALUES (1259,'文件模块','删除','/admin/file/delete','com.ican.controller.BlogFileController.deleteFile','删除文件','[[138,139,140,141,142,143,144,145]]','DELETE','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',28,'2023-06-07 19:33:24');
INSERT INTO `t_operation_log` VALUES (1260,'文件模块','删除','/admin/file/delete','com.ican.controller.BlogFileController.deleteFile','删除文件','[[146]]','DELETE','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',14,'2023-06-07 19:33:28');
INSERT INTO `t_operation_log` VALUES (1261,'照片模块','删除','/admin/photo/delete','com.ican.controller.PhotoController.deletePhoto','删除照片','[[19,20,21,22,23,24,25,26,27]]','DELETE','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',12,'2023-06-07 19:33:53');
INSERT INTO `t_operation_log` VALUES (1262,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','3a10aa097584f54f8b871ad0fc8668e6.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/3a10aa097584f54f8b871ad0fc8668e6.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',12,'2023-06-07 19:34:09');
INSERT INTO `t_operation_log` VALUES (1263,'照片模块','添加','/admin/photo/add','com.ican.controller.PhotoController.addPhoto','添加照片','[{\"albumId\":2,\"photoUrlList\":[\"https://upload.haoxx.site/photo/3a10aa097584f54f8b871ad0fc8668e6.png\"]}]','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',9,'2023-06-07 19:34:10');
INSERT INTO `t_operation_log` VALUES (1264,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','20ec88f94bff808a8bcdbbd7e00c08cd.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/20ec88f94bff808a8bcdbbd7e00c08cd.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',18,'2023-06-07 19:34:14');
INSERT INTO `t_operation_log` VALUES (1265,'照片模块','添加','/admin/photo/add','com.ican.controller.PhotoController.addPhoto','添加照片','[{\"albumId\":2,\"photoUrlList\":[\"https://upload.haoxx.site/photo/20ec88f94bff808a8bcdbbd7e00c08cd.png\"]}]','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',10,'2023-06-07 19:34:15');
INSERT INTO `t_operation_log` VALUES (1266,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','43d8a1d63838b68102c493a773adb831.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/b7cc08bb88c6ef808f23b3202d5763eb.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',13,'2023-06-07 19:34:17');
INSERT INTO `t_operation_log` VALUES (1267,'照片模块','添加','/admin/photo/add','com.ican.controller.PhotoController.addPhoto','添加照片','[{\"albumId\":2,\"photoUrlList\":[\"https://upload.haoxx.site/photo/b7cc08bb88c6ef808f23b3202d5763eb.png\"]}]','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',19,'2023-06-07 19:34:18');
INSERT INTO `t_operation_log` VALUES (1268,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','47fae86680ce79a7ed24d7237c1d16dc.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/47fae86680ce79a7ed24d7237c1d16dc.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',16,'2023-06-07 19:34:21');
INSERT INTO `t_operation_log` VALUES (1269,'照片模块','添加','/admin/photo/add','com.ican.controller.PhotoController.addPhoto','添加照片','[{\"albumId\":2,\"photoUrlList\":[\"https://upload.haoxx.site/photo/47fae86680ce79a7ed24d7237c1d16dc.png\"]}]','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',29,'2023-06-07 19:34:22');
INSERT INTO `t_operation_log` VALUES (1270,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','84e8bfe1bdfb66b1da75e06ca2c9fc33.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/84e8bfe1bdfb66b1da75e06ca2c9fc33.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',24,'2023-06-07 19:34:24');
INSERT INTO `t_operation_log` VALUES (1271,'照片模块','添加','/admin/photo/add','com.ican.controller.PhotoController.addPhoto','添加照片','[{\"albumId\":2,\"photoUrlList\":[\"https://upload.haoxx.site/photo/84e8bfe1bdfb66b1da75e06ca2c9fc33.png\"]}]','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',11,'2023-06-07 19:34:25');
INSERT INTO `t_operation_log` VALUES (1272,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','630cb06c3086ffba6fb203a5a3ae317b.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/630cb06c3086ffba6fb203a5a3ae317b.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',15,'2023-06-07 19:34:30');
INSERT INTO `t_operation_log` VALUES (1273,'照片模块','添加','/admin/photo/add','com.ican.controller.PhotoController.addPhoto','添加照片','[{\"albumId\":2,\"photoUrlList\":[\"https://upload.haoxx.site/photo/630cb06c3086ffba6fb203a5a3ae317b.png\"]}]','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',13,'2023-06-07 19:34:31');
INSERT INTO `t_operation_log` VALUES (1274,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','05438e1a57a775323713c45100ac9b5f.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/05438e1a57a775323713c45100ac9b5f.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',15,'2023-06-07 19:34:36');
INSERT INTO `t_operation_log` VALUES (1275,'照片模块','添加','/admin/photo/add','com.ican.controller.PhotoController.addPhoto','添加照片','[{\"albumId\":2,\"photoUrlList\":[\"https://upload.haoxx.site/photo/05438e1a57a775323713c45100ac9b5f.png\"]}]','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',14,'2023-06-07 19:34:37');
INSERT INTO `t_operation_log` VALUES (1276,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','a55a1d964faddbc271c37e56f0588cde.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/a55a1d964faddbc271c37e56f0588cde.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',13,'2023-06-07 19:34:40');
INSERT INTO `t_operation_log` VALUES (1277,'照片模块','添加','/admin/photo/add','com.ican.controller.PhotoController.addPhoto','添加照片','[{\"albumId\":2,\"photoUrlList\":[\"https://upload.haoxx.site/photo/a55a1d964faddbc271c37e56f0588cde.png\"]}]','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',15,'2023-06-07 19:34:41');
INSERT INTO `t_operation_log` VALUES (1278,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','c0bdec69bc1cc87001a1903296feba86.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/c0bdec69bc1cc87001a1903296feba86.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',12,'2023-06-07 19:34:44');
INSERT INTO `t_operation_log` VALUES (1279,'照片模块','添加','/admin/photo/add','com.ican.controller.PhotoController.addPhoto','添加照片','[{\"albumId\":2,\"photoUrlList\":[\"https://upload.haoxx.site/photo/c0bdec69bc1cc87001a1903296feba86.png\"]}]','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',8,'2023-06-07 19:34:45');
INSERT INTO `t_operation_log` VALUES (1280,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','image_1.jpg','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/ad7853d5d615749634bb5c890e0aad22.jpg\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',18,'2023-06-07 19:39:21');
INSERT INTO `t_operation_log` VALUES (1281,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','image_2.jpg','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/f0cf28ae9184f0e6d9a815b131d5317a.jpg\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',31,'2023-06-07 19:39:21');
INSERT INTO `t_operation_log` VALUES (1282,'照片模块','添加','/admin/photo/add','com.ican.controller.PhotoController.addPhoto','添加照片','[{\"albumId\":1,\"photoUrlList\":[\"https://upload.haoxx.site/photo/ad7853d5d615749634bb5c890e0aad22.jpg\",\"https://upload.haoxx.site/photo/f0cf28ae9184f0e6d9a815b131d5317a.jpg\"]}]','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',11,'2023-06-07 19:39:24');
INSERT INTO `t_operation_log` VALUES (1283,'文件模块','删除','/admin/file/delete','com.ican.controller.BlogFileController.deleteFile','删除文件','[[156]]','DELETE','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',15,'2023-06-07 19:40:51');
INSERT INTO `t_operation_log` VALUES (1284,'文件模块','删除','/admin/file/delete','com.ican.controller.BlogFileController.deleteFile','删除文件','[[157]]','DELETE','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',18,'2023-06-07 19:40:53');
INSERT INTO `t_operation_log` VALUES (1285,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','5529093d85e5635aa1effa437df22107.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/5529093d85e5635aa1effa437df22107.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',13,'2023-06-07 19:41:17');
INSERT INTO `t_operation_log` VALUES (1286,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','ae2a762c612c3978c89eac5acbea13ad.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/ae2a762c612c3978c89eac5acbea13ad.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',12,'2023-06-07 19:41:17');
INSERT INTO `t_operation_log` VALUES (1287,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','d1f2e482b131c2aac315142934b97807.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/d1f2e482b131c2aac315142934b97807.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',23,'2023-06-07 19:41:17');
INSERT INTO `t_operation_log` VALUES (1288,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','589080628386800bbe32bb04420e0977.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/589080628386800bbe32bb04420e0977.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',25,'2023-06-07 19:41:17');
INSERT INTO `t_operation_log` VALUES (1289,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','b329e9b72442e377d0ab3e954626d92a.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/b329e9b72442e377d0ab3e954626d92a.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',13,'2023-06-07 19:41:17');
INSERT INTO `t_operation_log` VALUES (1290,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','c2a7079ed0d2e0959a02775cfc93798f.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/c2a7079ed0d2e0959a02775cfc93798f.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',14,'2023-06-07 19:41:17');
INSERT INTO `t_operation_log` VALUES (1291,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','c9dd37b5aeb33abe47b944c4fa8bed5f.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/c9dd37b5aeb33abe47b944c4fa8bed5f.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',12,'2023-06-07 19:41:17');
INSERT INTO `t_operation_log` VALUES (1292,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','dcb7db7fed64b2b783a84f14c2324fc0.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/dcb7db7fed64b2b783a84f14c2324fc0.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',13,'2023-06-07 19:41:18');
INSERT INTO `t_operation_log` VALUES (1293,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','ebe07dbeff2c5d9943d4d094dca4ca93.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/ebe07dbeff2c5d9943d4d094dca4ca93.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',13,'2023-06-07 19:41:18');
INSERT INTO `t_operation_log` VALUES (1294,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','dffc560d52616dd91c7a30860543c238.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/dffc560d52616dd91c7a30860543c238.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',19,'2023-06-07 19:41:18');
INSERT INTO `t_operation_log` VALUES (1295,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','a480238e9c3785af646f9d776e569797.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/a480238e9c3785af646f9d776e569797.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',15,'2023-06-07 19:41:19');
INSERT INTO `t_operation_log` VALUES (1296,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','d9b061df62171b02e7a445e1d176c593.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/d9b061df62171b02e7a445e1d176c593.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',17,'2023-06-07 19:41:19');
INSERT INTO `t_operation_log` VALUES (1297,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','eeec806437bfc7f6d52f615ef7078477.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/eeec806437bfc7f6d52f615ef7078477.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',19,'2023-06-07 19:41:20');
INSERT INTO `t_operation_log` VALUES (1298,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','5cb46546d42be10317ef6f30ce6d2fa3.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/5cb46546d42be10317ef6f30ce6d2fa3.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',26,'2023-06-07 19:41:20');
INSERT INTO `t_operation_log` VALUES (1299,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','ae42db34e057eaba61295c7337e7c546.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/ae42db34e057eaba61295c7337e7c546.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',12,'2023-06-07 19:41:20');
INSERT INTO `t_operation_log` VALUES (1300,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','02a6d45da336592e5cb66280578c295e.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/02a6d45da336592e5cb66280578c295e.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',33,'2023-06-07 19:41:20');
INSERT INTO `t_operation_log` VALUES (1301,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','f58553028c983dc7f5284ea0f6ff8f10.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/f58553028c983dc7f5284ea0f6ff8f10.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',14,'2023-06-07 19:41:20');
INSERT INTO `t_operation_log` VALUES (1302,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','ef46427ce1d4b7268ae4baed43486364.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/ef46427ce1d4b7268ae4baed43486364.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',27,'2023-06-07 19:41:21');
INSERT INTO `t_operation_log` VALUES (1303,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','6f23ed4e0dfc3ec691de15324db383a4.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/6f23ed4e0dfc3ec691de15324db383a4.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',21,'2023-06-07 19:41:20');
INSERT INTO `t_operation_log` VALUES (1304,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','36cf0a7153422dfaf17386b3796366c4.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/36cf0a7153422dfaf17386b3796366c4.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',12,'2023-06-07 19:41:22');
INSERT INTO `t_operation_log` VALUES (1305,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','6d0a2a04a3119ad47edcabd7349d4673.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/6d0a2a04a3119ad47edcabd7349d4673.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',12,'2023-06-07 19:41:22');
INSERT INTO `t_operation_log` VALUES (1306,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','105c3ca0ae4de6b12b6147b916a61af1.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/105c3ca0ae4de6b12b6147b916a61af1.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',15,'2023-06-07 19:41:22');
INSERT INTO `t_operation_log` VALUES (1307,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','af808190d54947777f6c8ee2e8d91687.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/af808190d54947777f6c8ee2e8d91687.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',31,'2023-06-07 19:41:22');
INSERT INTO `t_operation_log` VALUES (1308,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','5341a44ed914b07567b7dc18abdb8390.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/5341a44ed914b07567b7dc18abdb8390.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',16,'2023-06-07 19:41:22');
INSERT INTO `t_operation_log` VALUES (1309,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','5f24fbd285b131e20cf48c931def0d45.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/5f24fbd285b131e20cf48c931def0d45.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',19,'2023-06-07 19:41:24');
INSERT INTO `t_operation_log` VALUES (1310,'照片模块','添加','/admin/photo/add','com.ican.controller.PhotoController.addPhoto','添加照片','[{\"albumId\":2,\"photoUrlList\":[\"https://upload.haoxx.site/photo/5529093d85e5635aa1effa437df22107.png\",\"https://upload.haoxx.site/photo/ae2a762c612c3978c89eac5acbea13ad.png\",\"https://upload.haoxx.site/photo/d1f2e482b131c2aac315142934b97807.png\",\"https://upload.haoxx.site/photo/589080628386800bbe32bb04420e0977.png\"]}]','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',12,'2023-06-07 19:42:30');
INSERT INTO `t_operation_log` VALUES (1311,'照片模块','删除','/admin/photo/delete','com.ican.controller.PhotoController.deletePhoto','删除照片','[[39,40,41,42]]','DELETE','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',10,'2023-06-07 19:43:05');
INSERT INTO `t_operation_log` VALUES (1312,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','02a6d45da336592e5cb66280578c295e.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/02a6d45da336592e5cb66280578c295e.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',3,'2023-06-07 19:43:13');
INSERT INTO `t_operation_log` VALUES (1313,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','5cb46546d42be10317ef6f30ce6d2fa3.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/5cb46546d42be10317ef6f30ce6d2fa3.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',6,'2023-06-07 19:43:13');
INSERT INTO `t_operation_log` VALUES (1314,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','5f24fbd285b131e20cf48c931def0d45.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/5f24fbd285b131e20cf48c931def0d45.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',10,'2023-06-07 19:43:13');
INSERT INTO `t_operation_log` VALUES (1315,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','6d0a2a04a3119ad47edcabd7349d4673.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/6d0a2a04a3119ad47edcabd7349d4673.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',8,'2023-06-07 19:43:13');
INSERT INTO `t_operation_log` VALUES (1316,'照片模块','添加','/admin/photo/add','com.ican.controller.PhotoController.addPhoto','添加照片','[{\"albumId\":2,\"photoUrlList\":[\"https://upload.haoxx.site/photo/02a6d45da336592e5cb66280578c295e.png\",\"https://upload.haoxx.site/photo/5cb46546d42be10317ef6f30ce6d2fa3.png\",\"https://upload.haoxx.site/photo/5f24fbd285b131e20cf48c931def0d45.png\",\"https://upload.haoxx.site/photo/6d0a2a04a3119ad47edcabd7349d4673.png\"]}]','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',10,'2023-06-07 19:43:16');
INSERT INTO `t_operation_log` VALUES (1317,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','6f23ed4e0dfc3ec691de15324db383a4.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/6f23ed4e0dfc3ec691de15324db383a4.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',4,'2023-06-07 19:43:22');
INSERT INTO `t_operation_log` VALUES (1318,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','105c3ca0ae4de6b12b6147b916a61af1.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/105c3ca0ae4de6b12b6147b916a61af1.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',3,'2023-06-07 19:43:22');
INSERT INTO `t_operation_log` VALUES (1319,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','36cf0a7153422dfaf17386b3796366c4.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/36cf0a7153422dfaf17386b3796366c4.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',4,'2023-06-07 19:43:22');
INSERT INTO `t_operation_log` VALUES (1320,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','5341a44ed914b07567b7dc18abdb8390.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/5341a44ed914b07567b7dc18abdb8390.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',4,'2023-06-07 19:43:22');
INSERT INTO `t_operation_log` VALUES (1321,'照片模块','添加','/admin/photo/add','com.ican.controller.PhotoController.addPhoto','添加照片','[{\"albumId\":2,\"photoUrlList\":[\"https://upload.haoxx.site/photo/6f23ed4e0dfc3ec691de15324db383a4.png\",\"https://upload.haoxx.site/photo/105c3ca0ae4de6b12b6147b916a61af1.png\",\"https://upload.haoxx.site/photo/36cf0a7153422dfaf17386b3796366c4.png\",\"https://upload.haoxx.site/photo/5341a44ed914b07567b7dc18abdb8390.png\"]}]','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',20,'2023-06-07 19:43:26');
INSERT INTO `t_operation_log` VALUES (1322,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','589080628386800bbe32bb04420e0977.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/589080628386800bbe32bb04420e0977.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',4,'2023-06-07 19:43:31');
INSERT INTO `t_operation_log` VALUES (1323,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','ae2a762c612c3978c89eac5acbea13ad.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/ae2a762c612c3978c89eac5acbea13ad.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',4,'2023-06-07 19:43:31');
INSERT INTO `t_operation_log` VALUES (1324,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','a480238e9c3785af646f9d776e569797.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/a480238e9c3785af646f9d776e569797.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',4,'2023-06-07 19:43:31');
INSERT INTO `t_operation_log` VALUES (1325,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','5529093d85e5635aa1effa437df22107.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/5529093d85e5635aa1effa437df22107.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',4,'2023-06-07 19:43:31');
INSERT INTO `t_operation_log` VALUES (1326,'照片模块','添加','/admin/photo/add','com.ican.controller.PhotoController.addPhoto','添加照片','[{\"albumId\":2,\"photoUrlList\":[\"https://upload.haoxx.site/photo/589080628386800bbe32bb04420e0977.png\",\"https://upload.haoxx.site/photo/ae2a762c612c3978c89eac5acbea13ad.png\",\"https://upload.haoxx.site/photo/a480238e9c3785af646f9d776e569797.png\",\"https://upload.haoxx.site/photo/5529093d85e5635aa1effa437df22107.png\"]}]','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',10,'2023-06-07 19:43:32');
INSERT INTO `t_operation_log` VALUES (1327,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','b329e9b72442e377d0ab3e954626d92a.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/b329e9b72442e377d0ab3e954626d92a.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',5,'2023-06-07 19:43:38');
INSERT INTO `t_operation_log` VALUES (1328,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','c2a7079ed0d2e0959a02775cfc93798f.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/c2a7079ed0d2e0959a02775cfc93798f.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',5,'2023-06-07 19:43:38');
INSERT INTO `t_operation_log` VALUES (1329,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','ae42db34e057eaba61295c7337e7c546.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/ae42db34e057eaba61295c7337e7c546.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',22,'2023-06-07 19:43:38');
INSERT INTO `t_operation_log` VALUES (1330,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','af808190d54947777f6c8ee2e8d91687.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/af808190d54947777f6c8ee2e8d91687.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',7,'2023-06-07 19:43:38');
INSERT INTO `t_operation_log` VALUES (1331,'照片模块','添加','/admin/photo/add','com.ican.controller.PhotoController.addPhoto','添加照片','[{\"albumId\":2,\"photoUrlList\":[\"https://upload.haoxx.site/photo/c2a7079ed0d2e0959a02775cfc93798f.png\",\"https://upload.haoxx.site/photo/b329e9b72442e377d0ab3e954626d92a.png\",\"https://upload.haoxx.site/photo/ae42db34e057eaba61295c7337e7c546.png\",\"https://upload.haoxx.site/photo/af808190d54947777f6c8ee2e8d91687.png\"]}]','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',18,'2023-06-07 19:43:39');
INSERT INTO `t_operation_log` VALUES (1332,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','dcb7db7fed64b2b783a84f14c2324fc0.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/dcb7db7fed64b2b783a84f14c2324fc0.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',6,'2023-06-07 19:43:47');
INSERT INTO `t_operation_log` VALUES (1333,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','c9dd37b5aeb33abe47b944c4fa8bed5f.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/c9dd37b5aeb33abe47b944c4fa8bed5f.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',9,'2023-06-07 19:43:47');
INSERT INTO `t_operation_log` VALUES (1334,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','d9b061df62171b02e7a445e1d176c593.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/d9b061df62171b02e7a445e1d176c593.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',14,'2023-06-07 19:43:47');
INSERT INTO `t_operation_log` VALUES (1335,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','d1f2e482b131c2aac315142934b97807.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/d1f2e482b131c2aac315142934b97807.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',12,'2023-06-07 19:43:47');
INSERT INTO `t_operation_log` VALUES (1336,'照片模块','添加','/admin/photo/add','com.ican.controller.PhotoController.addPhoto','添加照片','[{\"albumId\":2,\"photoUrlList\":[\"https://upload.haoxx.site/photo/dcb7db7fed64b2b783a84f14c2324fc0.png\",\"https://upload.haoxx.site/photo/d9b061df62171b02e7a445e1d176c593.png\",\"https://upload.haoxx.site/photo/c9dd37b5aeb33abe47b944c4fa8bed5f.png\",\"https://upload.haoxx.site/photo/d1f2e482b131c2aac315142934b97807.png\"]}]','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',20,'2023-06-07 19:43:47');
INSERT INTO `t_operation_log` VALUES (1337,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','ebe07dbeff2c5d9943d4d094dca4ca93.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/ebe07dbeff2c5d9943d4d094dca4ca93.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',9,'2023-06-07 19:43:53');
INSERT INTO `t_operation_log` VALUES (1338,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','f58553028c983dc7f5284ea0f6ff8f10.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/f58553028c983dc7f5284ea0f6ff8f10.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',6,'2023-06-07 19:43:53');
INSERT INTO `t_operation_log` VALUES (1339,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','eeec806437bfc7f6d52f615ef7078477.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/eeec806437bfc7f6d52f615ef7078477.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',6,'2023-06-07 19:43:53');
INSERT INTO `t_operation_log` VALUES (1340,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','dffc560d52616dd91c7a30860543c238.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/dffc560d52616dd91c7a30860543c238.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',12,'2023-06-07 19:43:53');
INSERT INTO `t_operation_log` VALUES (1341,'照片模块','上传','/admin/photo/upload','com.ican.controller.PhotoController.uploadPhoto','上传照片','ef46427ce1d4b7268ae4baed43486364.png','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/photo/ef46427ce1d4b7268ae4baed43486364.png\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',4,'2023-06-07 19:43:53');
INSERT INTO `t_operation_log` VALUES (1342,'照片模块','添加','/admin/photo/add','com.ican.controller.PhotoController.addPhoto','添加照片','[{\"albumId\":2,\"photoUrlList\":[\"https://upload.haoxx.site/photo/eeec806437bfc7f6d52f615ef7078477.png\",\"https://upload.haoxx.site/photo/ebe07dbeff2c5d9943d4d094dca4ca93.png\",\"https://upload.haoxx.site/photo/f58553028c983dc7f5284ea0f6ff8f10.png\",\"https://upload.haoxx.site/photo/dffc560d52616dd91c7a30860543c238.png\",\"https://upload.haoxx.site/photo/ef46427ce1d4b7268ae4baed43486364.png\"]}]','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',11,'2023-06-07 19:43:54');
INSERT INTO `t_operation_log` VALUES (1343,'文章模块','修改','/admin/article/update','com.ican.controller.ArticleController.updateArticle','修改文章','[{\"articleContent\":\"---\\ntitle: 进程与线程笔记\\ndate: 2023-4-12\\ntags:\\n - 进程与线程\\ncategories:\\n - 未分类\\n---\\n# 一、创建进程/线程：\\n\\n1、进程创建pid_t fork(void); 说明：fork - create a child process\\n\\n包含头：\\\\#include \\\\<unistd.h\\\\>\\n\\n返回值：创建成功，则在父进程中返回子进程的PID，在子进程中返回0。创建失败，在父进程中返回-1。\\n\\n2、进程创建pid_t vfork(void); 说明：vfork - create a child process and block parent\\n\\n包含头：\\\\#include \\\\<sys/types.h\\\\>\\n\\n\\\\#include \\\\<unistd.h\\\\>\\n\\n3、线程创建int pthread_create(pthread_t \\\\*thread, const pthread_attr_t \\\\*attr,\\n\\nvoid \\\\*(\\\\*start_routine) (void \\\\*), void \\\\*arg);\\n\\n包含头：\\\\#include \\\\<pthread.h\\\\>\\n\\n注意; Compile and link with -pthread.\\n\\n返回值：创建成功返回0，否则返回错误值。\\n\\n参数：\\n\\n1.  pthread_t \\\\*thread：传递一个 pthread_t 类型的指针变量，也可以直接传递某个 pthread_t 类型变量的地址。pthread_t 是一种用于表示线程的数据类型，每一个 pthread_t 类型的变量都可以表示一个线程。\\n2.  const pthread_attr_t \\\\*attr：用于手动设置新建线程的属性，例如线程的调用策略、线程所能使用的栈内存的大小等。大部分场景中，我们都不需要手动修改线程的属性，将 attr 参数赋值为 NULL，pthread_create() 函数会采用系统默认的属性值创建线程。\\n3.  void \\\\*(\\\\*start_routine) (void \\\\*)：以函数指针的方式指明新建线程需要执行的函数，该函数的参数最多有 1 个（可以省略不写），形参和返回值的类型都必须为 void\\\\* 类型。void\\\\* 类型又称空指针类型，表明指针所指数据的类型是未知的。使用此类型指针时，我们通常需要先对其进行强制类型转换，然后才能正常访问指针指向的数据。\\n4.  void \\\\*arg：指定传递给 start_routine 函数的实参，当不需要传递任何数据时，将 arg 赋值为 NULL 即可。\\n\\n\\\\*\\\\*如果成功创建线程，pthread_create() 函数返回数字 0，反之返回非零值。各个非零值都对应着不同的宏，指明创建失败的原因，常见的宏有以下几种：\\n\\nEAGAIN：系统资源不足，无法提供创建线程所需的资源。\\n\\nEINVAL：传递给 pthread_create() 函数的 attr 参数无效。\\n\\nEPERM：传递给 pthread_create() 函数的 attr 参数中，某些属性的设置为非法操作，程序没有相关的设置权限。\\n\\n\\\\*\\\\*以上这些宏都声明在 \\\\<errno.h\\\\> 头文件中，如果程序中想使用这些宏，需提前引入此头文件。\\n\\n\\\\*\\\\*示例：\\n\\nvoid \\\\*receive(void \\\\*pth_arg) {}\\n\\npthread_t id;\\n\\npthread_create(&id,NULL,receive,(void\\\\*)cfd);\\n\\n# 二、创建和使用进程/线程时的一些问题：\\n\\n## 1、fork()和vfork()函数的区别：\\n\\n![](https://upload.haoxx.site/photo/d9b061df62171b02e7a445e1d176c593.png)\\n\\n为什么会有vfork，因为以前的fork 很傻， 它创建一个子进程时，将会创建一个新的地址\\n\\n空间，并且拷贝父进程的资源，而往往在子进程中会执行exec 调用，这样，前面的拷贝工\\n\\n作就是白费力气了，这种情况下，聪明的人就想出了vfork，它产生的子进程刚开始暂时与\\n\\n父进程共享地址空间（其实就是线程的概念了），因为这时候子进程在父进程的地址空间中\\n\\n运行，所以子进程不能进行写操作，并且在儿子 霸占着老子的房子时候，要委屈老子一\\n\\n下了，让他在外面歇着（阻塞），一旦儿子执行了exec 或者exit 后，相 于儿子买了自己的\\n\\n房子了，这时候就相于分家了。\\n\\n参考： <https://blog.csdn.net/jianchi88/article/details/6985326>\\n\\n在代码中获得当前进程pid的函数为：getpid()；\\n\\n在代码中获得当前进程父进程pid的函数为：getppid()。\\n\\n## 2、fork()功能简介：\\n\\n![](https://upload.haoxx.site/photo/d1f2e482b131c2aac315142934b97807.png)\\n\\n![](https://upload.haoxx.site/photo/dffc560d52616dd91c7a30860543c238.png)\\n\\n参考：https://blog.csdn.net/qq_38410730/article/details/81193118\\n\\n![](https://upload.haoxx.site/photo/a480238e9c3785af646f9d776e569797.png)\\n\\n![](https://upload.haoxx.site/photo/c2a7079ed0d2e0959a02775cfc93798f.png)\\n\\n这里需要注明一点：**父子进程的调度的顺序是由调度器决定的，与进程的创建顺序无关。**\\n\\n**\\\\*\\\\***还记得之前的图吗？子进程与父进程共享程序代码，而数据区、栈区、系统栈区相互独立。因此，父进程的代码实际上父、子进程要各执行一次。为了让父子进程执行不同的程序，有两种办法：1是在if(pid==0)中执行子程序特有的程序，2在子进程中调用execv()函数集。\\n\\n在实际应用中，通常调用execv()的都是子进程。人们之所以创建一个子进程，其目的就是执行一个与父进程代码不同的程序，而系统调用execv()就是子进程执行一个新程序的手段之一。子进程调用execv()之后，系统会立即为子进程加载可执行文件分配私有程序内存空间，从此子进程也成为一个真正的进程。\\n\\n如果说子进程是父进程的“儿子”，那么子进程在调用execv()之前，它所具有的单独用户堆栈和数据区也仅相当于它的私有“房间”；但因它还没有自己的“住房”，因此也只能寄住在“父亲”家，而不能“自立门户”，尽管它有自己的“户口”（进程控制块）。\\n\\n![](https://upload.haoxx.site/photo/c9dd37b5aeb33abe47b944c4fa8bed5f.png)\\n\\n![](https://upload.haoxx.site/photo/ebe07dbeff2c5d9943d4d094dca4ca93.png) \\n\\n![](https://upload.haoxx.site/photo/af808190d54947777f6c8ee2e8d91687.png)\\n\\n![](https://upload.haoxx.site/photo/36cf0a7153422dfaf17386b3796366c4.png)\\n\\n调用exec系列函数的前后，父子进程的关系变化如下图所示：\\n\\n![](https://upload.haoxx.site/photo/02a6d45da336592e5cb66280578c295e.png) \\n\\n![](https://upload.haoxx.site/photo/6d0a2a04a3119ad47edcabd7349d4673.png)\\n\\n为了避免子进程成为孤儿进程，父进程应该要等子进程结束并销毁子进程后才可以退出。因此，父进程中应设置系统调用wait()，子进程中应设置退出函数exit()。\\n\\n![](https://upload.haoxx.site/photo/f58553028c983dc7f5284ea0f6ff8f10.png)\\n\\n![](https://upload.haoxx.site/photo/5cb46546d42be10317ef6f30ce6d2fa3.png)\\n\\n![](https://upload.haoxx.site/photo/ef46427ce1d4b7268ae4baed43486364.png)\\n\\n![](https://upload.haoxx.site/photo/dcb7db7fed64b2b783a84f14c2324fc0.png)\\n\\n## 3、vfork()的进一步说明：\\n\\n![](https://upload.haoxx.site/photo/5529093d85e5635aa1effa437df22107.png)\\n\\n## 4、线程的基本使用：\\n\\n![](https://upload.haoxx.site/photo/5f24fbd285b131e20cf48c931def0d45.png)\\n\\n参考资料：https://blog.csdn.net/yi_chengyu/article/details/120412980\\n\\n![](https://upload.haoxx.site/photo/b329e9b72442e377d0ab3e954626d92a.png)\\n\\n## 5、线程与进程\\n\\n![](https://upload.haoxx.site/photo/eeec806437bfc7f6d52f615ef7078477.png)\\n\\n![](https://upload.haoxx.site/photo/6f23ed4e0dfc3ec691de15324db383a4.png)\\n\\n![](https://upload.haoxx.site/photo/ae2a762c612c3978c89eac5acbea13ad.png)\\n\\n## 6、fork与vfork\\n\\n![](https://upload.haoxx.site/photo/ae42db34e057eaba61295c7337e7c546.png)\\n\\n![](https://upload.haoxx.site/photo/5341a44ed914b07567b7dc18abdb8390.png)\\n\",\"articleCover\":\"https://upload.haoxx.site/config/27c7f38a329c07159a80315712680ea5.jpg\",\"articleTitle\":\"进程与线程笔记\",\"articleType\":1,\"categoryName\":\"操作系统与计算机组成原理\",\"id\":103,\"isRecommend\":0,\"isTop\":0,\"status\":1,\"tagNameList\":[]}]','PUT','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',26,'2023-06-07 19:49:00');
INSERT INTO `t_operation_log` VALUES (1344,'文章模块','修改','/admin/article/update','com.ican.controller.ArticleController.updateArticle','修改文章','[{\"articleContent\":\"---\\ntitle: 进程间通信学习内容\\ndate: 2023-4-12\\ntags:\\n - 进程间通信\\ncategories:\\n - 未分类\\n---\\n\\n![](https://upload.haoxx.site/photo/84e8bfe1bdfb66b1da75e06ca2c9fc33.png)\\n\\n![](https://upload.haoxx.site/photo/b7cc08bb88c6ef808f23b3202d5763eb.png)\\n\\n![](https://upload.haoxx.site/photo/20ec88f94bff808a8bcdbbd7e00c08cd.png)\\n\\n## 一、定义介绍\\n\\n1.  **管道：**管道是Linux 中进程间通信的一种方式，它把一个程序的输出直接连接到另一个程序的输入。Linux 的管道主要包括两种：无名管道和命名管道。\\n    1.  **管道（无名管道）**\\n\\n        **（1）无名管道**\\n\\n无名管道有几个重要的限制：\\n\\n无名管道是半双工的，数据只能在一个方向上流动，A进程传给B进程，不能反向传递管道只能用于父子进程或兄弟进程之间的通信，即具有亲缘关系的进程。\\n\\n无名管道的特点：\\n\\n1）无名管道是半双工的\\n\\n2）无名管道没有名字：只能用于父子进程或者兄弟进程之间（具有亲缘关系的进程）。\\n\\n3）无名管道不是普通的文件，并且只存在与内存中。\\n\\n4）无名管道的缓冲区是有限的，该缓冲区的大小为4Kbyte。\\n\\n1.  **命名管道：**命名管道是一种特殊类型的文件，它在系统中以文件形式存在。这样克服了无名管道的弊端，他可以允许没有亲缘关系的进程间通信。\\n\\n命名管道特点：\\n\\n1）FIFO在文件系统中作为一个特殊的文件而存在。\\n\\n2）虽然FIFO文件存在于文件系统中，但FIFO中的内容却存放在内存中，在Linux中，该缓冲区的大小为4Kbyte。\\n\\n3）FIFO有名字，不同的进程可以通过该命名管道进行通信\\n\\n4）FIFO所传送的数据是无格式的。\\n\\n5）从FIFO读数据是一次性操作，数据一旦被读，它就从FIFO中被抛弃，释放空间以便写更多的数据。\\n\\n6）当共享FIFO的进程执行完所有的I/O操作以后，FIFO将继续保存在文件系统中以便以后使用。\\n\\n1.  **信号：**信号是软件层次上对中断机制的一种模拟，是一种异步通信方式，进程不必通过任何操作来等待信号的到达。信号可以在用户空间进程和内核之间直接交互，内核可以利用信号来通知用户空间的进程发生了哪些系统事件。\\n\\n信号的来源有两种：硬件来源（如键盘ctrl+c），软件来源（kill, raise, alarm和setitimer以及sigqueue函数，当然还包括一些非法操作）；\\n\\n操作系统对信号的处理方式：1）忽略；有两个信号是不能忽略的：SIGKLL和SIGSTOP；2）捕捉，执行对应的信号处理程序；3）缺省，执行默认操作。\\n\\n1.  **消息队列：**消息队列是内核地址空间中的内部链表，具有特定的格式,存放在内存中并由消息队列标识符标识，并且允许一个或多个进程向它写入与读取消息。消息队列通过Linux内核在各个进程直接传递内容，消息顺序地发送到消息队列中，并以几种不同的方式从队列中获得，每个消息队列可以用IPC标识符唯一地进行识别。\\n\\n消息队列克服了信号承载信息量少的问题，管道只能承载无格式字符流。\\n\\n1.  **信号量：**信号量实质上就是一个标识可用资源数量的计数器，它的值总是非负整数。它们常常被用作一个锁机制，在某个进程正在对特定的资源进行操作时，信号量可以防止另一个进程去访问它。\\n\\n信号量可细分为：二值信号量和计数信号量\\n\\n信号量是一种特殊的变量，它只取正整数值并且只允许对这个值进行两种操作：等待（wait）和信号（signal）。（P、V操作，P用于申请资源，V用于释放资源）。\\n\\n1.  **共享内存：**共享内存是在多个进程之间共享内存区域的一种进程间的通信方式，使得多个进程可以直接读写同一块内存空间，它是针对其他通信机制运行效率较低而设计的。共享内存由IPC为进程创建的一个特殊地址范围，为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间。进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率。\\n\\n需要注意的是：共享内存并未提供同步机制，在一个进程结束对共享内存的写操作之前，并无自动机制可以阻止另二个进程开始对它进行读取。所以，我们通常需要用其他的机制来同步对共享内存的访问。\\n\\n1.  **内存映射：**内存映射，是将一个文件映射到一块内存的方法。内存映射文件与虚拟内存有些类似，通过内存映射文件可以保留一个地址的区域，同时将物理存储器提交给此区域，内存文件映射的物理存储器来自一个已经存在于磁盘上的文件，而且在对该文件进行操作之前必须首先对文件进行映射。使用内存映射文件处理存储于磁盘上的文件时，将不必再对文件执行I/O操作。每一个使用该机制的进程通过把同一个共享的文件映射到自己的进程地址空间来实现多个进程间的通信（这里类似于共享内存，只要有一个进程对这块映射文件的内存进行操作，其他进程也能够马上看到）。\\n2.  **套接字socket：**套接字是更为基础的进程间通信机制，与其他方式不同的是，套接字可用于不同机器之间的进程间通信。在Linux中，套接字是基于网络的，它也有自己的家族名字--AF_INET。\\n\\n## 二、详细函数接口说明\\n\\n参考资料：知识点讲解<https://blog.csdn.net/a987073381/article/details/52006729>\\n\\n代码示例：<https://blog.csdn.net/zqixiao_09/article/details/50485047> （上）\\n\\n（下，缺个消息队列）[https://blog.csdn.net/zqixiao_09/article/details/50498874?utm_medium=distribute.pc_relevant.none-task-blog-2\\\\~default\\\\~baidujs_title\\\\~default-0.no_search_link&spm=1001.2101.3001.4242.1](https://blog.csdn.net/zqixiao_09/article/details/50498874?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-0.no_search_link&spm=1001.2101.3001.4242.1)\\n\\n消息队列：<https://blog.csdn.net/qq_27664167/article/details/81712887>\\n\\n1、管道\\n\\n1.1无名管道\\n\\n![](https://upload.haoxx.site/photo/05438e1a57a775323713c45100ac9b5f.png)\\n\\n![](https://upload.haoxx.site/photo/630cb06c3086ffba6fb203a5a3ae317b.png)\\n\\n通过使用底层的read和write调用来访问数据。向file_descriptor[1]写数据，从file_descriptor[0]中读数据。写入与读取的顺序原则是先进先出。\\n\\n1.2 命名管道\\n\\n命名管道是一种特殊类型的文件，它在系统中以文件形式存在。这样克服了无名管道的弊端，他可以允许没有亲缘关系的进程间通信。\\n\\n![](https://upload.haoxx.site/photo/47fae86680ce79a7ed24d7237c1d16dc.png)\\n\\n编程示例：\\n\\n\\\\#include \\\\<sys/types.h\\\\>\\n\\n\\\\#include \\\\<sys/stat.h\\\\>\\n\\nint mkfifo(const char \\\\*filename,mode_t mode); //建立一个名字为filename的命名管道，参数mode为该文件的权限（mode%\\\\~umask），若成功则返回0，否则返回-1，错误原因存于errno中。\\n\\neg.mkfifo( \\\"/tmp/cmd_pipe\\\", S_IFIFO \\\\| 0666 );\\n\\n具体操作方法只要创建了一个命名管道然后就可以使用open、read、write等系统调用来操作。创建可以手工创建或者程序中创建。\\n\\nint mknod(const char \\\\*path, mode_t mode, dev_t dev); //第一个参数表示你要创建的文件的名称，第二个参数表示文件类型，第三个参数表示该文件对应的设备文件的设备号。只有当文件类型为 S_IFCHR 或 S_IFBLK 的时候该文件才有设备号，创建普通文件时传入0即可。\\n\\neg.mknod(FIFO_FILE,S_IFIFO\\\\|0666,0);\\n\\n![](https://upload.haoxx.site/photo/c0bdec69bc1cc87001a1903296feba86.png)\\n\\n2、信号\\n\\n信号机制是unix系统中最为古老的进程之间的通信机制，用于一个或几个进程之间传递异步信号。信号可以有各种异步事件产生，比如键盘中断等。shell也可以使用信号将作业控制命令传递给它的子进程。\\n\\n在此列出几个简单使用方法定义：\\n\\n![](https://upload.haoxx.site/photo/a55a1d964faddbc271c37e56f0588cde.png)\\n\\n3、消息队列\\n\\nMsgget() msgsnd() msgrcv() msgctl()\\n\\n4、信号量（Semaphore）\\n\\nSemget() semop() sembuf\\n\\n5、共享内存（Share Memory）\\n\\nShmget() shmat() shmdt()\\n\\n6、内存映射（Memory Map）\\n\\n\\\\*mmap() munmap() msync()\\n\\n7、套接字\\n\\n套接字的创建和使用与管道是有区别的，套接字 明确地将客户端与服务器 区分开来，可以实现多个客户端连到同一服务器。\\n\\n服务器套接字连接过程描述：\\n\\n首先，服务器应用程序用socket创建一个套接字，它是系统分配服务器进程的类似文件描述符的资源。 接着，服务器调用bind给套接字命名。这个名字是一个标示符，它允许linux将进入的针对特定端口的连接转到正确的服务器进程。 然后，系统调用listen函数开始接听，等待客户端连接。listen创建一个队列并将其用于存放来自客户端的进入连接。 当客户端调用connect请求连接时，服务器调用accept接受客户端连接，accept此时会创建一个新套接字，用于与这个客户端进行通信。\\n\\n客户端套接字连接过程描述：\\n\\n客户端首先调用socket创建一个未命名套接字，让后将服务器的命名套接字作为地址来调用connect与服务器建立连接。\\n\\n只要双方连接建立成功，我们就可以像操作底层文件一样来操作socket套接字实现通信。\\n\\n1.  管道\\n\\n管道实际是用于进程间通信的一段共享内存，创建管道的进程称为管道服务器，连接到一个管道的进程为管道客户机。一个进程在向管道写入数据后，另一进程就可以从管道的另一端将其读取出来。\\n\\n管道的特点：\\n\\n1)、管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道；\\n\\n2)、 只能用于父子进程或者兄弟进程之间（ 具有亲缘关系的进程）。 比如fork或exec创建的新进程， 在使用exec创建新进程时，需要将管道的文件描述符作为参数传递给exec创建的新进程。 当父进程与使用fork创建的子进程直接通信时，发送数据的进程关闭读端，接受数据的进程关闭写端。\\n\\n3)、单独构成一种独立的文件系统：管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在与内存中。\\n\\n4)、数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。\\n\\n通过使用底层的read和write调用来访问数据。 向 file_descriptor[1]写 数据，从 file_descriptor[0]中 读数据。写入与读取的顺序原则是 先进先出。\\n\\n![](https://upload.haoxx.site/photo/3a10aa097584f54f8b871ad0fc8668e6.png)\\n\\n1.  命名管道mkfifo\\n2.  信号signal\\n3.  消息队列 （本质是 链表）\\n4.  信号量\\n5.  共享内存：（需要信号量辅助读写的先后顺序）效率最高。\\n\\n采用共享内存通信的一个显而易见的好处就是**效率高**，因为进程可以直接读写内存，而**不需要任何数据的拷贝**。对于像管道和消息队列等通信方式，则需要在内核和用户控件进行四次数据的拷贝，而**共享内存只拷贝两次数据：一次从输入文件到共享区，另一次从共享内存区到输出文件**。实际上，进程之间在共享内存时，并不总是读写少量数据后就解除映射，有新的通信时，再重新建立共享内存区域。而是保持共享区域，知道通信完毕为止，这样，数据内同一直保存在共享内存中，并没有写回文件。共享内存中的内容往往是在接触映射时才写回文件的。因此，采用共享内存的通信方式效率是最高的。\\n\\n共享内存最大不足之处在意，由于多个进程对同一块内存区域具有访问的权限，**各个进程之间的同步问题显得尤为重要**。必须控制同一时刻只有一个进程对共享内存区域写入数据，否则会造成数据的混乱。同步控制问题可以由信号量来解决；\\n\",\"articleCover\":\"https://upload.haoxx.site/config/27c7f38a329c07159a80315712680ea5.jpg\",\"articleTitle\":\"进程和线程间通信学习内容\",\"articleType\":1,\"categoryName\":\"操作系统与计算机组成原理\",\"id\":105,\"isRecommend\":0,\"isTop\":0,\"status\":1,\"tagNameList\":[]}]','PUT','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',33,'2023-06-07 19:52:45');
INSERT INTO `t_operation_log` VALUES (1345,'文章模块','添加','/admin/article/add','com.ican.controller.ArticleController.addArticle','添加文章','[{\"articleContent\":\"---\\ntitle: 进程与线程笔记\\ndate: 2023-4-12\\ntags:\\n - 进程与线程\\ncategories:\\n - 未分类\\n---\\n# 一、创建进程/线程：\\n\\n1、进程创建pid_t fork(void); 说明：fork - create a child process\\n\\n包含头：\\\\#include \\\\<unistd.h\\\\>\\n\\n返回值：创建成功，则在父进程中返回子进程的PID，在子进程中返回0。创建失败，在父进程中返回-1。\\n\\n2、进程创建pid_t vfork(void); 说明：vfork - create a child process and block parent\\n\\n包含头：\\\\#include \\\\<sys/types.h\\\\>\\n\\n\\\\#include \\\\<unistd.h\\\\>\\n\\n3、线程创建int pthread_create(pthread_t \\\\*thread, const pthread_attr_t \\\\*attr,\\n\\nvoid \\\\*(\\\\*start_routine) (void \\\\*), void \\\\*arg);\\n\\n包含头：\\\\#include \\\\<pthread.h\\\\>\\n\\n注意; Compile and link with -pthread.\\n\\n返回值：创建成功返回0，否则返回错误值。\\n\\n参数：\\n\\n1.  pthread_t \\\\*thread：传递一个 pthread_t 类型的指针变量，也可以直接传递某个 pthread_t 类型变量的地址。pthread_t 是一种用于表示线程的数据类型，每一个 pthread_t 类型的变量都可以表示一个线程。\\n2.  const pthread_attr_t \\\\*attr：用于手动设置新建线程的属性，例如线程的调用策略、线程所能使用的栈内存的大小等。大部分场景中，我们都不需要手动修改线程的属性，将 attr 参数赋值为 NULL，pthread_create() 函数会采用系统默认的属性值创建线程。\\n3.  void \\\\*(\\\\*start_routine) (void \\\\*)：以函数指针的方式指明新建线程需要执行的函数，该函数的参数最多有 1 个（可以省略不写），形参和返回值的类型都必须为 void\\\\* 类型。void\\\\* 类型又称空指针类型，表明指针所指数据的类型是未知的。使用此类型指针时，我们通常需要先对其进行强制类型转换，然后才能正常访问指针指向的数据。\\n4.  void \\\\*arg：指定传递给 start_routine 函数的实参，当不需要传递任何数据时，将 arg 赋值为 NULL 即可。\\n\\n\\\\*\\\\*如果成功创建线程，pthread_create() 函数返回数字 0，反之返回非零值。各个非零值都对应着不同的宏，指明创建失败的原因，常见的宏有以下几种：\\n\\nEAGAIN：系统资源不足，无法提供创建线程所需的资源。\\n\\nEINVAL：传递给 pthread_create() 函数的 attr 参数无效。\\n\\nEPERM：传递给 pthread_create() 函数的 attr 参数中，某些属性的设置为非法操作，程序没有相关的设置权限。\\n\\n\\\\*\\\\*以上这些宏都声明在 \\\\<errno.h\\\\> 头文件中，如果程序中想使用这些宏，需提前引入此头文件。\\n\\n\\\\*\\\\*示例：\\n\\nvoid \\\\*receive(void \\\\*pth_arg) {}\\n\\npthread_t id;\\n\\npthread_create(&id,NULL,receive,(void\\\\*)cfd);\\n\\n# 二、创建和使用进程/线程时的一些问题：\\n\\n## 1、fork()和vfork()函数的区别：\\n\\n![](https://upload.haoxx.site/photo/d9b061df62171b02e7a445e1d176c593.png)\\n\\n为什么会有vfork，因为以前的fork 很傻， 它创建一个子进程时，将会创建一个新的地址\\n\\n空间，并且拷贝父进程的资源，而往往在子进程中会执行exec 调用，这样，前面的拷贝工\\n\\n作就是白费力气了，这种情况下，聪明的人就想出了vfork，它产生的子进程刚开始暂时与\\n\\n父进程共享地址空间（其实就是线程的概念了），因为这时候子进程在父进程的地址空间中\\n\\n运行，所以子进程不能进行写操作，并且在儿子 霸占着老子的房子时候，要委屈老子一\\n\\n下了，让他在外面歇着（阻塞），一旦儿子执行了exec 或者exit 后，相 于儿子买了自己的\\n\\n房子了，这时候就相于分家了。\\n\\n参考： <https://blog.csdn.net/jianchi88/article/details/6985326>\\n\\n在代码中获得当前进程pid的函数为：getpid()；\\n\\n在代码中获得当前进程父进程pid的函数为：getppid()。\\n\\n## 2、fork()功能简介：\\n\\n![](https://upload.haoxx.site/photo/d1f2e482b131c2aac315142934b97807.png)\\n\\n![](https://upload.haoxx.site/photo/dffc560d52616dd91c7a30860543c238.png)\\n\\n参考：https://blog.csdn.net/qq_38410730/article/details/81193118\\n\\n![](https://upload.haoxx.site/photo/a480238e9c3785af646f9d776e569797.png)\\n\\n![](https://upload.haoxx.site/photo/c2a7079ed0d2e0959a02775cfc93798f.png)\\n\\n这里需要注明一点：**父子进程的调度的顺序是由调度器决定的，与进程的创建顺序无关。**\\n\\n**\\\\*\\\\***还记得之前的图吗？子进程与父进程共享程序代码，而数据区、栈区、系统栈区相互独立。因此，父进程的代码实际上父、子进程要各执行一次。为了让父子进程执行不同的程序，有两种办法：1是在if(pid==0)中执行子程序特有的程序，2在子进程中调用execv()函数集。\\n\\n在实际应用中，通常调用execv()的都是子进程。人们之所以创建一个子进程，其目的就是执行一个与父进程代码不同的程序，而系统调用execv()就是子进程执行一个新程序的手段之一。子进程调用execv()之后，系统会立即为子进程加载可执行文件分配私有程序内存空间，从此子进程也成为一个真正的进程。\\n\\n如果说子进程是父进程的“儿子”，那么子进程在调用execv()之前，它所具有的单独用户堆栈和数据区也仅相当于它的私有“房间”；但因它还没有自己的“住房”，因此也只能寄住在“父亲”家，而不能“自立门户”，尽管它有自己的“户口”（进程控制块）。\\n\\n![](https://upload.haoxx.site/photo/c9dd37b5aeb33abe47b944c4fa8bed5f.png)\\n\\n![](https://upload.haoxx.site/photo/ebe07dbeff2c5d9943d4d094dca4ca93.png) \\n\\n![](https://upload.haoxx.site/photo/af808190d54947777f6c8ee2e8d91687.png)\\n\\n![](https://upload.haoxx.site/photo/36cf0a7153422dfaf17386b3796366c4.png)\\n\\n调用exec系列函数的前后，父子进程的关系变化如下图所示：\\n\\n![](https://upload.haoxx.site/photo/02a6d45da336592e5cb66280578c295e.png) \\n\\n![](https://upload.haoxx.site/photo/6d0a2a04a3119ad47edcabd7349d4673.png)\\n\\n为了避免子进程成为孤儿进程，父进程应该要等子进程结束并销毁子进程后才可以退出。因此，父进程中应设置系统调用wait()，子进程中应设置退出函数exit()。\\n\\n![](https://upload.haoxx.site/photo/f58553028c983dc7f5284ea0f6ff8f10.png)\\n\\n![](https://upload.haoxx.site/photo/5cb46546d42be10317ef6f30ce6d2fa3.png)\\n\\n![](https://upload.haoxx.site/photo/ef46427ce1d4b7268ae4baed43486364.png)\\n\\n![](https://upload.haoxx.site/photo/dcb7db7fed64b2b783a84f14c2324fc0.png)\\n\\n## 3、vfork()的进一步说明：\\n\\n![](https://upload.haoxx.site/photo/5529093d85e5635aa1effa437df22107.png)\\n\\n## 4、线程的基本使用：\\n\\n![](https://upload.haoxx.site/photo/5f24fbd285b131e20cf48c931def0d45.png)\\n\\n参考资料：https://blog.csdn.net/yi_chengyu/article/details/120412980\\n\\n![](https://upload.haoxx.site/photo/b329e9b72442e377d0ab3e954626d92a.png)\\n\\n## 5、线程与进程\\n\\n![](https://upload.haoxx.site/photo/eeec806437bfc7f6d52f615ef7078477.png)\\n\\n![](https://upload.haoxx.site/photo/6f23ed4e0dfc3ec691de15324db383a4.png)\\n\\n![](https://upload.haoxx.site/photo/ae2a762c612c3978c89eac5acbea13ad.png)\\n\\n## 6、fork与vfork\\n\\n![](https://upload.haoxx.site/photo/ae42db34e057eaba61295c7337e7c546.png)\\n\\n![](https://upload.haoxx.site/photo/5341a44ed914b07567b7dc18abdb8390.png)\\n\",\"articleCover\":\"\",\"articleTitle\":\"进程与线程笔记\",\"articleType\":1,\"categoryName\":\"操作系统与计算机组成原理\",\"isRecommend\":0,\"isTop\":0,\"status\":1,\"tagNameList\":[]}]','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',32,'2023-06-07 19:53:22');
INSERT INTO `t_operation_log` VALUES (1346,'文章模块','上传','/admin/article/upload','com.ican.controller.ArticleController.saveArticleImages','上传文章图片','image_9.jpg','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/article/b6877ebd88b9d69396333c5769e07c05.jpg\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',16,'2023-06-07 19:54:51');
INSERT INTO `t_operation_log` VALUES (1347,'文章模块','修改','/admin/article/update','com.ican.controller.ArticleController.updateArticle','修改文章','[{\"articleContent\":\"\\n第一部分是C++基础，第二部分是C/C++内存问题，第三部分是C++面向对象，第四部分是C++标准模板库STL，第五部分是C++新特性，第六部分是C++操作系统内容，第七部分是C++计算机网络，第八部分提到了部分常用的设计模式，第九部分举了一些常见的编程题。\\n\\n内容参考自[牛客](https://www.nowcoder.com/issue/tutorial?zhuanlanId=Gj56lM&uuid=0d542159b96c424f8b35bd6f9a278609)\\n\\n## 1、C++基础\\n\\n\\n\\n### 1.1 简述C++语言的特点\\n\\n1. C++在C语言基础上引入了**面向对象**的机制，同时也**兼容C语言**。\\n2. C++有三大特性：封装、继承、多态\\n3. C++语言编写出的程序结构清晰、易于扩充，程序可读性好\\n4. C++生成的代码质量高，运行效率高，仅比汇编语言慢10%～20%\\n5. C++更加安全，增加了const常量、引用、四类cast转换（static_cast、dynamic_cast、const_cast、reinterpret_cast）、智能指针、try—catch等等\\n6. C++可复用性高，C++引入了模板的概念，后面在此基础上，实现了方便开发的标准模板库STL（Standard Template Library）\\n7. 同时，C++是**不断在发展**的语言。C++后续版本更是发展了不少新特性，如C++11中引入了nullptr、auto变量、Lambda匿名函数、右值引用、智能指针。\\n\\n### 1.2 说说C语言与C++语言的区别\\n\\n1. C语言是C++的子集，C++可以很好兼容C语言。但是C++又有很多**新特性**，如引用、智能指针、auto变量等。\\n2. C++是**面对对象**的编程语言；C语言是面对过程的编程语言\\n3. C语言有一些不安全的语言特性，如指针使用的潜在危险、强制转换的不确定性、内存泄露等。而C++对此增加了不少新特性来**改善安全性**，如const常量、引用、cast转换、智能指针、try—catch等等\\n4. C++**可复用性高**，C++引入了**模板**的概念，后面在此基础上，实现了方便开发的标准模板库STL。C++的STL库相对于C语言的函数库**更灵活、更通用**\\n\\n### 1.3 说说C++中struct和class的区别\\n\\n1. struct一般用于描述一个数据结构集合，而class是对一个对象数据的封装；\\n2. struct的默认访问权限是public，而class默认权限是private；\\n\\n```cpp\\nstruct A{\\n\\tint iNum;  //默认访问控制权限是public\\n};\\nclass B{\\n\\tint iNum;  //默认访问控制权限是private\\n};\\n```\\n\\n3. 在继承关系上，struct是public继承，而class是private继承；\\n4. class关键字可以用于定义模板参数，就像typename，而struct不能用于定义模板参数。\\n\\n### 1.4 说说C中结构体和C++中结构体的区别\\n\\n1. C的结构体内不允许有函数存在，C++允许有内部成员函数，且允许该函数是虚函数\\n2. C的结构体对内部成员变量的访问权限只能是public，而C++允许public,protected,private三种\\n3. C语言的结构体是不可以继承的，C++的结构体是可以从其他的结构体或者类继承过来的\\n4. C 中使用结构体需要加上 struct 关键字，或者对结构体使用 typedef 取别名，而 C++ 中可以省略 struct 关键字直接使用\\n\\n小总结一波：①C与C++在声明时的区别在于：\\n\\n|          |           C            |           C++            |\\n| :------: | :--------------------: | :----------------------: |\\n| 成员函数 |         不能有         |           可以           |\\n| 静态成员 |         不能有         |           可以           |\\n| 访问控制 |  默认public，不可修改  | public/private/protected |\\n| 继承关系 |       不可以继承       |  可从类或其他结构体继承  |\\n|  初始化  | 不能直接初始化数据成员 |           可以           |\\n\\n②使用时的区别：\\n\\nC 中使用结构体需要加上 struct 关键字，或者对结构体使用 typedef 取别名，而 C++ 中可以省略 struct 关键字直接使用，例如：\\n\\n```cpp\\nstruct Student{\\n\\tint iAge;\\n\\tstring strName;\\n};\\ntypedef struct Student Student2; //C中给结构体取别名\\n\\nstuct Student stu1;   //C中正常使用\\nStudent2 stu2;      //C中通过取别名来使用\\nStudent stu3;      // C++中使用结构体可以省略关键字struct\\n```\\n\\n### 1.5 说说include头文件的顺序以及双引号“”和尖括号<>的区别\\n\\n1. 区别\\n   （1）尖括号的头文件是系统文件，双引号的文件是自定义文件；\\n   （2）编译器预处理阶段查找头文件的路径不一样\\n2. 查找路径\\n   （1）使用尖括号<>的头文件的查找路径：编译器设置的头文件路径-->系统变量\\n   （2）使用双引号“”的头文件的查找路径：当前头文件目录-->编译器设置的头文件路径-->系统变量\\n\\n### 1.6 导入C函数的关键字是什么，C++编译的时候与C有什么区别\\n\\n1. **关键字**：在C++中，导入C函数的关键字是extern，表达形式为extern “C”， extern \\\"C\\\"的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern \\\"C\\\"后，会指示编译器这部分代码按C语言的进行编译，而不是C++的。\\n2. **编译区别**：由于C++支持函数重载，因此编译器编译函数的过程中会将函数的**参数类型**也加到编译后的代码中，而不仅仅是**函数名**；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括**函数名**。\\n   程序示例：\\n\\n```cpp\\n//extern示例\\n//在C++程序里边声明该函数，会指示编译器这部分代码按C语言的进行编译\\nextern \\\"C\\\" int strcmp(const char *s1, const char *s2);\\n\\n//在C++程序里边声明该函数\\nextern \\\"C\\\"{\\n    #include <string.h>//string.h里边包含了要调用的C函数的声明\\n}\\n\\n//两种不同的语言，有着不同的编译规则，比如一个函数fun，可能C语言编译的时候为_fun，而C++则是__fun__\\n```\\n\\n### 1.7 简述C++从代码到可执行二进制文件的过程\\n\\nC++和C语言类似，一个C++程序从源码到执行文件，有四个过程，**预处理、编译、汇编、链接**。\\n\\n1. 预处理：这个过程主要的处理操作如下：\\n   （1） 将所有的#define删除，并且展开所有的宏定义\\n   （2） 处理所有的条件预编译指令，如#if、#ifdef\\n   （3） 处理#include预编译指令，将被包含的文件插入到该预编译指令的位置。\\n   （4） 过滤所有的注释\\n   （5） 添加行号和文件名标识。\\n2. 编译：这个过程主要的处理操作如下：\\n   （1） 词法分析：将源代码的字符序列分割成一系列的记号。\\n   （2） 语法分析：对记号进行语法分析，产生语法树。\\n   （3） 语义分析：判断表达式是否有意义。\\n   （4） 代码优化：\\n   （5） 目标代码生成：生成汇编代码。\\n   （6） 目标代码优化：\\n3. 汇编：这个过程主要是将汇编代码转变成机器可以执行的指令。\\n4. 链接：将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。\\n\\n链接分为静态链接和动态链接。\\n\\n静态链接，是在链接的时候就已经把要调用的函数或者过程链接到了生成的可执行文件中，就算你在去把静态库删除也不会影响可执行程序的执行；生成的静态链接库，Windows下以.lib为后缀，Linux下以.a为后缀。\\n\\n而动态链接，是在链接的时候没有把调用的函数代码链接进去，而是在执行的过程中，再去找要链接的函数，生成的可执行文件中没有函数代码，只包含函数的重定位信息，所以当你删除动态库时，可执行程序就不能运行。生成的动态链接库，Windows下以.dll为后缀，Linux下以.so为后缀。\\n\\n### 1.8 说说 static关键字的作用\\n\\n**static关键字的作用**：一方面她延长了函数和变量的作用时间；另一方面，它也限制了函数和变量的作用范围。\\n\\n1. **定义全局静态变量和局部静态变量**：在变量前面加上static关键字。初始化的静态变量会在数据段（.data）分配内存，未初始化的静态变量会在BSS段（.bss）分配内存。直到程序结束，静态变量始终会维持前值。只不过全局静态变量和局部静态变量的作用域不一样；\\n2. **定义静态函数**：在函数返回类型前加上static关键字，函数即被定义为静态函数。静态函数只能在本源文件中使用；\\n3. 在变量类型前加上static关键字，变量即被定义为静态变量。静态变量只能在本源文件中使用；\\n4. 在C++中，static关键字可以用于定义类中的静态成员变量：使用静态数据成员，它既可以被当成全局变量那样去存储，但又被隐藏在类的内部。类中的static静态数据成员拥有一块单独的存储区，而不管创建了多少个该类的对象。所有这些对象的静态数据成员都共享这一块静态存储空间；\\n5. 在C++中，static关键字可以用于定义类中的静态成员函数：与静态成员变量类似，类里面同样可以定义静态成员函数。只需要在函数前加上关键字static即可。如静态成员函数也是类的一部分，而不是对象的一部分。所有这些对象的静态数据成员都共享这一块静态存储空间。\\n\\n**关于第五点的补充说明**：当调用一个对象的非静态成员函数时，系统会把该对象的起始地址赋给成员函数的this指针。而静态成员函数不属于任何一个对象，因此C++规定静态成员函数没有this指针（划重点，面试题常考）。既然它没有指向某一对象，也就无法对一个对象中的非静态成员进行访问。\\n\\n### 1.9 说说数组和指针的区别\\n\\n1、概念：\\n    （1）数组：数组是用于储存多个相同类型数据的集合。数组名是首元素的地址\\n    （2）指针：指针相当于一个变量，但是它和不同变量不一样，它存放的是其它变量在**内存中的地址**。指针名指向了内存的首地址\\n\\n2. 区别：\\n   （1）**赋值**：同类型指针变量可以相互赋值；数组不行，只能一个一个元素的赋值或拷贝\\n   （2）**存储方式**：\\n\\n数组：数组在内存中是连续存放的，开辟一块连续的内存空间。数组是根据数组的下标进行访问的，数组的存储空间，不是在静态区就是在栈上。\\n\\n指针：指针很灵活，它可以指向任意类型的数据。指针的类型说明了它所指向地址空间的内存。由于指针本身就是一个变量，再加上它所存放的也是变量，所以指针的存储空间不能确定。\\n（3）**求sizeof**：\\n\\n数组所占存储空间的内存大小是sizeof(数组)，计算数组中元素个数：sizeof（数组名）/sizeof（数据类型）\\n\\n在32位平台下，无论指针的类型是什么，sizeof（指针名）都是4，在64位平台下，无论指针的类型是什么，sizeof（指针名）都是8。\\n（4）**初始化**：\\n\\n```cpp\\n// 数组\\nint a[5] = { 0 };\\nchar b[] = \\\"Hello\\\";    // 按字符串初始化，大小为6\\nchar c[] = { \'H\',\'e\',\'l\',\'l\',\'o\',\'\\\\0\' };    // 按字符初始化\\nint* arr = new int[10];    // 动态创建一维数组\\n\\n// 指针\\n// 指向对象的指针\\nint* p = new int(0);\\ndelete p;\\n// 指向数组的指针\\nint* p1 = new int[10];\\ndelete[] p1;\\n// 指向类的指针：\\nstring* p2 = new string;\\ndelete p2;\\n// 指向指针的指针（二级指针）\\nint** pp = &p;\\n**pp = 10;\\n```\\n\\n（5）**指针操作**：\\n\\n数组名的指针操作：\\n\\n`int (*p)[4]`定义了一个数组指针，该指针指向一个包含4个元素的数组。\\n\\n```cpp\\nint a[3][4];  \\nint (*p)[4];  //该语句是定义一个数组指针，指向含4个元素的一维数组\\np = a;        //将该二维数组的首地址赋给p，也就是a[0]或&a[0][0]\\np++;          //该语句执行过后，也就是p=p+1；p跨过行a[0][]指向了行a[1][]\\n              //所以数组指针也称指向一维数组的指针，亦称行指针。\\n//访问数组中第i行j列的一个元素，有几种操作方式：\\n//*(p[i]+j)、*(*(p+i)+j)、(*(p+i))[j]、p[i][j]。其中，优先级：()>[]>*。\\n//这几种操作方式都是合法的。\\n```\\n\\n指针变量的数据操作：\\n\\n```cpp\\nchar *str = \\\"hello,douya!\\\";\\nstr[2] = \'a\';\\n*(str+2) = \'b\';\\n//这两种操作方式都是合法的。\\n```\\n\\n补充：int \\\\*p[4]和int (*p)[4]的区别和区分：因为[]的优先级要比\\\\*高，所以前者是p先和[ ]结合，表示一个数组，然后再与*结合，表示int指针类型的数组。（本质上是数组，不过是int指针类型的数组）这数组里每个元素都是int类型的指针，储存的是int类型变量的地址。\\n\\n而int(\\\\*p)[4]，p先和\\\\*结合，表示p是一个指针，int ［4］就是他的类型，表示这是一个数组类型的指针，即p是一个指向一个长度为4数组的指针，它的本质是一个指针，这个指针的类型是int类型长度为4的数组。表示，这个指针存的是int类型长度为4的数组的地址。（不是其中某个元素的地址）\\n\\n### 1.10 说说什么是函数指针，如何定义函数指针，有什么使用场景\\n\\n1. **概念**：函数指针就是指向函数的指针变量。每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址\\n2. **定义**形式如下：\\n\\n```cpp\\nint func(int a);  \\nint (*f)(int a);  \\nf = &func;  \\n```\\n\\n3. 函数指针的**应用场景**：**回调**(callback)。我们调用别人提供的 API函数(Application Programming Interface,应用程序编程接口)，称为Call；如果别人的库里面调用我们的函数，就叫回调Callback。\\n\\n  我们用系统的API叫调用，系统用我们的API叫回调。\\n\\n  程序示例：\\n\\n```cpp\\n//以库函数qsort排序函数为例，它的原型如下：\\nvoid qsort(void *base,//void*类型，代表原始数组\\n           size_t nmemb, //第二个是size_t类型，代表数据数量\\n           size_t size, //第三个是size_t类型，代表单个数据占用空间大小\\n           int(*compar)(const void *,const void *)//第四个参数是函数指针\\n          );\\n//第四个参数告诉qsort，应该使用哪个函数来比较元素，即只要我们告诉qsort比较大小的规则，它就可以帮我们对任意数据类型的数组进行排序。在库函数qsort调用我们自定义的比较函数，这就是回调的应用。\\n\\n//示例\\nint num[100];\\nint cmp_int(const void* _a , const void* _b){//参数格式固定\\n    int* a = (int*)_a;    //强制类型转换\\n    int* b = (int*)_b;\\n    return *a - *b;　　\\n}\\nqsort(num,100,sizeof(num[0]),cmp_int); //回调\\n```\\n\\n### 1.11 说说静态变量什么时候初始化\\n\\n<font color=\'red\'>对于C语言的全局和静态变量，初始化发生在任何代码执行之前，属于编译期初始化。</font>\\n\\n<font color=\'red\'>而C++标准规定：全局或静态对象当且仅当对象首次用到时才进行构造。</font>\\n\\n1. **作用域**：C++里作用域可分为6种：全局，局部，类，语句，命名空间和文件作用域\\n\\n  全局变量：全局作用域+文件作用域，可以通过extern作用于其他非定义的源文件。\\n  静态全局变量 ：全局作用域，所以无法在其他文件中使用。\\n  静态局部变量 ：局部作用域，只被初始化一次，直到程序结束。\\n  类静态成员变量：类作用域。\\n\\n2. **所在空间**：都在静态存储区。因为静态变量都在静态存储区，所以下次调用函数的时候还是能取到原来的值\\n\\n3. **生命周期**：静态全局变量、静态局部变量都在静态存储区，直到程序结束才会回收内存。类静态成员变量在静态存储区，当超出类作用域时回收内存\\n\\n### 1.12 nullptr可以调用成员函数吗，为什么？\\n\\n答案：能。\\n原因：因为在编译时对象就绑定了函数地址，和指针空不空没关系。\\n\\n因为在编译时对象就绑定了函数地址，和指针空不空没关系。pAn->breathe();编译的时候，函数的地址就和指针pAn绑定了；调用breath(\\\\*this), this就等于pAn。由于函数中没有需要解引用this的地方，所以函数运行不会出错，但是若用到this，因为this=nullptr，运行出错。\\n\\n```cpp\\n//给出实例\\nclass animal{\\npublic:\\n    void sleep(){ cout << \\\"animal sleep\\\" << endl; }\\n    void breathe(){ cout << \\\"animal breathe haha\\\" << endl; }\\n};\\nclass fish :public animal{\\npublic:\\n    void breathe(){ cout << \\\"fish bubble\\\" << endl; }\\n};\\nint main(){\\n    animal *pAn=nullptr;\\n    pAn->breathe();   // 输出：animal breathe haha\\n    fish *pFish = nullptr;\\n    pFish->breathe(); // 输出：fish bubble\\n    return 0;\\n}  \\n```\\n\\n### 1.13 什么是野指针，怎么产生的，如何避免？\\n\\n1. **概念**：野指针就是指针指向的位置是不可知的（随机的、不正确的、没有明确限制的）\\n2. **产生原因**：释放内存后指针不及时置空（野指针），依然指向了该内存，那么可能出现非法访问的错误。这些我们都要注意避免，如：\\n\\n```cpp\\nchar *p = (char *)malloc(sizeof(char)*100);  \\nstrcpy(p, \\\"Douya\\\");  \\nfree(p);//p所指向的内存被释放，但是p所指的地址仍然不变  \\n...  \\nif (p != NULL){//没有起到防错作用  \\n    strcpy(p, \\\"hello, Douya!\\\");//出错  \\n}  \\n```\\n\\n3. 避免办法：\\n   （1）初始化置为NULL\\n   （2）申请内存后判空\\n   （3）指针释放后置NULL\\n   （4）使用智能指针\\n\\n```cpp\\nint *p = NULL; //初始化置NULL\\np = (int *)malloc(sizeof(int)*n); //申请n个int内存空间  \\nassert(p != NULL); //判空，防错设计\\n//C 库函数 void *realloc(void *ptr, size_t size) 尝试重新调整之前调用 malloc 或 calloc 所分配的 ptr 所指向的内存块的大小。\\n//注意：如果大小为 0，且 ptr 指向一个已存在的内存块，则 ptr 所指向的内存块会被释放，并返回一个空指针。\\np = (int *) realloc(p, 25);//重新分配内存, p 所指向的内存块会被释放并分配一个新的内存地址\\nfree(p);  \\np = NULL; //释放后置空\\n\\nint *p1 = NULL; //初始化置NULL\\ncalloc默认设置分配的内存数据为0\\np1 = (int *)calloc(n, sizeof(int)); //申请n个int内存空间同时初始化为0 \\nassert(p1 != NULL); //判空，防错设计\\nfree(p1);  \\np1 = NULL; //释放后置空\\n\\nint *p2 = NULL; //初始化置NULL\\np2 = new int[n]; //申请n个int内存空间  \\nassert(p2 != NULL); //判空，防错设计\\ndelete []p2;  \\np2 = nullptr; //释放后置空  \\n```\\n\\n### 1.14 说说静态局部变量，全局变量，局部变量的特点，以及使用场景\\n\\n1. **首先从作用域考虑**：C++里作用域可分为6种：全局，局部，类，语句，命名空间和文件作用域。\\n   全局变量：全局作用域+文件作用域，可以通过extern作用于其他非定义的源文件。\\n   静态全局变量 ：全局作用域，所以无法在其他文件中使用。\\n   局部变量：局部作用域，比如函数的参数，函数内的局部变量等等。\\n   静态局部变量 ：局部作用域，只被初始化一次，直到程序结束。\\n2. **从所在空间考虑**：除了局部变量在栈上外，其他都在静态存储区。因为静态变量都在静态存储区，所以下次调用函数的时候还是能取到原来的值。\\n3. **生命周期**： 局部变量在栈上，出了作用域就回收内存；而全局变量、静态全局变量、静态局部变量都在静态存储区，直到程序结束才会回收内存。\\n4. **使用场景**：从它们各自特点就可以看出各自的应用场景，不再赘述。\\n\\n### 1.15 说说内联函数和宏函数的区别\\n\\n区别：\\n\\n1. **宏定义不是函数**，但是使用起来像函数。预处理器用复制宏代码的方式代替函数的调用，省去了函数压栈退栈过程，提高了效率；而**内联函数本质上是一个函数**，内联函数一般用于函数体的代码比较简单的函数，不能包含复杂的控制语句，while、switch，并且内联函数本身不能直接调用自身(内联函数不能用于迭代)。\\n\\n2. **宏定义**是在预编译的时候把所有的宏名用宏体来替换，简单的说就是字符串替换 ；而**内联函数**则是在编译的时候进行代码插入，编译器会在每处调用内联函数的地方直接把内联函数的内容展开，这样可以省去函数的调用的开销，提高效率\\n\\n3. **宏定义**是没有类型检查的，无论对还是错都是直接替换；而**内联函数**在编译的时候会进行类型的检查，内联函数满足函数的性质，比如有返回值、参数列表等\\n\\n  **说人话**：相同点是，宏定义和内联函数，相比于函数体内代码较短，逻辑简单的普通函数而言，避免了出栈入栈的开销，提高了运行效率。不同的在于，宏定义本质不是函数。只是简单的字符替换，而且不会进行检查；内联函数本质是函数，是进行代码插入，有检错（宏定义不会对传入的参数进行检查），有形参，有返回值。\\n\\n  代码示例如下：\\n\\n```cpp\\n//宏定义示例\\n#define MAX(a，b) ((a)>(b)?(a):(b))\\nMAX(a,\\\"Hello\\\")； //错误地比较int和字符串，没有参数类型检查\\n\\n//内联函数示例\\n#include <stdio.h>\\ninline int add(int a, int b){\\n    return (a + b);\\n}\\nint main(void){\\n    int a;\\n    a = add(1, 2);\\n    printf(\\\"a+b=%d\\\\n\\\", a);\\n    return 0;\\n}\\n//以上a = add(1, 2);处在编译时将被展开为：a = (a + b);\\n```\\n\\n1、使用时的一些注意事项：\\n\\n+ 使用宏定义一定要注意错误情况的出现，比如宏定义函数没有类型检查，可能传进来任意类型，从而带来错误，如举例。还有就是括号的使用，宏在定义时要小心处理宏参数，一般用括号括起来，否则容易出现二义性\\n\\n+ inline函数一般用于比较小的，频繁调用的函数，这样可以减少函数调用带来的开销。只需要在函数返回类型前加上关键字inline，即可将函数指定为inline函数。\\n\\n+ 同其它函数不同的是，最好将inline函数定义在头文件，而不仅仅是声明，因为编译器在处理inline函数时，需要在调用点内联展开该函数，所以仅需要函数声明是不够的。\\n\\n2、内联函数使用的条件：\\n\\n+ 内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。以下情况不宜使用内联：\\n\\n+ （1）如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。\\n+ （2）如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。\\n+ 内联不是什么时候都能展开的，一个好的编译器将会根据函数的定义体，自动地取消不符合要求的内联。\\n\\n### 1.16 说说运算符i++和++i的区别\\n\\n先看代码示例：\\n\\n```cpp\\n#include <stdio.h>\\nint main(){\\n    int i = 2;\\n    int j = 2;\\n    j += i++; //先赋值后加\\n    printf(\\\"i= %d, j= %d\\\\n\\\",i, j); //i= 3, j= 4\\n    i = 2;\\n    j = 2;\\n    j += ++i; //先加后赋值\\n    printf(\\\"i= %d, j= %d\\\",i, j); //i= 3, j= 5\\n}\\n```\\n\\n区别：\\n\\n1. 赋值顺序不同：++ i 是先加后赋值；i ++ 是先赋值后加；++i和i++都是分两步完成的。\\n2. 效率不同：<font color=\'red\'>后置++执行速度比前置的慢</font>。\\n3. i++ 不能作为左值，而++i 可以：\\n\\n```cpp\\nint i = 0;\\nint *p1 = &（++i）；//正确\\nint *p2 = &（i++）；//错误\\n++i = 1；//正确\\ni++ = 1；//错误\\n```\\n\\n4. 两者都不是原子操作\\n\\n### 1.17 说说new和malloc的区别，各自底层实现原理\\n\\n1. new是操作符，而malloc是函数。\\n2. new在调用的时候先分配内存，在调用构造函数，释放的时候调用析构函数；而malloc没有构造函数和析构函数。\\n3. malloc需要给定申请内存的大小，返回的指针需要强转；new会调用构造函数，不用指定内存的大小，返回指针不用强转。\\n4. new可以被重载；malloc不行\\n5. new分配内存更直接和安全。\\n6. new发生错误抛出异常，malloc返回null\\n\\n答案解析：\\n\\n**malloc底层实现**：当开辟的空间小于 128K 时，调用 brk（）函数；当开辟的空间大于 128K 时，调用mmap（）。malloc采用的是内存池的管理方式，以减少内存碎片。先申请大块内存作为堆区，然后将堆区分为多个内存块。当用户申请内存时，直接从堆区分配一块合适的空闲快。采用隐式链表将所有空闲块，每一个空闲块记录了一个未分配的、连续的内存地址。\\n\\n**new底层实现**：关键字new在调用构造函数的时候实际上进行了如下的几个步骤：\\n\\n1. 创建一个新的对象\\n2. 将构造函数的作用域赋值给这个新的对象（因此this指向了这个新的对象）\\n3. 执行构造函数中的代码（为这个新对象添加属性）\\n4. 返回新对象\\n\\n### 1.18 说说const和define的区别\\n\\nconst用于定义常量；而define用于定义宏，而宏也可以用于定义常量。都用于常量定义时，它们的\\n区别有：\\n\\n1. const生效于编译的阶段；define生效于预处理阶段。\\n2. const定义的常量，在C语言中是存储在内存中、需要额外的内存空间的；define定义的常量，运行时是直接的操作数，并不会存放在内存中。\\n3. const定义的常量是带类型的；define定义的常量不带类型。因此define定义的常量不利于类型检查。\\n\\n### 1.19 说说C++中函数指针和指针函数的区别\\n\\n1. 定义不同\\n   指针函数本质是一个函数，其返回值为指针。\\n   函数指针本质是一个指针，其指向一个函数。\\n\\n2. 写法不同\\n\\n>指针函数：int \\\\*fun(int x,int y);\\n>\\t   函数指针：int (\\\\*fun)(int x,int y);\\n\\n3. 用法不同\\n\\n用法参考以下代码示例：\\n\\n```cpp\\n//指针函数示例\\ntypedef struct _Data{\\n    int a;\\n    int b;\\n}Data;\\n//指针函数\\nData* f(int a,int b){\\n    Data * data = new Data;\\n    //...\\n    return data;\\n}\\nint main(){\\n    //调用指针函数\\n    Data * myData = f(4,5);\\n    //Data * myData = static_cast<Data*>(f(4,5));\\n   //...\\n}\\n\\n//函数指针示例\\nint add(int x,int y){\\n    return x+y;\\n}\\n//函数指针\\nint (*fun)(int x,int y);\\n//赋值\\nfun = add;\\n//调用\\ncout << \\\"(*fun)(1,2) = \\\" << (*fun)(1,2) ;\\n//输出结果\\n//(*fun)(1,2) =  3\\n```\\n\\n### 1.20 说说const int *a, int const *a, const int a, int *const a, const int *const a分别是什么，有什么特点。\\n\\n参考答案：\\n\\n```cpp\\n1. const int a;     //指的是a是一个常量，不允许修改。\\n2. const int *a;    //a指针所指向的内存里的值不变，即（*a）不变\\n3. int const *a;    //同const int *a;\\n4. int *const a;    //a指针所指向的内存地址不变，即a不变\\n5. const int *const a;   //都不变，即（*a）不变，a也不变\\n```\\n\\n### 1.21 说说使用指针需要注意什么？\\n\\n1. 定义指针时，先初始化为NULL。\\n2. 用malloc或new申请内存之后，应该立即检查指针值是否为NULL。防止使用指针值为NULL的内存。\\n3. 不要忘记为数组和动态内存赋初值。防止将未被初始化的内存作为右值使用。\\n4. 避免数字或指针的下标越界，特别要当心发生“多1”或者“少1”操作\\n5. 动态内存的申请与释放必须配对，防止内存泄漏\\n6. 用free或delete释放了内存之后，立即将指针设置为NULL，防止“野指针”\\n\\n示例代码：\\n\\n```cpp\\n//（1）初始化置NULL\\n//（2）申请内存后判空\\n//（3）指针释放后置NULL\\nint *p = NULL; //初始化置NULL\\np = (int *)malloc(sizeof(int)*n); //申请n个int内存空间  \\nassert(p != NULL); //判空，防错设计\\np = (int *) realloc(p, 25);//重新分配内存, p 所指向的内存块会被释放并分配一个新的内存地址\\nfree(p);  \\np = NULL; //释放后置空\\n\\nint *p1 = NULL; //初始化置NULL\\np1 = (int *)calloc(n, sizeof(int)); //申请n个int内存空间同时初始化为0 \\nassert(p1 != NULL); //判空，防错设计\\nfree(p1);  \\np1 = NULL; //释放后置空\\n\\nint *p2 = NULL; //初始化置NULL\\np2 = new int[n]; //申请n个int内存空间  \\nassert(p2 != NULL); //判空，防错设计\\ndelete []p2;  \\np2 = nullptr; //释放后置空  \\n```\\n\\n### 1.22 说说内联函数和函数的区别，内联函数的作用\\n\\n1. 内联函数比普通函数多了关键字inline\\n2. 内联函数避免了函数调用的开销；普通函数有调用的开销\\n3. 普通函数在被调用的时候，需要寻址（函数入口地址）；内联函数不需要寻址。\\n4. 内联函数有一定的限制，内联函数体要求代码简单，不能包含复杂的结构控制语句；普通函数没有这个要求。\\n\\n**内联函数的作用**：内联函数在调用时，是将调用表达式用内联函数体来替换。避免函数调用的开销。\\n\\n在使用内联函数时，应注意如下几点：　\\n\\n1. 在内联函数内不允许用循环语句和开关语句。　\\n\\n如果内联函数有这些语句，则编译将该函数视同普通函数那样产生函数调用代码,递归函数是不能被用来做内联函数的。内联函数只适合于只有1～5行的小函数。对一个含有许多语句的大函数，函数调用和返回的开销相对来说微不足道，所以也没有必要用内联函数实现。　\\n\\n2. 内联函数的定义必须出现在内联函数第一次被调用之前。\\n\\n### 1.23 简述C++有几种传值方式，之间的区别是什么？\\n\\n传参方式有这三种：**值传递**、**引用传递**、**指针传递**\\n\\n1. 值传递：形参即使在函数体内值发生变化，也不会影响实参的值；\\n2. 引用传递：形参在函数体内值发生变化，会影响实参的值；\\n3. 指针传递：在指针指向没有发生改变的前提下，形参在函数体内值发生变化，会影响实参的值；\\n\\n值传递用于对象时，整个对象会拷贝一个副本，这样效率低；而引用传递用于对象时，不发生拷贝行为，只是绑定对象，更高效；指针传递同理，但不如引用传递安全。\\n\\n```cpp\\n//代码示例\\n#include <iostream>\\nusing namespace std;\\n\\nvoid testfunc(int a, int *b, int &c){//形参a值发生了改变，但是没有影响实参i的值；但形参*b、c的值发生了改变，影响到了实参*j、k的值\\n    a += 1;\\n    (*b) += 1;\\n    c += 1;\\n    printf(\\\"a= %d, b= %d, c= %d\\\\n\\\",a,*b,c);//a= 2, b= 2, c= 2\\n}\\nint main(){\\n       int i = 1;\\n    int a = 1;\\n    int *j = &a;\\n    int k = 1;\\n    testfunc(i, j, k);\\n    printf(\\\"i= %d, j= %d, k= %d\\\\n\\\",i,*j,k);//i= 1, j= 2, k= 2\\n    return 0;\\n}\\n```\\n\\n### 1.24 简述const（星号）和（星号）const的区别\\n\\n代码示例：\\n\\n```cpp\\n//const* 是常量指针，*const 是指针常量\\n\\nint const *a;    //a指针所指向的内存里的值不变，即（*a）不变\\nint *const a;    //a指针所指向的内存地址不变，即a不变\\n```\\n\\n\\n\\n\\n\\n\\n## 2、C/C++内存问题\\n\\n### 2.1 简述一下堆和栈的区别\\n\\n1. **堆栈空间分配不同**。栈由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等；堆一般由程序员分配释放。\\n2. **堆栈缓存方式不同**。栈使用的是一级缓存， 它们通常都是被调用时处于存储空间中，调用完毕立即释放；堆则是存放在二级缓存中，速度要慢些。\\n3. **堆栈数据结构不同**。堆类似数组结构；栈类似栈结构，先进后出。\\n\\n### 2.2 简述C++的内存管理\\n\\n1. 内存分配方式\\n   在C++中，内存分成5个区，他们分别是堆、栈、自由存储区、全局/静态存储区和常量存储区。\\n\\n><font color=\'red\'>栈</font>，在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。\\n>\\n><font color=\'red\'>堆</font>，就是那些由malloc/realloc/calloc分配的内存块，一般一个malloc就要对应一个free。\\n>\\n><font color=\'red\'>自由存储区</font>，就是那些由new分配的内存块，和堆是十分相似的，不过是用delete来结束自己的生命。 【补充说明】\\n>\\n><font color=\'red\'>全局/静态存储区</font>，全局变量和静态变量被分配到同一块内存中\\n>\\n><font color=\'red\'>常量存储区</font>，这是一块比较特殊的存储区，里面存放的是常量，不允许修改。\\n\\n【**补充说明**】：\\n\\n如果我接着问你自由存储区与堆有什么区别，你或许这样回答：“malloc在堆上分配的内存块，使用free释放内存，而new所申请的内存则是在自由存储区上，使用delete来释放。”\\n\\n这样听起来似乎也没错，但如果我接着问：\\n\\n自由存储区与堆是两块不同的内存区域吗？它们有可能相同吗？\\n\\n你可能就懵了。\\n\\n**尽管C++标准没有要求，但很多编译器的new/delete都是以malloc/free为基础来实现的。那么请问：借以malloc实现的new，所申请的内存是在堆上还是在自由存储区上？ 明显，此时的堆与自由存储区所代表的空间是相同的。**\\n\\n如果，你重载了new运算符，使其不在堆上开辟空间，那么对于自动存储区的概念就完全不相同了。\\n\\n从技术上来说，堆（heap）是C语言和操作系统的术语。堆是操作系统所维护的一块特殊内存，它提供了动态分配的功能，当运行程序调用malloc()时就会从中分配，稍后调用free可把内存交还。而自由存储是C++中通过new和delete动态分配和释放对象的抽象概念，通过new来申请的内存区域可称为自由存储区。基本上，所有的C++编译器默认使用堆来实现自由存储，也即是缺省的全局运算符new和delete也许会按照malloc和free的方式来被实现，这时藉由new运算符分配的对象，说它在堆上也对，说它在自由存储区上也正确。但程序员也可以通过重载操作符，改用其他内存来实现自由存储，例如全局变量做的对象池，这时自由存储区就区别于堆了。我们所需要记住的就是：\\n\\n><font color=\'red\'>堆是操作系统维护的一块内存，而自由存储是C++中通过new与delete动态分配和释放对象的抽象概念。堆与自由存储区并不等价。</font>\\n\\n【**补充说明结束**】\\n\\n2. 常见的内存错误和对策\\n\\n（1）内存分配未成功，却使用了它。\\n\\n（2）内存分配虽然成功，但是尚未初始化就引用它。\\n\\n（3）内存分配成功并且已经初始化，但操作越过了内存的边界。\\n\\n（4）忘记了释放内存，造成内存泄露。\\n\\n（5）释放了内存却继续使用它。\\n\\n对策：\\n\\n（1）定义指针时，先初始化为NULL。\\n\\n（2）用malloc或new申请内存之后，应该立即检查指针值是否为NULL。防止使用指针值为NULL的内存。\\n\\n（3）不要忘记为数组和动态内存赋初值。防止将未被初始化的内存作为右值使用。\\n\\n（4）避免数字或指针的下标越界，特别要当心发生“多1”或者“少1”操作\\n\\n（5）动态内存的申请与释放必须配对，防止内存泄漏\\n\\n（6）用free或delete释放了内存之后，立即将指针设置为NULL，防止“野指针”\\n\\n（7）使用智能指针。\\n\\n3. 内存泄漏及解决办法\\n\\n**什么是内存泄露？**\\n\\n简单地说就是申请了一块内存空间，使用完毕后没有释放掉。（1）new和malloc申请资源使用后，没有用delete和free释放；（2）子类继承父类时，父类析构函数不是虚函数。（3）Windows句柄资源使用后没有释放。\\n\\n**怎么检测？**\\n\\n第一：良好的编码习惯，使用了内存分配的函数，一旦使用完毕,要记得使用其相应的函数释放掉。\\n\\n第二：将分配的内存的指针以链表的形式自行管理，使用完毕之后从链表中删除，程序结束时可检查改链表。\\n\\n第三：使用智能指针。\\n\\n第四：一些常见的工具插件，如ccmalloc、Dmalloc、Leaky、Valgrind等等。\\n\\n### 2.3 malloc和局部变量分配在堆还是栈？\\n\\n malloc是在堆上分配内存，需要程序员自己回收内存；局部变量是在栈中分配内存，超过作用域就自动回收。\\n\\n### 2.4 程序有哪些section，分别的作用？程序启动的过程？怎么判断数据分配在栈上还是堆上？\\n\\n![图1](https://s3.bmp.ovh/imgs/2022/08/29/91e07f9f6bdac247.png)\\n\\n**一个程序有哪些section**：\\n\\n如上图，从低地址到高地址，一个程序由**代码段、数据段、 BSS 段**组成。\\n\\n【1】、**数据段**：存放程序中已初始化的全局变量和静态变量的一块内存区域。\\n\\n【2】、**代码段**：存放程序执行代码的一块内存区域。只读，代码段的头部还会包含一些<font color=\'blue\'>只读的**常数变量**</font>。(全局常量和字符串常量位于全局区/静态区还是代码区，还有待商榷)\\n\\n【3】、**BSS 段**：存放程序中未初始化的全局变量和静态变量的一块内存区域。\\n\\n【4】、可执行程序在运行时又会多出两个区域：堆区和栈区。\\n\\n**堆区**：动态申请内存用。堆从低地址向高地址增长。\\n\\n**栈区**：存储局部变量、函数参数值。栈从高地址向低地址增长。是一块连续的空间。\\n\\n【5】、最后还有一个**文件映射区**，位于堆和栈之间。\\n\\n<font color=\'red\'>【警告】：在网上查阅的资料显示，字符串常量存放在全局/静态区，而不是代码区。普通常量也是位于全局/静态区。</font>根据观察和代码验证，字符串数组是变量，存放在栈区；字符串指针是常量，存放在全局/静态区。还有一点，全局/静态区是低地址，栈是高地址。\\n\\n```cpp\\n#include <stdio.h>\\n\\nvoid test01()\\n{\\nchar str1[] = \\\"abcd\\\";\\nchar str2[] = \\\"abcd\\\";\\n \\nconst char str3[] = \\\"abcd\\\";\\nconst char str4[] = \\\"abcd\\\";\\n \\nconst char *str5 = \\\"abcd\\\";\\nconst char *str6 = \\\"abcd\\\";\\n \\nchar *str7 = \\\"abcd\\\";\\nchar *str8 = \\\"abcd\\\";\\n\\nprintf(\\\"str1: %p\\\\n\\\",str1);\\nprintf(\\\"str2: %p\\\\n\\\",str2);\\nprintf(\\\"str3: %p\\\\n\\\",str3);\\nprintf(\\\"str4: %p\\\\n\\\",str4);\\n\\nprintf(\\\"str5: %p\\\\n\\\",str5);\\nprintf(\\\"str6: %p\\\\n\\\",str6);\\nprintf(\\\"str7: %p\\\\n\\\",str7);\\nprintf(\\\"str8: %p\\\\n\\\",str8);\\n}\\n\\nvoid test02()\\n{\\n    char p[]=\\\"hello world!\\\";\\n    printf(\\\"test02 p[] is %p\\\\n\\\",p);\\n\\n    char *p1=\\\"hello world!\\\";\\n    printf(\\\"test02 *p is %p\\\\n\\\",p1);\\n}\\n\\nint main()\\n{\\n    test01();\\n    test02();\\n    return 0;\\n}\\n//输出结果为:\\nstr1: 0061FEEB //栈 char str1[] = \\\"abcd\\\";\\nstr2: 0061FEE6 //栈 char str2[] = \\\"abcd\\\";\\nstr3: 0061FEE1 //栈 const char str3[] = \\\"abcd\\\";\\nstr4: 0061FEDC //栈 const char str4[] = \\\"abcd\\\";\\nstr5: 00405094 //全局/静态区 const char str3[] = \\\"abcd\\\";\\nstr6: 00405094 //全局/静态区 const char *str6 = \\\"abcd\\\";\\nstr7: 00405094 //全局/静态区 char *str7 = \\\"abcd\\\";\\nstr8: 00405094 //全局/静态区 char *str8 = \\\"abcd\\\";\\ntest02 p[] is 0061FEEF //栈 char p[]=\\\"hello world!\\\";\\ntest02 *p is 00405064 //全局/静态区 char *p1=\\\"hello world!\\\";\\n```\\n\\n<font color=\'red\'>注意！</font>字符串指针所表示的是字符串常量，并且全局常量和字符串常量都是位于全局/静态变量区，但是，局部常量位于栈区。演示代码如下所示：\\n\\n```cpp\\n#include <stdio.h>\\n\\n//已初始化的全局变量 --全局区的.data区\\nint g_a=10;\\nint g_b=12;\\n\\n//已初始化的全局静态变量   --全局区的.data区 \\nstatic int s_g_a=10;\\nstatic int s_g_b=10;\\n\\n//全局常量 全局区\\nconst int g_c_a=10;\\nconst int g_c_b=11;\\n\\nvoid test01()\\n{\\n    //静态局部变量  全局区\\n    static int s_a=10;\\n    static int s_b=11;\\n\\n    //局部常量  位于栈区\\n    const int l_g_c_a=10;\\n    const int l_g_c_b=11;\\n\\n    printf(\\\"全局变量g_a的地址是：%p\\\\n\\\",&g_a);\\n    printf(\\\"全局变量g_b的地址是：%p\\\\n\\\",&g_b);\\n\\n    printf(\\\"全局静态变量s_g_a的地址是：%p\\\\n\\\",&s_g_a);\\n    printf(\\\"全局静态变量s_g_b的地址是：%p\\\\n\\\",&s_g_b);\\n\\n    printf(\\\"静态局部变量s_a的地址是：%p\\\\n\\\",&s_a);\\n    printf(\\\"静态局部变量s_b的地址是：%p\\\\n\\\",&s_b);\\n\\n    printf(\\\"全局常量g_a的地址是：%p\\\\n\\\",&g_c_a);\\n    printf(\\\"全局常量g_b的地址是：%p\\\\n\\\",&g_c_b);\\n\\n    printf(\\\"局部常量g_a的地址是：%p\\\\n\\\",&l_g_c_a);\\n    printf(\\\"局部常量g_b的地址是：%p\\\\n\\\",&l_g_c_b);\\n\\n    //字符串常量 全局区\\n    printf(\\\"字符串常量的地址是：%p\\\\n\\\",&\\\"Hello1\\\");\\n    printf(\\\"字符串常量的地址是：%p\\\\n\\\",&\\\"Hello2\\\");\\n}\\n\\nint main()\\n{\\n    test01();\\n    return 0;\\n}\\n//测试结果为：\\n全局变量g_a的地址是：00404004\\n全局变量g_b的地址是：00404008\\n全局静态变量s_g_a的地址是：0040400C\\n全局静态变量s_g_b的地址是：00404010\\n静态局部变量s_a的地址是：00404014\\n静态局部变量s_b的地址是：00404018\\n全局常量g_a的地址是：00405064\\n全局常量g_b的地址是：00405068\\n局部常量g_a的地址是：0061FF0C\\n局部常量g_b的地址是：0061FF08\\n字符串常量的地址是：0040517D\\n字符串常量的地址是：0040519C\\n```\\n\\n<font color=\'red\'>有一种说法</font>：程序只分text区、data区、bss区，当程序运行时才会增加堆区和栈区。（linux下查看代码二进制的elf格式)\\n**程序启动的过程**：\\n1、操作系统首先创建相应的进程并分配私有的进程空间，然后操作系统的加载器负责把可执行文件的数据段和代码段映射到进程的虚拟内存空间中。\\n2、加载器读入可执行程序的导入符号表，根据这些符号表可以查找出该可执行程序的所有依赖的动态链接库。\\n3、加载器针对该程序的每一个动态链接库调用LoadLibrary\\n\\t（1）查找对应的动态库文件，加载器为该动态链接库确定一个合适的基地址。\\n\\t（2）加载器读取该动态链接库的导入符号表和导出符号表，比较应用程序要求的导入符号是否匹配该库的导出符号。\\n\\t（3）针对该库的导入符号表，查找对应的依赖的动态链接库，如有跳转，则跳到3\\n\\t（4）调用该动态链接库的初始化函数\\n4、初始化应用程序的全局变量，对于全局对象自动调用构造函数。\\n5、进入应用程序入口点函数开始执行。\\n**怎么判断数据分配在栈上还是堆上**：首先局部变量分配在栈上；而通过malloc和new申请的空间是在堆上。\\n\\n### 2.5 初始化为0的全局变量在bss还是data\\n\\n答：全局变量和静态变量，初始化了的存入data段，未初始化的存入bss段。\\n\\n### 2.6 请简述一下atomoic内存顺序\\n\\n有六个内存顺序选项可应用于对原子类型的操作：\\n\\nmemory_order_relaxed：在原子类型上的操作以自由序列执行，没有任何同步关系，仅对此操作要求原子性。\\n\\nmemory_order_consume：memory_order_consume只会对其标识的对象保证该对象存储先行于那些需要加载该对象的操作。\\n\\nmemory_order_acquire：使用memory_order_acquire的原子操作，当前线程的读写操作都不能重排到此操作之前。\\n\\nmemory_order_release：使用memory_order_release的原子操作，当前线程的读写操作都不能重排到此操作之后。\\n\\nmemory_order_acq_rel：memory_order_acq_rel在此内存顺序的读-改-写操作既是获得加载又是释放操作。没有操作能够从此操作之后被重排到此操作之前，也没有操作能够从此操作之前被重排到此操作之后。\\n\\nmemory_order_seq_cst：memory_order_seq_cst比std::memory_order_acq_rel更为严格。memory_order_seq_cst不仅是一个\\\"获取释放\\\"内存顺序，它还会对所有拥有此标签的内存操作建立一个单独全序。\\n\\n除非你为特定的操作指定一个顺序选项，否则内存顺序选项对于所有原子类型默认都是memory_order_seq_cst。\\n\\n## 2.7 简述C++中内存对齐的使用场景\\n\\n内存对齐应用于三种数据类型中：struct/class/union\\n\\nstruct/class/union内存对齐原则有四个：\\n\\n>1. 数据成员对齐规则：结构(struct)或联合(union)的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小或者成员的子成员大小的整数倍开始。\\n\\n>2. 结构体作为成员:如果一个结构里有某些结构体成员,则结构体成员要从其内部\\\"最宽基本类型成员\\\"的整数倍地址开始存储。(struct a里存有struct b,b里有char,int ,double等元素,那b应该从8的整数倍开始存储)。\\n\\n>3. 收尾工作:结构体的总大小，也就是sizeof的结果，必须是其内部最大成员的\\\"最宽基本类型成员\\\"的整数倍。不足的要补齐。(基本类型不包括struct/class/uinon)。\\n\\n>4. sizeof(union)，以结构里面size最大元素为union的size，因为在某一时刻，union只有一个成员真正存储于该地址。\\n\\n补充说明：\\n\\n1. **什么是字节对齐**\\n\\n那么什么是字节对齐？在C语言中，结构体是一种复合数据类型，其构成元素既可以是基本数据类型（如int、long、float等）的变量，也可以是一些复合数据类型（如数组、结构体、联合体等）的数据单元。在结构体中，编译器为结构体的每个成员按其自然边界（alignment）分配空间。各个成员按照它们被声明的顺序在内存中顺序存储，第一个成员的地址和整个结构体的地址相同。\\n\\n为了使CPU能够对变量进行快速的访问，变量的起始地址应该具有某些特性，即所谓的“对齐”，比如4字节的int型，其起始地址应该位于4字节的边界上，即起始地址能够被4整除，也即“对齐”跟数据在内存中的位置有关。如果一个变量的内存地址正好位于它长度的整数倍，他就被称做自然对齐。\\n\\n比如在32位cpu下，假设一个整型变量的地址为0x00000004(为4的倍数)，那它就是自然对齐的，而如果其地址为0x00000002（非4的倍数）则是非对齐的。现代计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。\\n\\n2. **为什么要字节对齐**\\n\\n需要字节对齐的根本原因在于CPU访问数据的效率问题。假设上面整型变量的地址不是自然对齐，比如为0x00000002，则CPU如果取它的值的话需要访问两次内存，第一次取从0x00000002-0x00000003的一个short，第二次取从0x00000004-0x00000005的一个short然后组合得到所要的数据，如果变量在0x00000003地址上的话则要访问三次内存，第一次为char，第二次为short，第三次为char，然后组合得到整型数据。\\n\\n而如果变量在自然对齐位置上，则只要一次就可以取出数据。一些系统对对齐要求非常严格，比如sparc系统，如果取未对齐的数据会发生错误，而在x86上就不会出现错误，只是效率下降。\\n\\n各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。比如有些平台每次读都是从偶地址开始，如果一个int型（假设为32位系统）如果存放在偶地址开始的地方，那么一个读周期就可以读出这32bit，而如果存放在奇地址开始的地方，就需要2个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该32bit数据。显然在读取效率上下降很多。\\n\\n3. **字节对齐实例**：\\n\\n```cpp\\nunion example {  \\n    int a[5];  \\n    char b;  \\n    double c;  \\n};  \\nint result = sizeof(example);  \\n/*\\n联合体只取最长的，int a[5]，长度为20，字节对齐为24\\n*/\\n\\nstruct example {  \\n    int a[5];  \\n    char b;  \\n    double c;  \\n}test_struct;\\nint result = sizeof(test_struct);  \\n/*\\nstruct总和 int 20 分为 8 8 4 char 1 double 8 最大对齐8 char补充到int的4 所以为 8+8+8（4+1）+8（double），总计32\\n*/\\n\\nstruct example {  \\n    char b;  \\n    double c;  \\n    int a;  \\n}test_struct;  \\nint result = sizeof(test_struct);  \\n/*\\n字节对齐除了内存起始地址要是数据类型的整数倍以外，还要满足一个条件，那就是占用的内存空间大小需要是结构体中占用最大内存空间的类型的整数倍，所以20不是double（8Byte）的整数倍，我们还要扩充四个字节，最后的结果是result=24\\n*/\\n```\\n\\n## 3、C++面向对象\\n\\n### 3.1 简述一下什么是面向对象\\n\\n1. 面向对象是一种编程思想，把一切东西看成是一个个对象，比如人、耳机、鼠标、水杯等，他们各自都有属性，比如：耳机是白色的，鼠标是黑色的，水杯是圆柱形的等等，把这些对象拥有的属性变量和操作这些属性变量的函数打包成一个类来表示\\n\\n2. 面向过程和面向对象的区别\\n\\n面向过程：根据业务逻辑从上到下写代码\\n\\n面向对象：将数据与函数绑定到一起，进行封装，这样能够更快速的开发程序，减少了重复代码的重写过程\\n\\n### 3.2 简述一下面向对象的三大特征\\n\\n封装、继承、多态\\n\\n1. 封装：将数据和操作数据的方法进行有机结合，隐藏对象的属性和实现细节，仅对外公开接口来和对象进行 交互。封装本质上是一种管理：我们如何管理兵马俑呢？比如如果什么都不管，兵马俑就被随意破坏了。那么我们首先建了一座房子把兵马俑给封装起来。但是我们目的全封装起来，不让别人看。所以我们开放了售票通道，可以买票突破封装在合理的监管机制下进去参观。类也是一样，不想给别人看到的，我们使用protected/private把成员封装起来。开放一些公有的成员函数对成员合理的访问。所以封装本质是一种管理。\\n\\n2. 继承：可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。\\n   三种继承关系：\\n\\n| 继承方式            | private继承     | protected继承     | public继承        |\\n| ------------------- | --------------- | ----------------- | ----------------- |\\n| 基类的private成员   | 不可见          | 不可见            | 不可见            |\\n| 基类的protected成员 | 变为private成员 | 仍为protected成员 | 仍为protected成员 |\\n| 基类的public成员    | 变为private成员 | 变为protected成员 | 仍为protected成员 |\\n\\n3. 多态：用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。实现多态，有二种方式，重写，重载。（虚函数/纯虚函数、函数重载）\\n\\n### 3.3 简述一下C++的重写与重载，以及他们之间的区别\\n\\n1、重写\\n\\n是指派生类中存在重新定义的函数。其函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致。只有函数体不同（花括号内），派生类对象调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有virtual修饰。（虚函数/纯虚函数）\\n\\n```cpp\\n#include<bits/stdC++.h>\\n\\nusing namespace std;\\n\\nclass A\\n{\\npublic:\\n    virtual    void fun()\\n    {\\n        cout << \\\"A\\\";\\n    }\\n};\\nclass B :public A\\n{\\npublic:\\n    virtual void fun()\\n    {\\n        cout << \\\"B\\\";\\n    }\\n};\\nint main(void)\\n{\\n    A* a = new B();\\n    a->fun();//输出B，A类中的fun在B类中重写\\n}\\n```\\n\\n2、重载\\n\\n我们在平时写代码中会用到几个函数但是他们的实现功能相同，但是有些细节却不同。例如：交换两个数的值其中包括（int, float,char,double)这些个类型。在C语言中我们是利用不同的函数名来加以区分。这样的代码不美观而且给程序猿也带来了很多的不便。于是在C++中人们提出了用一个函数名定义多个函数，也就是所谓的函数重载。函数重载是指同一可访问区内被声明的几个具有不同参数列（**参数的类型，个数，顺序不同**）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型。\\n\\n```cpp\\n#include<bits/stdC++.h>\\n\\nusing namespace std;\\n\\nclass A\\n{\\n    void fun() {};\\n    void fun(int i) {};\\n    void fun(int i, int j) {};\\n    void fun1(int i,int j){};\\n};\\n```\\n\\n### 3.4 C++如何实现重写与重载的？在C语言中怎么实现函数重载？\\n\\n答1：重写：在基类的函数前加上virual关键字，就可以在派生类中重写该函数，运行时将会根据对象的实际类型来调用对应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数。\\n\\n>i. 用virtual关键字申明的函数叫做虚函数，虚函数肯定是类的成员函数\\n>ii. 存在虚函数的类都有一个一维的虚函数表叫做虚表，类的对象有一个指向虚表开始的虚指针。虚表是和类对应的，虚表指针是和对象对应的\\n>iii. 多态性是一个接口多种实现，是面向对象的核心，分为类的多态性和函数的多态性\\n>iv. 重写用虚函数来实现，结合动态绑定\\n>v. 纯虚函数是虚函数再加上 = 0\\n>vi. 抽象类是指包括至少一个纯虚函数的类\\n\\n纯虚函数：virtual void fun()=0。即抽象类必须在子类实现这个函数，即先有名称，没有内容，在派生类实现内容。而虚函数可以再子类中不实现。还有，仅含有虚函数的类，并不是抽象类。\\n\\n答2：重载：C++通过命名倾轧（name mangling）技术来改名函数名，区分参数不同的同名函数，命名倾轧是在编译阶段完成的。\\n\\n题外话：C++在编译阶段通过函数名+形参列表的方式来区分函数，所以可以实现函数重载。而C语言在编译时是以函数名来区分函数的，所以C与C++混编的时候会出现错误。可以在++代码中使用extern{}关键字来保证正确编译。\\n\\n答3：c语言中不允许有同名函数，因为编译时函数命名是一样的，不像C++会添加参数类型和返回类型作为函数编译后的名称，进而实现重载。如果要用c语言显现函数重载，可通过以下方式来实现：\\n\\n>1. 使用函数指针来实现，重载的函数不能使用同名称，只是类似的实现了函数重载功能\\n>2. 重载函数使用可变参数，方式如打开文件open函数\\n>3. gcc有内置函数，程序使用编译函数可以实现函数重载\\n\\n一般方式1比较常用，示例代码：\\n\\n```cpp\\n#include<stdio.h>\\n\\nvoid func_int(void * a)\\n{\\n    printf(\\\"%d\\\\n\\\",*(int*)a);  //输出int类型，注意 void * 转化为int\\n}\\n\\nvoid func_double(void * b)\\n{\\n    printf(\\\"%.2f\\\\n\\\",*(double*)b);\\n}\\n\\ntypedef void (*ptr)(void *);  //typedef申明一个函数指针\\n\\nvoid c_func(ptr p,void *param)\\n{\\n     p(param);                //调用对应函数\\n}\\n\\nint main()\\n{\\n    int a = 23;\\n    double b = 23.23;\\n    c_func(func_int,&a);\\n    c_func(func_double,&b);\\n    return 0;\\n}\\n```\\n\\n关于typedef和函数指针的恩怨纠葛，在补充代码如下：\\n\\n```cpp\\n//形式1：返回类型(*函数名)(参数列表)\\n#include <iostream>\\nusing namespace std;\\n//定义一个函数指针pFUN，它指向一个返回类型为char，有一个整型的参数的函数\\nchar (*pFun)(int);\\n//定义一个返回类型为char，参数为int的函数\\n//从指针层面上理解该函数，即函数的函数名实际上是一个指针，\\n//该指针指向函数在内存中的首地址\\nchar glFun(int a)\\n{\\n    cout << a;\\n    //return a;\\n}\\nint main()\\n{\\n//将函数glFun的地址赋值给变量pFun\\n    pFun = glFun;\\n//*pFun”显然是取pFun所指向地址的内容，当然也就是取出了函数glFun()的内容，然后给定参数为2。\\n    (*pFun)(2);\\n    return 0;\\n}\\n\\n//形式2 typedef  返回类型(*新类型)(参数表)\\n// typedef可以让函数指针更直观方便 ,typedef是新定义了一种类型\\ntypedef char (*PTRFUN)(int); \\nPTRFUN pFun; \\nchar glFun(int a){ return;} \\nvoid main() \\n{ \\n    pFun = glFun; \\n    (*pFun)(2); \\n}\\n```\\n\\n对于typedef void(\\\\*T)(void \\\\*)，我们进行一层层的剖析\\n\\n1、首先写成 void(\\\\*T)() 可以看出 T是一个指针，是一个指向返回值为void ，参数为空的类型的函数指针\\n\\n2、在加上(void \\\\*)  为 void(\\\\*T)(void \\\\*)  就变成了一个指向 返回值为void，参数为void \\\\*类型的指针\\n\\n3、在加上上typedef ，加上后，T就不再是一个函数指针了，它代表着一种类型，这种类型可以定义一个 指向 返回值为void，参数为void \\\\*类型的指针 \\n\\n4、``比如 T t;``\\n\\n``void func(void \\\\*)；``\\n\\n``t=func ``\\n\\n### 3.5 构造函数分为哪几种？\\n\\n默认无参构造函数、拷贝构造函数、有参构造函数（初始化列表或函数体内赋值）、<font color=\'red\'>移动构造函数</font>\\n\\n需要注意：有参构造中，可细分为初始化列表he函数体内赋值。初始化列表就是在定义变量的同时就给值，函数体内赋值相当于先定义变量，再给值。当类中有成员变量为常量时，必须使用初始化列表。\\n\\n下面以代码举例，说明拷贝构造函数和移动构造函数：\\n\\n```cpp\\n//拷贝构造函数\\nTest(const Test& t)\\n    {\\n        this->i = t.i;\\n        this->p = new int(*t.p);\\n    }\\n    \\n//移动构造函数\\nclass Example{\\nprivate:\\n\\tstring *ptr;\\npublic:\\n\\t //移动构造函数\\n\\t Example (Example&& x) : ptr(x.ptr) \\n    {\\n        x.ptr = nullptr;\\n    }\\n    //拷贝构造函数 深拷贝  区别在于不会处理形参元素x\\n    Example (Example& x)\\n    {\\n    \\tdelete ptr;\\n    \\tptr=new string(x.ptr);\\n    }\\n    //有参构造函数\\n    Example (const string& str) : ptr(new string(str)) {}\\n    //重载赋值运算符\\n    Example& operator= (Example6&& x) \\n    {\\n        delete ptr; \\n        ptr = x.ptr;\\n        x.ptr=nullptr;\\n        return *this;\\n    }\\n    //打印字符串\\n    const string& content() const {return *ptr;}\\n    //重载加号运算符：\\n    Example operator+(const Example& rhs) \\n    {\\n        return Example(content()+rhs.content());\\n    }\\n}；\\n```\\n\\n### 3.6 只定义析构函数，会自动生成哪些构造函数\\n\\n只定义了析构函数，编译器将自动为我们生成拷贝构造函数和默认构造函数。\\n\\n注意：有了有参的构造了，编译器就不提供默认的构造函数。\\n\\n### 3.7 说说一个类，默认会生成哪些函数\\n\\n定义了一个空类，默认为生成以下几个函数：\\n1、无参构造函数\\n2、拷贝构造函数（默认的为浅拷贝）\\n3、重载赋值运算符\\n4、析构函数（非虚）\\n\\n### 3.8 说说 C++ 类对象的初始化顺序，有多重继承情况下的顺序\\n\\n1. 创建派生类的对象，基类的构造函数优先被调用（也优先于派生类里的成员类）；\\n\\n2. 如果类里面有成员类，成员类的构造函数优先被调用；(也优先于该类本身的构造函数）\\n\\n3. 基类构造函数如果有多个基类，则<font color=\'red\'>构造函数的调用顺序是某类在类派生表中出现的顺序</font>而不是它们在成员初始化表中的顺序；；（即：class 类名：public 基类1，public 基类2）\\n\\n4. 成员类对象构造函数如果有多个成员类对象，则<font color=\'red\'>构造函数的调用顺序是对象在类中被声明的顺序</font>而不是它们出现在成员初始化表中的顺序；（即：类内变量：类名 变量1；类名 变量2）\\n\\n5. 派生类构造函数，作为一般规则派生类构造函数应该不能直接向一个基类数据成员赋值而是把值传递给适当的基类构造函数,否则两个类的实现变成紧耦合的（tightly coupled）将更加难于正确地修改或扩展基类的实现。（基类设计者的责任是提供一组适当的基类构造函数）\\n\\n综上可以得出，初始化顺序：\\n\\n> 父类构造函数–>成员类对象构造函数–>自身构造函数\\n>\\n> 其中成员变量的初始化与声明顺序有关，构造函数的调用顺序是类派生列表中的顺序。\\n>\\n> 析构顺序和构造顺序相反。\\n\\n代码示例：\\n\\n```cpp\\n#include <iostream>\\nusing namespace std;\\nclass Base1 {\\npublic:\\n\\tBase1(int i)\\n\\t{\\n\\t\\tcout << \\\"construting Base1——\\\" << i << endl;\\n\\t}\\n\\tBase1(Base1& b1)\\n\\t{\\n\\t\\tcout << \\\"Base1 Copy constructor\\\" << endl;\\n\\t}\\n\\t~Base1()\\n\\t{\\n\\t\\tcout << \\\"~Base1\\\" << endl;\\n\\t}\\n};\\nclass Base2\\n{\\npublic:\\n\\tBase2(int j)\\n\\t{\\n\\t\\tcout << \\\"constructing Base2——\\\" << j << endl;\\n\\t}\\n\\tBase2(Base2& b2)\\n\\t{\\n\\t\\tcout << \\\"Base2 Copy constructor\\\" << endl;\\n\\t}\\n\\t~Base2()\\n\\t{\\n\\t\\tcout << \\\"~Base2\\\" << endl;\\n\\t}\\n};\\nclass Derived :public Base1, public Base2\\n{\\npublic:\\n\\t//Derived(int a, int b, int c, int d) :Base1(b), member2(c), Base2(a), member1(d)\\n\\tDerived(int a, int b, int c, int d) :Base1(a), member2(b), Base2(c), member1(d)\\n\\t{\\n\\t\\tcout << \\\"constructing Derived\\\" << endl;\\n\\t}\\n\\tDerived(Derived& d) :Base1(d), member2(d), Base2(d), member1(d)\\n\\t{\\n\\t\\tcout << \\\"Derived Copy constructor \\\" << endl;\\n\\t}\\n\\t~Derived()\\n\\t{\\n\\t\\tcout << \\\"~Derived\\\" << endl;\\n\\t}\\nprivate:\\n\\tBase2 member2; \\n\\tBase1 member1;\\n};\\n//在派生类中的，基类构造函数的调用顺序是，先看权限继承方式上的顺序：public Base1, public Base2；\\n//再看成员变量定义的顺序：Base2 member2; Base1 member1;\\nint test()\\n{\\n\\tDerived d1(1, 2, 3, 4);\\n\\tDerived d2(d1);\\n\\treturn 0;\\n}\\nint main()\\n{\\n\\ttest();\\n\\tsystem(\\\"pause\\\");\\n\\treturn 0;\\n}\\n//输出结果为：\\nconstruting Base1——1\\nconstructing Base2——3\\nconstructing Base2——2\\nconstruting Base1——4\\nconstructing Derived\\nBase1 Copy constructor\\nBase2 Copy constructor\\nBase2 Copy constructor\\nBase1 Copy constructor\\nDerived Copy constructor\\n~Derived\\n~Base1\\n~Base2\\n~Base2\\n~Base1\\n~Derived\\n~Base1\\n~Base2\\n~Base2\\n~Base1\\n```\\n\\n### 3.9 简述下向上转型和向下转型\\n\\n1. 子类转换为父类：向上转型，使用dynamic_cast(expression)，这种转换相对来说比较安全不会有数据的丢失；\\n\\n2. 父类转换为子类：向下转型，可以使用强制转换，这种转换时不安全的，会导致数据的丢失，原因是父类的指针或者引用的内存中可能不包含子类的成员的内存。\\n\\n### 3.10 简述下深拷贝和浅拷贝，如何实现深拷贝\\n\\n1. 浅拷贝：又称值拷贝，将源对象的值拷贝到目标对象中去，本质上来说源对象和目标对象共用一份实体，只是所引用的变量名不同，地址其实还是相同的。举个简单的例子，你的小名叫西西，大名叫冬冬，当别人叫你西西或者冬冬的时候你都会答应，这两个名字虽然不相同，但是都指的是你。\\n\\n2. 深拷贝，拷贝的时候先开辟出和源对象大小一样的空间，然后将源对象里的内容拷贝到目标对象中去，这样两个指针就指向了不同的内存位置。并且里面的内容是一样的，这样不但达到了我们想要的目的，还不会出现问题，两个指针先后去调用析构函数，分别释放自己所指向的位置。即为每次增加一个指针，便申请一块新的内存，并让这个指针指向新的内存，深拷贝情况下，不会出现重复释放同一块内存的错误。\\n\\n### 3.11 简述一下C++中的多态\\n\\n由于派生类重写基类方法，然后用基类引用指向派生类对象，调用方法时候会进行动态绑定，这就是多态。 多态分为静态多态和动态多态：\\n\\n1. 静态多态：编译器在编译期间完成的，编译器会根据实参类型来推断该调用哪个函数，如果有对应的函数，就调用，没有则在编译时报错。例如：\\n\\n```cpp\\ninclude<iostream>\\nusing namespace std;\\n\\nint Add(int a,int b)//1\\n{\\n    return a+b;\\n}\\n\\nchar Add(char a,char b)//2\\n{\\n    return a+b;\\n}\\n\\nint main()\\n{\\n    cout<<Add(666,888)<<endl;//1\\n    cout<<Add(\'1\',\'2\');//2\\n    return 0;\\n}\\n```\\n\\n静态多态，就是在编译阶段就实现的多态。\\n\\n2. 动态多态：其实要实现动态多态，需要几个条件----即动态绑定条件：\\n\\n> 虚函数，基类必须含有虚函数，派生类必须重写虚函数；\\n> 通过基类指针或引用来调用虚函数\\n\\n### 3.12 为什么要虚析构，为什么不能虚构造？\\n\\n1. 为什么要虚析构：将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。如果基类的析构函数不是虚函数，在特定情况下会导致派生类无法被析构。\\n\\n> i. 用派生类类型指针绑定派生类实例，析构的时候，不管基类析构函数是不是虚函数，都会正常析构\\n>\\n> ii. 用基类类型指针绑定派生类实例，析构的时候，如果基类析构函数不是虚函数，则只会析构基类，不会析构派生类对象，从而造成内存泄漏。为什么会出现这种现象呢，个人认为析构的时候如果没有虚函数的动态绑定功能，就只根据指针的类型来进行的，而不是根据指针绑定的对象来进行，所以只是调用了基类的析构函数；如果基类的析构函数是虚函数，则析构的时候就要根据指针绑定的对象来调用对应的析构函数了。\\n\\nC++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。\\n\\n2. 为什么不能虚构造？\\n\\ni. 从存储空间角度：虚函数对应一个vtable,这个表的地址是存储在对象的内存空间的。如果将构造函数设置为虚函数，就需要到vtable 中调用，可是对象还没有实例化，没有内存空间分配，如何调用。（悖论）\\n\\nii. 从使用角度：虚函数主要用于在信息不全的情况下，能使重载的函数得到对应的调用。构造函数本身就是要初始化实例，那使用虚函数也没有实际意义呀。所以构造函数没有必要是虚函数。虚函数的作用在于通过父类的指针或者引用来调用它的时候能够变成调用子类的那个成员函数。而构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数。\\n\\niii. 从实现上看，vtable 在构造函数调用后才建立，因而构造函数不可能成为虚函数。从实际含义上看，在调用构造函数时还不能确定对象的真实类型（因为子类会调父类的构造函数）；而且构造函数的作用是提供初始化，在对象生命期只执行一次，不是对象的动态行为，也没有太大的必要成为虚函数。\\n\\n### 3.13 说说模板类是在什么时候实现的\\n\\n1. 模板实例化：模板的实例化分为显式实例化和隐式实例化，前者是研发人员明确的告诉模板应该使用什么样的类型去生成具体的类或函数，后者是在编译的过程中由编译器来决定使用什么类型来实例化一个模板。不管是显式实例化或隐式实例化，最终生成的类或函数完全是按照模板的定义来实现的\\n\\n2. 模板具体化：当模板使用某种类型实例化后生成的类或函数不能满足需要时，可以考虑对模板进行具体化。具体化时可以修改原模板的定义，当使用该类型时，按照具体化后的定义实现，具体化相当于对某种类型进行特殊处理。<font color=\'blue\'>模板的具体化，就是重写模板</font>>\\n\\n代码示例：\\n\\n```cpp\\n#include <iostream>\\nusing namespace std;\\n\\n// #1 模板定义\\ntemplate<class T>\\nstruct TemplateStruct\\n{\\n    TemplateStruct()\\n    {\\n        cout << sizeof(T) << endl;\\n    }\\n};\\n\\n// #2 模板显示实例化\\ntemplate struct TemplateStruct<int>;\\n\\n// #3 模板具体化\\ntemplate<> struct TemplateStruct<double>\\n{\\n    TemplateStruct() {\\n        cout << \\\"--8--\\\" << endl;\\n    }\\n};\\n\\nint main()\\n{\\n    TemplateStruct<int> intStruct;\\n    TemplateStruct<double> doubleStruct;\\n\\n    // #4 模板隐式实例化\\n    TemplateStruct<char> llStruct;\\n}\\n//输出结果为：\\n4\\n--8--\\n1\\n```\\n\\n### 3.14 说说类继承时，派生类对不同关键字修饰的基类方法的访问权限\\n\\n类中的成员可以分为三种类型，分别为public成员、protected成员、public成员。类中可以直接访问自己类的public、protected、private成员，但类对象只能访问自己类的public成员。\\n\\n1. public继承：派生类可以访问基类的public、protected成员，不可以访问基类的private成员；\\n   派生类对象可以访问基类的public成员，不可以访问基类的protected、private成员。\\n\\n2. protected继承：派生类可以访问基类的public、protected成员，不可以访问基类的private成员；\\n   派生类对象不可以访问基类的public、protected、private成员。\\n\\n3. private继承：派生类可以访问基类的public、protected成员，不可以访问基类的private成员；\\n   派生类对象不可以访问基类的public、protected、private成员。\\n\\n### 3.15 简述一下移动构造函数，什么库用到了这个函数？\\n\\nC++11中新增了移动构造函数。与拷贝类似，移动也使用一个对象的值设置另一个对象的值。但是，又与拷贝不同的是，移动实现的是对象值真实的转移（源对象到目的对象）：源对象将丢失其内容，其内容将被目的对象占有。移动操作的发生的时候，是当移动值的对象是未命名的对象的时候。这里未命名的对象就是那些临时变量，甚至都不会有名称。典型的未命名对象就是函数的返回值或者类型转换的对象。使用临时对象的值初始化另一个对象值，不会要求对对象的复制：因为临时对象不会有其它使用，因而，它的值可以被移动到目的对象。做到这些，就要使用移动构造函数和移动赋值：当使用一个临时变量对对象进行构造初始化的时候，调用移动构造函数。类似的，使用未命名的变量的值赋给一个对象时，调用移动赋值操作。\\n\\n移动操作的概念对对象管理它们使用的存储空间很有用的，诸如对象使用new和delete分配内存的时候。在这类对象中，拷贝和移动是不同的操作：从A拷贝到B意味着，B分配了新内存，A的整个内容被拷贝到为B分配的新内存上。\\n\\n而从A移动到B意味着分配给A的内存转移给了B，没有分配新的内存，它仅仅包含简单地拷贝指针。\\n\\n看下面的例子：\\n\\n```cpp\\n// 移动构造函数和赋值\\n#include <iostream>\\n#include <string>\\nusing namespace std;\\n\\nclass Example6 {\\nprivate:\\n    string* ptr;\\npublic:\\n    Example6 (const string& str) : ptr(new string(str)) {}\\n    ~Example6 () {delete ptr;}\\n    // 移动构造函数，参数x不能是const Pointer&& x，\\n    // 因为要改变x的成员数据的值；\\n    // C++98不支持，C++0x（C++11）支持\\n    Example6 (Example6&& x) : ptr(x.ptr) \\n    {\\n        x.ptr = nullptr;\\n    }\\n    // move assignment\\n    Example6& operator= (Example6&& x) \\n    {\\n        delete ptr; \\n        ptr = x.ptr;\\n        x.ptr=nullptr;\\n        return *this;\\n    }\\n    // access content:\\n    const string& content() const {return *ptr;}\\n    // addition:\\n    Example6 operator+(const Example6& rhs) \\n    {\\n        return Example6(content()+rhs.content());\\n    }\\n};\\nint main () {\\n    Example6 foo(\\\"Exam\\\");           // 构造函数\\n    Example6 bar(move(foo));     // 移动构造函数\\n                                // 调用move之后，foo变为一个右值引用变量，\\n                                // 此时，foo所指向的字符串已经被\\\"掏空\\\"，\\n                                // 所以此时不能再调用foo\\n\\tExample6 bar2 = Example6(\\\"ple\\\"); // 拷贝构造函数\\n    bar = bar+ bar2;             // 移动赋值，在这儿\\\"=\\\"号右边的加法操作，\\n                                // 产生一个临时值，即一个右值\\n                                 // 所以此时调用移动赋值语句\\n    cout << \\\"bar\'s content: \\\" << bar.content() << \'\\\\n\';\\n    return 0;\\n}\\n//说明：std::move()函数时C++11新增的，用于将一个左值引用转换为右值引用。\\n//输出结果为：bar`s content: Example\\n//附加说明：本例中，如何调用重载赋值运算符：Example6 str2=move(bar);此时，bar字符串被删除内存，str2=Example\\n```\\n\\n### 3.16 请你回答一下 C++ 类内可以定义引用数据成员吗？\\n\\nC++类内可以定义引用成员变量，但要遵循以下三个规则：\\n\\n1. 不能用默认构造函数初始化，必须提供构造函数，用初始化列表的方式来初始化引用成员变量。否则会造成引用未初始化错误。\\n\\n2. 构造函数的形参也必须是引用类型。\\n\\n3. 不能在构造函数里初始化，必须在初始化列表中进行初始化。\\n\\n### 3.17 简述一下什么是常函数，有什么作用\\n\\n类的成员函数后面加 const，表明这个函数不会对这个类对象的数据成员（准确地说是非静态数据成员）作任何改变。在设计类的时候，一个原则就是对于不改变数据成员的成员函数都要在后面加const，而对于改变数据成员的成员函数不能加 const。所以 const 关键字对成员函数的行为作了更明确的限定：有 const 修饰的成员函数（指 const 放在函数参数表的后面，而不是在函数前面或者参数表内），只能读取数据成员，不能改变数据成员；没有 const 修饰的成员函数，对数据成员则是可读可写的。除此之外，在类的成员函数后面加 const 还有什么好处呢？那就是**常量（即 const）对象可以调用 const 成员函数，而不能调用非const修饰的函数**。正如非const类型的数据可以给const类型的变量赋值一样，反之则不成立。\\n\\n```cpp\\n#include<iostream>\\nusing namespace std;\\n\\nclass CStu\\n{\\npublic:\\n    int a;\\n    CStu()\\n    {\\n        a = 12;\\n    }\\n\\n    void Show() const\\n    {\\n        //a = 13; //常函数不能修改数据成员\\n        cout <<a << \\\"I am show()\\\" << endl;\\n    }\\n};\\n\\nint main()\\n{\\n    CStu st;\\n    st.Show();\\n    system(\\\"pause\\\");\\n    return 0;\\n}\\n```\\n\\n### 3.18 说说什么是虚继承，解决什么问题，如何实现？\\n\\n虚继承是解决C++多重继承问题的一种手段，从不同途径继承来的同一基类，会在子类中存在多份拷贝。这将存在两个问题：其一，浪费存储空间；第二，存在二义性问题，通常可以将派生类对象的地址赋值给基类对象，实现的具体方式是，将基类指针指向继承类（继承类有基类的拷贝）中的基类对象的地址，但是多重继承可能存在一个基类的多份拷贝，这就出现了二义性。虚继承可以解决多种继承前面提到的两个问题（即菱形继承问题）\\n\\n```cpp\\n#include<iostream>\\nusing namespace std;\\nclass A{\\npublic:\\n    int _a;\\n};\\nclass B :virtual public A\\n{\\npublic:\\n    int _b;\\n};\\nclass C :virtual public A\\n{\\npublic:\\n    int _c;\\n};\\nclass D :public B, public C\\n{\\npublic:\\n    int _d;\\n};\\n//菱形继承和菱形虚继承的对象模型\\nint main()\\n{\\n    D d;\\n    d.B::_a = 1;\\n    d.C::_a = 2;\\n    d._b = 3;\\n    d._c = 4;\\n    d._d = 5;\\n    cout << sizeof(D) << endl;\\n    return 0;\\n}\\n```\\n\\n分别从菱形继承和虚继承来分析：\\n\\n>菱形继承中A在B,C,D,中各有一份，虚继承中，A共享。\\n>\\n>上面的虚继承表实际上是一个指针数组。B、C实际上是虚基表指针，指向虚基表。\\n>\\n>虚基表：存放相对偏移量，用来找虚基类\\n\\n### 3.19 简述一下虚函数和纯虚函数，以及实现原理\\n\\n1. C++中的虚函数的作用主要是实现了多态的机制。关于多态，简而言之就是用父类型的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。这种技术可以让父类的指针有“多种形态”，这是一种泛型技术。**如果调用非虚函数，则无论实际对象是什么类型，都执行基类类型所定义的函数**。非虚函数总是在编译时根据调用该函数的对象，引用或指针的类型而确定。如果调用虚函数，则直到运行时才能确定调用哪个函数，运行的虚函数是引用所绑定或指针所指向的对象所属类型定义的版本。虚函数必须是基类的非静态成员函数。虚函数的作用是实现动态联编，也就是在程序的运行阶段动态地选择合适的成员函数，在定义了虚函数后，可以在基类的派生类中对虚函数重新定义，在派生类中重新定义的函数应与虚函数具有相同的形参个数和形参类型。以实现统一的接口，不同定义过程。如果在派生类中没有对虚函数重新定义，则它继承其基类的虚函数。\\n\\n\\n```cpp\\nclass Person{\\n    public:\\n        //虚函数\\n        virtual void GetName(){\\n            cout<<\\\"PersonName:xiaosi\\\"<<endl;\\n        };\\n};\\nclass Student:public Person{\\n    public:\\n        void GetName(){\\n            cout<<\\\"StudentName:xiaosi\\\"<<endl;\\n        };\\n};\\nint main(){\\n    //指针\\n    Person *person = new Student();\\n    //基类调用子类的函数\\n    person->GetName();//StudentName:xiaosi\\n}\\n```\\n\\n虚函数（Virtual Function）是通过一张虚函数表（Virtual Table）来实现的。简称为V-Table。在这个表中，主是要一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，保证其真实反应实际的函数。这样，在有虚函数的类的实例中这个表被分配在了这个实例的内存中，所以，当我们用父类的指针来操作一个子类的时候，这张虚函数表就显得尤为重要了，它就像一个地图一样，指明了实际所应该调用的函数。\\n\\n\\n2. 纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加“=0” virtualvoid GetName() =0。在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。为了解决上述问题，将函数定义为纯虚函数，则编译器要求在派生类中必须予以重写以实现多态性。同时含有纯虚拟函数的类称为抽象类，它不能生成对象。这样就很好地解决了上述两个问题。将函数定义为纯虚函数能够说明，该函数为后代类型提供了可以覆盖的接口，但是这个类中的函数绝不会调用。声明了纯虚函数的类是一个抽象类。所以，用户不能创建类的实例，只能创建它的派生类的实例。必须在继承类中重新声明函数（不要后面的＝0）否则该派生类也不能实例化，而且它们在抽象类中往往没有定义。定义纯虚函数的目的在于，使派生类仅仅只是继承函数的接口。纯虚函数的意义，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但类无法为纯虚函数提供一个合理的缺省实现。所以类纯虚函数的声明就是在告诉子类的设计者，“你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它”。\\n\\n```cpp\\n//抽象类\\nclass Person{\\n    public:\\n        //纯虚函数\\n        virtual void GetName()=0;\\n};\\nclass Student:public Person{\\n    public:\\n        Student(){\\n        };\\n        void GetName(){\\n            cout<<\\\"StudentName:xiaosi\\\"<<endl;\\n        };\\n};\\nint main(){\\n    Student student;\\n}\\n```\\n\\n### 3.20 说说纯虚函数能实例化吗，为什么？派生类要实现吗，为什么？\\n\\n1. 纯虚函数不可以实例化，但是可以用其派生类实例化，示例如下：\\n\\n```cpp\\nclass Base\\n{\\npublic:\\n    virtual void func() = 0;\\n};\\n```\\n\\n```cpp\\n #include<iostream>\\n\\n using namespace std;\\n\\n class Base\\n {\\n public:\\n     virtual void func() = 0;\\n };\\n\\n class Derived :public Base\\n {\\n public:\\n     void func() override\\n     {\\n         cout << \\\"哈哈\\\" << endl;\\n     }\\n };\\n\\n int main()\\n {\\n     Base *b = new Derived();\\n     b->func();\\n\\n     return 0;\\n }\\n\\n```\\n\\n2. 虚函数的原理采用 vtable。类中含有纯虚函数时，其vtable 不完全，有个空位。\\n   即“纯虚函数在类的vtable表中对应的表项被赋值为0。也就是指向一个不存在的函数。由于编译器绝对不允许有调用一个不存在的函数的可能，所以该类不能生成对象。在它的派生类中，除非重写此函数，否则也不能生成对象。”\\n\\n   所以纯虚函数不能实例化。\\n\\n3. 纯虚函数是在基类中声明的虚函数，它要求任何派生类都要定义自己的实现方法，以实现多态性。\\n\\n4. 定义纯虚函数是为了实现一个接口，用来规范派生类的行为，也即规范继承这个类的程序员必须实现这个函数。派生类仅仅只是继承函数的接口。纯虚函数的意义在于，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但基类无法为纯虚函数提供一个合理的缺省实现。所以类纯虚函数的声明就是在告诉子类的设计者，“你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它”。\\n\\n### 3.21 说说C++中虚函数与纯虚函数的区别\\n\\n答：\\n\\n1. 虚函数和纯虚函数可以定义在同一个类中，含有纯虚函数的类被称为抽象类，而只含有虚函数的类不能被称为抽象类。\\n\\n2. 虚函数可以被直接使用，也可以被子类重载以后，以多态的形式调用，而纯虚函数必须在子类中实现该函数才可以使用，因为纯虚函数在基类有声明而没有定义。\\n\\n3. 虚函数和纯虚函数都可以在子类中被重载，以多态的形式被调用。\\n\\n4. 虚函数和纯虚函数通常存在于抽象基类之中，被继承的子类重载，目的是提供一个统一的接口。\\n\\n5. 虚函数的定义形式：`virtual{}`;纯虚函数的定义形式：`virtual {} = 0`;在虚函数和纯虚函数的定义中不能有static标识符，原因很简单，被static修饰的函数在编译时要求前期绑定,然而虚函数却是动态绑定，而且被两者修饰的函数生命周期也不一样。\\n\\n举个虚函数的例子：\\n\\n```cpp\\nclass A\\n{\\npublic:\\n    virtual void foo()\\n    {\\n        cout<<\\\"A::foo() is called\\\"<<endl;\\n    }\\n};\\nclass B:public A\\n{\\npublic:\\n    void foo()\\n    {\\n        cout<<\\\"B::foo() is called\\\"<<endl;\\n    }\\n};\\nint main(void)\\n{\\n    A *a = new B();\\n    a->foo();   // 在这里，a虽然是指向A的指针，但是被调用的函数(foo)却是B的!\\n    return 0;\\n}\\n```\\n\\n这个例子是虚函数的一个典型应用，通过这个例子，也许你就对虚函数有了一些概念。它虚就虚在所谓“推迟联编”或者“动态联编”上，一个类函数的调用并不是在编译时刻被确定的，而是在运行时刻被确定的。由于编写代码的时候并不能确定被调用的是基类的函数还是哪个派生类的函数，所以被成为“虚”函数。\\n\\n虚函数只能借助于指针或者引用来达到多态的效果。\\n\\n\\n2. 纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加“=0” 。形如`virtual void funtion1()=0`\\n\\n为了方便使用多态特性，我们常常需要在基类中定义虚拟函数。\\n\\n在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。\\n\\n为了解决上述问题，引入了纯虚函数的概念，将函数定义为纯虚函数（方法：virtual ReturnType Function()= 0;），则编译器要求在派生类中必须予以重写以实现多态性。同时含有纯虚拟函数的类称为抽象类，它不能生成对象。这样就很好地解决了上述两个问题。\\n声明了纯虚函数的类是一个抽象类。所以，用户不能创建类的实例，只能创建它的派生类的实例。\\n\\n纯虚函数最显著的特征是：它们必须在继承类中重新声明函数（不要后面的＝0，否则该派生类也不能实例化），而且它们在抽象类中往往没有定义。\\n\\n定义纯虚函数的目的在于，使派生类仅仅只是继承函数的接口。\\n\\n纯虚函数的意义，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但类无法为纯虚函数提供一个合理的缺省实现。所以类纯虚函数的声明就是在告诉子类的设计者，“你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它”。\\n\\n### 3.22 说说 C++ 中什么是菱形继承问题，如何解决\\n\\n使用虚继承来解决该问题\\n\\n```cpp\\nclass Tiger : virtual public Animal { /* ... */ };\\nclass Lion : virtual public Animal { /* ... */ }\\n```\\n\\n### 3.23 请问构造函数中的能不能调用虚方法\\n\\n不要在构造函数中调用虚方法，从语法上讲，调用完全没有问题，但是从效果上看，往往不能达到需要的目的。\\n\\n派生类对象构造期间进入基类的构造函数时，对象类型变成了基类类型，而不是派生类类型。\\n\\n同样，进入基类析构函数时，对象也是基类类型。\\n\\n所以，虚函数始终仅仅调用基类的虚函数（如果是基类调用虚函数），不能达到多态的效果，所以放在构造函数中是没有意义的，而且往往不能达到本来想要的效果。\\n\\n### 3.24 请问拷贝构造函数的参数是什么传递方式，为什么\\n\\n1. 拷贝构造函数的参数必须使用引用传递\\n\\n2. 如果拷贝构造函数中的参数不是一个引用，即形如CClass(const CClass c_class)，那么就相当于采用了传值的方式(pass-by-value)，而传值的方式会调用该类的拷贝构造函数，从而造成无穷递归地调用拷贝构造函数。因此拷贝构造函数的参数必须是一个引用。\\n\\n需要澄清的是，传指针其实也是传值，如果上面的拷贝构造函数写成CClass(const CClass\\\\* c_class)，也是不行的。事实上，只有传引用不是传值外，其他所有的传递方式都是传值。\\n\\n### 3.25 如何理解抽象类？\\n\\n1. 抽象类的定义如下：\\n\\n纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加“=0”，有虚函数的类就叫做抽象类。\\n\\n2. 抽象类有如下几个特点：\\n\\n1）抽象类只能用作其他类的基类，不能建立抽象类对象。\\n\\n2）抽象类不能用作参数类型、函数返回类型或显式转换的类型。\\n\\n3）可以定义指向抽象类的指针和引用，此指针可以指向它的派生类，进而实现多态性。\\n\\n### 3.26 什么是多态？除了虚函数，还有什么方式能实现多态？\\n\\n1. 多态是面向对象的重要特性之一，它是一种行为的封装，就是不同对象对同一行为会有不同的状态。(举例 : 学生和成人都去买票时,学生会打折,成人不会)\\n\\n2. 多态是以封装和继承为基础的。在C++中多态分为静态多态（早绑定）和动态多态（晚绑定）两种，其中动态多态是通过虚函数实现，静态多态通过函数重载实现，代码如下：\\n\\n```cpp\\nclass A\\n{\\npublic:    \\n    void do(int a);    \\n    void do(int a, int b);\\n};\\n```\\n\\n### 3.27 简述一下虚析构函数，什么作用\\n\\n1. 虚析构函数，是将基类的析构函数声明为virtual，举例如下：\\n\\n```cpp\\nclass TimeKeeper\\n{\\npublic:    \\n    TimeKeeper() {}        \\n    virtual ~TimeKeeper() {}    \\n};\\n```\\n\\n2. 虚析构函数的主要作用是防止内存泄露。\\n\\n定义一个基类的指针p，在delete p时，如果基类的析构函数是虚函数，这时只会看p所赋值的对象，如果p赋值的对象是派生类的对象，就会调用派生类的析构函数（毫无疑问，在这之前也会先调用基类的构造函数，在调用派生类的构造函数，然后调用派生类的析构函数，基类的析构函数，所谓先构造的后释放）；如果p赋值的对象是基类的对象，就会调用基类的析构函数，这样就不会造成内存泄露。\\n\\n如果基类的析构函数不是虚函数，在delete p时，调用析构函数时，只会看指针的数据类型，而不会去看赋值的对象，这样就会造成内存泄露。\\n\\n说明：\\n我们创建一个TimeKeeper基类和一些及其它的派生类作为不同的计时方法：\\n\\n```cpp\\nclass TimeKeeper\\n{\\npublic:\\n    TimeKeeper() {}\\n    ~TimeKeeper() {}  //非virtual的\\n};\\n\\n//都继承与TimeKeeper\\nclass AtomicClock :public TimeKeeper{};\\nclass WaterClock :public TimeKeeper {};\\nclass WristWatch :public TimeKeeper {};\\n```\\n\\n如果客户想要在程序中使用时间，不想操作时间如何计算等细节，这时候我们可以设计factory（工厂）函数，让函数返回指针指向一个计时对象。该函数返回一个基类指针，这个基类指针是指向于派生类对象的\\n\\n```cpp\\nTimeKeeper* getTimeKeeper()\\n{\\n    //返回一个指针，指向一个TimeKeeper派生类的动态分配对象\\n}\\n```\\n\\n因为函数返回的对象存在于堆中，因此为了在不使用时我们需要使用释放该对象（delete）\\n\\n```cpp\\nTimeKeeper* ptk = getTimeKeeper();\\ndelete ptk;\\n```\\n\\n**此处基类的析构函数是非virtual的，因此通过一个基类指针删除派生类对象是错误的**\\n\\n<font color=\'red\'>解决办法</font>： 将基类的析构函数改为virtual就正确了\\n\\n```cpp\\nclass TimeKeeper\\n{\\npublic:\\n    TimeKeeper() {}\\n    virtual ~TimeKeeper() {}\\n};\\n```\\n\\n声明为virtual之后，通过基类指针删除派生类对象就会释放整个对象（基类+派生类）\\n\\n### 3.28 说说什么是虚基类，可否被实例化？\\n\\n1. 在被继承的类前面加上virtual关键字，这时被继承的类称为虚基类，代码如下：\\n\\n```cpp\\nclass A\\nclass B1:public virtual A;\\nclass B2:public virtual A;\\nclass D:public B1,public B2;\\n```\\n\\n2. 虚继承的类可以被实例化，举例如下：\\n\\n```cpp\\nclass Animal {/* ... */ };\\nclass Tiger : virtual public Animal { /* ... */ };\\nclass Lion : virtual public Animal { /* ... */ }\\n```\\n\\n```cpp\\nint main( )\\n{\\nLiger lg ;\\n/*既然我们已经在Tiger和Lion类的定义中声明了\\\"virtual\\\"关键字，于是下面的代码编译OK */\\nint weight = lg.getWeight();\\n}\\n```\\n\\n### 3.29  简述一下拷贝赋值和移动赋值？\\n\\n1. 拷贝赋值是通过拷贝构造函数来赋值，在创建对象时，使用同一类中之前创建的对象来初始化新创建的对象。\\n\\n2. 移动赋值是通过移动构造函数来赋值，二者的主要区别在于\\n\\n1）拷贝构造函数的形参是一个左值引用，而移动构造函数的形参是一个右值引用；\\n\\n2）拷贝构造函数完成的是整个对象或变量的拷贝，而移动构造函数是生成一个指针指向源对象或变量的地址，接管源对象的内存，相对于大量数据的拷贝**节省时间和内存空间**。\\n\\n### 3.30 仿函数了解吗？有什么作用\\n\\n1. 仿函数（functor）又称为函数对象（function object）**是一个能行使函数功能的类**。仿函数的语法几乎和我们普通的函数调用一样，不过作为仿函数的类，都<font color=\'red\'>必须重载operator()运算符</font>，举个例子：\\n\\n ```cpp\\n class Func{\\n     public:\\n         void operator() (const string& str) const {\\n             cout<<str<<endl;\\n         }\\n };\\n Func myFunc;\\n myFunc(\\\"helloworld!\\\");\\n//输出：\\nhelloworld!\\n ```\\n\\n2. 仿函数既能想普通函数一样传入给定数量的参数，还能存储或者处理更多我们需要的有用信息。我们可以举个例子：\\n\\n假设有一个`vector<string>`，你的任务是统计长度小于5的string的个数，如果使用count_if函数的话，你的代码可能长成这样：\\n\\n```cpp\\n  bool LengthIsLessThanFive(const string& str) {\\n       return str.length()<5;   \\n  }\\nint res=count_if(vec.begin(), vec.end(), LengthIsLessThanFive);\\n其中count_if函数的第三个参数是一个函数指针，返回一个bool类型的值。一般的，如果需要将特定的阈值长度也传入的话，我们可能将函数写成这样：\\n```cpp\\n bool LenthIsLessThan(const string& str, int len) {\\n      return str.length()<len;\\n  }\\n```\\n\\n这个函数看起来比前面一个版本更具有一般性，但是他不能满足count_if函数的参数要求：count_if要求的是unary function（仅带有一个参数）作为它的最后一个参数。如果我们使用仿函数，是不是就豁然开朗了呢：\\n\\n```cpp\\n  class ShorterThan {\\n      public:\\n          explicit ShorterThan(int maxLength) : length(maxLength) {}\\n          bool operator() (const string& str) const {\\n              return str.length() < length;\\n          }\\n      private:\\n          const int length;\\n  };\\n```\\n\\n### 3.31 C++ 中哪些函数不能被声明为虚函数？\\n\\n常见的不不能声明为虚函数的有：**普通函数（非成员函数），静态成员函数，内联成员函数，构造函数，友元函数**。\\n\\n1. 为什么C++不支持普通函数为虚函数？\\n\\n普通函数（非成员函数）只能被overload(重载)，不能被override(重写)，声明为虚函数也没有什么意思，因此编译器会在编译时绑定函数。\\n\\n2. 为什么C++不支持构造函数为虚函数？\\n\\n这个原因很简单，主要是从语义上考虑，所以不支持。因为构造函数本来就是为了明确初始化对象成员才产生的，然而virtual function主要是为了再不完全了解细节的情况下也能正确处理对象。另外，virtual函数是在不同类型的对象产生不同的动作，现在对象还没有产生，如何使用virtual函数来完成你想完成的动作。（这不就是典型的悖论）\\n\\n构造函数用来创建一个新的对象,而虚函数的运行是建立在对象的基础上,在构造函数执行时,对象尚未形成,所以不能将构造函数定义为虚函数\\n\\n3. 为什么C++不支持内联成员函数为虚函数？\\n\\n内联函数就是为了在代码中直接展开，减少函数调用花费的代价，而虚函数是为了在继承后对象能够准确的执行自己的动作，这是不可能统一的。（再说了，inline函数在编译时被展开，虚函数在运行时才能动态的绑定函数）\\n\\n内联函数是在编译时期展开,而虚函数的特性是运行时才动态联编,所以两者矛盾,不能定义内联函数为虚函数\\n\\n4. 为什么C++不支持静态成员函数为虚函数？\\n\\n这也很简单，静态成员函数对于每个类来说只有一份代码，所有的对象都共享这一份代码，他也没有要动态绑定的必要性。\\n\\n静态成员函数属于一个类而非某一对象,没有this指针,它无法进行对象的判别\\n\\n5. 为什么C++不支持友元函数为虚函数？\\n\\n因为C++不支持友元函数的继承，对于没有继承特性的函数没有虚函数的说法。\\n\\n### 3.32 解释下 C++ 中类模板和模板类的区别\\n\\n1. 类模板是模板的定义，不是一个实实在在的类，定义中用到通用类型参数\\n\\n2. 模板类是实实在在的类定义，是类模板的实例化。类定义中参数被实际类型所代替。\\n\\n答案解析\\n\\n1. 类模板的类型参数可以有一个或多个，每个类型前面都必须加class或typename，如template <class T1,class T2>class someclass{…};在定义对象时分别代入实际的类型名，如 someclass<int,double> obj;\\n\\n2. 和使用类一样，使用类模板时要注意其作用域，只能在其有效作用域内用它定义对象。\\n\\n3. 模板可以有层次，一个类模板可以作为基类，派生出派生模板类。\\n\\n### 3.33 虚函数表里存放的内容是什么时候写进去的？\\n\\n1. 虚函数表是一个存储虚函数地址的数组,以NULL结尾。虚表（vtable）在**编译阶段生成**，对象内存空间开辟以后，写入对象中的 v_ptr，然后调用构造函数。即：虚表在构造函数之前写入。\\n\\n2. 除了在构造函数之前写入之外，我们还需要考虑到虚表的二次写入机制，通过此机制让每个对象的虚表指针都能准确的指向到自己类的虚表，为实现动多态提供支持。\\n\\n## 4、标准模板库STL\\n\\n\\n\\n\\n## 5、C++新特性\\n\\n### 5.1 C++新特性\\n\\n内容参考于[csdn](https://blog.csdn.net/dnty00/article/details/126171485)\\n一、C++新特性\\nC++新特性主要包括包含语法改进和标准库扩充两个方面，主要包括以下11点\\n1、语法的改进\\n1）统一的初始化方法\\n在 C++11 中，可以直接在变量名后面跟上初始化列表，来进行对象的初始化\\n2）成员变量默认初始化\\n3）auto关键字用于定义变量，编译器可以自动判断的类型（前提：定义一个变量时对其进行初始化）\\n4）decltype 求表达式的类型\\n5）智能指针 shared_ptr\\n\\n和 unique_ptr、weak_ptr 不同之处在于，多个 shared_ptr 智能指针可以共同使用同一块堆内存。并且，由于该类型智能指针在实现上采用的是引用计数机制，即便有一个 shared_ptr 指针放弃了堆内存的“使用权”（引用计数减 1），也不会影响其他指向同一堆内存的 shared_ptr 指针（只有引用计数为 0 时，堆内存才会被自动释放）\\n6）空指针 nullptr（原来NULL）\\n7）基于范围的for循环\\n8）右值引用和move语义\\n\\n+ 右值引用\\n\\n```cpp\\n//左值引用\\nint num = 10;\\nint &b = num;  //正确\\nint &c = 10;   //错误，在C++98/03标准中，无法为右值添加引用\\n```\\n\\n实际开发中可能需要对右值进行修改（实现移动语义时就需要），显然左值引用的方式是行不通的。为此，C++11 标准新引入了另一种引用方式，称为右值引用，用 “&&” 表示。\\n\\n```cpp\\nint num = 10;\\n//int && a = num;  //右值引用不能初始化为左值\\nint && a = 10;\\n```\\n\\n+ move语义\\n\\n在C++11中，标准库在中提供了一个有用的函数std::move，std::move()函数并不能移动任何东西，它唯一的功能是将一个左值引用强制转化为右值引用，继而可以通过右值引用使用该值，以用于移动语义。从实现上讲，std::move基本等同于一个类型转换：static_cast<T&&>(lvalue);\\n\\n```cpp\\nmove( arg ) //其中，arg 表示指定的左值对象。该函数会返回 arg 对象的右值形式。\\n```\\n\\n2、标准模板库的扩充（往STL里面添加了一些模板类，比较好用）\\n9）无序容器（哈希表）\\n用法和功能同map一模一样，区别在于哈希表的效率更高\\n10）正则表达式\\n可以认为正则表达式实质上是一个字符串，该字符串描述了一种特定模式的字符串\\n11）Lambda表达式（匿名函数）\\nlambda表达式是一个匿名函数，用于定义并创建匿名的函数对象，以简化编程工作。举个例子：\\n\\n```cpp\\n vector<int> vec;\\n sort(vec.begin(), vec.end(), cmp); // 旧式\\n sort(vec.begin(), vec.end(), [](int a, int b) -> bool { return a < b; });   // Lambda表达式\\n```\\n\\n声明lambda表达式：\\n\\n```cpp\\n[capture list] (params list) mutable exception-> return type { function body }\\n```\\n\\n+ capture list：捕获外部变量列表\\n+ params list：形参列表\\n+ mutable指示符：用来说用是否可以修改捕获的变量\\n+ exception：异常设定\\n+ return type：返回类型\\n+ function body：函数体\\n\\n详细说明：\\n\\n1. 统一的初始化方法\\n   C++98/03 可以使用初始化列表（initializer list）进行初始化：\\n\\n```cpp\\nint i_arr[3] = { 1, 2, 3 };\\nlong l_arr[] = { 1, 3, 2, 4 };\\nstruct A\\n{\\n    int x;\\n    int y;\\n} a = { 1, 2 };\\n```\\n\\n但是这种初始化方式的适用性非常狭窄，只有上面提到的这两种数据类型可以使用初始化列表。在 C++11 中，初始化列表的适用性被大大增加了。它现在可以用于任何类型对象的初始化，实例如下：\\n\\n```cpp\\nclass Foo\\n{\\npublic:\\n    Foo(int) {}\\nprivate:\\n    Foo(const Foo &);\\n};\\nint main(void)\\n{\\n    Foo a1(123);\\n    Foo a2 = 123;  //error: \'Foo::Foo(const Foo &)\' is private\\n    Foo a3 = { 123 };\\n    Foo a4 { 123 };\\n    int a5 = { 3 };\\n    int a6 { 3 };\\n    return 0;\\n}\\n```\\n\\n在上例中，a3、a4 使用了新的初始化方式来初始化对象，效果如同 a1 的直接初始化。a5、a6 则是基本数据类型的列表初始化方式。可以看到，它们的形式都是统一的。这里需要注意的是，a3 虽然使用了等于号，但它仍然是列表初始化，因此，私有的拷贝构造并不会影响到它。a4 和 a6 的写法，是 C++98/03 所不具备的。在 C++11 中，可以直接在变量名后面跟上初始化列表，来进行对象的初始化。\\n\\n2. 成员变量默认初始化\\n   好处：构建一个类的对象不需要用构造函数初始化成员变量。\\n\\n```cpp\\n//程序实例\\n#include<iostream>\\nusing namespace std;\\nclass B\\n{\\npublic:\\n    int m = 1234; //成员变量有一个初始值\\n    int n;\\n};\\nint main()\\n{\\n    B b;\\n    cout << b.m << endl;\\n    return 0;\\n}\\n```\\n\\n3. auto关键字\\n   用于定义变量，编译器可以自动判断的类型（前提：定义一个变量时对其进行初始化）。\\n\\n```cpp\\n//程序实例\\n#include <vector>\\nusing namespace std;\\nint main(){\\n    vector< vector<int> > v;\\n    vector< vector<int> >::iterator i = v.begin();\\n    return 0;\\n}\\n```\\n\\n可以看出来，定义迭代器 i 的时候，类型书写比较冗长，容易出错。然而有了 auto 类型推导，我们大可不必这样，只写一个 auto 即可。\\n\\n4. decltype 求表达式的类型\\n\\ndecltype 是 C++11 新增的一个关键字，它和 auto 的功能一样，都用来在编译时期进行自动类型推导。\\n\\n(1)为什么要有decltype\\n\\n因为 auto 并不适用于所有的自动类型推导场景，在某些特殊情况下 auto 用起来非常不方便，甚至压根无法使用，所以 decltype 关键字也被引入到 C++11 中。\\n\\nauto 和 decltype 关键字都可以自动推导出变量的类型，但它们的用法是有区别的：\\n\\n```cpp\\nauto varname = value;\\ndecltype(exp) varname = value;\\n```\\n\\n其中，varname 表示变量名，value 表示赋给变量的值，exp 表示一个表达式。\\n\\nauto 根据\\\"=\\\"右边的初始值 value 推导出变量的类型，而 decltype 根据 exp 表达式推导出变量的类型，跟\\\"=\\\"右边的 value 没有关系。\\n\\n另外，auto 要求变量必须初始化，而 decltype 不要求。这很容易理解，auto 是根据变量的初始值来推导出变量类型的，如果不初始化，变量的类型也就无法推导了。decltype 可以写成下面的形式：\\n\\n>decltype(exp) varname;\\n\\n(2)代码示例\\n\\n```cpp\\n// decltype 用法举例\\nnt a = 0;\\ndecltype(a) b = 1;  //b 被推导成了 int\\ndecltype(10.8) x = 5.5;  //x 被推导成了 double\\ndecltype(x + 100) y;  //y 被推导成了 double\\n```\\n\\n5. 智能指针 shared_ptr\\n\\n和 unique_ptr、weak_ptr 不同之处在于，多个 shared_ptr 智能指针可以共同使用同一块堆内存。并且，由于该类型智能指针在实现上采用的是引用计数机制，即便有一个 shared_ptr 指针放弃了堆内存的“使用权”（引用计数减 1），也不会影响其他指向同一堆内存的 shared_ptr 指针（只有引用计数为 0 时，堆内存才会被自动释放）。\\n\\n```cpp\\n#include <iostream>\\n#include <memory>\\nusing namespace std;\\nint main()\\n{\\n    //构建 2 个智能指针\\n    std::shared_ptr<int> p1(new int(10));\\n    std::shared_ptr<int> p2(p1);\\n    //输出 p2 指向的数据\\n    cout << *p2 << endl;\\n    p1.reset();//引用计数减 1,p1为空指针\\n    if (p1) {\\n        cout << \\\"p1 不为空\\\" << endl;\\n    }\\n    else {\\n        cout << \\\"p1 为空\\\" << endl;\\n    }\\n    //以上操作，并不会影响 p2\\n    cout << *p2 << endl;\\n    //判断当前和 p2 同指向的智能指针有多少个\\n    cout << p2.use_count() << endl;\\n    return 0;\\n}\\n\\n/*    程序运行结果：        \\n            10\\n            p1 为空\\n            10\\n            1    \\n*/   \\n```\\n\\n6. 空指针 nullptr（原来NULL）\\n\\n nullptr 是 nullptr_t 类型的右值常量，专用于初始化空类型指针。nullptr_t 是 C++11 新增加的数据类型，可称为“指针空值类型”。也就是说，nullpter 仅是该类型的一个实例对象（已经定义好，可以直接使用），如果需要我们完全定义出多个同 nullptr 完全一样的实例对象。值得一提的是，nullptr 可以被隐式转换成任意的指针类型。例如：\\n\\n```cpp\\nint * a1 = nullptr;\\nchar * a2 = nullptr;\\ndouble * a3 = nullptr;\\n```\\n\\n 显然，不同类型的指针变量都可以使用 nullptr 来初始化，编译器分别将 nullptr 隐式转换成 int、char 以及 double\\\\* 指针类型。另外，通过将指针初始化为 nullptr，可以很好地解决 NULL 遗留的问题，比如：\\n\\n```cpp\\n#include <iostream>\\nusing namespace std;\\nvoid isnull(void *c){\\n    cout << \\\"void*c\\\" << endl;\\n}\\nvoid isnull(int n){\\n    cout << \\\"int n\\\" << endl;\\n}\\nint main() {\\n    isnull(NULL);\\n    isnull(nullptr);\\n    return 0;\\n}\\n\\n/*    程序运行结果：        \\n        int n\\n        void*c\\n*/         \\n```\\n\\n7. 基于范围的for循环\\n   如果要用 for 循环语句遍历一个数组或者容器，只能套用如下结构：\\n\\n```cpp\\nfor(表达式 1; 表达式 2; 表达式 3){\\n    //循环体\\n}\\n```\\n\\n```cpp\\n//程序实例\\n#include <iostream>\\n#include <vector>\\n#include <string.h>\\nusing namespace std;\\nint main() {\\n    char arc[] = \\\"www.123.com\\\";\\n    int i;\\n    //for循环遍历普通数组\\n    for (i = 0; i < strlen(arc); i++) {\\n        cout << arc[i];\\n    }\\n    cout << endl;\\n    vector<char>myvector(arc,arc+3);\\n    vector<char>::iterator iter;\\n    //for循环遍历 vector 容器\\n    for (iter = myvector.begin(); iter != myvector.end(); ++iter) {\\n        cout << *iter;\\n    }\\n    return 0;\\n}\\n/*    程序运行结果：        \\n        www.123.com\\n        www\\n*/      \\n```\\n\\n8. 右值引用和move语义\\n   i. 右值引用\\n\\n C++98/03 标准中就有引用，使用 \\\"&\\\" 表示。但此种引用方式有一个缺陷，即正常情况下只能操作 C++ 中的左值，无法对右值添加引用。举个例子：\\n\\n```cpp\\nint num = 10;\\nint &b = num; //正确\\nint &c = 10; //错误\\n```\\n\\n 如上所示，编译器允许我们为 num 左值建立一个引用，但不可以为 10 这个右值建立引用。因此，C++98/03 标准中的引用又称为左值引用。\\n\\n注意，虽然 C++98/03 标准不支持为右值建立非常量左值引用，但允许使用常量左值引用操作右值。也就是说，常量左值引用既可以操作左值，也可以操作右值，例如：\\n\\n```cpp\\nint num = 10;\\nconst int &b = num;\\nconst int &c = 10;\\n```\\n\\n我们知道，右值往往是没有名称的，因此要使用它只能借助引用的方式。这就产生一个问题，实际开发中我们可能需要对右值进行修改（实现移动语义时就需要），显然左值引用的方式是行不通的。\\n\\n 为此，C++11 标准新引入了另一种引用方式，称为右值引用，用 \\\"&&\\\" 表示。\\n\\n 需要注意的，和声明左值引用一样，右值引用也必须立即进行初始化操作，且只能使用右值进行初始化，比如：\\n\\n```cpp\\nint num = 10;\\n//int && a = num;  //右值引用不能初始化为左值\\nint && a = 10;\\n​ 和常量左值引用不同的是，右值引用还可以对右值进行修改。例如：\\n\\nint && a = 10;\\na = 100;\\ncout << a << endl;\\n/*    程序运行结果：        \\n        100    \\n*/          \\n​ 另外值得一提的是，C++ 语法上是支持定义常量右值引用的，例如:\\nconst int&& a = 10;//编译器不会报错\\n```\\n\\n 但这种定义出来的右值引用并无实际用处。一方面，右值引用主要用于移动语义和完美转发，其中前者需要有修改右值的权限；其次，常量右值引用的作用就是引用一个不可修改的右值，这项工作完全可以交给常量左值引用完成。\\n\\nii. move语义\\n\\n move 本意为 \\\"移动\\\"，但该函数并不能移动任何数据，它的功能很简单，就是将某个左值强制转化为右值。基于 move() 函数特殊的功能，其常用于实现移动语义。move() 函数的用法也很简单，其语法格式如下：\\n\\n> move( arg ) //其中，arg 表示指定的左值对象。该函数会返回 arg 对象的右值形式。\\n\\n```cpp\\n//程序实例\\n#include <iostream>\\nusing namespace std;\\nclass first {\\npublic:\\n    first() :num(new int(0)) {\\n        cout << \\\"construct!\\\" << endl;\\n    }\\n    //移动构造函数\\n    first(first &&d) :num(d.num) {\\n        d.num = NULL;\\n        cout << \\\"first move construct!\\\" << endl;\\n    }\\npublic:    //这里应该是 private，使用 public 是为了更方便说明问题\\n    int *num;\\n};\\nclass second {\\npublic:\\n    second() :fir() {}\\n    //用 first 类的移动构造函数初始化 fir\\n    second(second && sec) :fir(move(sec.fir)) {\\n        cout << \\\"second move construct\\\" << endl;\\n    }\\npublic:    //这里也应该是 private，使用 public 是为了更方便说明问题\\n    first fir;\\n};\\nint main() {\\n    second oth;\\n    second oth2 = move(oth);\\n    //cout << *oth.fir.num << endl;   //程序报运行时错误\\n    return 0;\\n}\\n\\n/*    程序运行结果：\\n          construct!\\n        first move construct!\\n        second move construct\\n*/            \\n```\\n\\n9. 无序容器（哈希表）\\n\\n用法和功能同map一模一样，区别在于哈希表的效率更高。\\n\\n(1) 无序容器具有以下 2 个特点：\\n\\n a. 无序容器内部存储的键值对是无序的，各键值对的存储位置取决于该键值对中的键，\\n\\n b. 和关联式容器相比，无序容器擅长通过指定键查找对应的值（平均时间复杂度为 O(1)）；但对于使用迭代器遍历容器中存储的元素，无序容器的执行效率则不如关联式容器。\\n\\n(2) 和关联式容器一样，无序容器只是一类容器的统称，其包含有 4 个具体容器，分别为 unordered_map、unordered_multimap、unordered_set 以及 unordered_multiset。功能如下表：\\n\\n| 无序容器           | 功能                                                         |\\n| ------------------ | ------------------------------------------------------------ |\\n| unordered_map      | 存储键值对 <key, value> 类型的元素，其中各个键值对键的值不允许重复，且该容器中存储的键值对是无序的。 |\\n| unordered_multimap | 和 unordered_map 唯一的区别在于，该容器允许存储多个键相同的键值对。 |\\n| unordered_set      | 不再以键值对的形式存储数据，而是直接存储数据元素本身（当然也可以理解为，该容器存储的全部都是键 key 和值 value 相等的键值对，正因为它们相等，因此只存储 value 即可）。另外，该容器存储的元素不能重复，且容器内部存储的元素也是无序的。 |\\n| unordered_multiset | 和 unordered_set 唯一的区别在于，该容器允许存储值相同的元素。 |\\n\\n 程序实例（以 unordered_map 容器为例）\\n\\n```cpp\\n#include <iostream>\\n#include <string>\\n#include <unordered_map>\\nusing namespace std;\\nint main()\\n{\\n    //创建并初始化一个 unordered_map 容器，其存储的 <string,string> 类型的键值对\\n    std::unordered_map<std::string, std::string> my_uMap{\\n        {\\\"教程1\\\",\\\"www.123.com\\\"},\\n        {\\\"教程2\\\",\\\"www.234.com\\\"},\\n        {\\\"教程3\\\",\\\"www.345.com\\\"} };\\n    //查找指定键对应的值，效率比关联式容器高\\n    string str = my_uMap.at(\\\"C语言教程\\\");\\n    cout << \\\"str = \\\" << str << endl;\\n    //使用迭代器遍历哈希容器，效率不如关联式容器\\n    for (auto iter = my_uMap.begin(); iter != my_uMap.end(); ++iter)\\n    {\\n        //pair 类型键值对分为 2 部分\\n        cout << iter->first << \\\" \\\" << iter->second << endl;\\n    }\\n    return 0;\\n}\\n\\n/*    程序运行结果：\\n          教程1 www.123.com\\n          教程2 www.234.com\\n          教程3 www.345.com\\n*/  \\n```\\n\\n10. 正则表达式\\n\\n可以认为正则表达式实质上是一个字符串，该字符串描述了一种特定模式的字符串。常用符号的意义如下：\\n\\n11. Lambda匿名函数\\n    所谓匿名函数，简单地理解就是没有名称的函数，又常被称为 lambda 函数或者 lambda 表达式。\\n\\n（1）定义\\n\\n lambda 匿名函数很简单，可以套用如下的语法格式：\\n\\n [外部变量访问方式说明符] (参数) mutable noexcept/throw() -> 返回值类型\\n​ {\\n​ 函数体;\\n​ };\\n\\n其中各部分的含义分别为：\\n\\na. [外部变量方位方式说明符]\\n\\n> [ ] 方括号用于向编译器表明当前是一个 lambda 表达式，其不能被省略。在方括号内部，可以注明当前 lambda 函数的函数体中可以使用哪些“外部变量”。\\n\\n所谓外部变量，指的是和当前 lambda 表达式位于同一作用域内的所有局部变量。\\nb. (参数)\\n\\n>和普通函数的定义一样，lambda 匿名函数也可以接收外部传递的多个参数。和普通函数不同的是，如果不需要传递参数，可以连同 () 小括号一起省略；\\n\\nc. mutable\\n\\n>此关键字可以省略，如果使用则之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，对于以值传递方式引入的外部变量，不允许在 lambda 表达式内部修改它们的值（可以理解为这部分变量都是 const 常量）。而如果想修改它们，就必须使用 mutable 关键字。\\n\\n 注意:对于以值传递方式引入的外部变量，lambda 表达式修改的是拷贝的那一份，并不会修改真正的外部变量；\\n\\nd. noexcept/throw()\\n\\n>可以省略，如果使用，在之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，lambda 函数的函数体中可以抛出任何类型的异常。而标注 noexcept 关键字，则表示函数体内不会抛出任何异常；使用 throw() 可以指定 lambda 函数内部可以抛出的异常类型。\\n\\ne. -> 返回值类型\\n\\n>指明 lambda 匿名函数的返回值类型。值得一提的是，如果 lambda 函数体内只有一个 return 语句，或者该函数返回 void，则编译器可以自行推断出返回值类型，此情况下可以直接省略\\\"-> 返回值类型\\\"。\\n\\nf. 函数体\\n\\n>和普通函数一样，lambda 匿名函数包含的内部代码都放置在函数体中。该函数体内除了可以使用指定传递进来的参数之外，还可以使用指定的外部变量以及全局范围内的所有全局变量。\\n\\n（2）程序实例\\n\\n```cpp\\n#include <iostream>\\n#include <algorithm>\\nusing namespace std;\\nint main()\\n{\\n    int num[4] = {4, 2, 3, 1};\\n    //对 a 数组中的元素进行排序\\n    sort(num, num+4, [=](int x, int y) -> bool{ return x < y; } );\\n    for(int n : num){\\n        cout << n << \\\" \\\";\\n    }\\n    return 0;\\n}\\n\\n/*    程序运行结果：\\n          1 2 3 4\\n*/ \\n```\\n\\n### 5.2 说说 C++ 中智能指针和指针的区别是什么？\\n\\n1. 智能指针\\n\\n 如果在程序中使用new从堆（自由存储区）分配内存，等到不需要时，应使用delete将其释放。C++引用了智能指针auto_ptr，以帮助自动完成这个过程。随后的编程体验（尤其是使用STL）表明，需要有更精致的机制。基于程序员的编程体验和BOOST库提供的解决方案，C++11摒弃了auto_ptr，并新增了三种智能指针：unique_ptr、shared_ptr和weak_ptr。所有新增的智能指针都能与STL容器和移动语义协同工作。\\n\\n2. 指针\\n\\n C 语言规定所有变量在使用前必须先定义，指定其类型，并按此分配内存单元。指针变量不同于整型变量和其他类型的变量，它是专门用来存放地址的，所以必须将它定义为“指针类型”。\\n\\n智能指针和普通指针的区别\\n\\n 智能指针和普通指针的区别在于智能指针实际上是对普通指针加了一层封装机制，区别是它负责自动释放所指的对象，这样的一层封装机制的目的是为了使得智能指针可以方便的管理一个对象的生命期。\\n\\n### 5.3 \\n\\n\\n## 6、C++操作系统（Linux相关）\\n\\n\\n\\n\\n## 7、计算机网络\\n\\n\\n\\n\\n\\n## 8、设计模式（摘选）\\n\\n\\n\\n\\n\\n## 9、常见编程大题\\n\\n\\n\\n\",\"articleCover\":\"https://upload.haoxx.site/article/b6877ebd88b9d69396333c5769e07c05.jpg\",\"articleTitle\":\"全面内容综述\",\"articleType\":1,\"categoryName\":\"编程语言基础\",\"id\":71,\"isRecommend\":0,\"isTop\":0,\"status\":1,\"tagNameList\":[]}]','PUT','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',42,'2023-06-07 19:54:56');
INSERT INTO `t_operation_log` VALUES (1348,'文章模块','上传','/admin/article/upload','com.ican.controller.ArticleController.saveArticleImages','上传文章图片','image_10.jpg','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/article/a48f6cb59c54e3e6f6397ee22eed38b2.jpg\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',21,'2023-06-07 19:55:16');
INSERT INTO `t_operation_log` VALUES (1349,'文章模块','修改','/admin/article/update','com.ican.controller.ArticleController.updateArticle','修改文章','[{\"articleContent\":\"\\n## C++基础\\n\\n\\n\\n### 1. 虚函数\\n\\n### 2. 指针的理解\\n\\n### 3. malloc和new的基本概念以及区别\\n\\n[csdn资料](https://blog.csdn.net/weixin_43899008/article/details/123261412)\\n一、属性方面，malloc是库函数，需要头文件支持，new是运算符，需要编译器支持。\\n二、参数方面，new无需指定内存大小，编译器会自行计算；malloc需要指定内存大小。而且new会调用构造函数。\\n三、处理数组方面，new使用new[]，并使用delete[]进行释放，malloc需要手动定义数组大小，并用free释放内存。\\n四、返回类型，malloc返回值是void\\\\*指针，使用前需要显式地指定为需要的指针类型。new分配成功返回的是对象类型指针，与对象严格匹配，无类型转换，所以new是符合类型安全性操作符。\\n五、内存分配方面，new内存分配失败时，抛出bad_alloc异常，malloc分配内存失败时返回NULL。\\n六、自定义类型方面，new会先调用operator new函数，申请足够的内存，然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete就是反着来，先调用析构函数，然后operator delete函数释放内存。malloc是库函数，只能动态地申请和释放内存，无法强制要求其做自定义类型对象构造和析构函数。\\n七、new可以重载，malloc不可以\\n八、new在自由储存区分配内存，malloc在堆上分配内存。\\n九、内存泄漏方面，内存泄漏对于new和malloc都能检测出来，new可以明确指出是哪个文件的哪一行，但是malloc不可以明确指出是哪个文件的哪一行。\\n十、效率方面，new是关键字，malloc是库函数，new效率更高。\\n\\n![图1](https://s3.bmp.ovh/imgs/2022/08/28/6c46c39176ca9029.png)\\n\\n### 4. 智能指针，弱指针作用\\n\\n### 5. \\\\*p++的间隔\\n\\n### 6. 指针为NULL，访问会怎样\\n\\n简单说一下，c的NULL是宏定义，为void\\\\*，而cpp的NULL宏定义为0。cpp常用nullptr来给指针赋初值。nullptr的值为void\\\\*。\\n\\n可以给指针赋初始值为NULL，但是不可以访问。内存地址为0的区域是用户应用程序访问的禁区，一旦访问就会段错误。\\n\\n### 7. const int \\\\*p和int \\\\* const p的区别\\n\\n常量指针和指针常量。前者本质为指针，只是指针指向内存区域里存放的数据为常量，所以常量指针：指向的区域可以更改，指向的内容不可以更改；后者本质为常量，只是常量里装的是指针，所以指针指向不能改，指向的内容可以更改。\\n\\n### 8. C++ join detach\\n\\npthread_join()是在父线程中调用，等子线程运行完后通知子线程，然后父线程回收子线程资源。pthread_detach()是在子线程中调用，是子线程脱离父线程，子线程运行完后由系统回收资源。\\n\\n### 9. <font color=\'red\'>C++ 11新特性</font>\\n\\n内容参考于[csdn](https://blog.csdn.net/dnty00/article/details/126171485)\\n一、cpp新特性\\ncpp新特性主要包括包含语法改进和标准库扩充两个方面，主要包括以下11点\\n1、语法的改进\\n1）统一的初始化方法\\n在 cpp11 中，可以直接在变量名后面跟上初始化列表，来进行对象的初始化\\n2）成员变量默认初始化\\n3）auto关键字用于定义变量，编译器可以自动判断的类型（前提：定义一个变量时对其进行初始化）\\n4）decltype 求表达式的类型\\n5）智能指针 shared_ptr\\n\\n和 unique_ptr、weak_ptr 不同之处在于，多个 shared_ptr 智能指针可以共同使用同一块堆内存。并且，由于该类型智能指针在实现上采用的是引用计数机制，即便有一个 shared_ptr 指针放弃了堆内存的“使用权”（引用计数减 1），也不会影响其他指向同一堆内存的 shared_ptr 指针（只有引用计数为 0 时，堆内存才会被自动释放）\\n6）空指针 nullptr（原来NULL）\\n7）基于范围的for循环\\n8）右值引用和move语义\\n\\n+ 右值引用\\n\\n```cpp\\n//左值引用\\nint num = 10;\\nint &b = num;  //正确\\nint &c = 10;   //错误，在cpp98/03标准中，无法为右值添加引用\\n```\\n\\n实际开发中可能需要对右值进行修改（实现移动语义时就需要），显然左值引用的方式是行不通的。为此，cpp11 标准新引入了另一种引用方式，称为右值引用，用 “&&” 表示。\\n\\n```cpp\\nint num = 10;\\n//int && a = num;  //右值引用不能初始化为左值\\nint && a = 10;\\n```\\n\\n+ move语义\\n\\n在cpp11中，标准库在中提供了一个有用的函数std::move，std::move()函数并不能移动任何东西，它唯一的功能是将一个左值引用强制转化为右值引用，继而可以通过右值引用使用该值，以用于移动语义。从实现上讲，std::move基本等同于一个类型转换：static_cast<T&&>(lvalue);\\n\\n```cpp\\nmove( arg ) //其中，arg 表示指定的左值对象。该函数会返回 arg 对象的右值形式。\\n```\\n\\n2、标准模板库的扩充（往STL里面添加了一些模板类，比较好用）\\n9）无序容器（哈希表）\\n用法和功能同map一模一样，区别在于哈希表的效率更高\\n10）正则表达式\\n可以认为正则表达式实质上是一个字符串，该字符串描述了一种特定模式的字符串\\n11）Lambda表达式（匿名函数）\\nlambda表达式是一个匿名函数，用于定义并创建匿名的函数对象，以简化编程工作。举个例子：\\n\\n```cpp\\n vector<int> vec;\\n sort(vec.begin(), vec.end(), cmp); // 旧式\\n sort(vec.begin(), vec.end(), [](int a, int b) -> bool { return a < b; });   // Lambda表达式\\n```\\n\\n声明lambda表达式：\\n\\n```cpp\\n[capture list] (params list) mutable exception-> return type { function body }\\n```\\n\\n+ capture list：捕获外部变量列表\\n+ params list：形参列表\\n+ mutable指示符：用来说用是否可以修改捕获的变量\\n+ exception：异常设定\\n+ return type：返回类型\\n+ function body：函数体\\n\\n二、智能指针\\n\\n**为什么要使用智能指针**：\\n\\n智能指针的作用是管理一个指针，因为存在申请的空间在函数结束时忘记释放，造成内存泄漏的情况。使用智能指针可以很大程度上避免这个问题，因为智能指针就是一个类，当超出了类的作用域时，类会自动调用析构函数，自动释放资源。所以**智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间**。\\n智能指针的作用：处理内存泄漏问题和空悬指针问题。\\n\\ncpp中的智能指针有4种，分别为：shared_ptr、unique_ptr、weak_ptr、auto_ptr，其中auto_ptr被cpp11弃用。\\n\\n+ 对于shared_ptr，可解决资源忘记释放的内存泄漏问题，及悬空指针问题。\\n  *shared_ptr实现共享式拥有的概念，多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。从名字share就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。\\n\\n+ 对于unique_ptr，对象对其有唯一所有权。\\n  unique_ptr实现独占式拥有的概念，同一时间只能有一个智能指针可以指向该对象，它对于避免资源泄露，因为无法进行拷贝构造和拷贝赋值，但是可以进行移动构造和移动赋值。\\n\\n+ 对于weak_ptr，和 shared_ptr 搭配，不会增加引用计数，用于避免循环引用（比如 a 对象持有 b 对象，b 对象持有 a 对象），这样必然会导致内存泄露。\\n  解决shared_ptr相互引用时，两个指针的引用计数永远不会下降为0，从而导致死锁问题。而weak_ptr是对对象的一种弱引用，可以绑定到shared_ptr，但不会增加对象的引用计数\\n\\n+ 对于auto_ptr，实现独占式拥有的概念，同一时间只能有一个智能指针可以指向该对象；但auto_ptr在cpp11中被摒弃，其主要问题在于：\\n  1）对象所有权的转移，比如在函数传参过程中，对象所有权不会返还，从而存在潜在的内存崩溃问题；\\n  2）不能指向数组，也不能作为STL容器的成员\\n\\n### 10. 匿名函数\\n\\n匿名函数lambada表达式，就是没有名字的函数。最常见的匿名函数是`[](){}`。它没有参数也没有返回值。在匿名函数中，[]里面用来捕获函数外部的变量，而()里面就是匿名函数的参数，{}里面就是函数的执行代码。\\n\\n概念：cpp11提供了类似与Python的lambda表达式的方式，称为匿名函数，其好处是：使用匿名函数，可以免去函数的声明和定义。这样匿名函数仅在调用函数的时候才会创建函数对象，而调用结束后立即释放，所以匿名函数比非匿名函数更节省空间。\\n\\nLambda在STL中使用，书写上带来极大的方便。\\n捕获capture： //类似于函数名，是匿名函数的触发条件\\n\\n>[] //未定义变量.试图在Lambda内使用任何外部变量都是错误的.\\n>[x, &y] //x 按值捕获, y 按引用捕获.\\n>[&] //用到的任何外部变量都隐式按引用捕获\\n>[=] //用到的任何外部变量都隐式按值捕获\\n>[&, x] //x显式地按值捕获. 其它变量按引用捕获\\n>[=, &z] //z按引用捕获. 其它变量按值捕获\\n\\nparameters: //参数\\nreturn-type: //返回值\\nbody: //函数体\\n例子：\\n\\n```cpp\\n[](int x, int y) { return x + y; } // 隐式返回类型\\n[](int& x) { ++x; }   // 没有return语句 -> lambda 函数的返回类型是\'void\'\\n[]() { ++global_x; }  // 没有参数,仅访问某个全局变量\\n[]{ ++global_x; }     // 与上一个相同,省略了()\\n```\\n\\n### 11. 类内默认的函数\\n\\n6种：<font color=\'red\'>无参构造函数，析构函数，拷贝构造函数（浅拷贝的）、赋值运算符重载函数</font>、const成员、取地址及const取地址操作符重载。\\n\\n![](https://s3.bmp.ovh/imgs/2022/08/28/a9b8047f51af8e86.png)\\n\\n### 12. 什么时候重载拷贝构造函数\\n\\n\\n### 13. 深浅拷贝\\n\\n浅拷贝就是直接用等号连接的赋值操作，一般类中不涉及内存开辟的话，浅拷贝可以使用。深拷贝需要重写拷贝构造函数。浅拷贝就是创建一个新的指针来指向对应的内容。深拷贝是新开辟一块区域，然后向指定的内容存入这块区域，然后用一个新的指针指向这块区域。\\n\\n浅拷贝只是对指针的拷贝，浅拷贝后两个指针指向同一个内存空间；深拷贝不仅对指针进行拷贝，而且对指针指向的内容进行拷贝，经深拷贝后的指针是指向两个不同地址的指针。\\n\\n当拷贝一个基类指针到派生类时，如果调用系统默认的拷贝构造函数，这时只是对指针进行拷贝，两个指针指向同一个地址，这就会导致指针被分配了一次内存，但内存被释放了两次（两次调用析构函数），造成程序崩溃。\\n\\n对于类中开辟了内存空间的情况，必须重写拷贝构造函数以实现深拷贝，否则会出现一块内存区域被重复释放多次的错误。\\n\\n### 14. stl容器底层实现\\n\\n\\n### 15. unordered_map和map区别\\n\\n### 16. 锁的作用\\n\\n\\n### 17. lock_guard的用法\\n\\n\\n\\n## 操作系统\\n\\n### 1. 进程和线程区别\\n\\n### 2. 一个线程崩溃了对其他线程有什么影响\\n\\n## 数据结构\\n\\n### 1. 红黑树基础概念，特性，根节点是什么颜色，可以有连续两个红节点吗\\n\\n## 算法题\\n\\n### 1. 获取链表倒数第三个节点（双指针）\\n\\n\\n\\n# C++中的智能指针\\n\\n内容参考自[csdn1](https://blog.csdn.net/m0_67623521/article/details/125695620)和[csdn2](https://blog.csdn.net/K346K346/article/details/81478223?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165743267316781432922953%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=165743267316781432922953&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-81478223-null-null.142%5Ev32%5Eexperiment_2_v1,185%5Ev2%5Econtrol&utm_term=c%2B%2B%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88&spm=1018.2226.3001.4187)\\n\\n## 前言\\n\\nC++ STL（Standard Template Library）一共提供了四种指针：auto_ptr、unique_ptr、shared_ptr 和 weak_ptr，其中auto_ptr是cpp98提供的，cpp11 已将其摒弃，并提出了 unique_ptr 替代 auto_ptr。\\n\\n虽然 auto_ptr 已被摒弃，但在实际项目中仍可使用，但建议使用更加安全的 unique_ptr。cpp98中只有一种智能指针auto_ptr，这个智能指针实际上是一个封装好的类，方便管理指针，使用构造函数来生成指针，使用析构函数来释放指针，避免内存泄漏。但是auto_ptr有漏洞，基于此，提出了三种新指针，unique_ptr限制了指针的所有权，只有一个对象所持有；shared_ptr在指针管理类中新增一个计数值，来记录指针所引用对象的个数，当计数值为0时就释放指针；weak_ptr智能指针没有没有重载 operator* 和 operator->，他常作为shared_ptr的辅助指针，用于监测shared_ptr的引用计数值。\\n\\n## 1、unique_ptr\\n\\n它持有对对象的独有权——两个unique_ptr 不能指向一个对象，即 unique_ptr 不共享它所管理的对象。它无法复制到其他 unique_ptr，无法通过值传递到函数，也无法用于需要副本的任何标准模板库 （STL）算法。只能移动 unique_ptr，即对资源管理权限可以实现转移。这意味着，内存资源所有权可以转移到另一个 unique_ptr，并且原始 unique_ptr 不再拥有此资源。\\n\\nunique_ptr 与原始指针一样有效，并可用于 STL 容器。将 unique_ptr 实例添加到 STL 容器运行效率很高，因为通过 unique_ptr 的移动构造函数，不再需要进行复制操作。\\n\\n独占的指针，只可以自己使用，它指向的对象只可以他一个人使用，可以使用move将使用权转移，如：\\n\\n```cpp\\n#include <iostream>\\n#include <memory>\\nusing namespace std;\\nint main(){\\n    auto ptr1=make_unique<string> (\\\"12345\\\");\\n    cout<<*ptr1<<endl;\\n    auto ptr2=std::move(ptr1);\\n    // cout<<*ptr1<<endl;\\n    cout<<*ptr2<<endl;\\n    return 0;\\n}\\n//输出结果：\\n//12345\\n//12345\\n```\\n\\n创建智能指针的方法：通过构造函数指定、通过 reset 方法重新指定、通过 release 方法释放所有权、通过移动语义转移所有权（move），unique_ptr 还可能没有对象，这种情况被称为 empty。\\n\\n```cpp\\n#include <iostream>\\n#include <memory>\\nusing namespace std;\\nint main(){\\n    unique_ptr<int> p1;\\n    p1.reset(new int(123));\\n    cout<<*p1<<endl;\\n    unique_ptr<int> p2(new int(1234));\\n    cout<<*p2<<endl;\\n    int *p3=p1.release();\\n    cout<<*p3<<endl;\\n    unique_ptr<int> p4=move(p2);\\n    cout<<*p4<<endl;\\n \\n    return 0;\\n}\\n// 123\\n// 1234\\n// 123\\n// 1234\\n```\\n\\n## 2、auto_ptr\\n\\n引入问题：\\n\\n```cpp\\nauto_ptr< string> p1(new string (\\\"string1\\\");\\nauto_ptr<string> p2;\\np2=p1;\\n```\\n\\n如果上面的指针是普通的指针，那么就会面临一个问题，就是delete的时候会删除有两次，解决方案有多种：\\n\\n1、重载复制运算符，将其定义为深复制，这样他们俩就会指向不同的地方，缺点是会浪费空间。\\n\\n2、建立所有全概念。将指针定义为只可以有一个对象拥有，赋值运算符直接将所有权转移。这就是用于 auto_ptr 和 unique_ptr 的策略，但 unique_ptr 的策略更严格。\\n\\n3、创建智能更高的指针，跟踪引用特定对象的智能指针数。这称为引用计数。例如，赋值时，计数将加 1，而指针过期时，计数将减 1,。当减为 0 时才调用 delete。这是 shared_ptr 采用的策略。\\n\\n## 3、shared_ptr\\n\\nshared_ptr 是一个标准的共享所有权的智能指针，**允许多个指针指向同一个对象**，定义在 memory 文件中，命名空间为 std。shared_ptr 利用引用计数的方式实现了对所管理的对象的所有权的分享，即允许多个 shared_ptr 共同管理同一个对象。像 shared_ptr 这种智能指针，《Effective cpp》称之为“引用计数型智能指针”（reference-counting smart pointer，RCSP）。\\n\\nshared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性（auto_ptr 是独占的），在使用引用计数的机制上提供了可以共享所有权的智能指针，当然这需要额外的开销：\\n（1）shared_ptr 对象除了包括一个所拥有对象的指针外，还必须包括一个引用计数代理对象的指针；\\n（2）时间上的开销主要在初始化和拷贝操作上， * 和 -> 操作符重载的开销跟 auto_ptr 是一样；\\n（3）开销并不是我们不使用 shared_ptr 的理由,，永远不要进行不成熟的优化，直到性能分析器告诉你这一点。\\n\\n\\n\\n可以使用辅助类来实现该智能指针，它的具体做法如下：\\n（a）当创建智能指针类的新对象时，初始化指针，并将引用计数设置为1；\\n（b）当能智能指针类对象作为另一个对象的副本时，拷贝构造函数复制副本的指向辅助类对象的指针，并增加辅助类对象对基础类对象的引用计数（加1）；\\n（c）使用赋值操作符对一个智能指针类对象进行赋值时，处理复杂一点：先使左操作数的引用计数减 1（为何减 1：因为指针已经指向别的地方），如果减1后引用计数为 0，则释放指针所指对象内存。然后增加右操作数所指对象的引用计数（为何增加：因为此时做操作数指向对象即右操作数指向对象）；\\n（d）完成析构函数：调用析构函数时，析构函数先使引用计数减 1，如果减至 0 则 delete 对象。\\n接口：\\n\\n```cpp\\nclass Point {\\nprivate:\\n    int x, y;\\npublic:\\n    Point(int xVal = 0, int yVal = 0) :x(xVal), y(yVal) {}\\n    int getX() const { return x; }\\n    int getY() const { return y; }\\n    void setX(int xVal) { x = xVal; }\\n    void setY(int yVal) { y = yVal; }\\n};\\n```\\n\\n实现：\\n\\n```cpp\\nclass SmartPtr {\\npublic:\\n\\t//构造函数\\n\\tSmartPtr() { rp = nullptr; }\\n\\tSmartPtr(Point *ptr):rp(new RefPtr(ptr)) {}\\n\\tSmartPtr(const SmartPtr &sp):rp(sp.rp) { \\n\\t\\t++rp->count;\\n\\t\\tcout << \\\"in copy constructor\\\" <<endl;\\n\\t}\\n\\t\\n\\t// 重载赋值运算符\\n\\tSmartPtr& operator=(const SmartPtr& rhs) {\\n\\t\\t++rhs.rp->count;\\n\\t\\tif (rp != nullptr && --rp->count == 0) {\\n\\t\\t\\tdelete rp;\\n\\t\\t}\\n\\t\\trp = rhs.rp;\\n\\t\\tcout << \\\"in assignment operator\\\" << endl;\\n\\t\\treturn *this;\\n\\t}\\n\\t\\n\\t// 重载->操作符\\n\\tPoint* operator->() {\\n\\t\\treturn rp->p;\\n\\t}\\n\\t\\n\\t// 重载*操作符\\n\\tPoint& operator*() {\\n\\t\\treturn *(rp->p);\\n\\t}\\n \\n\\t~SmartPtr() {\\n\\t\\tif (--rp->count == 0) delete rp;\\n\\t\\telse cout << \\\"还有\\\" << rp->count << \\\"个指针指向基础对象\\\" << endl;\\n\\t}\\n \\nprivate:\\n\\tRefPtr* rp;\\n};\\n```\\n\\n## 4、weak_ptr\\n\\nweak_ptr 被设计为与 shared_ptr 共同工作，可以从一个 shared_ptr 或者另一个 weak_ptr 对象构造而来。weak_ptr 是为了配合 shared_ptr 而引入的一种智能指针，它更像是 shared_ptr 的一个助手而不是智能指针，因为它不具有普通指针的行为，没有重载 operator* 和 operator-> ，因此取名为 weak，表明其是功能较弱的智能指针。***它的最大作用在于协助 shared_ptr 工作，可获得资源的观测权，像旁观者那样观测资源的使用情况。观察者意味着 weak_ptr 只对 shared_ptr 进行引用，而不改变其引用计数，当被观察的 shared_ptr 失效后，相应的 weak_ptr 也相应失效。**\\n\\n解决循环引用的问题，用法：\\n\\n```cpp\\nweak_ptr<T> w;\\t \\t//创建空 weak_ptr，可以指向类型为 T 的对象\\nweak_ptr<T> w(sp);\\t//与 shared_ptr 指向相同的对象，shared_ptr 引用计数不变。T必须能转换为 sp 指向的类型\\nw=p;\\t\\t\\t\\t//p 可以是 shared_ptr 或 weak_ptr，赋值后 w 与 p 共享对象\\nw.reset();\\t\\t\\t//将 w 置空\\nw.use_count();\\t\\t//返回与 w 共享对象的 shared_ptr 的数量\\nw.expired();\\t\\t//若 w.use_count() 为 0，返回 true，否则返回 false\\nw.lock();\\t\\t\\t//如果 expired() 为 true，返回一个空 shared_ptr，否则返回非空 shared_ptr\\n```\\n\\nweak_ptr 对象引用资源时不会增加引用计数，但是它能够通过 lock() 方法来判断它所管理的资源是否被释放。\\n\\n### weak_ptr指针的作用\\n\\n现在要说的问题是，weak_ptr 到底有什么作用呢？从上面那个例子看来，似乎没有任何作用。其实 weak_ptr 可用于打破循环引用。引用计数是一种便利的内存管理机制，但它有一个很大的缺点，那就是不能管理循环引用的对象。一个简单的例子如下：\\n\\n```cpp\\n#include <iostream>\\n#include <memory>\\n  \\nclass Woman;  \\nclass Man {\\nprivate:  \\n    //std::weak_ptr<Woman> _wife;  \\n    std::shared_ptr<Woman> _wife;  \\npublic:  \\n    void setWife(std::shared_ptr<Woman> woman) {  \\n        _wife = woman;  \\n    }  \\n  \\n    void doSomthing() {  \\n        if(_wife.lock()){}  \\n    }  \\n  \\n    ~Man() {\\n        std::cout << \\\"kill man\\\\n\\\";  \\n    }  \\n};  \\n  \\nclass Woman {  \\nprivate:  \\n    //std::weak_ptr<Man> _husband;  \\n    std::shared_ptr<Man> _husband;  \\npublic:  \\n    void setHusband(std::shared_ptr<Man> man) {  \\n        _husband = man;  \\n    }  \\n    ~Woman() {  \\n        std::cout <<\\\"kill woman\\\\n\\\";  \\n    }  \\n};\\n\\nint main(int argc, char** argv) {  \\n    std::shared_ptr<Man> m(new Man());  \\n    std::shared_ptr<Woman> w(new Woman());  \\n    if(m && w) {  \\n        m->setWife(w);  \\n        w->setHusband(m);  \\n    }  \\n    return 0;  \\n}\\n```\\n\\n在 Man 类内部会引用一个 Woman，Woman 类内部也引用一个 Man。当一个 man 和一个 woman 是夫妻的时候，他们直接就存在了相互引用问题。man 内部有个用于管理wife生命期的 shared_ptr 变量，也就是说 wife 必定是在 husband 去世之后才能去世。同样的，woman 内部也有一个管理 husband 生命期的 shared_ptr 变量，也就是说 husband 必须在 wife 去世之后才能去世。这就是循环引用存在的问题：husband 的生命期由 wife 的生命期决定，wife 的生命期由 husband 的生命期决定，最后两人都死不掉，违反了自然规律，导致了内存泄漏。\\n\\n一般来讲，解除这种循环引用有下面三种可行的方法：\\n（1）当只剩下最后一个引用的时候需要手动打破循环引用释放对象。\\n（2）当 parent 的生存期超过 children 的生存期的时候，children 改为使用一个普通指针指向 parent。\\n（3）使用弱引用的智能指针打破这种循环引用。\\n虽然这三种方法都可行，但方法 1 和方法 2 都需要程序员手动控制，麻烦且容易出错。这里主要介绍一下第三种方法，使用弱引用的智能指针std:weak_ptr 来打破循环引用。\\n\\nweak_ptr 对象引用资源时不会增加引用计数，但是它能够通过 lock() 方法来判断它所管理的资源是否被释放。**做法就是上面的代码注释的地方取消注释，取消 Woman 类或者 Man 类的任意一个即可，也可同时取消注释，全部换成弱引用 weak_ptr**。\\n\\n另外很自然地一个问题是：既然 weak_ptr 不增加资源的引用计数，那么在使用 weak_ptr 对象的时候，资源被突然释放了怎么办呢？不用担心，因为不能直接通过 weak_ptr 来访问资源。那么如何通过 weak_ptr 来间接访问资源呢？答案是在需要访问资源的时候 weak_ptr 为你生成一个shared_ptr，shared_ptr 能够保证在 shared_ptr 没有被释放之前，其所管理的资源是不会被释放的。创建 shared_ptr 的方法就是 lock() 成员函数。\\n\\n注意： shared_ptr 实现了 operator bool() const 方法来判断被管理的资源是否已被释放。\\n\\n## 5、如何选择智能指针\\n\\n上文简单地介绍了 cpp STL 的四种智能指针。当然，除了 STL 的智能指针，cpp 准标准库 Boost 的智能指针，比如 boost::scoped_ptr、boost::shared_array、boost::intrusive_ptr 也可在实践中使用，但这里不做进一步介绍，有兴趣的读者可以参考：[cpp 智能指针详解](https://blog.csdn.net/xt_xiaotian/article/details/5714477)。\\n\\n在了解 STL 的四种智能指针后，大家可能会想另一个问题：在实际应用中，应使用哪种智能指针呢？\\n\\n下面给出几个使用指南。\\n（1）如果程序要使用多个指向同一个对象的指针，应选择 shared_ptr。这样的情况包括：\\n\\n将指针作为参数或者函数的返回值进行传递的话，应该使用 shared_ptr；\\n两个对象都包含指向第三个对象的指针，此时应该使用 shared_ptr 来管理第三个对象；\\nSTL 容器包含指针。很多 STL 算法都支持复制和赋值操作，这些操作可用于 shared_ptr，但不能用于 unique_ptr（编译器发出 warning）和 auto_ptr（行为不确定）。如果你的编译器没有提供 shared_ptr，可使用 Boost 库提供的 shared_ptr。\\n（2）如果程序不需要多个指向同一个对象的指针，则可使用 unique_ptr。如果函数使用 new 分配内存，并返还指向该内存的指针，将其返回类型声明为 unique_ptr 是不错的选择。这样，所有权转让给接受返回值的 unique_ptr，而该智能指针将负责调用 delete。可将 unique_ptr 存储到 STL 容器中，只要对容器元素不使用拷贝操作的算法即可（如 sort()）。例如，可在程序中使用类似于下面的代码段。\\n\\n```cpp\\nunique_ptr<int> make_int(int n) {\\n    return unique_ptr<int>(new int(n));\\n}\\n\\nvoid show(unique_ptr<int>& p1) {\\n    cout << *p1 << \' \';\\n}\\n\\nint main() {\\n\\t//...\\n    vector<unique_ptr<int>> vp(size);\\n    for(int i = 0; i < vp.size(); i++) {\\n\\t\\tvp[i] = make_int(rand() % 1000);       // copy temporary unique_ptr\\n\\t}\\n    vp.push_back(make_int(rand() % 1000));     // ok because arg is temporary\\n    for_each(vp.begin(), vp.end(), show);      // use for_each()\\n\\t//...\\n}\\n```\\n\\n其中 push_back 调用没有问题，因为它返回一个临时 unique_ptr，该 unique_ptr 被赋给 vp 中的一个 unique_ptr。另外，如果按值而不是按引用给 show() 传递对象，for_each() 将非法，因为这将导致使用一个来自 vp 的非临时 unique_ptr 初始化 pi，而这是不允许的。前面说过，编译器将发现错误使用 unique_ptr 的企图。\\n\\n在 unique_ptr 为右值时，可将其赋给 shared_ptr，这与将一个 unique_ptr 赋给另一个 unique_ptr 需要满足的条件相同，即 unique_ptr 必须是一个临时对象。与前面一样，在下面的代码中，`make_int() `的返回类型为 `unique_ptr<int>`：\\n\\n```cpp\\nunique_ptr<int> pup(make_int(rand() % 1000));\\t\\t// ok\\nshared_ptr<int> spp(pup);\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// not allowed, pup as lvalue\\nshared_ptr<int> spr(make_int(rand() % 1000));    \\t// ok\\n```\\n\\n模板 shared_ptr 包含一个显式构造函数，可用于将右值 unique_ptr 转换为 shared_ptr。shared_ptr 将接管原来归 unique_ptr 所有的对象。\\n\\n在满足 unique_ptr 要求的条件时，也可使用 auto_ptr，但 unique_ptr 是更好的选择。如果你的编译器没有unique_ptr，可考虑使用 Boost 库提供的 scoped_ptr，它与 unique_ptr 类似。\\n（3）虽然说在满足 unique_ptr 要求的条件时，使用 auto_ptr 也可以完成对内存资源的管理，但是因为 auto_ ptr 不够安全，不提倡使用，即任何情况下都不应该使用 auto_ptr。\\n（4）为了解决 shared_ptr 的循环引用问题，我们可以祭出 weak_ptr。\\n（5）在局部作用域（例如函数内部或类内部），且不需要将指针作为参数或返回值进行传递的情况下，如果对性能要求严格，使用 scoped_ptr 的开销较 shared_ptr 会小一些。scoped_ptr正如其名，是一个局部指针。\\n\\n## 6、auto_ptr存在的问题\\n\\n尽可能不要把auto_ptr设置为全局指针；除非自己知道后果，否则不要把auto_ptr赋值给同类型的另一个智能指针。\\n\\n在某些应用场景下，拷贝构造函数的意义不明确，同理赋值语句也是这个道理，意义同样不明确，因为C11标准之前并不存在移动赋值和移动构造的概念，还有就是之前谈到的一个对象和一组对象的问题，对于自定义类型而言，auto_ptr的析构函数仅能够析构一个对象，不能够处理一组对象的情况，这些都是尚未解决的问题。\\n\\nauto_ptr指针当使用赋值语句将ptr1赋值给ptr2时，程序并未报错，但实际上存在隐患。问题1：auto_ptr并不共享管理权，当使用赋值语句将指针赋值后，ptr1将失去对内存的管理权。问题2：程序结束时，内存释放时会被释放两次，引发程序崩溃。\",\"articleCover\":\"https://upload.haoxx.site/article/a48f6cb59c54e3e6f6397ee22eed38b2.jpg\",\"articleTitle\":\"C++方面的部分内容\",\"articleType\":1,\"categoryName\":\"编程语言基础\",\"id\":72,\"isRecommend\":0,\"isTop\":0,\"status\":1,\"tagNameList\":[]}]','PUT','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',29,'2023-06-07 19:55:18');
INSERT INTO `t_operation_log` VALUES (1350,'文章模块','上传','/admin/article/upload','com.ican.controller.ArticleController.saveArticleImages','上传文章图片','image_12.jpg','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/article/8a9d452db38f480ff6fc43806fe4f0df.jpg\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',16,'2023-06-07 19:55:38');
INSERT INTO `t_operation_log` VALUES (1351,'文章模块','修改','/admin/article/update','com.ican.controller.ArticleController.updateArticle','修改文章','[{\"articleContent\":\"\\n\\nC++：基本数据类型/扩展数据类型、复合数据类型、函数、循环和分支、类、模板、内存模型/命令空间/堆的使用、异常。\\n\\n数据类型：基本数据类型分为整型和浮点型。整型有bool、char、short int、int、long int、long long；浮点型有float、double还有long double。扩展类型则是unsigned XXX。\\n\\n复合数据类型有数组、结构体、共用体、枚举、字符串、String类、指针、(vector容器和array)。注意，数组的两种替代品：vector使用new实现的类模板，可变长，方便且安全。array和数组一样定长，但是方便且安全。可以用方法begin和end来确定头尾，避免越界，用at方法来取元素时会自动检查越界问题，要比数组用方括号安全一些。\\n\\n函数：\\n\\n循环：for、while、do_while。分支：if/else、switch/case、三元运算符?:\\n\\n类：类的申明与定义、类的继承（注意权限问题）、（构造函数、拷贝构造函数深拷贝浅拷贝、析构函数），还有static和const修饰的方法和属性的一些使用注意事项，最后还有一个问题就是友元（全局函数友元和类友元）\\n\\n重载：函数重载和运算符重载。注意cpp三要素：封装、继承、多态。\\n\\n模板：函数模板、类模板\\n\\n\\n异常：try throw catch\\n\\n文件IO\\n\\n## 1、char与signed char和signed char\\n\\n一般char就是signed char （VC编译器、X86上的GCC），不过arm-linux-gcc却把char定义为 unsigned char。在存储介质中的表现形式是一样的，占1字节8bit。区别在于看第一位是不是符号位。\\n\\nint默认就是signed int。\\n\\n在补充一点，32位和64位系统中，数据类型的不同之处：\\n\\n在32位机器和64机器中int类型都占用4个字节。编译器可以根据自身硬件来选择合适的大小，但是需要满足约束：short和int型至少为16位，long型至少为32位，并且short型长度不能超过int型，而int型不能超过long型。这即是说各个类型的变量长度是由编译器来决定的，而当前主流的编译器中一般是32位机器和64位机器中int型都是4个字节（例如，GCC）。下面列举在GCC编译器下32位机器和64位机器各个类型变量所占字节数：\\n![图1](https://s3.bmp.ovh/imgs/2022/08/10/e2def3a84e510cd9.png)\\n需要关注的是，一般而言，32位机器和64位最大的不同就是long和指针。一般32位的long是4字节，64位是8字节；32位的指针是4字节，64位的指针是8字节。\",\"articleCover\":\"https://upload.haoxx.site/article/8a9d452db38f480ff6fc43806fe4f0df.jpg\",\"articleTitle\":\"C++复习总攻略\",\"articleType\":1,\"categoryName\":\"编程语言基础\",\"id\":73,\"isRecommend\":0,\"isTop\":0,\"status\":1,\"tagNameList\":[]}]','PUT','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',18,'2023-06-07 19:55:40');
INSERT INTO `t_operation_log` VALUES (1352,'文章模块','上传','/admin/article/upload','com.ican.controller.ArticleController.saveArticleImages','上传文章图片','image_13.jpg','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/article/04e39dc69be59749653fec847b165ae6.jpg\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',13,'2023-06-07 19:55:50');
INSERT INTO `t_operation_log` VALUES (1353,'文章模块','修改','/admin/article/update','com.ican.controller.ArticleController.updateArticle','修改文章','[{\"articleContent\":\"\\n[参考资料](https://zhuanlan.zhihu.com/p/467001575)\\n\\n![cpp关键字图示](https://s3.bmp.ovh/imgs/2022/07/14/d1b5fade281cfa4b.jpg)\\n\\n## 1）auto\\n\\ncpp11的 auto 表示变量的自动类型推断。即在声明变量的时候，根据变量初始值的类型自动为此变量选择匹配的类型。\\n\\n```cpp\\nauto x = 3; // x 为 int 类型\\ncout << typeid(x).name() << endl;auto \\n```\\n\\n变量必须在定义时初始化，这类似于const关键字。\\n\\n## 2）bool、true、false\\n\\nbool 类型是cpp 中的基本数据结构。bool 类型只有两个取值，true 和 false。true 表示“真”，false 表示“假”。\\nbool 类型常用于条件判断、开关变量的值或函数返回值。\\n\\n## 3）char、wchar_t\\n\\nchar 类型表示单个字符。char 类型的数据需要用单引号括起来：\\nchar letter =\'A\';\\nwchar_t 是宽字符类型，每个 wchar_t 类型占2个字节，16位宽。汉字的表示就需要用到 wchar_t。\\n<font color=\'skyblue\'>字符与整数密切相关，它们在内部其实是被存储为整数</font>。每个可打印的字符以及许多不可打印的字符都被分配一个唯一的数字。用于编码字符的最常见方法是 ASCII（美国信息交换标准代码的首字母简写）。\\n**备注**：UTF-8编码方式，中文占3个字符，中文标点也占3个字符。*UTF-8存储中文时占2-4个字节。utf-8是变长的、不定长的，ucs-4范围是1~6字节。 决定一个utf8字长度得看它首个字符，根据左侧位1的个数来决定占用了几个字节。*\\n\\n## 4）int、short、long\\n\\n略\\n\\n## 5）float、double、long double\\n\\n略\\n\\n## 6）signed和unsigned\\n\\n区别在于二进制数据时，第一位是否为符号位\\n\\n## 7）enum枚举类型\\n\\nenum 表示枚举类型，可以给出一系列固定值，实质上是 int 类型\\n\\n```cpp\\nenum color {\\n    RED = 0,\\n    GREEN = 1,\\n    BLUE = 2 \\n};\\n```\\n\\n## 8）union联合体类型\\n\\nunion 是联合体类型，通过共享内存，一个union可以有多个数据成员。但在任意时刻，联合中只能有一个数据成员可以有值。例如\\n\\n```cpp\\nunion price {\\n    char x\\n    int y;\\n    double z; \\n};\\n```\\n\\n## 9）struct和class     \\n\\nclass是一般的类类型，struct在cpp中是特殊的类类型，声明中默认的访问权限与class不同，struct是public，class是private。\\n\\n结构体是一种特殊形态的类,它和类一样,可以有自己的数据成员和函数成员,可以有自己的构造函数和析构函数,可以控制访问权限，可以继承,支持包含多态等,二者定义的语法形式也几乎一样。结构体和类的唯一区别在于，结构体和类具有不同的默认访问控制属性：在类中,对于未指定访问控制属性的成员，其访问控制属性为私有类型(private) ;在结构体中,对于未指定任何访问控制属性的成员,其访问控制属性为公有类型。\\n\\n结构体可以有函数成员(包含构造函数和析构函数)，但实质上是函数指针。C语言没有权限控制的说法，C语言的结构体自然不能对成员进行权限控制。\\n\\n```cpp\\n#include <stdio.h>\\ntypedef struct CStructure\\n{\\nint (*memberFunction)(); //结构体里的函数成员，实质上是函数指针\\n}CStructure;\\nint globalFunction()\\n{\\nprintf(\\\"Member function of a struct in C\\\\n\\\");\\nreturn 0;\\n}\\nint main()\\n{\\nCStructure obj; //创建结构体对象\\nobj.memberFunction=globalFunction;//为函数指针赋值\\nobj.memberFunction();//使用函数指针\\nreturn 0;\\n}\\n```\\n\\n## 10）sizeof运算符用于获取数据类型占用的字节数\\n\\nsizeof 运算法用于获取数据类型占用的字节数。\\n\\ncpp中有5种不能重载的运算符：两个是类的成员引用符号（.和->)，一个是类空间引用符号(::)，一个是唯一的三元运算符(?:)，还有一个就是sizeof运算符\\n\\n## 11）typeid运算符可以输出变量的类型\\n\\ntypeid运算符可以输出变量的类型。\\n![程序示例1](https://s3.bmp.ovh/imgs/2022/07/14/8a88a709070fd5a4.jpg)\\n![程序示例2](https://s3.bmp.ovh/imgs/2022/07/14/a1eb9b5310ce14da.png)\\n\\n## 12）typedef \\n\\ntypedef 可以为现有数据类型创建一个别名，便于程序的阅读和编写。\\n**补充**：\\n\\ntypedef和define都是替一个对象取一个别名，以此增强程序的可读性，区别如下：\\n**（1）原理不同**\\n\\n#define是C语言中定义的语法，是预处理指令，在预处理时进行简单而机械的字符串替换，不作正确性检查，只有在编译已被展开的源程序时才会发现可能的错误并报错。\\n\\ntypedef是关键字，在编译时处理，有类型检查功能。它在自己的作用域内给一个已经存在的类型一个别名，但不能在一个函数定义里面使用typedef。用typedef定义数组、指针、结构等类型会带来很大的方便，不仅使程序书写简单，也使意义明确，增强可读性。\\n\\n**（2）功能不同**\\n\\ntypedef用来定义类型的别名，一是起到类型易于记忆的功能。另一个是定义机器无关的类型。如定义一个REAL的浮点类型，在目标机器上它可以获得最高的精度：typedef long double REAL， 在不支持long double的机器上，看起来是这样的，typedef double REAL，在不支持double的机器上，是这样的，typedef float REAL\\n\\n#define不只是可以为类型取别名，还可以定义常量、变量、编译开关等。\\n\\n**（3）作用域不同**\\n\\n#define没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用，而typedef有自己的作用域\\n\\n**（4）对指针的操作不同**\\n\\n```C\\n例1：\\n#define INTPTR1 int*     //新的别名放在中间，注意：#define N 5,别名N在中间\\ntypedef int* INTPTR2; //新的别名在后面\\nINTPTR1 p1, p2;\\nINTPTR2 p3, p4;\\n含义分别为，\\n声明一个指针变量p1和一个整型变量p2 //因为#define知识简单的字符替换\\n声明两个指针变量p3、p4\\n例2：\\n#define INTPTR1 int*\\ntypedef int* INTPTR2;\\nint a = 1;\\nint b = 2;\\nint c = 3;\\nconst INTPTR1 p1 = &a;//等同于const int* p1,p1是常量指针\\nconst INTPTR2 p2 = &b;//等同于const int* p2,p2是常量指针\\nINTPTR2 const p3 = &c;//等同于int* const p3，p3是指针常量\\n````\\n\\n```cpp\\n//一、关于“指针常量“和“常量指针”的一些思考：\\n主要是看这个表述最后的那个名词：是常量还是指针。那么它的本质就是对应的常量还是指针。\\n//1、指针常量：本质是常量，但是常量里面装的是指针。\\n表达式为（先*后const）：int* const p;\\n所以，指针指向的地址不能变，但是地址中存储的值可以变化。\\nint a=1,b=2;\\nint* const p=&a;\\ncout<<*p<<endl; //值为1\\n*p=7; //正确，指针常量允许修改值。\\n*p=&b; //错误！指针常量不允许修改指向的地址\\n\\n//2、常量指针：本质是指针，但是指针指向常量\\n表达式为（先const后*）：const int* q;或者 int const* q; \\n注意： const* int q;会报错。\\n所以，指针指向的地址可以变，但是指针所指向的值不允许变化。\\nint c=1,d=2;\\nint const *q=&c;  // 或者 const int* q=&c;\\ncout<<*q<<endl; //值为1\\n*q=7; //错误！常量指针不允许修改值。\\nq=&d; //正确，常量指针允许修改指向的地址\\n```\\n\\n因为<font color=\'red\'>*引用* 是指针常量</font>嘛，所以引用本身是一个常量，但是里面装的是指针。即：引用的指针不能变，但是指向的内容可以变化。在定义**引用**的同时，必须初始化。\\n\\n+ 引用除了给变量赋予新的名称，还可以用于函数形参（常见于类的拷贝构造）。\\n+ 引用可以用作函数返回值。注意，不要返回局部变量。还有**函数调用作左值**的使用。\\n+ 常量引用，形如：`const int& v;`\\n\\n**小技巧**：\\n\\n+ 指针常量/常量指针，就看这个词的最后两个字是什么，它的本质就是什么。\\n+ 指针常量：是一个常量，常量里面装的是指针，所以指针的指向内存不能改变；\\n+ 常量指针：是一个指针，指针指向内存中存放的数据是称量，所以指针的指向内存可以变，但是存放的数据可以变。\\n\\n## 13）static \\n\\n用于声明静态变量或类的静态函数。静态变量作用范围在一个文件内，程序开始时分配空间，结束时释放空间，默认初始化为 0，使用时可改变其值。\\ncpp 类的成员变量被声明为 static（称为静态成员变量），意味着它被该类的所有实例所共享，也就是说当某个类的实例修改了该静态成员变量，其修改值为该类的其它所有实例所见；而类的静态成员函数也只能访问静态成员（变量或函数）。\\n**static和extern**\\n\\n对于全局变量和函数而言，两者功能相反，extern想让程序使用其他文件的函数或全局变量；static是将函数和全局变量限制在本文件当中。\\n\\n对于局部变量，static是将变量的创建空间从栈区更改到了静态数据区。\\n**class类中的static成员函数/变量 和 const成员函数/变量**\\n\\n0、前言\\n\\n为什么cpp中会出现/保留static关键字和const关键字呢？\\n参考链接：https://zhuanlan.zhihu.com/p/141113043\\n\\nstatic有两个功能，对于全局变量和函数，是限制其作用域；对于局部变量，是将其创建空间从栈区更改到静态存储区，以保证在函数调用结束时，变量值不会被释放。\\n\\n在cpp类的多个对象中，如果我们想要一个变量值，可以让所有对象共享，常规的做法是使用全局变量。但是全局变量的使用破坏了类的封装性，而类的静态变量，既可以让类内对象共享，也可以对类外对象隐藏。\\n\\n**cpp中为什么会引入const**\\n\\ncpp有一个类型严格的编译系统，这使得cpp程序的错误在编译阶段即可发现许多，从而使得出错率大为减少，因此，也成为了cpp与c相比，有着突出优点的一个方面。\\n\\nc中很常用的预处理命令`#define 变量名 变量值`，可以很方便地进行值替代。这种值代替至少有三个优势：\\n\\n> 一是避免了意义模糊的数字出现，使得程序语义流畅清晰，如下例：\\n> 　　#define user_num_max 107 这样就避免了直接使用107带来的困惑。\\n> 　　二是可以很方便地进行参数的调整与修改，如上例，当人数由107变为201时，进改动此处即可，\\n> 　　三是提高了程序的执行效率，由于使用了预编译器进行值替代，并不需要为这些常量分配存储空间，所以执行的效率较高。\\n\\n预处理语句虽然有以上的许多优点，但它有个比较致命的缺点，即，预处理语句仅仅只是简单值替代，缺乏类型的检测机制。这样预处理语句就不能享受cpp严格类型检查的好处，从而可能成为引发一系列错误的隐患。\\n\\n结论：\\n\\n> const 推出的初始目的，正是为了取代预编译指令，消除它的缺点，同时继承它的优点。\\n\\n现在它的形式变为：`const typename 变量名=变量值`，**为什么const能很好的替代预定义命令？**\\n\\n> 1． 首先，以const 修饰的常量值，具有不可变性，这是它能取代预定义语句的基础。\\n> 2． 第二，很明显，它也同样可以避免意义模糊的数字出现，同样可以很方便地进行参数的调整和修改。\\n> 3． 第三，<font color=\'red\'>cpp的编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高</font>，同时，这也是它取代预定义语句的重要基础。这里，我要提一下，为什么说这一点是也是它能取代预定义语句的基础，这是因为，编译器不会去读存储的内容，如果编译器为const分配了存储空间，它就不能够成为一个编译期间的常量了。\\n> 4． 最后，const定义也像一个普通的变量定义一样，它会由编译器对它进行类型的检测，消除了预定义语句的隐患。\\n\\n**const 使用场景分析**\\n\\n1. const用于修饰指针的两种情况\\n\\n```c\\nint const *a; 　//a可变，*a不可变 [常量指针，本质为指针，指针指向的内存空间存放的是常量。所以，值不能变，指针能变。即*a不能变，a能变]\\nint *const a; 　//a不可变，*a可变 [指针常量，本质为常量，常量里存放的是指针。所以指针指向不能变，值能变，例如cpp的引用。即a不能变，*a能变]\\n```\\n\\n*分析*：const 是一个左结合的类型修饰符，它与其左侧的类型修饰符和为一个类型修饰符，所以，int const 限定\\\\*a,不限定a。int \\\\*const 限定a,不限定\\\\*a。\\n\\n2. const 限定函数的传递值参数\\n   *分析*：上述写法限定参数在函数体中不可被改变。由值传递的特点可知，var在函数体中的改变不会影响到函数外部。所以，此限定与函数的使用者无关，仅与函数的编写者有关。\\n3. const限定函数的返回值\\n\\n```C\\nconst int fun1(); \\nconst myclass fun2();\\n```\\n\\n*分析*：上述写法限定函数的返回值不可被更新，当函数返回内部的类型时（如fun1），已经是一个数值，当然不可被赋值更新，所以，此时const无意义，最好去掉，以免困惑。当函数返回自定义的类型时（如fun2），这个类型仍然包含可以被赋值的变量成员，所以，此时有意义。\\n\\n一般而言，当返回值类型是指针或者class类，或者struct结构体时，返回值用const限制才比较合适。当返回值是基本数据类型时，用const并无意义。\\n\\n4. 传递与返回指针\\n\\n此种情况最为常见，由地址变量的特点可知，适当使用const，意义昭然。\\n\\n5. const限定类的成员函数\\n\\n```cpp\\nclass classname {\\n　public:\\n　　int fun() const; //常成员函数\\n　.....\\n}\\n```\\n\\n　　注意：采用此种const 后置的形式是一种规定，亦为了不引起混淆。在此函数的声明中和定义中均要使用const,因为const已经成为类型信息的一部分。\\n\\n> 获得能力：可以操作常量对象。\\n>       失去能力：不能修改类的数据成员，不能在函数中调用其他不是const的函数。\\n\\n**const使用总结**\\n\\n> 1. 函数返回值为const时，返回的东西赋给一个类型相同的标示后其不能为左值；\\n> 2. 用const定义的int可用来开辟数组，但const定义的常量数组中的元素，不能用来定义数组。\\n> 3. const int *i; int const *i; int * const i; 前两个功能相同，说明i所指向的值不变；最后一个说明指针指向的地址不变，但值可以变。\\n> 4. 类中的const成员函数,定义为在原型后加const。常量函数不能修改类中的任何属性。但有两种方法可以修改。\\n>\\n> > 1) {(yourclass *)this->member = values;}\\n> > 2) 将一个成员定义成mutable即可被常量函数修改。\\n>\\n> 5. 类中的常量const 类型的，不能在类中被用来定义数组。而enum {ONE=100; TWO=2};定义的ONE、TWO 却可以。通常的enum定义的值分配问题：enum A{ L=9, Z};此时Z的值为10。\\n\\n一、静态数据成员的特点\\n\\n+ 静态成员不属于某一个对象，而是属于整个类（定义在数据段）\\n+ 静态成员供所有对象共享，每个对象可以调用且修改。一个对象修改，其他对象也跟着变化\\n+ 可以直接通过类名直接访问\\n+ *注意!* 静态数据成员，类内定义，类外初始化\\n\\n二、类的静态成员函数\\n\\n+ 类的静态成员函数不属于某一个对象，属于整个类，所以不存在this指针\\n+ 因为没有this指针，所以不能调用普通成员函数和变量\\n+ 静态成员函数不能用const修饰\\n+ 静态成员函数只能访问类的静态成员，不能访问普通成员。因为类的静态成员是属于整个类的，在类定义好的时候就已经在内存开辟了空间，而普通成员是在对象生成的时候才在内存开辟空间，如果使用静态成员函数去访问普通的类会出错\\n+ 普通成员函数可以调用静态成员或者非静态成员\\n\\n三、类的常量成员const\\n常量数据成员特点：\\n\\n+ 必须在构造函数那里进行列表初始化，不可以在构造函数内部初始化\\n+ 初始化以后不可以再修改\\n\\n四、常量成员函数const\\n\\n+ 常量成员函数内不允许对类的成员变量进行修改，也不允许对函数的const参数进行修改（防止对成员变量误操作）\\n\\n五、比较compare：静态和常量\\n\\n+ 静态成员变量类内定义，类外初始化。常量成员必须在构造函数的初始化列表中初始化，不能在函数体中初始化；\\n+ 普通对象能调用静态成员函数，能调用常量成员函数。静态对象只能调用静态成员函数，不能访问普通成员变量和函数*(因为类的静态成员是属于整个类的，在类定义好时就已经在内存中开辟了空间，而普通成员是在对象生成的时候才在内存中开辟空间，如果使用静态成员函数访问普通成员变量/函数就会出错)*。常对象只能访问常成员函数。常成员函数只能调用常成员变量(防止这个函数修改普通变量的值)，不过普通变量可用mutable关键字修饰，这样，常成员函数就可以了调用和修改它了。\\n+ <font color=\'red\'>需要注意的是</font>,其实静态成员函数可以访问为非静态成员变量，只是十分复杂，故不建议采用。之前说到，静态成员函数不能访问普通成员变量，是因为没有this指针，那么如果静态函数的形参就包含该类，那就可以访问该类的普通成员变量了。`如类A中有static void f(A a); static int a,int b，void A::f(A a) {cout<<a;//正确，cout<<b;//错误；cout<<a.b/正确}`。\\n+ 建议规范调用静态成员函数和变量，即使用类名而非对象名来调用静态对象。如A::a和A::func(),而不是A obj;obj.a和obj.func()。\\n+ \\n\\n## 14）public、protected、private \\n\\n权限修饰符。\\n\\n## 15）virtual\\n\\n用于声明虚基类、虚函数。虚函数=0时，则为纯虚函数，纯虚函数所在的类称为抽象类。\\n\\n## 16）override、final\\n\\noverride 用于表示当前函数重写了基类的虚函数。\\nfinal 用于禁止类继承、禁止重载虚函数。\\n\\n## 17）operator\\n\\n用于重载操作符。如下重载类Person的 == 运算法：\\n![程序示例](https://s3.bmp.ovh/imgs/2022/07/14/12e8450b6ab81b3a.jpg)\\n\\n## 18）const、constexpr\\n\\nconst 表示所修饰的对象或变量不能被改变。\\nconstexpr 用于生成常量表达式，常量表达式主要是允许一些计算发生在编译时，而不是运行的时候。\\n\\n## 19）using\\n\\n用于在当前文件引入命名空间，例如：using namespace std；\\n在子类中，使用 using 声明引入基类成员名称。\\n\\n## 20）namespace\\n\\ncpp标准程序库中的所有标识符都被定义于一个名为 std 的namespace中。\\n命名空间除了系统定义的名字空间之外，还可以自己定义，定义命名空间用关键字 namespace，使用命名空间时用符号 :: 指定。\\n\\n## 21）inline\\n\\n声明为内联函数，即在编译时将所调用的函数代码直接嵌入到主调函数中。\\n作用是提高效率，但是程序应尽量短小\\n\\n## 22）new、delete  <font color=\'red\'>补充</font>\\n\\nnew 用于向内存申请一段新的空间，delete 用于释放申请空间。\\n用new创建一个int型的空间，并附初始值：`int *p=new int(2);`。 `delete p`\\n用new创建一个数组的空间，并附初始值：`int *p=new int [5](0);` `delete[] p`\\n\\n## 23）this\\n\\n每个类成员函数都隐含了一个this指针，用来指向类本身。\\nthis指针一般可以省略，但在赋值运算符重载的时候要显示使用。静态成员函数没有this指针。\\n\\n## 24）nullptr\\n\\ncpp11新引入的，用来声明一个 空指针，代替NULL。\\nint* p = nullptr;\\n\\n## 25）void\\n\\n特殊的\\\"空\\\"类型，指定函数无返回值或无参数。\\n\\n## 26）friend\\n\\n用于声明友元关系。\\n友元可以访问与其有 friend 关系的类中的 private/protected 成员，通过友元直接访问类中的 private/protected 成员的主要目的是提高效率。\\n友元包括友元函数和友元类。全局函数/成员函数做友元，类做友元。\\n\\n#### 4.4.1 全局函数做友元\\n\\n```cpp\\nclass Building\\n{\\n\\t//告诉编译器 goodGay全局函数 是 Building类的好朋友，可以访问类中的私有内容\\n\\tfriend void goodGay(Building * building);\\n\\npublic:\\n\\n\\tBuilding()\\n\\t{\\n\\t\\tthis->m_SittingRoom = \\\"客厅\\\";\\n\\t\\tthis->m_BedRoom = \\\"卧室\\\";\\n\\t}\\n\\n\\npublic:\\n\\tstring m_SittingRoom; //客厅\\n\\nprivate:\\n\\tstring m_BedRoom; //卧室\\n};\\n\\n\\nvoid goodGay(Building * building)\\n{\\n\\tcout << \\\"好基友正在访问： \\\" << building->m_SittingRoom << endl;\\n\\tcout << \\\"好基友正在访问： \\\" << building->m_BedRoom << endl;\\n}\\n\\n\\nvoid test01()\\n{\\n\\tBuilding b;\\n\\tgoodGay(&b);\\n}\\n\\nint main(){\\n\\n\\ttest01();\\n\\n\\tsystem(\\\"pause\\\");\\n\\treturn 0;\\n}\\n```\\n\\n\\n\\n#### 4.4.2 类做友元\\n\\n```cpp\\nclass Building;\\nclass goodGay\\n{\\npublic:\\n\\tgoodGay();\\n\\tvoid visit();\\nprivate:\\n\\tBuilding *building;\\n};\\nclass Building\\n{\\n\\t//告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类中私有内容\\n\\tfriend class goodGay;\\npublic:\\n\\tBuilding();\\npublic:\\n\\tstring m_SittingRoom; //客厅\\nprivate:\\n\\tstring m_BedRoom;//卧室\\n};\\nBuilding::Building()\\n{\\n\\tthis->m_SittingRoom = \\\"客厅\\\";\\n\\tthis->m_BedRoom = \\\"卧室\\\";\\n}\\ngoodGay::goodGay()\\n{\\n\\tbuilding = new Building;\\n}\\nvoid goodGay::visit()\\n{\\n\\tcout << \\\"好基友正在访问\\\" << building->m_SittingRoom << endl;\\n\\tcout << \\\"好基友正在访问\\\" << building->m_BedRoom << endl;\\n}\\nvoid test01()\\n{\\n\\tgoodGay gg;\\n\\tgg.visit();\\n\\n}\\nint main(){\\n\\n\\ttest01();\\n\\n\\tsystem(\\\"pause\\\");\\n\\treturn 0;\\n}\\n```\\n\\n#### 4.4.3 成员函数做友元\\n\\n```cpp\\nclass Building;\\nclass goodGay\\n{\\npublic:\\n\\n\\tgoodGay();\\n\\tvoid visit(); //只让visit函数作为Building的好朋友，可以发访问Building中私有内容\\n\\tvoid visit2(); \\n\\nprivate:\\n\\tBuilding *building;\\n};\\n\\n\\nclass Building\\n{\\n\\t//告诉编译器  goodGay类中的visit成员函数 是Building好朋友，可以访问私有内容\\n\\tfriend void goodGay::visit();\\n\\npublic:\\n\\tBuilding();\\n\\npublic:\\n\\tstring m_SittingRoom; //客厅\\nprivate:\\n\\tstring m_BedRoom;//卧室\\n};\\n\\nBuilding::Building()\\n{\\n\\tthis->m_SittingRoom = \\\"客厅\\\";\\n\\tthis->m_BedRoom = \\\"卧室\\\";\\n}\\n\\ngoodGay::goodGay()\\n{\\n\\tbuilding = new Building;\\n}\\n\\nvoid goodGay::visit()\\n{\\n\\tcout << \\\"好基友正在访问\\\" << building->m_SittingRoom << endl;\\n\\tcout << \\\"好基友正在访问\\\" << building->m_BedRoom << endl;\\n}\\n\\nvoid goodGay::visit2()\\n{\\n\\tcout << \\\"好基友正在访问\\\" << building->m_SittingRoom << endl;\\n\\t//cout << \\\"好基友正在访问\\\" << building->m_BedRoom << endl;\\n}\\n\\nvoid test01()\\n{\\n\\tgoodGay  gg;\\n\\tgg.visit();\\n\\n}\\n\\nint main(){\\n    \\n\\ttest01();\\n\\n\\tsystem(\\\"pause\\\");\\n\\treturn 0;\\n}\\n```\\n\\n\\n\\n## 27）template \\n\\n模板，cpp中泛型机制的实现。模板就是实现代码重用机制的一种工具，它可以实现类型参数化，即把类型定义为参数， 从而实现了真正的代码可重用性。模版可以分为两类，一个是函数模版，另外一个是类模版。\\n\\n## 28）if、else\\n\\n用于条件语句。\\n\\n## 29）for、while、do\\n\\n用于循环语句。\\n\\n## 30）switch、case、default\\n\\n用于分支语句。switch 表示分支语句的起始，根据 switch 条件跳转到 case 标记或 defalut 标记的分支上。\\n\\n## 31）break、continue、goto\\n\\nbreak用于跳出for、while循环或switch语句。\\ncontinue用于跳到一个循环的起始位置。\\ngoto用于无条件跳转到函数内的标记处，一般情况不建议使用goto。\\n\\n## 32）and、or、xor、not、bitand、bitor\\n\\nand 表示逻辑与 &&；\\nor 表示逻辑或 ||；\\nxor 表示逻辑异或 ^；\\nnot 表示逻辑非 !；\\nbitand 表示按位与 &；\\nbitor 表示按位或 |。\\n\\n## 33）return\\n\\nreturn表示从被调函数返回到主调函数继续执行，返回时可带一个返回值。\\n\\n## 34）try、catch、throw\\n\\n用于异常处理。try 指定 try 块的起始，try 块后的 catch 可以捕获异常，异常由 throw 抛出。\\n\\n## 35）noexcept\\n\\ncpp11中，用于声明一个函数不可以抛出任何异常。\\n\\n## 36）static_cast、const_cast、dynamic_cast、reinterpret_cast\\n\\ncpp类型风格来性转换：\\nstatic_cast用于静态转换；\\nconst_cast删除const变量的属性，方便赋值；\\ndynamic_cast用于将一个父类对象的指针转换为子类对象的指针或引用；\\nreinterpret_cast将一种类型转换为另一种不同的类型。\\n参考链接：https://www.cnblogs.com/wangchaoguo-li/p/14210679.html\\n\\n|       方式       |                           使用场景                           |\\n| :--------------: | :----------------------------------------------------------: |\\n|   static_cast    | 基本数据类型之间的转换使用，例如float转int，int转char等；子类对象指针转换成父类对象指针也可以使用static_cast；在有类型指针和void\\\\*之间转换使用，不能使用static_cast在有类型指针之间进行类型转换。 |\\n|   dynamic_cast   | 用于将父类的指针或引用转换为子类的指针或引用，此场景下父类必须要有虚函数（只要拥有虚函数就行） |\\n|    const_cast    |       用于常量指针或引用与非常量指针或引用之间的转换。       |\\n| reinterpret_cast | 类似C语言中的强制类型转换，什么都可以转，尽量不要使用此方式。 |\\n\\n**static_cast**\\n\\n基本数据类型之间的转换使用，例如float转int，int转char等，在有类型指针和void\\\\*之间转换使用，子类对象指针转换成父类对象指针也可以使用static_cast（<font color=\'red\'>不能使用static_cast在有类型指针之间进行类型转换</font>）。\\n\\n```c\\n#include <iostream>\\n\\nusing namespace std;\\n\\nstruct Base {\\n    virtual void Func() { cout << \\\"Base Func \\\\n\\\"; }\\n};\\n\\nstruct Derive : public Base {\\n    void Func() override { cout << \\\"Derive Func \\\\n\\\"; }\\n};\\n\\nint main()\\n{\\n    float f = 1.23;\\n    cout << \\\"f \\\" << f << endl;\\n    int i = static_cast<int>(f);\\n    cout << \\\"i \\\" << i << endl;\\n\\n    void *p;\\n    int *i_p = static_cast<int *>(p);\\n    void *pi = static_cast<void *>(&f);\\n    int *pi = static_cast<int *>(&f);  //error invalid static_cast from type ‘float*’ to type ‘int*’\\n\\n    Derive d;\\n    d.Func();\\n    Base *b = static_cast<Base *>(&d);\\n    b->Func();\\n    return 0;\\n}\\n```\\n\\n**dynamic_cast**\\n\\n用于将父类的指针或引用转换为子类的指针或引用，此场景下父类必须要有虚函数（只要拥有虚函数就行），因为dynamic_cast是运行时检查，检查需要运行时信息RTTI。\\n\\n```cpp\\n#include <iostream>\\n\\nusing namespace std;\\n\\nstruct Base {\\n    virtual void Func() { cout << \\\"Base Func \\\\n\\\"; }\\n};\\n\\nstruct Derive : public Base {\\n    void Func() override { cout << \\\"Derive Func \\\\n\\\"; }\\n};\\n\\nint main() {\\n    Derive d;\\n    d.Func();\\n    Base *b = dynamic_cast<Base *>(&d);\\n    b->Func();\\n    Derive *dd = dynamic_cast<Derive *>(b);\\n    dd->Func();\\n    return 0;\\n}\\n```\\n\\n**const_cast**\\n\\n用于常量指针或引用与非常量指针或引用之间的转换，只有const_cast才可以对常量进行操作，一般都是用它来去除常量性（去除常量性是危险操作，还是要谨慎操作）。\\n\\n```cpp\\nint main() {\\n    int data = 10;\\n    const int *cpi = &data;\\n\\n    int *pi = const_cast<int *>(cpi);\\n\\n    const int *cpii = const_cast<const int *>(pi);\\n    return 0;\\n}\\n```\\n\\n**reinterpret_cast**\\n\\n类似C语言中的强制类型转换，什么都可以转，万不得已不要使用，一般前三种转换方式不能解决问题了使用这种强制类型转换方式。\\n\\n```cpp\\nint main() {\\n    int data = 10;\\n    int *pi = &data;\\n\\n    float *fpi = reinterpret_cast<float *>(pi);\\n\\n    return 0;\\n}\\n```\\n\\n## 37）register\\n\\n提示编译器尽可能把变量存入到CPU内部寄存器中。\\n\\n## 38）explicit\\n\\nexplicit 的作用是禁止单参数构造函数被用于自动类型转换，比较典型的是容器类型。\\n\\n再次注意，是单参数，形如`explicit Fraction(int numerator:m_numerator(numerator){}`，还有一种情况是多参数，但是后面几个参数都有默认值，只有第一个参数没有默认值：`explicit Fraction(int numerator, int denominator = 1): m_numerator(numerator), m_denominator(denominator){}`\\n\\n注意：当类的声明和定义分别在两个文件中时，explicit只能写在在声明.h中，不能写在定义.c中。\\n参考链接：[CSDN](https://blog.csdn.net/l2563898960/article/details/97769569)\\nexplicit意为清晰地，明确的意思，顾名思义，它的作用就是阻止隐式转换的发生。\\n**例如**: cpp中只带有一个参数的构造函数,或者或者除了第一个参数外其余参数都有缺省值的多参构造函数,承担了两个角色:\\n1.用于构建单参数的类对象.\\n2.隐含的类型转换操作符.\\n\\n>例如:一个类A的构造函数A(int i)就是，既可以用来作为构造器，又可以实现隐式转换A a=1；因为1可以通过构造函数A(int i)转换为一个类A的对象。(隐含的类型转换操作符)\\n\\n但有时候，我们并不想让他进行隐式转换，这是cpp的explicit关键字就起作用了。\\nexplicit的三种使用情况：**类型转换（operator())**、**单操作数构造函数**、**同时出现类型转换和有参构造函数**\\n再说下面的内容前，需要提及：类型类型转换函数的一般形式：\\n\\n```cpp\\noperator 数据类型() const\\n{\\n\\t//函数实现\\n}\\n```\\n\\n> 1.转换函数必须是类的成员函数\\n> 2.转换函数不能声明返回类型\\n> 3.形参列表必须为空\\n> 4.类型转换函数通常应该是const\\n\\n### 使用情况1：类型转换\\n\\n```cpp\\n#include<iostream>\\nusing namespace std;\\nclass Fraction{\\npublic:\\n\\tFraction(int numerator, int denominator = 1): m_numerator(numerator), m_denominator(denominator){}\\n\\toperator double() const   //类型转换函数\\n\\t{\\n\\t\\treturn (double)m_numerator/m_denominator;\\n\\t}\\nprivate:\\n\\tint m_numerator;\\n\\tint m_denominator;\\n};\\n\\nint main(void)\\n{\\n\\tFraction f(3, 5);\\n\\tdouble d = 3.5 + f;\\n\\tcout << d << endl;\\n\\treturn 0;\\n}\\n```\\n\\n我们设计了一个Fraction类(分数类), 在主函数中定义了一个分数对象<font color=red>f</font>,然后将<font color=red>3.5 + f</font>赋值给double类型变量<font color=red>d</font>, 但是我们发现f并不是一个double类型的变量,因此编译器会从Fraction类中寻找<font color=red>operator double()</font>函数,隐式调用该函数将Fraction类型转换成一个double类型. <font color=red>operator double()</font>就是我们所说的类型转换函数(type conversion function).\\n\\n注意，此代码中含有隐式类型转换。在计算3.5+f时，类的对象f回调用类型转换函数operator double()来将f转换成double。\\n\\n使用explicit关键字来避免隐式类型转换，在进行类型转换时，必须显示声明：用`static_cast<double>f`\\n\\n```cpp\\n#include<iostream>\\nusing namespace std;\\nclass Fraction{\\npublic:\\n\\tFraction(int numerator, int denominator = 1): m_numerator(numerator), m_denominator(denominator){}\\n\\texplicit operator double() const    //不能隐式类型转换了\\n\\t{\\n\\t\\treturn (double)m_numerator/m_denominator;\\n\\t}\\nprivate:\\n\\tint m_numerator;\\n\\tint m_denominator;\\n}；\\n\\nint main(void)\\n{\\n\\tFraction f(3, 5);\\n\\tdouble d = 3.5 + static_cast<double>(f);//必须显式类型转换\\n\\tcout << d << endl;\\n\\treturn 0;\\n}\\n```\\n\\n### 使用情况2：有参构造函数\\n\\n对于3.5+f，上面的例子是使用类型转换来实现的。其实，也可以使用重载运算符+的方法来实现，不过，需要写成f+3.5的形式。\\n\\n```cpp\\n//code 1\\n#include<iostream>\\nusing namespace std;\\nclass Fraction\\n{\\npublic:\\n    Fraction(int numerator, int denominator = 1) : m_numerator(numerator), m_denominator(denominator) {}\\n    double operator+(double a)\\n    {\\n        return (double)this->m_numerator /this->m_denominator+a;\\n    }\\nprivate:\\n    int m_numerator;\\n    int m_denominator;\\n};\\n\\nint main(void)\\n{\\n    Fraction f(3, 5);\\n    double d = f+3.5;\\n    cout << d << endl;\\n    system(\\\"pause\\\");\\n    return 0;\\n}\\n////////////////operator+中隐藏的类型转换//////////////////////////////\\n//code 2\\n#include<iostream>\\nusing namespace std;\\nclass Fraction\\n{\\n public:\\n \\tFraction(int numerator, int denominator = 1): m_numerator(numerator), m_denominator(denominator){}\\n \\tdouble operator+(const Fraction& a)\\n \\t{\\n \\t\\treturn (a.m_numerator + this->m_numerator)/(a.m_denominator + this->m_denominator);\\n \\t}\\n private:\\n \\tint m_numerator;\\n\\tint m_denominator;\\n }\\n \\n int main(void)\\n{\\n\\tFraction f(3, 5);\\n\\tdouble d = f + 3;\\n\\tcout << d << endl;\\n\\treturn 0;\\n}\\n```\\n\\n在double d = f + 3 这句话中构造函数就是前面所提到的第二种角色隐含的类型转换操作符.,因为执行到这句话首先会调用+的重载函数,该函数的调用对象默认为左操作数,右操作数为Fraction类型,因此会调用有参构造函数将3转换成Fraction类型,然后将得到的返回值double类型赋值给变量d.\\n\\n同理如果不想让构造函数进行隐式类型转换,可以在构造函数前面加上explicit关键字,防止进行隐式转换.使用方法如下:\\n\\n```cpp\\n#include<iostream>\\nusing namespace std;\\nclass Fraction\\n{\\n public:\\n \\texplicit Fraction(int numerator, int denominator = 1): m_numerator(numerator), m_denominator(denominator){}\\n \\tdouble operator+(const Fraction& a)\\n \\t{\\n \\t\\treturn (a.m_numerator + this->m_numerator)/(a.m_denominator + this->m_denominator);\\n \\t}\\n private:\\n \\tint m_numerator;\\n\\tint m_denominator;\\n };\\n \\n int main(void)\\n{\\n\\tFraction f(3, 5);\\n\\tdouble d = f + 3;//注意，此处代码会报错\\n\\tcout << d << endl;\\n\\tsystem(\\\"pause\\\");\\n\\treturn 0;\\n\\t//想要代码运行，需要将3类型准换为Fraction类，即使用类的有参构造函数。但是有参构造函数使用explicit修饰，不能隐式类型转换。\\n}\\n```\\n\\n### 使用情形3：有参构造和类型转换函数同时出现\\n\\n```cpp\\n#include<iostream>\\nusing namespace std；\\nclass Fraction\\n{\\n public:\\n \\tFraction(int numerator, int denominator = 1): m_numerator(numerator), m_denominator(denominator){}\\n \\toperator int()  //强制类型转换\\n \\t{\\n \\t\\treturn m_numerator/denominator;\\n \\t}\\n \\tint operator+(const Fraction& a)//重载运算符+，以及隐式使用了有参构造函数\\n \\t{\\n \\t\\treturn (a.m_numerator + this->m_numerator)/(a.m_denominator + this->m_denominator);\\n \\t}\\n private:\\n \\tint m_numerator;\\n\\tint m_denominator;\\n }\\n\\n int main(void)\\n{\\n\\tFraction f(3, 5);\\n\\tint d = f + 3;//上面两种方法都有效，使用哪个？有歧义\\n\\tcout << d << endl;\\n\\treturn 0;\\n}\\n```\\n\\n这时你会发现会产生一个二义性问题,在执行int d = f + 3的时候到底是该选择类型转换函数,将f转换成int类型再继续运算呢?还是应该将3作为构造函数的参数进行隐式转换,然后再调用+运算符重载函数呢?\\n解决这个问题的办法就是使用explicit关键字限制,具体方法有两种：\\n1.在构造函数前面加上explicit关键字, 防止int类型隐式转换成为Fraction类型.\\n2.在类型转换函数前面加上explicit关键字,这样只有显示调用类型转换`static_cast<int>(f)`时,才会调用该函数.\\n**总结**：\\n\\n1. cpp中，一个参数的构造函数(或者除了第一个参数外其余参数都有缺省值的多参构造函数)，承担了两个角色。\\n\\n+ 用于构建单参数的类对象\\n+ 隐含的类型转换操作符\\n\\n2. explicit关键字只对有一个参数的类构造函数有效, 如果类构造函数参数大于或等于两个时, 是不会产生隐式转换的, 所以explicit关键字也就无效了\\n3. 声明为explicit的构造函数不能在隐式转换中使用，只能显示调用，去构造一个类对象。\\n\\n```cpp\\nBase base(‘a’) //显示调用,OK\\nBase base = ‘a’ //隐式调用,err 调用了单参数的有参构造函数，或多参数，但后面几个参数有缺省值的\\n```\\n\\n4. 尽量避免有二义性的类型转换，如果类中包含一个或多个隐式类型转换，则必需使用explicit关键字确保在类类型和目标类型之间只存在唯一一种隐式转换方式，否则将出现二义性。\\n5. 但是将拷贝构造函数声明成explicit并不是良好的设计，一般只将有单个参数的constructor声明为explicit，而copy constructor不要声明为explicit.\\n\\n## 39）extern\\n\\n1、\\n\\n当出现extern “C”时，表示 extern “C”之后的代码按照C语言的规则去编译；\\n\\n当extern修饰变量或函数时，表示其具有外部链接属性，即其既可以在本模块中使用也可以在其他模块中使用。\\n\\n为什么会出现 extern “C\\\" ?因为C不支持函数重载，而cpp支持函数重载，所以两类编程语言在汇编时对函数的处理方式不一样。c语言是用函数名来匹配，cpp使用函数名+形参列表来匹配。对于函数`Func(int i,int j)`,c语言的汇编结果为Func，cpp汇编结果为`_Z8Funcii`，这样如果c和cpp混编的话就会出现链接时找不到函数定义的情况。\\n**注意**：除了函数重载外，extern “C”不影响cpp的其他特性\\n\\n```cpp\\n//一般情况，extern \\\"C\\\"是和函数声明放在一起，即位于h头文件中\\n//情况1：在cpp中调用c代码的函数\\nc文件中有一个函数： void Transfer(int a,char b);\\ncpp文件必须用extern \\\"C\\\"声明该函数如下才可以实现调用：\\nextern \\\"C\\\" void Transfer(int a,char b);\\n\\n//情况2：c调用cpp代码的函数\\nc文件若要调用，就必须在cpp文件中用extern \\\"C\\\"来声明该函数，否则cpp在编译过程中就会对其进行名字改编，c文件就找不到该函数的原型\\ncpp文件中有一函数：\\n        void Transfer(int a; char b);\\n但必须用extern \\\"C\\\"来声明后，如下：\\n        extern “C” void Transfer(int a; char b);\\nc文件才可以调用void Transfer(int a; char b)函数。\\n\\n//附加说明1\\n在.cpp文件中引用c的头文件：\\n　// cpp code\\n　　extern “C” {\\n　　#include “my-header1.h”\\n　　#include “my-header2.h”\\n　　}\\n//附加说明2\\nc的头文件如果想被cpp文件使用的话：\\n#ifdef __cplusplus\\nextern \\\"C\\\" {\\n#endif\\n ...   // 按照C语言的规则去编译，C语言的头文件声明放在此处\\n#ifdef __cplusplus\\n}\\n#endif\\n使用附加说明1，cpp代码能正确使用c的头文件。使用附加说明2，该c头文件可被c和cpp正确使用。两种情况，仍选其一即可。\\n```\\n\\n2、extern关键字的常规使用\\nextern是用来声明全局变量或者全局函数的，需要注意，是声明，不是定义\\n`extern  int  i; //声明变量i，但没分配存储空间，还不能使用`，还有`int  i; //定义了变量i，并分配了空间，可以使用`。注意：在程序中一个变量可以声明多次，但只能定义一次。如果声明时有初始化式，也会被当做定义，例如：\\n`extern  int  i = 5； //定义了变量5 ，说明：这样做不规范，会被报警告`\\n后面的程序中若再出现extern  int  i = 5；或者int  i;的语句，就会出错，因为变量只能定义一次。\\n\\n**关于extern的进一步说明**：对于普通定义的变量，常规定义正常使用；在其他文件中要使用此变量时，需要先加extern做声明，编辑器才会在当前文件以外的文件中去寻找该变量或函数的定义，例如：\\n\\n```cpp\\nfile1:\\n\\tint i=10;\\nfile2:\\n\\textern int i;\\n\\ti=2;\\n```\\n\\n**特别地**：对于被const修饰的变量或函数而言，这个变量/函数默认为“局部的”。即使在其他文件中使用extern修饰了也无法使用。如果想在其他文件中使用这个变量，必须在定义该const变量时，显式地指出它将用于外部文件：\\n\\n```cpp\\nfile1:\\nextern const int i=10;\\nfile2:\\nextern const int i;\\n```\\n\\n**说明**：extern与static的功能是相对的。extern用于在程序中使用其他文件中定义的变量或函数，1）static修饰函数，用于将函数的使用限制在当前文件内。2）static修饰全局变量也是同样的道理，限制变量的使用区域。3）static修饰局部变量，那变量的创建空间就从栈区变更到了静态数据区，可用于多次调用某个函数时，函数内计数值的递增。\\n\\n## 40）mutable\\n\\nmutable就是为了突破成员函数 const的限制，可以在const函数里面来修改被mutable修饰的成员变量。\",\"articleCover\":\"https://upload.haoxx.site/article/04e39dc69be59749653fec847b165ae6.jpg\",\"articleTitle\":\"C++关键字说明\",\"articleType\":1,\"categoryName\":\"编程语言基础\",\"id\":74,\"isRecommend\":0,\"isTop\":0,\"status\":1,\"tagNameList\":[]}]','PUT','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',28,'2023-06-07 19:55:52');
INSERT INTO `t_operation_log` VALUES (1354,'文章模块','上传','/admin/article/upload','com.ican.controller.ArticleController.saveArticleImages','上传文章图片','image_14.jpg','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/article/2ec42f646cb85e6554ab21b4e9bc6c19.jpg\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',13,'2023-06-07 19:56:12');
INSERT INTO `t_operation_log` VALUES (1355,'文章模块','修改','/admin/article/update','com.ican.controller.ArticleController.updateArticle','修改文章','[{\"articleContent\":\"---\\ntitle: C++指针与常量知识点说明\\ndate: 2022-10-30\\ncategory:\\n - 1编程语言基础\\n\\nfooter: <a href=\\\"https://beian.miit.gov.cn/#/Integrated/index\\\">渝ICP备2023001651号</a>\\n\\n---\\n\\n:::tip\\nC++指针与常量知识点说明\\n:::\\n\\n<!-- more -->\\n\\n\\n[参考资料](https://www.cnblogs.com/zpcdbky/p/4902688.html)\\n\\n网上常见的说法似乎有误：\\n\\n```cpp\\nconst int* p  //常量指针\\nint* const p  //指针常量\\n```\\n\\n在外文书籍中很少有这种说法。一种简洁易懂的说法是：\\n\\n> 指向常量的指针----`const int* p`     【常量指针】\\n>\\n> 本身是常量的指针----`int* const p`  【本身是常量的指针】，也是cpp中的引用\\n\\n判断方法：\\n\\t**先找到\\\\*，然后看\\\\*的两边，右边是对指针p本身的限定，左边是对p所指向的东西的限定。**\\n\\n说明：(顺带一提：\\\\*号优先级排第二，从右往左结合)\\n\\n1.const int\\\\* p：\\n\\n就是所谓的“指向常量的指针”。这里注意，<font color=\\\"blue\\\">所谓“指向常量”只是这个指针的“一厢情愿”，只是一种效果上的等价。</font>事实上，const int \\\\*p=&a;a既可以是常量(const int a=10;)又可以是变量(int a=10;)，但p一厢情愿地认为它所指的就是一个常量，所以它不允许通过自己来修改所指，这就造成一种效果上的等价——从p的角度看，它所指的“的确”是常量。所以，<font color=\\\"red\\\">对“指向常量的指针”的最佳理解应为：我们不能通过该指针修改它所指向的东西（常量或者变量）。</font>\\n\\n 注意，const int \\\\*p=&a;只是说不能通过p来修改a，如果a本身不是const的，通过其它方式修改a自然是可以的（例如直接++a）。\\n\\n另外一点，由于p本身只是一个普通的指针，所以允许在声明时不初始化。但需要注意的是，我们只是说可以，但并不提倡这样做。在任何时候都不应该让指针无所指，如果在声明一个指针时还不知道让它指向谁，就先将其初始化为nullptr或NULL（nullptr是cpp11新特性，用它比用NULL更安全些，这里不详细介绍）。\\n\\n2.int\\\\* const p：\\n\\n就是所谓的“本身是常量的指针”。关于“p本身不能修改但可以通过p修改其所指”这一点，我们在讲判断方法时已经说过，这里主要再说一下p的初始化。\\n\\n由于p本身是const的，所以在编译的时候必须知道p的值（即p所指向的东西的地址），所以在声明p的同时必须初始化p。但要注意，对于 int\\\\* const p=&a，我们只要求a的地址是确定的，但a的值可以不确定。\\n\\n3.const int\\\\* cosnt p：\\n\\n就是所谓的“所指和本身都是常量的指针”。它的语法特性就是前两者的结合，这里不再赘述。\\n\\n4.补充说明：\\n\\n引用生命是必须初始化，且必须左值初始化。这一点与“本身是敞亮的指针”(int\\\\* const p)的特性一样。事实上，我们完全可以借用“本身是常量的指针”来理解甚至定义引用：\\n\\n**引用是一个指向不可变的、被编译器自动解引用的指针，即，引用是一个被编译器自动解引用的“本身是常量的指针”。**\\n-\",\"articleCover\":\"https://upload.haoxx.site/article/2ec42f646cb85e6554ab21b4e9bc6c19.jpg\",\"articleTitle\":\"C++指针与常量知识点说明\",\"articleType\":1,\"categoryName\":\"编程语言基础\",\"id\":75,\"isRecommend\":0,\"isTop\":0,\"status\":1,\"tagNameList\":[]}]','PUT','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',22,'2023-06-07 19:56:15');
INSERT INTO `t_operation_log` VALUES (1356,'文章模块','上传','/admin/article/upload','com.ican.controller.ArticleController.saveArticleImages','上传文章图片','image_7.jpg','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/article/e16db2f6b4c568f36a1baa140b2e3b86.jpg\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',16,'2023-06-07 19:56:35');
INSERT INTO `t_operation_log` VALUES (1357,'文章模块','修改','/admin/article/update','com.ican.controller.ArticleController.updateArticle','修改文章','[{\"articleContent\":\"---\\ntitle: C/C++的比较\\ndate: 2022-04-01\\ncategory:\\n - 1编程语言基础\\n\\nfooter: <a href=\\\"https://beian.miit.gov.cn/#/Integrated/index\\\">渝ICP备2023001651号</a>\\n\\n---\\n\\n:::tip\\nC/C++的比较\\n:::\\n\\n<!-- more -->\\n\\n\\n## 1、第一部分 C++高級編程\\n\\n以下部分内容来源于[知乎：C++高级编程学习笔记](https://zhuanlan.zhihu.com/p/414375745)\\n1.头文件添加注释(文件名, 作者, 函数简介, 日期). （建议而非必要）\\n2.当头文件数目较多时, 应将头文件放在include目录下, 源文件放在source目录下.\\n3.const常量有数据类型, 宏常量#define没有数据类型.\\n4.对于重载赋值运算符`operator =`, 应该用\\\"引用传递\\\"方式。形如：\\n\\n```cpp\\nA operator=(B &b)\\n{\\n\\tA a;\\n    a.Data=b.Data;\\n    return a;\\n}\\n//或\\n#include <iostream>\\nusing namespace std;\\n\\nclass Distance\\n{\\nprivate:\\n    int feet;\\n    int inches;\\npublic:\\n    Distance(){\\n        feet=0;\\n        inches=0;\\n    }\\n    Distance(int f,int i){\\n        feet=f;\\n        inches=i;\\n    }\\n    void operator=(const Distance &D) //赋值运算符重载\\n    {\\n\\t\\tfeet=D.feet;\\n        inches=D.inches;\\n    }\\n    void displayDistance()\\n    {\\n\\t\\tcout<<\\\"F: \\\"<<feet<<\\\"I: \\\"<<inches<<endl;\\n    }\\n};\\nint main()\\n{\\n\\tDistance D1(11,10),D2(5,11);\\n\\t\\n\\tcout<<\\\"First Distance : \\\";\\n\\tD1.displayDistance();\\n\\tcout<<\\\"Second Distance : \\\";\\n\\tD2.displayDistance();\\n\\t\\n\\t//使用赋值运算符\\n\\tD1=D2;\\n\\tcout<<\\\"then,the new First Distance :\\\";\\n\\tD1.displayDistance();\\n\\treturn 0;\\n}\\n```\\n\\n5.函数入口处用assert检查\\n6.内存分配方式有三种, 从静态存储区域分配, 从栈上分配, 从堆上分配, 静态存储区包括全局变量, static变量等.\\n7.C++/C语言，没有办法知道指针所指的内存容量.\\n8.指针消亡了, 不表示所指的内存会被自动释放。内存被释放了, 不表示指针会消亡或者成了NULL指针.\\n9.指针被free或delete之后, 别忘记设置为NULL.\\n\\n关于8和9的思考：先用指针开辟一个空间，然后在令指针为NULL。这时，指针消亡了，但是内存空间还在，只是不能使用了（内存泄漏）。对开启了空间的指针free或者delete，内存空间会被释放，但是指针还能使用（只是使用前需要重新在赋指针值）。\\n10.malloc不调用构造函数, new自动调用构造函数, free和delete类似.\\nmalloc是c语言的底层函数，new是C++的类方法。\\n11.为什么要用重载? (1) 便于记忆。(2) 不得不, 比如说类的多个构造函数\\n12.不能编译头文件\\n全局变量定义时, (直接赋值), extern无作用\\n全局变量声明时, extern告诉编译器, 定义部分在其它模块中\\n全局变量默认extern\\n13.重载: 同一个类中, 或都是全局函数.\\n覆盖: 分别位于派生类与基类中, 函数名与参数都相同，有virtual关键字，用于多态.\\n隐藏: 分别位于派生类与基类中, 只要同名, 且非覆盖, 均为隐藏.\\n14.函数参数的缺省值，只能出现在函数的<font color=\\\"red\\\">声明</font>中. \\n15.操作符重载。调用时, 普通函数参数出现在圆括号内, 对于运算符, 参数出现在其左右两侧。定义时，可定义为全局函数和类的成员函数，后者比前者少了一个参数。\\n16.类的构造次序，先构造基类，再构造构造函数的参数，再构造成员，再构造自己。析构完全相反。\\n17.String a(\\\"hello\\\"); String b=a; 其实是调用了b的拷贝构造函数，最好写成String b(a).\\n18.对于一个类，编译器默认生成4个函数，无参构造函数，拷贝构造函数，析构函数，赋值函数(重载=运算符)\\n19.类的析构函数，应为虚函数, 多态\\n20.对于非内部数据类型的输入参数，应该将“值传递”的方式，改为“const 引用传递”，目的是提高效率。例如，将void Func(A a)，改为 void Func(const A &a)。其实实参在向形参传递值时，是用实参的值在栈上重新开辟了一块临时空间，再来装实参的值。如果使用引用的方法，就是单纯地指针传递，没有开辟空间这个步骤，节约时间，节约栈内存。\\n21.引用被创建的同时，必须被初始化，一旦引用被初始化，就不能改变引用的关系。引用的实质是<font color=\\\"red\\\">指针常量</font>。即：<font color=\\\"red\\\">指针常量：本质为常量，常量里面装的是指针。所以，指针的指向不能变，指向的内存空间中，存放的值可以变</font>。\\n22.对比于C语言的函数，cpp增加了重载，内联，const和virtual四种新机制，重载和内联机制，既可以用于全局函数，也可用于类的成员函数，const与virtual机制，仅用于类的成员函数\\n23.赋值符号的重载，不能为友元，只能是类的成员函数\\n\\n## 2、第二部分 cpp和C的区别\\n\\n紧接上文，还是参考[知乎专栏](https://zhuanlan.zhihu.com/p/414375745)\\n1、概述\\n\\n+ C++三要素：封装、继承、多态。封装是class，继承是class的继承，多态是函数重载和运算符重载\\n+ 面向对象：\\n  对象：存在即合理，抽象性：物以类聚，封装：事物的封闭性，继承：事物的相似性，多态：事物的多样性。\\n+ 面向对象的方法：\\n  ![图1](https://s3.bmp.ovh/imgs/2022/07/25/b6c212804ba23100.jpg)\\n+ cpp是什么？\\n  cpp是c语言的超集；是面向对象编程；可移植性，不牺牲性能和底层功能。可以用cpp compiler将cpp代码翻译成c代码\\n+ cpp适合？\\n  算法、应用开发、C/cpp服务器\\n+ cpp设计原则\\n  =1、cpp设计成使用静态型别机制、与C同样高效，可移植的，多用途程序设计语言。\\n  =2、cpp设计成直接的和广泛的，支持多种程序设计风格（程序化程序设计、数据抽象化、面向对象程序设计、泛型程序设计）。\\n  =3、cpp设计成给程序设计者，更多的选择，即使可能导致程序设计者选择错误。\\n  =4、cpp设计成尽可能与C兼容，提供一个从C到cpp的平滑过渡。\\n  =5、cpp避免平台限定，或没有普遍用途的特性。\\n  =6、cpp不使用会带来额外开销的特性。\\n  =7、cpp设计成无需复杂的程序设计环境。\\n\\n2、流的概念\\ncpp的I/O是以字节流的形式实现的，流(stream)实际上就是一个字节序列。\\n输入流: 在输入操作中，字节从输入设备(如键盘、磁盘、网络连接等)流向内存；输出流: 在输出操作中，字节从内存流向输出设备(如显示器、打印机、磁盘、网络连接等);这里“流”，试图说明字符，随着时间顺序生成或消耗的。输人/输出系统的任务，实际上就是以一种稳定、可靠的方式，在设备与内存之间传输数据。cpp并没有直接定义，进行输入输出的任何语句，这些功能是由标准IO库完成。\\n\\n3、命名空间\\n实际上就是，一个由程序设计者命名的内存区域，程序设计者，可以根据需要指定一些有名字的空间域，把一些全局实体，分别放在各个命名空间中，从而与其它全局实体分隔开来。\\n\\n命名空间是ANSIcpp引入的，可以由用户命名的作用域，用来处理程序中常见的同名冲突。\\n4、cpp程序的执行过程\\n预处理、汇编、编译、连接\\n5、C/cpp的字符串比较\\n\\n① C语言字符串练习 char st[100];\\n① cpp语言字符串练习 string str;\\n\\n② 检测字符串长度 int len = strlen(st);\\n② 检测字符串长度 int len = str.length();\\n\\n③ 字符串比较 strcmp(st1, st2);\\n③ 字符串比较 str1.compare(str2);\\n\\n④ 在已有字符串后，追加新串 strcat(st1, st2); strncat(st1,st2,n);\\n④ 在已有字符串后，追加新串 str1 += str2; str1.append(str2);\\n\\n⑤ 字符串拷贝 strcpy(st1,st2); strncpy(st1,st2, n);\\n⑤ 字符串拷贝 str2 = str1; str2 = str1.substr();\\n\\n⑥ 字符串查找 where = strchr(st, ch)\\n⑥ 字符串查找 where = str1.find(str2);\\n\\n6、c/cpp的数据类型和变量\\n数据类型：\\n![图3](https://s3.bmp.ovh/imgs/2022/07/25/9a78f1d9dd477a24.jpg)\\n程序运行过程中，值能否发生改变，分为**常量和变量**\\n从变量作用域的大小考虑：全局变量，局部变量\\n全局变量：定义在所有的函数体之外，在程序开始运行时，分配存储空间，在程序结束时，释放存储空间\\n函数中定义的变量，称为局部变量（Local Variable）\\n从变量的生命周期考虑: 静态生存周期和动态生存周期\\n动态存储变量：变量仅在需要的时候，分配和占用内存\\n静态存储变量：变量在程序运行过程中，占用固定的内存\\n从变量的在内存中位置考虑：普通变量与指针变量\\n\\nC语言中没有引用，cpp中才有引用，引用的主要用途，就是在函数传参和返回值上。如果既要利用引用提高使用效率，又要保护传递给函数的数据，不在函数中被改变，就应当使用常引用。\\n\\n如果输入参数，以值传递的方式传递对象，宜改用“&”引用方式来传递，这样可以省去临时对象的构造和析构过程，提高效率。特别是函数形参为类对象时，最好使用引用传递，而非值传递。\\n\\n如果函数的返回值是一个对象，有些场合，用“引用传递”替换“值传递”，可以提高效率，有些场合不可以。\\n\\n常引用\\n\\n声明一个引用，不是新定义一个变量，只是该引用名是目标变量的一个别名，本身不是一种数据类型，引用不占存储单元。对引用取地址，就是对目标变量取地址。\\n\\n还需注意，所谓常引用，这个“常”只对引用有效，对原数据是无效的。例如`int a=10;const int &b=a;a=20；//该语句有效，b=20;//该语句无效！`\\n\\n警告：主函数不允许操作栈指针！（如何区分指针和引用？）\\n\\n```cpp\\n#include<iostream>\\nusing namespace std;\\nint &getlnt(const int v) //int&返回引用，int* getlnt(*)是返回指针\\n{\\nint *p = new int(v);\\nreturn *p;\\n}\\nint main()\\n{\\nint &n = getlnt(123456789);\\n//出错！栈指针在函数退出时会立即释放，操作野指针是非法的！\\ncout << n << endl;\\nint *pp = &n;\\ndelete pp; //删除失败\\nreturn 0;\\n}\\n```\\n\\n7、c/cpp函数说明\\n函数实现的三结构：函数申明、函数（体）实现、函数调用\\n函数体的构成：返回值类型、函数名、形参表、函数体\\n函数与指针：指针函数和函数指针\\n指针函数：本身是函数，返回值是指针。形如：`int* func_sum(int n)`，再次提醒：操作栈指针是非法的，对于返回值是指针的函数，这个指针①应当是指向静态变量static，或者该指针②全局变量指针。反正这个指针不能指向栈空间。\\n函数指针：本质是一个指针，他指向了函数。形如`ret (*p)(参数列表)`，其中p称为函数指针。\\n\\n```cpp\\nint max(int a,int b)\\n{\\n\\treturn a>b?a:b;\\n}\\nint min(int a,int b)\\n{\\n\\treturn a<b?a:b;\\n}\\nint main()\\n{\\n    int (*p)(int,int); //或者int (*p)(int a,int b)\\n    p=max; //给函数指针赋值\\n    int ret1=p(10,20);\\n    p=min;\\n    int ret2=p(2,10);\\n    return 0;\\n}\\n```\\n\\n**为什么要使用函数指针**\\n\\n那么，有不少人就觉得，本来很简单的函数调用，搞那么复杂干什么？其实在这样比较简单的代码实现中不容易看出来，当项目比较大，代码变得复杂了以后，函数指针就体现出了其优越性。\\n\\n举个例子，如果我们要实现数组的排序，我们知道，常用的数组排序方法有很多种，比如快排，插入排序，冒泡排序，选择排序等，如果不管内部实现，你会发现，除了函数名不一样之外，返回值，包括函数入参都是相同的，这时候如果要调用不同的排序方法，就可以使用指针函数来实现，我们只需要修改函数指针初始化的地方，而不需要去修改每个调用的地方（特别是当调用特别频繁的时候）。\\n\\n**函数指针的典型应用：回调函数**\\n函数指针的一个典型应用就是**回调函数**。回调函数就是一个通过函数指针来调用其他函数的函数。其将函数指针作为一个参数，传递给另一个函数。\\n\\n```cpp\\n#include<stdio.h>\\n#include<stdlib.h>\\n\\n//函数功能：实现累加求和\\nint func_sum(int n)\\n{\\n        int sum = 0;\\n        if (n < 0)\\n        {\\n                printf(\\\"n must be > 0\\\\n\\\");\\n                exit(-1);\\n        }\\n        for (int i = 0; i < n; i++)\\n        {\\n                sum += i;\\n        }\\n        return sum;\\n}\\n\\n//这个函数是回调函数，其中第二个参数为一个函数指针，通过该函数指针来调用求和函数，并把结果返回给主调函数\\nint callback(int n, int (*p)(int))\\n{\\n\\treturn p(n);\\n}\\n\\nint main(void)\\n{\\n    int n = 0;\\n    printf(\\\"please input number:\\\");\\n    scanf(\\\"%d\\\", &n);\\n    printf(\\\"the sum from 0 to %d is %d\\\\n\\\", n, callback(n, func_sum));       //此处直接调用回调函数，而不是直接调用func_sum函数\\n    return 0;\\n}\\n```\\n\\n上面这个简单的demo就是一个比较典型的回调函数的例子。在这个程序中，回调函数callback无需关心func_sum是怎么实现的，只需要去调用即可。\\n\\n这样的好处就是，如果以后对求和函数有优化，比如新写了个func_sum2函数的实现，我们只需要在调用回调函数的地方将函数指针指向func_sum2即可，而无需去修改callback函数内部。\\n\\n回调函数广泛用于开发场景中，比如信号函数、线程函数等，都使用到了回调函数的知识。\\n\\n内存五区（按地址从低到高排序）：代码区、文字常量区（字符串常量）、全局区（静态区）、堆区、栈区。（来源百度）\\n内存四区：代码区（存放代码）、全局区（存放全局变量、静态变量和常量）、栈区、堆区。（黑马）\\n\\nc/cpp增强了函数类型：\\n基础函数：内联函数（cpp新增，c语言在c99后也引入了）、函数重载、模板函数（泛型编程）\\n成员函数：构造/析构函数、常成员函数、静态成员函数、虚函数\\n\\n内联函数inline：主要解决程序的运行效率问题。针对那种函数体代码量较小，但是又会频繁调用的函数，在编译阶段，编译器会将函数名直接替换成函数体，以节省函数调用出栈入栈的开销。\\n\\n以代码量增加为代价，提高程序运行效率。\\n\\n内联函数的定义，必须出现在该函数第一次被调用前;内联函数不能有复杂的控制语句，如switch，goto和while。递归函数不能是内联函数，（递归函数）自己调用自己的函数如果用于内联的话，反而会影响效率。\\n递归：自己调用自己；迭代：A调用B来获取新值。递归中一定含有迭代，迭代中不一定有递归。数据类型：树的打印函数使用了递归的方法。\\n\\n```cpp\\n//迭代\\nvoid print_shu(int i)\\n{\\n\\t...\\n}\\nint main()\\n{\\n\\tfor(int i=0;i<n;i++)\\n\\t{\\n\\t\\tprint_shu(i);          //迭代\\n\\t}\\n\\treturn 0;\\n\\t\\n}\\n//递归\\n```\\n\\n![图4](https://s3.bmp.ovh/imgs/2022/07/25/054dd7c396abe92b.png)\\n函数重载：形参个数不同、形参顺序不同或形参类型不同。（返回值类型不能作为重载依据）\\n函数形参默认值（缺省值）：如果同时存在函数声明和函数定义，默认值应在声明中给定，而不允许在定义中给定。默认值按从右到左的顺序。\\n形参的默认值，可以是全局常量、全局变量、表达式、函数调用，但不能为局部变量。例如，\\n\\n```cpp\\nvoid funcl(）\\n{\\nint k；\\nvoid g(int x=k)；//k为局部变量\\n}\\n```\\n\\n## 3、第三部分 C++新特性\\n\\n参考链接[南邮武三郎的文章](https://www.zhihu.com/people/wujitao/posts?page=4)\",\"articleCover\":\"https://upload.haoxx.site/article/e16db2f6b4c568f36a1baa140b2e3b86.jpg\",\"articleTitle\":\"C/C++的比较\",\"articleType\":1,\"categoryName\":\"编程语言基础\",\"id\":76,\"isRecommend\":0,\"isTop\":0,\"status\":1,\"tagNameList\":[]}]','PUT','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',18,'2023-06-07 19:56:37');
INSERT INTO `t_operation_log` VALUES (1358,'文章模块','上传','/admin/article/upload','com.ican.controller.ArticleController.saveArticleImages','上传文章图片','image_25.jpg','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/article/27d6c34fad9892fa82032f4bfa681d4f.jpg\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',20,'2023-06-07 19:56:50');
INSERT INTO `t_operation_log` VALUES (1359,'文章模块','修改','/admin/article/update','com.ican.controller.ArticleController.updateArticle','修改文章','[{\"articleContent\":\"---\\ntitle: 大话数据结构和算法\\ndate: 2022-10-30\\ncategory:\\n - 2数据结构与算法\\n\\nfooter: <a href=\\\"https://beian.miit.gov.cn/#/Integrated/index\\\">渝ICP备2023001651号</a>\\n\\n---\\n\\n:::tip\\n大话数据结构和算法\\n:::\\n\\n<!-- more -->\\n\\n\\n注：内容来源于书籍《大话数据结构》，部分内容来源于网络补充。\\n\\n数据结构：使相互之间存在的一种或多种特定关系的数据元素的集合。从不同的角度来讨论，会有不同的分类。按照逻辑结构来分，有“集合结构、线性结构、树状结构和图形结构”，按照物理结构分类，有“顺序存储结构、链式存储结构”。\\n\\n算法：是解决特定问题求解步骤的描述，在计算机中表现为指令的优先序列，并且每条指令表示一个或多个操作。\\n\\n算法的五大基本特性：输入、输出、有穷性】确定性和可行性。\\n\\n算法设计的要求：正确性、可读性、健壮性、时间效率高和存储量低。\\n\\n## 一、算法优劣的度量\\n\\n算法优劣的度量有事前分析法和事后统计法。一般采用事前分析法，分析算法的时间效率和空间存储量。\\n\\n大O记法：T(n)=O(f(n))，一般说来，随着n的增大，T(n)增长最慢的算法为最优算法。\\n\\n> 推导大O阶：\\n>\\n> + 用常数1来取代运行时间中的所有加法常数\\n> + 在修改后的运行次数函数中，只保留最高阶项\\n> + 如果最高阶项存在且系数不为1，就像系数调整为1\\n\\n1、常数阶O(1)\\n\\n一般顺序结构的时间复杂度是O(1)。对于分支结构而言，无论是镇还是假，执行的次数都是恒定的，不会随着n的变大而发生变化，所以单纯的分支结构（不包含在循环结构里），其时间复杂度也是O(1)。\\n\\n```c\\nint sum=0,n=100  //执行一次\\nsum=(1+n)*n/2;   //执行一次\\n```\\n\\n2、线性阶O(n)\\n\\n一般循环结构都要重复执行n次，所以循环结构的时间复杂度为O(n)。一般分析算法的复杂度，主要就是分析循环结构的复杂度。\\n\\n```c\\nint i;\\nfor(i=0;i<n;i++)  //时间复杂度为n\\n{\\n//时间复杂度为1的代码序列\\n}\\n```\\n\\n3、对数阶O(logn)\\n\\n如果在循环中，对循环因子进行了处理，那这段代码的时间复杂度就会发生变化，比如：\\n\\n```c\\nint count=1;\\nwhile(count<n)\\n{\\ncount = count*2;\\n//时间复杂度为1的代码序列\\n}\\n```\\n\\n因为每次count乘以2之后，就距离n更近了一步，也就是说有多少个2相乘后大于n，则会退出循环，有2^x^=n可以得到x=log~2~n。所以该类算法的时间复杂度为log~2~n。\\n\\n4、平方阶\\n\\n1、简单循环结构的循环嵌套，其算法时间度一般为O(n^2^)。\\n2、如果外层循环改为了m，那么时间复杂度就该为了O(mxn);\\n3、有些排序和搜索算法会用到这种循环结构：\\n\\n```c\\nfor(i=0;i<n;i++)\\n{\\n\\tfor(j=i;j<n;j++)\\n\\t{\\n\\t//时间复杂度为1的程序代码片段\\n\\t}\\n}\\n```\\n\\n当i=0时，内循环了n次；当i=1时，内循环了n-1次，...，当i=n-1时，内循环了1次。综上，这个代码块的总运行时间为：n+(n-1)+(n-2)+...+1=(n+1)n/2=1/2(n^2^+n)。根据大O算法，推导出时间复杂度为O(n^2^)。\\n\\n下面这段代码相对而言更复杂：\\n\\n```c\\nn++;   //执行次数为1\\nfunction(n);//执行次数为n\\nint i,j;//执行次数为1\\nfor(i=0;i<n;i++)//执行次数为n*n\\n{\\n\\tfunction(i);\\n}\\nfor(i=0;i<n;i++)//执行次数为n*(n+1)/2\\n{\\n\\tfor(j=i;j<n;j++)\\n\\t{\\n\\t\\t//时间复杂度为1的代码\\n\\t}\\n}\\nvoid function(int n)\\n{\\n\\tfor(int i=0;i<n;i++)\\n\\t{\\n\\t\\t//时间复杂度为1的代码\\n\\t}\\n}\\n```\\n\\n综上，它的执行次数为1+n+1+n\\\\*n+n\\\\*(n+1)/2，时间复杂度为O(n^2^)。\\n![](https://s3.bmp.ovh/imgs/2022/11/05/dda3163c8daa0b01.png)\\n\\n算法的空间复杂度S(n)=O(f(n))，其中n为问题的规模，f(n)为语句关于n所占存储空间的函数。\\n\\n一般来说，一个程序在机器上执行时，出了需要存储程序本身的指令、常数、变量和输入数据外，还需要存储对数据操作的存储单元。若输入数据所占空间只取决于问题本身，和算法无关，这样只需要分析该算法在实现时所需的辅助单元即可。若算法执行时所需的辅助空间相对于输入数据量而言是个常数，则称此算法为原地工作，空间复杂度为O(1)。\\n\\n\\n\\n## 二、线性表（顺序存储结构和链式存储结构）\\n\\n线性表：零个或多个数据元素的有限序列。分为顺序存储结构（数组）和链式存储结构（链表）。\\n线性表的两个特点：1）有序；2）有限。有序是指，首元素无前驱结点，尾元素无后继节点，其余元素都有唯一的前驱结点和后继节点。有限是指元素个数是可以统计的。\\n\\n<font color=\'red\'>线性表的顺序存储结构</font>代码：\\n\\n```c\\n#define MAXSIZE 30\\ntypedef int ElemType\\ntypedef struct\\n{\\n\\tElemType data[MAXSIZE];\\n\\tint length;\\n}Sqlist;\\n```\\n\\n这里，我们可以发现描述顺序存储结构需要三个属性：\\n\\n+ 存储空间的起始位置，数组data\\n+ 线性表的最大存储容量；\\n+ 线性表当前的长度；\\n\\n通过上述分析，不难看出数组、链表(单链表、双向链表、循环链表)、栈、队列和字符串都是一种线性表结构。他们都有下面几种操作(除字符串以外)\\n\\n```c\\n1、初始化  InitList(*L)\\n2、验证是否为空：ListEmpty(L)\\n3、清空 ClearList(*L)\\n3.2 摧毁 DestroyList(*L)\\n\\n4、通过序号获取元素GetElem(L,i,*e)\\n5、通过元素查找序号LocateElem(L,e)\\n\\n6、增ListInsert(*L,i,e)\\n7、删ListDelete(*L,i,*e)\\n8、改Modify(*L,i,e)\\n9、统计长度ListLength(L)\\n\\n//细节\\n当然，各自的细节不一样。比如1、数组不需要清空和验证是否为空，还有通过元素获取序号、通过序号查询值也是不需要的。在插入上，单链表、循环链表、双向链表上有微小差异。2、栈只有查询栈顶元素，队列只有查询队首元素 3、注意区分线性表长度和数组长度（针对顺序存储结构），数组长度一般是指这个数据结构对象的容量，而线性表长度是指这个对象的实际存储数据的数量。4、关于字符串，它是一种特殊的线性表，他符合线性表的特征，它是线性表，他也有顺序存储和链式存储，不过其他几种线性表能关注单个元素的操作，比如查找、插入和删除，但是串中更多的查找子串、得到指定位置的子串和替换子串等操作。\\n\\n```\\n\\n\\n线性表顺序存储结构的优缺点：\\n\\n> 优点\\n>\\n> + 无需为表示表中元素之间的逻辑关系而增加额外的存储空间；\\n> + 可以快速地存储、查找表中任意位置的元素\\n>\\n> 缺点\\n>\\n> + 插入/删除元素的效率较低。特别是在首部插入和删除元素时，时间效率为O(n)，平均插入/删除的小绿尾O((n-1)/2)\\n> + 当线性表长度变化较大时，难以确定存储空间的容量\\n> + 造成存储空间的“碎片”\\n\\n<font color=\'red\'>线性表的链式存储结构</font>：\\n\\n顺序存储结构最大的缺点就是插入和删除元素的效率问题，而链式存储可以解决该问题。链式存储解除了空间上的连续性，使得元素存储自由化，就可以提高元素插入/删除的效率，但也带来了额外的空间消耗。\\n\\n除了其本身的信息之外，还需存储一个指向其直接后继的信息(即直接后继的存储位置)。\\n\\n链表的分类有很多种，可以分为有头结点、无头结点；可以分为单链表、双向链表、循环链表。双向链表是有头尾指针，可以前进也可以后退。循环链表是头尾相连的链表。双向循环链表指的是在循环链表和双向链表的基础上，将两种链表的最后一个结点指向第一个结点从而实现循环。\\n\\n```c\\ntypedef struct Node\\n{\\n\\tint data;\\n\\tstruct Node *next;\\n}List;\\n```\\n\\n1、从查找性能上看，顺序存储结构的性能为O(1)，链式存储的性能为O(n)；2、从插入/删除的性能上看，顺序存储结构的性能为O(n)，链式存储的性能为O(1)；3、从空间性能上看，顺序存储需要预先分配空间，分配大了就浪费，分配小了会溢出，而链式存储不需要提前分配空间。\\n\\n<font color=\'red\'>结论</font>：情况1：若线性表需要频繁查找，很少进行插入和删除操作时，宜采用顺序存储结构。若需要频繁插入和删除时，宜采用单链表结构。举个简单的例子，游戏开发中的玩家账号信息，只有注册时需要插入，平时一般是查询操作，最好采用顺序结构。游戏装备会频繁刷新，经常读写，最好采用链式结构。\\n\\n情况2：如果元素总数变化较大或者不知道有多少总数时，宜采用链式结构。\\n\\n补充一点，散列表（Hash哈希表）：一种由数组和链表组合起来的数据结构，（也可能是数组、链表和红黑树组合起来），它兼顾数组和链表的优点，有较好的查询性能和插入/删除性能。[参考CSDN博客](https://blog.csdn.net/heyuchang666/article/details/49996237)，哈希表的结构如图所示：\\n![](https://s3.bmp.ovh/imgs/2022/11/15/65762f5ec5f6d72a.png)\\n\\n\\n数组和链表的对比：\\n![](https://s3.bmp.ovh/imgs/2022/10/30/106260aed0a641e5.png)\\n\\n跳表：上表说过，链表的优点是可以更灵活的使用内存空间，长度可以动态变化，且插入/删除数据灵活。但是链表查询元素必须遍历链表，效率低。所以提出了一种跳表。在原链表的基础上，在新增一条或多条索引链表，加速对元素的查询。\\n![](https://s3.bmp.ovh/imgs/2022/10/30/1db5cfb2d228ca2b.png)\\n\\n### 2.2 链表小总结\\n\\n```c\\n//单链表插入元素\\n//在p节点后插入新节点new:\\nnew->next=p->next;\\np->next=new;\\n```\\n\\n普通链表、静态链表、循环链表、双向链表\\n\\n为了使空链表与非空链表处理 致，我们通常设一个头结点，当然 这并不是说，循环链表一定要头结点，这需要注意。\\n\\n普通链表，各节点之间通过指针相连，无需提前设计容量，无数据溢出风险。数据插入/删除效率高，但是遍历效率低。数组是查询效率高。对于遍历效率低的问题，可以使用循环链表解决。对于链表只能前进不能后退的问题，引入了双向链表。\\n\\n### 2.2.2 循环链表\\n\\n头尾相连的链表，为了使空链表的处理和非空链表的处理保持一致，通常要设置一个头结点。\\n\\n除了头结点，还需要一个指针。设置头指针还是尾指针？设置头指针：访问第一个元素，时间复杂度为O(1)，访问尾元素为O(n)。设置尾指针，访问尾元素，时间复杂度为O(1)，访问首元素为O(2)，即为`rear->next->next`（因为要跳过头结点）。\\n\\n有了尾指针，两个循环链表的结合也变得非常简单了，如下图所示。\\n![](https://s3.bmp.ovh/imgs/2022/12/15/c7b7bf6fb88cb300.png)\\n\\n```c\\np=rearA->next;\\nrearA->next=rearB->next->next;\\nq=rearB->next;\\nrearB->next=p;\\nfree(q);\\n```\\n\\n### 2.2.3 双向链表\\n\\n双向循环链表是从单链表里面扩展出来的，所以他的很多操作都与单链表相同。比如求长度、查元素位置和通过位置查元素等。只是涉及到插入和删除的时候，需要两个指针的参与。\\n\\n```c\\n有：p->next->prior=p=p->prior->next;\\n//双向链表的插入：\\n//在p节点后插入新节点e\\ne->next=p->next;\\ne->prior=p;\\np->next->prior=e;\\np->next=e;\\n//双向链表的插入-2 李慧芹方法\\ne->next=p->next;\\ne->prior=p;\\ne->next->prior=e;\\ne->prior->next=e;\\n//双向链表的删除  删除节点p\\np->prior->next=p->next;\\np->next->prior=p->prior;\\nfree(p);\\n\\n```\\n\\n\\n## 三、栈与队列\\n\\n栈是先进后出的FILO，队列是先进先出的FIFO。栈和队列都有链式结构和顺序结构的实现。虽然把栈和队列从第二章线性表中分离来讲，但是栈和队列也是一种线性表。\\n\\n特殊之处在于，栈和队列限制了元素的插入和删除的位置。对于该部分的重点只是在于：\\n\\n- [ ] 不同情况的出栈顺序，其出栈结果不同\\n- [ ] 栈和队列都有链式存储和顺序存储两种结构\\n- [ ] 两栈共享空间(一般是顺序存储结构)\\n- [ ] 栈的应用：浏览器网页的后退功能、word的后退功能、用栈实现递归(斐波那契数列)、用栈实现计算器(包含如何将中缀运算符转换成后缀元素安抚、后缀运算符的计算规则)\\n- [ ] 队列的应用：任务队列\\n- [ ] 队列的顺序存储的不足(循环队列)、链式队列\\n\\n### 3.1 栈的顺序存储和两栈共享空间\\n\\n顺序存储一般使用数组实现，栈底为a[0]元素。栈顶指针top随元素增减而变化。\\n\\n顺序存储的弊端在于长度固定，所以容量设置小了容易溢出，设置打了容易浪费。对于浪费这种情况，可以采用“两栈共享的方法”来解决。两个栈各占数组的一端，\\n\\n```c\\n1)当top1=-1时，栈1为空，当top2=n时，栈2位空\\n2)当top1为n-1，或top2位0，又或者top+1=top2时栈满\\n```\\n\\n事实上，使用这种数据结构的情况，一般是“当两个栈的空间需求为相反关系时，也就是一个栈增长同时另一个栈减小的情况”，比如投票、买卖股票。\\n\\n栈的链式存储，因为链表有头结点，栈有栈顶指针，所以索性就把这两个指针合二为一了。在（栈顶指针）头结点后插入元素。\\n\\n### 3.2 斐波那契数列\\n\\n其核心就是使用了递归。递归是自己调用自己，迭代是循环。\\n递归：自己调用自己，重复运行函数，选择结构，[优}结构简单，节省代码，[缺]费时费空间]\\n迭代：循环重复运行代码，循环结构，[优]占内存小  [缺]\\n这是斐波那契数列的公式：\\n$$\\nF(n)=\\\\left\\\\{\\\\begin{array}{l}\\n0, \\\\text { 当 } n=0 \\\\\\\\\\n1, \\\\text { 当 } n=1 \\\\\\\\\\nF(n-1)+F(n-2), \\\\text { 当 } n>1\\n\\\\end{array}\\\\right.\\n$$\\n\\n### 3.3 用栈实现计算器\\n\\n1、 用后缀运算符来计算\\n\\n后缀运算符又称逆波兰表示法， 它的特点是所有符号都是在要运算的数字后面出现，例如：\\n\\n```c\\n前缀模式：9+(3-1)*3+10/2\\n后缀模式：9 3 1 - * 3 + 10 2 / +\\n```\\n\\n计算机喜欢用后缀模式来处理运算符，是因为栈的结构。1）左括号进，直到遇到右括号才弹出。2）遇到数字进栈，遇到运算符取两个数字进行运算。注意，后缀运算符中只有数字和运算符了。\\n\\n还有一点是，在栈中数字从上往下依次为1和3，然后遇到减号，则1先弹出做减数，然后3后弹出做被减数，所以为：`3-1`。\\n\\n2、中缀转后缀表达式\\n\\n规则：从左到右遍历中缀表达式的每个数字和符号，若是数字就输出，即成为后缀表达式的一部分；若是符号，则判断其与楼顶符号的优先级，是右括号或优先级不高于栈顶符号(乘除优先加减)则栈顶元素依次弹出并输出，并将当前符号进栈，一直到最终输出后缀表达式为止。\\n\\n即：1）数字直接输出，2）符号考虑情况，要不要进栈。2.1 左括号直接进，2.2 右括号直接出，并且把左右括号之间的东西一起弹出  2.3 如果是运算符之间，要比较大小。外头的运算符大，不弹，直接进栈。2.4 否则，先把栈里面的小的或相同的弹出并输出，然后再把栈外新元素（运算符）入栈。\\n\\n### 顺序存储队列的不足\\n\\n1、一方面，顺序存储的通病就是在不知道最大长度的情况下，容量不好设置。设置大了浪费，小了就溢出。\\n\\n2、另一方面，插入和删除元素问题。更改一个，整个数组就要跟着动。影响效率。\\n\\n解决方案1：新增一个队头和队尾的指针，插入和删除只是这两指针在动。新问题：“假溢出”：数组前半部分空着，但是数据都在后面存着，数据插入时会出现溢出错误。\\n\\n解决方案2：循环队列\\n\\n特点就是头尾相连。\\n\\n问题又来了：如何判断队列是否为空？\\n\\n在前面带两个指针的队列，队头指向首元素，队尾指向尾元素的下一个。这样，队列为空是就是front=rear。那这里的循环队列呢？front=rear有可能是空，有可能是满队列。\\n\\n方案1：设置标志量flag。当队列为空时，flag=0,队列满时，flag=1\\n方案2：保留了个元素空间。当front=rear时，就是表示队列为空。当(rear+1)%QueueSize=front时，队列为满。\\n\\n计算队列长度的公式：(rear-front+QueueSize)%QueueSize\\n\\n\\n## 四、字符串\\n\\n字符串操作常见的有：生成字符串、复制字符串、清空字符串、字符串是否为空？、字符串长度、字符串比较和字符串拼接、子串、子串索引、替换子串、插入子串、删除子串\\n\\n其中的核心操作就是字符串的比较。这里一共提到了三种匹配操作：\\n1）朴素的模式匹配方法  \\n2）KMP模式匹配算法\\n3）改进的KMP模式匹配算法\\n\\n朴素的模式匹配方法：\\n\\n通过循环，将主串的每一个字符和测试串T的每个元素进行比较。采用双层循环结构。优点是想法简单，容易实现，缺点是算法效率低。\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n## 五、树\\n\\n> 完全二叉树：除了最后一层节点，其余层的节点数已经达到了最大值，且最后一层的节点是按照从左到右的顺序排列的。\\n>\\n> 满二叉树：除了最后一层，其余层的节点都有两个子节点。\\n>\\n> 二叉排序树：左节点的值一定小于根节点；右节点的值一定大于根节点。 \\n>\\n> 平衡二叉树：又称AVL树，它是一颗二叉平衡树，且具有以下性质：它是一颗空树或左右两个子树的高度差绝对值不超过1，并且左右两个子树都是一颗平衡二叉树。\\n>\\n> > 说明：平衡因子：左子树高度 - 右子树高度    \\n>\\n> 红黑树：一种自平衡二叉查找树，是一种特化的平衡二叉树。\\n\\n![](https://s3.bmp.ovh/imgs/2022/10/30/ad75abd7cfbc22ba.png)\\n\\n**二叉排序树**：\\n\\n二叉排序树：是一棵空树，或者：若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；它的左、右子树也分别为二叉排序树。\\n\\n二叉排序树意味着二叉树中的数据是排好序的，顺序为左结点<根节点<右结点，这表明二叉排序树的中序遍历结果是有序的。\\n\\n**平衡二叉树**：\\n平衡二叉树的产生是为了解决二叉排序树在插入时发生线性排列的现象。由于二叉排序树本身为有序，当插入一个有序程度十分高的序列时，生成的二叉排序树会持续在某个方向的字数上插入数据，导致最终的二叉排序树会退化为链表，从而使得二叉树的查询和插入效率恶化。\\n![](https://s3.bmp.ovh/imgs/2022/10/30/a88628b6aef2dec2.png)\\n\\n平衡二叉树的出现能够解决上述问题，但是在构造平衡二叉树时，却需要采用不同的调整方式，使得二叉树在插入数据后保持平衡。主要的四种调整方式有LL（左旋）、RR（右旋）、LR（先左旋再右旋）、RL（先右旋再左旋）。这里先给大家介绍下简单的单旋转操作，左旋和右旋。LR和RL本质上只是LL和RR的组合。\\n\\n> 在插入一个结点后应该沿搜索路径将路径上的结点平衡因子进行修改，当平衡因子大于1时，就需要进行平衡化处理。从发生不平衡的结点起，沿刚才回溯的路径取直接下两层的结点，如果这三个结点在一条直线上，则采用单旋转进行平衡化，如果这三个结点位于一条折线上，则采用双旋转进行平衡化。\\n\\n左旋：S为当前需要左旋的结点，E为当前结点的父节点。\\n![](https://s3.bmp.ovh/imgs/2022/10/30/d9a414037fcbe702.png)\\n左旋的操作可以用一句话简单表示：将当前结点S的左孩子旋转为当前结点父结点E的右孩子，同时将父结点E旋转为当前结点S的左孩子。\\n\\n二叉排序树：当插入的数据高度有序时，二叉树会退化成链表，从而使得二叉树的查询和插入效率恶化。\\n\\n平衡二叉树优化了查询效率问题。但是在构造平衡二叉树时，却需要采用不同的调整方式使得二叉树在插入数据后保持平衡。高度平衡带来的好处是能够提供更高的搜索效率，其最坏的查找时间复杂度都是O(logN)。\\n\\n平衡二叉树带来了插入效率低的问题。有没有一种方法可以兼顾插入效率和查询效率呢？--答案是红黑树。\\n\\n**红黑树**：\\n\\n平衡二叉树（AVL）为了追求高度平衡，需要通过平衡处理使得左右子树的高度差必须小于等于1。高度平衡带来的好处是能够提供更高的搜索效率，其最坏的查找时间复杂度都是O(logN)。但是由于需要维持这份高度平衡，所付出的代价就是当对树种结点进行插入和删除时，需要经过多次旋转实现复衡。这导致AVL的插入和删除效率并不高。\\n\\n为了解决这样的问题，能不能找一种结构能够兼顾搜索和插入删除的效率呢？这时候红黑树便申请出战了。\\n\\n红黑树的五个特性：\\n\\n> 1、每个结点要么是红的要么是黑的。\\n>\\n> 2、根结点是黑的。\\n>\\n> 3、每个叶结点（叶结点即指树尾端NIL指针或NULL结点）都是黑的。\\n>\\n> 4、如果一个结点是红的，那么它的两个儿子都是黑的。\\n>\\n> 5、对于任意结点而言，其到叶结点树尾端NIL指针的每条路径都包含相同数目的黑结点。\\n>\\n> ![](https://s3.bmp.ovh/imgs/2022/10/30/6810891e8e72ed25.png)\\n> 黑树通过将结点进行红黑着色，使得原本高度平衡的树结构被稍微打乱，平衡程度降低。红黑树不追求完全平衡，只要求达到部分平衡。这是一种折中的方案，大大提高了结点删除和插入的效率。C++中的STL就常用到红黑树作为底层的数据结构。\\n\\n红黑树VS平衡二叉树\\n![](https://s3.bmp.ovh/imgs/2022/10/30/285dcb87b89c0d04.png)\\n\\n除了上面所提及的树结构，还有许多广泛应用在数据库、磁盘存储等场景下的树结构。比如B树、B+树等。这里就先不介绍了诶，下次在讲述相关存储原理的时候将会着重介绍。（其实是因为懒）\\n\\n\\n\\n\\n## 六、堆与散列表（哈希表）\\n\\n### 6.1 堆\\n\\n了解完二叉树，再来理解堆就不是什么难事了。堆通常是一个可以被看做一棵树的数组对象。堆的具体实现一般不通过指针域，而是通过构建一个一维数组与二叉树的父子结点进行对应，因此堆总是一颗完全二叉树。\\n\\n对于任意一个父节点的序号n来说（这里n从0算），它的子节点的序号一定是2n+1，2n+2，因此可以直接用数组来表示一个堆。\\n\\n不仅如此，堆还有一个性质：堆中某个节点的值总是不大于或不小于其父节点的值。将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。\\n\\n![](https://s3.bmp.ovh/imgs/2022/10/30/a0e7cdbcd8e45b1d.png)\\n堆常用来实现优先队列，在面试中经常考的问题都是与排序有关，比如堆排序、topK问题等。由于堆的根节点是序列中最大或者最小值，因而可以在建堆以及重建堆的过程中，筛选出数据序列中的极值，从而达到排序或者挑选topK值的目的。\\n\\n### 6.2 哈希表\\n\\n散列表也叫哈希表，是一种通过键值对直接访问数据的机构。在初中，我们就学过一种能够将一个x值通过一个函数获得对应的一个y值的操作，叫做映射。散列表的实现原理正是映射的原理，通过设定的一个关键字和一个映射函数，就可以直接获得访问数据的地址，实现O(1)的数据访问效率。在映射的过程中，事先设定的函数就是一个映射表，也可以称作散列函数或者哈希函数。\\n![](https://s3.bmp.ovh/imgs/2022/10/30/3ba468006ba54746.png)\\n散列表的实现最关键的就是散列函数的定义和选择。一般常用的有以下几种散列函数：\\n\\n> 直接寻址法：取关键字或关键字的某个线性函数值为散列地址。\\n>\\n> 数字分析法：通过对数据的分析，发现数据中冲突较少的部分，并构造散列地址。例如同学们的学号，通常同一届学生的学号，其中前面的部分差别不太大，所以用后面的部分来构造散列地址。\\n>\\n> 平方取中法：当无法确定关键字里哪几位的分布相对比较均匀时，可以先求出关键字的平方值，然后按需要取平方值的中间几位作为散列地址。这是因为：计算平方之后的中间几位和关键字中的每一位都相关，所以不同的关键字会以较高的概率产生不同的散列地址。\\n>\\n> 取随机数法：使用一个随机函数，取关键字的随机值作为散列地址，这种方式通常用于关键字长度不同的场合。\\n>\\n> 除留取余法：取关键字被某个不大于散列表的表长 n 的数 m 除后所得的余数 p 为散列地址。这种方式也可以在用过其他方法后再使用。该函数对 m 的选择很重要，一般取素数或者直接用 n。\\n\\n确定好散列函数之后，通过某个key值的确会得到一个唯一的value地址。但是却会出现一些特殊情况。即通过不同的key值可能会访问到同一个地址，这个现象称之为冲突。\\n\\n冲突在发生之后，当在对不同的key值进行操作时会使得造成相同地址的数据发生覆盖或者丢失，是非常危险的。所以在设计散列表往往还需要采用冲突解决的办法。\\n\\n常用的冲突处理方式有很多，常用的包括以下几种：\\n\\n> 开放地址法（也叫开放寻址法）：实际上就是当需要存储值时，对Key哈希之后，发现这个地址已经有值了，这时该怎么办？不能放在这个地址，不然之前的映射会被覆盖。这时对计算出来的地址进行一个探测再哈希，比如往后移动一个地址，如果没人占用，就用这个地址。如果超过最大长度，则可以对总长度取余。这里移动的地址是产生冲突时的增列序量。\\n>\\n> 再哈希法：在产生冲突之后，使用关键字的其他部分继续计算地址，如果还是有冲突，则继续使用其他部分再计算地址。这种方式的缺点是时间增加了。\\n>\\n> 链地址法：链地址法其实就是对Key通过哈希之后落在同一个地址上的值，做一个链表。其实在很多高级语言的实现当中，也是使用这种方式处理冲突的。\\n>\\n> 公共溢出区：这种方式是建立一个公共溢出区，当地址存在冲突时，把新的地址放在公共溢出区里。\\n\\n目前比较常用的冲突解决方法是链地址法，一般可以通过数组和链表的结合达到冲突数据缓存的目的。\\n![](https://s3.bmp.ovh/imgs/2022/10/30/77f0d941522f5204.png)\\n\\n左侧数组的每个成员包括一个指针，指向一个链表的头。每发生一个冲突的数据，就将该数据作为链表的节点链接到链表尾部。这样一来，就可以保证冲突的数据能够区分并顺利访问。\\n\\n考虑到链表过长造成的问题，还可以使用红黑树替换链表进行冲突数据的处理操作，来提高散列表的查询稳定性。\\n\\n\\n\\n## 七、图\\n\\n图相较于上文的几个结构可能接触的不多，但是在实际的应用场景中却经常出现。比方说交通中的线路图，常见的思维导图都可以看作是图的具体表现形式。\\n\\n图结构一般包括顶点和边，顶点通常用圆圈来表示，边就是这些圆圈之间的连线。边还可以根据顶点之间的关系设置不同的权重，默认权重相同皆为1。此外根据边的方向性，还可将图分为有向图和无向图。\\n![](https://s3.bmp.ovh/imgs/2022/10/30/6895b3dbf5ae8d5f.png)\\n图结构用抽象的图线来表示十分简单，顶点和边之间的关系非常清晰明了。但是在具体的代码实现中，为了将各个顶点和边的关系存储下来，却不是一件易事。\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n## 八、算法：查找\\n\\n参考： https://blog.csdn.net/chenlong_cxy/article/details/116563972?spm=1001.2101.3001.6661.1&depth_1-\\n\\n参考：https://blog.csdn.net/heyuchang666/article/details/50041455?spm=1001.2101.3001.6650.1&depth_1-\\n\\n参考：https://blog.csdn.net/heyuchang666/article/details/47275047\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n## 九、算法：排序\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\",\"articleCover\":\"https://upload.haoxx.site/article/27d6c34fad9892fa82032f4bfa681d4f.jpg\",\"articleTitle\":\"大话数据结构和算法\",\"articleType\":1,\"categoryName\":\"数据结构与算法\",\"id\":84,\"isRecommend\":0,\"isTop\":0,\"status\":1,\"tagNameList\":[]}]','PUT','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',23,'2023-06-07 19:56:52');
INSERT INTO `t_operation_log` VALUES (1360,'文章模块','上传','/admin/article/upload','com.ican.controller.ArticleController.saveArticleImages','上传文章图片','image_26.jpg','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/article/9a42c06ea0f36c4eacc2fb9bfc59781d.jpg\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',12,'2023-06-07 19:57:02');
INSERT INTO `t_operation_log` VALUES (1361,'文章模块','修改','/admin/article/update','com.ican.controller.ArticleController.updateArticle','修改文章','[{\"articleContent\":\"---\\ntitle: 结构体字节大小计算手册\\ndate: 2023-04-01\\ncategory:\\n - 1编程语言基础\\n\\nfooter: <a href=\\\"https://beian.miit.gov.cn/#/Integrated/index\\\">渝ICP备2023001651号</a>\\n\\n---\\n\\n:::tip\\n结构体字节大小计算手册\\n:::\\n\\n<!-- more -->\\n\\n\\n结构体\\n1、结构体计算字节数规则\\n总结规则如下:\\n\\n+ 0:结构体变量的首地址能够被其最宽基本类型成员的大小所整除\\n+ 1: VC6和VC71默认的内存对齐方式是#pragam pack(8)\\n+ 2: 结构体中每个成员按其类型的对齐参数(通常是这个类型的大小)和指定对齐参数中较小的个对齐.\\n+ 3:结构体每 个成员相对于结构体首地址的偏移量都是成员大小的整数倍.\\n+ 4:结构体本身也存在着对齐要求规则，不能比它所有字段中要求最严格的那个宽松\\n+ 5:结构体的总大小为结构体最宽基本类型成员大小的整数倍.且应尽量节省内存。\\n+ 6: 在GCC中，对齐模数的准则是:对齐模数最大只能是4，也就是说，即使结构体中有\\n  double类型，对齐模数还是4，所以对齐模数只能是1，2，4。而且在上述的规则中，第3条里，offset必须是成员大小的整数倍:\\n    + (1):如果这个成员大小小于等于4则按照上述准则是可行的，\\n    + (2):如果成员的大小大于4，则结构体每个成员相对于结构体首地址的偏移量只能按照是4的整数倍来进行判断是否添加填充。\\n\\n2、位域\\n[参考链接](http://www.javashuo.com/article/p-pyhbyxqy-bh.html)\\n\\n1. 一个位域必须存储在同一个字节中，不能跨两个字节，故位域的长度不能大于一个字节的长度。\\n2. 取地址操做符&不能应用在位域字段上;\\n3. 位域字段不能是类的静态成员;\\n4. 位域字段在内存中的位置是按照从低位向高位的顺序放置的;\\n5. 位域的对齐\\n\\n>1. 若是相邻位域字段的类型相同，且其位宽之和小于类型的sizeof大小，则后面的字段将紧邻前一个字段存储，直到不能容纳为止；\\n>2. 若是相邻位域字段的类型相同，但其位宽之和大于类型的sizeof大小，则后面的字段将重新的存储单元开始，其偏移量为其类型大小的整数倍；\\n>3. 若是相邻的两个位域字段的类型不一样,则各个编译器的具体实现有差别,VC6采起不压缩方式,GCC和Dev-C++都采用压缩方式;\\n>4. 整个结构体的总大小为最宽基本类型成员大小的整数倍。\\n>5. 若是位域字段之间穿插着非位域字段，则不进行压缩；（不针对全部的编译器）\\n\\n1. 当要把某个成员说明成位域时,其类型只能是int,unsigned int与signed int三者之一(说明:int类型一般表明特定机器中整数的天然长度。short类型一般为16位,long类型一般为32位,int类型能够为16位或32位.各编译器能够根据硬件特性自主选择合适的类型长度.见The C Programming Language中文 P32)。\\n\\n\",\"articleCover\":\"https://upload.haoxx.site/article/9a42c06ea0f36c4eacc2fb9bfc59781d.jpg\",\"articleTitle\":\"结构体字节大小计算手册\",\"articleType\":1,\"categoryName\":\"编程语言基础\",\"id\":81,\"isRecommend\":0,\"isTop\":0,\"status\":1,\"tagNameList\":[]}]','PUT','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',59,'2023-06-07 19:57:02');
INSERT INTO `t_operation_log` VALUES (1362,'文章模块','上传','/admin/article/upload','com.ican.controller.ArticleController.saveArticleImages','上传文章图片','image_27.jpg','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/article/b9f3f2f6ed8b951e6e047298abf80a23.jpg\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',15,'2023-06-07 19:57:13');
INSERT INTO `t_operation_log` VALUES (1363,'文章模块','修改','/admin/article/update','com.ican.controller.ArticleController.updateArticle','修改文章','[{\"articleContent\":\"---\\ntitle: 进程与线程笔记\\ndate: 2023-4-12\\ntags:\\n - 进程与线程\\ncategories:\\n - 未分类\\n---\\n# 一、创建进程/线程：\\n\\n1、进程创建pid_t fork(void); 说明：fork - create a child process\\n\\n包含头：\\\\#include \\\\<unistd.h\\\\>\\n\\n返回值：创建成功，则在父进程中返回子进程的PID，在子进程中返回0。创建失败，在父进程中返回-1。\\n\\n2、进程创建pid_t vfork(void); 说明：vfork - create a child process and block parent\\n\\n包含头：\\\\#include \\\\<sys/types.h\\\\>\\n\\n\\\\#include \\\\<unistd.h\\\\>\\n\\n3、线程创建int pthread_create(pthread_t \\\\*thread, const pthread_attr_t \\\\*attr,\\n\\nvoid \\\\*(\\\\*start_routine) (void \\\\*), void \\\\*arg);\\n\\n包含头：\\\\#include \\\\<pthread.h\\\\>\\n\\n注意; Compile and link with -pthread.\\n\\n返回值：创建成功返回0，否则返回错误值。\\n\\n参数：\\n\\n1.  pthread_t \\\\*thread：传递一个 pthread_t 类型的指针变量，也可以直接传递某个 pthread_t 类型变量的地址。pthread_t 是一种用于表示线程的数据类型，每一个 pthread_t 类型的变量都可以表示一个线程。\\n2.  const pthread_attr_t \\\\*attr：用于手动设置新建线程的属性，例如线程的调用策略、线程所能使用的栈内存的大小等。大部分场景中，我们都不需要手动修改线程的属性，将 attr 参数赋值为 NULL，pthread_create() 函数会采用系统默认的属性值创建线程。\\n3.  void \\\\*(\\\\*start_routine) (void \\\\*)：以函数指针的方式指明新建线程需要执行的函数，该函数的参数最多有 1 个（可以省略不写），形参和返回值的类型都必须为 void\\\\* 类型。void\\\\* 类型又称空指针类型，表明指针所指数据的类型是未知的。使用此类型指针时，我们通常需要先对其进行强制类型转换，然后才能正常访问指针指向的数据。\\n4.  void \\\\*arg：指定传递给 start_routine 函数的实参，当不需要传递任何数据时，将 arg 赋值为 NULL 即可。\\n\\n\\\\*\\\\*如果成功创建线程，pthread_create() 函数返回数字 0，反之返回非零值。各个非零值都对应着不同的宏，指明创建失败的原因，常见的宏有以下几种：\\n\\nEAGAIN：系统资源不足，无法提供创建线程所需的资源。\\n\\nEINVAL：传递给 pthread_create() 函数的 attr 参数无效。\\n\\nEPERM：传递给 pthread_create() 函数的 attr 参数中，某些属性的设置为非法操作，程序没有相关的设置权限。\\n\\n\\\\*\\\\*以上这些宏都声明在 \\\\<errno.h\\\\> 头文件中，如果程序中想使用这些宏，需提前引入此头文件。\\n\\n\\\\*\\\\*示例：\\n\\nvoid \\\\*receive(void \\\\*pth_arg) {}\\n\\npthread_t id;\\n\\npthread_create(&id,NULL,receive,(void\\\\*)cfd);\\n\\n# 二、创建和使用进程/线程时的一些问题：\\n\\n## 1、fork()和vfork()函数的区别：\\n\\n![](https://upload.haoxx.site/photo/d9b061df62171b02e7a445e1d176c593.png)\\n\\n为什么会有vfork，因为以前的fork 很傻， 它创建一个子进程时，将会创建一个新的地址\\n\\n空间，并且拷贝父进程的资源，而往往在子进程中会执行exec 调用，这样，前面的拷贝工\\n\\n作就是白费力气了，这种情况下，聪明的人就想出了vfork，它产生的子进程刚开始暂时与\\n\\n父进程共享地址空间（其实就是线程的概念了），因为这时候子进程在父进程的地址空间中\\n\\n运行，所以子进程不能进行写操作，并且在儿子 霸占着老子的房子时候，要委屈老子一\\n\\n下了，让他在外面歇着（阻塞），一旦儿子执行了exec 或者exit 后，相 于儿子买了自己的\\n\\n房子了，这时候就相于分家了。\\n\\n参考： <https://blog.csdn.net/jianchi88/article/details/6985326>\\n\\n在代码中获得当前进程pid的函数为：getpid()；\\n\\n在代码中获得当前进程父进程pid的函数为：getppid()。\\n\\n## 2、fork()功能简介：\\n\\n![](https://upload.haoxx.site/photo/d1f2e482b131c2aac315142934b97807.png)\\n\\n![](https://upload.haoxx.site/photo/dffc560d52616dd91c7a30860543c238.png)\\n\\n参考：https://blog.csdn.net/qq_38410730/article/details/81193118\\n\\n![](https://upload.haoxx.site/photo/a480238e9c3785af646f9d776e569797.png)\\n\\n![](https://upload.haoxx.site/photo/c2a7079ed0d2e0959a02775cfc93798f.png)\\n\\n这里需要注明一点：**父子进程的调度的顺序是由调度器决定的，与进程的创建顺序无关。**\\n\\n**\\\\*\\\\***还记得之前的图吗？子进程与父进程共享程序代码，而数据区、栈区、系统栈区相互独立。因此，父进程的代码实际上父、子进程要各执行一次。为了让父子进程执行不同的程序，有两种办法：1是在if(pid==0)中执行子程序特有的程序，2在子进程中调用execv()函数集。\\n\\n在实际应用中，通常调用execv()的都是子进程。人们之所以创建一个子进程，其目的就是执行一个与父进程代码不同的程序，而系统调用execv()就是子进程执行一个新程序的手段之一。子进程调用execv()之后，系统会立即为子进程加载可执行文件分配私有程序内存空间，从此子进程也成为一个真正的进程。\\n\\n如果说子进程是父进程的“儿子”，那么子进程在调用execv()之前，它所具有的单独用户堆栈和数据区也仅相当于它的私有“房间”；但因它还没有自己的“住房”，因此也只能寄住在“父亲”家，而不能“自立门户”，尽管它有自己的“户口”（进程控制块）。\\n\\n![](https://upload.haoxx.site/photo/c9dd37b5aeb33abe47b944c4fa8bed5f.png)\\n\\n![](https://upload.haoxx.site/photo/ebe07dbeff2c5d9943d4d094dca4ca93.png) \\n\\n![](https://upload.haoxx.site/photo/af808190d54947777f6c8ee2e8d91687.png)\\n\\n![](https://upload.haoxx.site/photo/36cf0a7153422dfaf17386b3796366c4.png)\\n\\n调用exec系列函数的前后，父子进程的关系变化如下图所示：\\n\\n![](https://upload.haoxx.site/photo/02a6d45da336592e5cb66280578c295e.png) \\n\\n![](https://upload.haoxx.site/photo/6d0a2a04a3119ad47edcabd7349d4673.png)\\n\\n为了避免子进程成为孤儿进程，父进程应该要等子进程结束并销毁子进程后才可以退出。因此，父进程中应设置系统调用wait()，子进程中应设置退出函数exit()。\\n\\n![](https://upload.haoxx.site/photo/f58553028c983dc7f5284ea0f6ff8f10.png)\\n\\n![](https://upload.haoxx.site/photo/5cb46546d42be10317ef6f30ce6d2fa3.png)\\n\\n![](https://upload.haoxx.site/photo/ef46427ce1d4b7268ae4baed43486364.png)\\n\\n![](https://upload.haoxx.site/photo/dcb7db7fed64b2b783a84f14c2324fc0.png)\\n\\n## 3、vfork()的进一步说明：\\n\\n![](https://upload.haoxx.site/photo/5529093d85e5635aa1effa437df22107.png)\\n\\n## 4、线程的基本使用：\\n\\n![](https://upload.haoxx.site/photo/5f24fbd285b131e20cf48c931def0d45.png)\\n\\n参考资料：https://blog.csdn.net/yi_chengyu/article/details/120412980\\n\\n![](https://upload.haoxx.site/photo/b329e9b72442e377d0ab3e954626d92a.png)\\n\\n## 5、线程与进程\\n\\n![](https://upload.haoxx.site/photo/eeec806437bfc7f6d52f615ef7078477.png)\\n\\n![](https://upload.haoxx.site/photo/6f23ed4e0dfc3ec691de15324db383a4.png)\\n\\n![](https://upload.haoxx.site/photo/ae2a762c612c3978c89eac5acbea13ad.png)\\n\\n## 6、fork与vfork\\n\\n![](https://upload.haoxx.site/photo/ae42db34e057eaba61295c7337e7c546.png)\\n\\n![](https://upload.haoxx.site/photo/5341a44ed914b07567b7dc18abdb8390.png)\\n\",\"articleCover\":\"https://upload.haoxx.site/article/b9f3f2f6ed8b951e6e047298abf80a23.jpg\",\"articleTitle\":\"进程与线程笔记\",\"articleType\":1,\"categoryName\":\"操作系统与计算机组成原理\",\"id\":106,\"isRecommend\":0,\"isTop\":0,\"status\":1,\"tagNameList\":[]}]','PUT','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',28,'2023-06-07 19:57:16');
INSERT INTO `t_operation_log` VALUES (1364,'文章模块','上传','/admin/article/upload','com.ican.controller.ArticleController.saveArticleImages','上传文章图片','image_19.jpg','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/article/17f10cd4cbe9e8cba44a22c4d0ee0381.jpg\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',14,'2023-06-07 19:57:25');
INSERT INTO `t_operation_log` VALUES (1365,'文章模块','修改','/admin/article/update','com.ican.controller.ArticleController.updateArticle','修改文章','[{\"articleContent\":\"---\\ntitle: 进程间通信学习内容\\ndate: 2023-4-12\\ntags:\\n - 进程间通信\\ncategories:\\n - 未分类\\n---\\n\\n![](https://upload.haoxx.site/photo/84e8bfe1bdfb66b1da75e06ca2c9fc33.png)\\n\\n![](https://upload.haoxx.site/photo/b7cc08bb88c6ef808f23b3202d5763eb.png)\\n\\n![](https://upload.haoxx.site/photo/20ec88f94bff808a8bcdbbd7e00c08cd.png)\\n\\n## 一、定义介绍\\n\\n1.  **管道：**管道是Linux 中进程间通信的一种方式，它把一个程序的输出直接连接到另一个程序的输入。Linux 的管道主要包括两种：无名管道和命名管道。\\n    1.  **管道（无名管道）**\\n\\n        **（1）无名管道**\\n\\n无名管道有几个重要的限制：\\n\\n无名管道是半双工的，数据只能在一个方向上流动，A进程传给B进程，不能反向传递管道只能用于父子进程或兄弟进程之间的通信，即具有亲缘关系的进程。\\n\\n无名管道的特点：\\n\\n1）无名管道是半双工的\\n\\n2）无名管道没有名字：只能用于父子进程或者兄弟进程之间（具有亲缘关系的进程）。\\n\\n3）无名管道不是普通的文件，并且只存在与内存中。\\n\\n4）无名管道的缓冲区是有限的，该缓冲区的大小为4Kbyte。\\n\\n1.  **命名管道：**命名管道是一种特殊类型的文件，它在系统中以文件形式存在。这样克服了无名管道的弊端，他可以允许没有亲缘关系的进程间通信。\\n\\n命名管道特点：\\n\\n1）FIFO在文件系统中作为一个特殊的文件而存在。\\n\\n2）虽然FIFO文件存在于文件系统中，但FIFO中的内容却存放在内存中，在Linux中，该缓冲区的大小为4Kbyte。\\n\\n3）FIFO有名字，不同的进程可以通过该命名管道进行通信\\n\\n4）FIFO所传送的数据是无格式的。\\n\\n5）从FIFO读数据是一次性操作，数据一旦被读，它就从FIFO中被抛弃，释放空间以便写更多的数据。\\n\\n6）当共享FIFO的进程执行完所有的I/O操作以后，FIFO将继续保存在文件系统中以便以后使用。\\n\\n1.  **信号：**信号是软件层次上对中断机制的一种模拟，是一种异步通信方式，进程不必通过任何操作来等待信号的到达。信号可以在用户空间进程和内核之间直接交互，内核可以利用信号来通知用户空间的进程发生了哪些系统事件。\\n\\n信号的来源有两种：硬件来源（如键盘ctrl+c），软件来源（kill, raise, alarm和setitimer以及sigqueue函数，当然还包括一些非法操作）；\\n\\n操作系统对信号的处理方式：1）忽略；有两个信号是不能忽略的：SIGKLL和SIGSTOP；2）捕捉，执行对应的信号处理程序；3）缺省，执行默认操作。\\n\\n1.  **消息队列：**消息队列是内核地址空间中的内部链表，具有特定的格式,存放在内存中并由消息队列标识符标识，并且允许一个或多个进程向它写入与读取消息。消息队列通过Linux内核在各个进程直接传递内容，消息顺序地发送到消息队列中，并以几种不同的方式从队列中获得，每个消息队列可以用IPC标识符唯一地进行识别。\\n\\n消息队列克服了信号承载信息量少的问题，管道只能承载无格式字符流。\\n\\n1.  **信号量：**信号量实质上就是一个标识可用资源数量的计数器，它的值总是非负整数。它们常常被用作一个锁机制，在某个进程正在对特定的资源进行操作时，信号量可以防止另一个进程去访问它。\\n\\n信号量可细分为：二值信号量和计数信号量\\n\\n信号量是一种特殊的变量，它只取正整数值并且只允许对这个值进行两种操作：等待（wait）和信号（signal）。（P、V操作，P用于申请资源，V用于释放资源）。\\n\\n1.  **共享内存：**共享内存是在多个进程之间共享内存区域的一种进程间的通信方式，使得多个进程可以直接读写同一块内存空间，它是针对其他通信机制运行效率较低而设计的。共享内存由IPC为进程创建的一个特殊地址范围，为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间。进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率。\\n\\n需要注意的是：共享内存并未提供同步机制，在一个进程结束对共享内存的写操作之前，并无自动机制可以阻止另二个进程开始对它进行读取。所以，我们通常需要用其他的机制来同步对共享内存的访问。\\n\\n1.  **内存映射：**内存映射，是将一个文件映射到一块内存的方法。内存映射文件与虚拟内存有些类似，通过内存映射文件可以保留一个地址的区域，同时将物理存储器提交给此区域，内存文件映射的物理存储器来自一个已经存在于磁盘上的文件，而且在对该文件进行操作之前必须首先对文件进行映射。使用内存映射文件处理存储于磁盘上的文件时，将不必再对文件执行I/O操作。每一个使用该机制的进程通过把同一个共享的文件映射到自己的进程地址空间来实现多个进程间的通信（这里类似于共享内存，只要有一个进程对这块映射文件的内存进行操作，其他进程也能够马上看到）。\\n2.  **套接字socket：**套接字是更为基础的进程间通信机制，与其他方式不同的是，套接字可用于不同机器之间的进程间通信。在Linux中，套接字是基于网络的，它也有自己的家族名字--AF_INET。\\n\\n## 二、详细函数接口说明\\n\\n参考资料：知识点讲解<https://blog.csdn.net/a987073381/article/details/52006729>\\n\\n代码示例：<https://blog.csdn.net/zqixiao_09/article/details/50485047> （上）\\n\\n（下，缺个消息队列）[https://blog.csdn.net/zqixiao_09/article/details/50498874?utm_medium=distribute.pc_relevant.none-task-blog-2\\\\~default\\\\~baidujs_title\\\\~default-0.no_search_link&spm=1001.2101.3001.4242.1](https://blog.csdn.net/zqixiao_09/article/details/50498874?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-0.no_search_link&spm=1001.2101.3001.4242.1)\\n\\n消息队列：<https://blog.csdn.net/qq_27664167/article/details/81712887>\\n\\n1、管道\\n\\n1.1无名管道\\n\\n![](https://upload.haoxx.site/photo/05438e1a57a775323713c45100ac9b5f.png)\\n\\n![](https://upload.haoxx.site/photo/630cb06c3086ffba6fb203a5a3ae317b.png)\\n\\n通过使用底层的read和write调用来访问数据。向file_descriptor[1]写数据，从file_descriptor[0]中读数据。写入与读取的顺序原则是先进先出。\\n\\n1.2 命名管道\\n\\n命名管道是一种特殊类型的文件，它在系统中以文件形式存在。这样克服了无名管道的弊端，他可以允许没有亲缘关系的进程间通信。\\n\\n![](https://upload.haoxx.site/photo/47fae86680ce79a7ed24d7237c1d16dc.png)\\n\\n编程示例：\\n\\n\\\\#include \\\\<sys/types.h\\\\>\\n\\n\\\\#include \\\\<sys/stat.h\\\\>\\n\\nint mkfifo(const char \\\\*filename,mode_t mode); //建立一个名字为filename的命名管道，参数mode为该文件的权限（mode%\\\\~umask），若成功则返回0，否则返回-1，错误原因存于errno中。\\n\\neg.mkfifo( \\\"/tmp/cmd_pipe\\\", S_IFIFO \\\\| 0666 );\\n\\n具体操作方法只要创建了一个命名管道然后就可以使用open、read、write等系统调用来操作。创建可以手工创建或者程序中创建。\\n\\nint mknod(const char \\\\*path, mode_t mode, dev_t dev); //第一个参数表示你要创建的文件的名称，第二个参数表示文件类型，第三个参数表示该文件对应的设备文件的设备号。只有当文件类型为 S_IFCHR 或 S_IFBLK 的时候该文件才有设备号，创建普通文件时传入0即可。\\n\\neg.mknod(FIFO_FILE,S_IFIFO\\\\|0666,0);\\n\\n![](https://upload.haoxx.site/photo/c0bdec69bc1cc87001a1903296feba86.png)\\n\\n2、信号\\n\\n信号机制是unix系统中最为古老的进程之间的通信机制，用于一个或几个进程之间传递异步信号。信号可以有各种异步事件产生，比如键盘中断等。shell也可以使用信号将作业控制命令传递给它的子进程。\\n\\n在此列出几个简单使用方法定义：\\n\\n![](https://upload.haoxx.site/photo/a55a1d964faddbc271c37e56f0588cde.png)\\n\\n3、消息队列\\n\\nMsgget() msgsnd() msgrcv() msgctl()\\n\\n4、信号量（Semaphore）\\n\\nSemget() semop() sembuf\\n\\n5、共享内存（Share Memory）\\n\\nShmget() shmat() shmdt()\\n\\n6、内存映射（Memory Map）\\n\\n\\\\*mmap() munmap() msync()\\n\\n7、套接字\\n\\n套接字的创建和使用与管道是有区别的，套接字 明确地将客户端与服务器 区分开来，可以实现多个客户端连到同一服务器。\\n\\n服务器套接字连接过程描述：\\n\\n首先，服务器应用程序用socket创建一个套接字，它是系统分配服务器进程的类似文件描述符的资源。 接着，服务器调用bind给套接字命名。这个名字是一个标示符，它允许linux将进入的针对特定端口的连接转到正确的服务器进程。 然后，系统调用listen函数开始接听，等待客户端连接。listen创建一个队列并将其用于存放来自客户端的进入连接。 当客户端调用connect请求连接时，服务器调用accept接受客户端连接，accept此时会创建一个新套接字，用于与这个客户端进行通信。\\n\\n客户端套接字连接过程描述：\\n\\n客户端首先调用socket创建一个未命名套接字，让后将服务器的命名套接字作为地址来调用connect与服务器建立连接。\\n\\n只要双方连接建立成功，我们就可以像操作底层文件一样来操作socket套接字实现通信。\\n\\n1.  管道\\n\\n管道实际是用于进程间通信的一段共享内存，创建管道的进程称为管道服务器，连接到一个管道的进程为管道客户机。一个进程在向管道写入数据后，另一进程就可以从管道的另一端将其读取出来。\\n\\n管道的特点：\\n\\n1)、管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道；\\n\\n2)、 只能用于父子进程或者兄弟进程之间（ 具有亲缘关系的进程）。 比如fork或exec创建的新进程， 在使用exec创建新进程时，需要将管道的文件描述符作为参数传递给exec创建的新进程。 当父进程与使用fork创建的子进程直接通信时，发送数据的进程关闭读端，接受数据的进程关闭写端。\\n\\n3)、单独构成一种独立的文件系统：管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在与内存中。\\n\\n4)、数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。\\n\\n通过使用底层的read和write调用来访问数据。 向 file_descriptor[1]写 数据，从 file_descriptor[0]中 读数据。写入与读取的顺序原则是 先进先出。\\n\\n![](https://upload.haoxx.site/photo/3a10aa097584f54f8b871ad0fc8668e6.png)\\n\\n1.  命名管道mkfifo\\n2.  信号signal\\n3.  消息队列 （本质是 链表）\\n4.  信号量\\n5.  共享内存：（需要信号量辅助读写的先后顺序）效率最高。\\n\\n采用共享内存通信的一个显而易见的好处就是**效率高**，因为进程可以直接读写内存，而**不需要任何数据的拷贝**。对于像管道和消息队列等通信方式，则需要在内核和用户控件进行四次数据的拷贝，而**共享内存只拷贝两次数据：一次从输入文件到共享区，另一次从共享内存区到输出文件**。实际上，进程之间在共享内存时，并不总是读写少量数据后就解除映射，有新的通信时，再重新建立共享内存区域。而是保持共享区域，知道通信完毕为止，这样，数据内同一直保存在共享内存中，并没有写回文件。共享内存中的内容往往是在接触映射时才写回文件的。因此，采用共享内存的通信方式效率是最高的。\\n\\n共享内存最大不足之处在意，由于多个进程对同一块内存区域具有访问的权限，**各个进程之间的同步问题显得尤为重要**。必须控制同一时刻只有一个进程对共享内存区域写入数据，否则会造成数据的混乱。同步控制问题可以由信号量来解决；\\n\",\"articleCover\":\"https://upload.haoxx.site/article/17f10cd4cbe9e8cba44a22c4d0ee0381.jpg\",\"articleTitle\":\"进程和线程间通信学习内容\",\"articleType\":1,\"categoryName\":\"操作系统与计算机组成原理\",\"id\":105,\"isRecommend\":0,\"isTop\":0,\"status\":1,\"tagNameList\":[]}]','PUT','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',20,'2023-06-07 19:57:26');
INSERT INTO `t_operation_log` VALUES (1366,'文章模块','上传','/admin/article/upload','com.ican.controller.ArticleController.saveArticleImages','上传文章图片','image_26.jpg','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/article/9a42c06ea0f36c4eacc2fb9bfc59781d.jpg\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',4,'2023-06-07 19:57:36');
INSERT INTO `t_operation_log` VALUES (1367,'文章模块','修改','/admin/article/update','com.ican.controller.ArticleController.updateArticle','修改文章','[{\"articleContent\":\"---\\ntitle: 进程与线程笔记\\ndate: 2023-4-12\\ntags:\\n - 进程与线程\\ncategories:\\n - 未分类\\n---\\n# 一、创建进程/线程：\\n\\n1、进程创建pid_t fork(void); 说明：fork - create a child process\\n\\n包含头：\\\\#include \\\\<unistd.h\\\\>\\n\\n返回值：创建成功，则在父进程中返回子进程的PID，在子进程中返回0。创建失败，在父进程中返回-1。\\n\\n2、进程创建pid_t vfork(void); 说明：vfork - create a child process and block parent\\n\\n包含头：\\\\#include \\\\<sys/types.h\\\\>\\n\\n\\\\#include \\\\<unistd.h\\\\>\\n\\n3、线程创建int pthread_create(pthread_t \\\\*thread, const pthread_attr_t \\\\*attr,\\n\\nvoid \\\\*(\\\\*start_routine) (void \\\\*), void \\\\*arg);\\n\\n包含头：\\\\#include \\\\<pthread.h\\\\>\\n\\n注意; Compile and link with -pthread.\\n\\n返回值：创建成功返回0，否则返回错误值。\\n\\n参数：\\n\\n1.  pthread_t \\\\*thread：传递一个 pthread_t 类型的指针变量，也可以直接传递某个 pthread_t 类型变量的地址。pthread_t 是一种用于表示线程的数据类型，每一个 pthread_t 类型的变量都可以表示一个线程。\\n2.  const pthread_attr_t \\\\*attr：用于手动设置新建线程的属性，例如线程的调用策略、线程所能使用的栈内存的大小等。大部分场景中，我们都不需要手动修改线程的属性，将 attr 参数赋值为 NULL，pthread_create() 函数会采用系统默认的属性值创建线程。\\n3.  void \\\\*(\\\\*start_routine) (void \\\\*)：以函数指针的方式指明新建线程需要执行的函数，该函数的参数最多有 1 个（可以省略不写），形参和返回值的类型都必须为 void\\\\* 类型。void\\\\* 类型又称空指针类型，表明指针所指数据的类型是未知的。使用此类型指针时，我们通常需要先对其进行强制类型转换，然后才能正常访问指针指向的数据。\\n4.  void \\\\*arg：指定传递给 start_routine 函数的实参，当不需要传递任何数据时，将 arg 赋值为 NULL 即可。\\n\\n\\\\*\\\\*如果成功创建线程，pthread_create() 函数返回数字 0，反之返回非零值。各个非零值都对应着不同的宏，指明创建失败的原因，常见的宏有以下几种：\\n\\nEAGAIN：系统资源不足，无法提供创建线程所需的资源。\\n\\nEINVAL：传递给 pthread_create() 函数的 attr 参数无效。\\n\\nEPERM：传递给 pthread_create() 函数的 attr 参数中，某些属性的设置为非法操作，程序没有相关的设置权限。\\n\\n\\\\*\\\\*以上这些宏都声明在 \\\\<errno.h\\\\> 头文件中，如果程序中想使用这些宏，需提前引入此头文件。\\n\\n\\\\*\\\\*示例：\\n\\nvoid \\\\*receive(void \\\\*pth_arg) {}\\n\\npthread_t id;\\n\\npthread_create(&id,NULL,receive,(void\\\\*)cfd);\\n\\n# 二、创建和使用进程/线程时的一些问题：\\n\\n## 1、fork()和vfork()函数的区别：\\n\\n![](https://upload.haoxx.site/photo/d9b061df62171b02e7a445e1d176c593.png)\\n\\n为什么会有vfork，因为以前的fork 很傻， 它创建一个子进程时，将会创建一个新的地址\\n\\n空间，并且拷贝父进程的资源，而往往在子进程中会执行exec 调用，这样，前面的拷贝工\\n\\n作就是白费力气了，这种情况下，聪明的人就想出了vfork，它产生的子进程刚开始暂时与\\n\\n父进程共享地址空间（其实就是线程的概念了），因为这时候子进程在父进程的地址空间中\\n\\n运行，所以子进程不能进行写操作，并且在儿子 霸占着老子的房子时候，要委屈老子一\\n\\n下了，让他在外面歇着（阻塞），一旦儿子执行了exec 或者exit 后，相 于儿子买了自己的\\n\\n房子了，这时候就相于分家了。\\n\\n参考： <https://blog.csdn.net/jianchi88/article/details/6985326>\\n\\n在代码中获得当前进程pid的函数为：getpid()；\\n\\n在代码中获得当前进程父进程pid的函数为：getppid()。\\n\\n## 2、fork()功能简介：\\n\\n![](https://upload.haoxx.site/photo/d1f2e482b131c2aac315142934b97807.png)\\n\\n![](https://upload.haoxx.site/photo/dffc560d52616dd91c7a30860543c238.png)\\n\\n参考：https://blog.csdn.net/qq_38410730/article/details/81193118\\n\\n![](https://upload.haoxx.site/photo/a480238e9c3785af646f9d776e569797.png)\\n\\n![](https://upload.haoxx.site/photo/c2a7079ed0d2e0959a02775cfc93798f.png)\\n\\n这里需要注明一点：**父子进程的调度的顺序是由调度器决定的，与进程的创建顺序无关。**\\n\\n**\\\\*\\\\***还记得之前的图吗？子进程与父进程共享程序代码，而数据区、栈区、系统栈区相互独立。因此，父进程的代码实际上父、子进程要各执行一次。为了让父子进程执行不同的程序，有两种办法：1是在if(pid==0)中执行子程序特有的程序，2在子进程中调用execv()函数集。\\n\\n在实际应用中，通常调用execv()的都是子进程。人们之所以创建一个子进程，其目的就是执行一个与父进程代码不同的程序，而系统调用execv()就是子进程执行一个新程序的手段之一。子进程调用execv()之后，系统会立即为子进程加载可执行文件分配私有程序内存空间，从此子进程也成为一个真正的进程。\\n\\n如果说子进程是父进程的“儿子”，那么子进程在调用execv()之前，它所具有的单独用户堆栈和数据区也仅相当于它的私有“房间”；但因它还没有自己的“住房”，因此也只能寄住在“父亲”家，而不能“自立门户”，尽管它有自己的“户口”（进程控制块）。\\n\\n![](https://upload.haoxx.site/photo/c9dd37b5aeb33abe47b944c4fa8bed5f.png)\\n\\n![](https://upload.haoxx.site/photo/ebe07dbeff2c5d9943d4d094dca4ca93.png) \\n\\n![](https://upload.haoxx.site/photo/af808190d54947777f6c8ee2e8d91687.png)\\n\\n![](https://upload.haoxx.site/photo/36cf0a7153422dfaf17386b3796366c4.png)\\n\\n调用exec系列函数的前后，父子进程的关系变化如下图所示：\\n\\n![](https://upload.haoxx.site/photo/02a6d45da336592e5cb66280578c295e.png) \\n\\n![](https://upload.haoxx.site/photo/6d0a2a04a3119ad47edcabd7349d4673.png)\\n\\n为了避免子进程成为孤儿进程，父进程应该要等子进程结束并销毁子进程后才可以退出。因此，父进程中应设置系统调用wait()，子进程中应设置退出函数exit()。\\n\\n![](https://upload.haoxx.site/photo/f58553028c983dc7f5284ea0f6ff8f10.png)\\n\\n![](https://upload.haoxx.site/photo/5cb46546d42be10317ef6f30ce6d2fa3.png)\\n\\n![](https://upload.haoxx.site/photo/ef46427ce1d4b7268ae4baed43486364.png)\\n\\n![](https://upload.haoxx.site/photo/dcb7db7fed64b2b783a84f14c2324fc0.png)\\n\\n## 3、vfork()的进一步说明：\\n\\n![](https://upload.haoxx.site/photo/5529093d85e5635aa1effa437df22107.png)\\n\\n## 4、线程的基本使用：\\n\\n![](https://upload.haoxx.site/photo/5f24fbd285b131e20cf48c931def0d45.png)\\n\\n参考资料：https://blog.csdn.net/yi_chengyu/article/details/120412980\\n\\n![](https://upload.haoxx.site/photo/b329e9b72442e377d0ab3e954626d92a.png)\\n\\n## 5、线程与进程\\n\\n![](https://upload.haoxx.site/photo/eeec806437bfc7f6d52f615ef7078477.png)\\n\\n![](https://upload.haoxx.site/photo/6f23ed4e0dfc3ec691de15324db383a4.png)\\n\\n![](https://upload.haoxx.site/photo/ae2a762c612c3978c89eac5acbea13ad.png)\\n\\n## 6、fork与vfork\\n\\n![](https://upload.haoxx.site/photo/ae42db34e057eaba61295c7337e7c546.png)\\n\\n![](https://upload.haoxx.site/photo/5341a44ed914b07567b7dc18abdb8390.png)\\n\",\"articleCover\":\"https://upload.haoxx.site/article/9a42c06ea0f36c4eacc2fb9bfc59781d.jpg\",\"articleTitle\":\"进程与线程笔记\",\"articleType\":1,\"categoryName\":\"操作系统与计算机组成原理\",\"id\":103,\"isRecommend\":0,\"isTop\":0,\"status\":1,\"tagNameList\":[]}]','PUT','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',20,'2023-06-07 19:57:38');
INSERT INTO `t_operation_log` VALUES (1368,'文章模块','上传','/admin/article/upload','com.ican.controller.ArticleController.saveArticleImages','上传文章图片','image_57.jpg','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/article/06d11f52c1fcd3abcda231e09209d1cd.jpg\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',20,'2023-06-07 19:57:48');
INSERT INTO `t_operation_log` VALUES (1369,'文章模块','修改','/admin/article/update','com.ican.controller.ArticleController.updateArticle','修改文章','[{\"articleContent\":\"---\\ntitle: C++ STL常用容器知识点说明\\ndate: 2023-4-12\\ntags:\\n - C++ STL\\ncategories:\\n - 未分类\\n\\n---\\n\\n# 0、总体概述\\n\\nSTL就是标准模板库，从广义上分为容器、算法和迭代器。当然，具体细分的话，STL大体分为六大组件，分别是:容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器。\\n\\n1.  容器：各种数据结构，如vector、list、deque、set、map等,用来存放数据。\\n2.  算法：各种常用的算法，如sort、find、copy、for_each等\\n3.  迭代器：扮演了容器与算法之间的胶合剂。\\n4.  仿函数：行为类似函数，可作为算法的某种策略。\\n5.  适配器：一种用来修饰容器或者仿函数或迭代器接口的东西。\\n6.  空间配置器：负责空间的配置与管理。\\n\\n容器：就是将运用最广泛的一些数据结构实现出来，常用的数据结构：数组, 链表,树, 栈, 队列, 集合, 映射表等。这些容器分为序列式容器（值有顺序）和关联式容器（值之间有关联）。\\n\\n算法：有限的步骤，解决逻辑或数学上的问题，这一门学科我们叫做算法(Algorithms)。分为质变算法和非质变算法。质变算法：是指运算过程中会更改区间内的元素的内容。例如拷贝，替换，删除等等。非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等。\\n\\n# 0.1、迭代器\\n\\n迭代器：容器和算法的粘合剂。提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。迭代器使用非常类似于指针，初学阶段我们可以先理解迭代器为指针。\\n\\n![](media/589080628386800bbe32bb04420e0977.png)\\n\\n常用的容器中迭代器种类为双向迭代器，和随机访问迭代器。vector的begin和end是随机访问迭代器。\\n\\n![](media/105c3ca0ae4de6b12b6147b916a61af1.png)\\n\\n# 一、STL容器\\n\\n这是STL常用容器知识点总结。（1）是构造函数；（2）是赋值；（3）是（string）查找、大小/容量与交换；（4）插入与删除；（5）数据存取；第六部分，其它补充内容。容器最常用的是vector和list\\n\\n## 1、构造函数\\n\\n|        | （1）构造函数                                                |\\n| ------ | ------------------------------------------------------------ |\\n| string | 1、无参构造string(); 2、拷贝构造string(const string& str); 3、字符串构造string(const char\\\\* s)； 4、n个字符构造string(int n, char c); |\\n| vector | 1、无参构造vector\\\\<T\\\\> v; 2、拷贝构造vector(const vector \\\\&vec); 3、（迭代器）区间拷贝构造vector(v.begin(), v.end()); 4、n个元素构造vector(n, elem); |\\n| deque  | 1、无参构造deque\\\\<T\\\\> deq; 2、拷贝构造deque(const deque \\\\&deq); 3、（迭代器）区间拷贝构造deque(beg, end); 4、n个元素构造deque(n, elem); |\\n| stack  | 1、无参构造stack\\\\<T\\\\> stk; 2、拷贝构造 stack(const stack \\\\&stk); |\\n| queue  | 1、无参构造 queue\\\\<T\\\\> que; 2、拷贝构造 queue(const queue \\\\&que); |\\n| List   | 1、无参构造list\\\\<T\\\\> lst; 2、拷贝构造 list(const list \\\\&lst); 3、（迭代器）区间拷贝构造 list(beg,end); 4、n个元素构造list(n, elem); |\\n| set    | 1、无参构造 set\\\\<T\\\\> st; 2、拷贝构造 set(const set \\\\&st);    |\\n| map    | 1、无参构造 map\\\\<T1,T2\\\\> mp; 2、拷贝构造 map(const map \\\\&mp); |\\n\\n## 2、赋值\\n\\n|        | （2）赋值                                                    |\\n| ------ | ------------------------------------------------------------ |\\n| string | - string& operator=(const char\\\\* s); //char\\\\*类型字符串 赋值给当前的字符串 - string& operator=(const string \\\\&s); //把字符串s赋给当前的字符串 - string& operator=(char c); //字符赋值给当前的字符串 - string& assign(const char \\\\*s); //把字符串s赋给当前的字符串 - string& assign(const char \\\\*s, int n); //把字符串s的前n个字符赋给当前的字符串 - string& assign(const string \\\\&s); //把字符串s赋给当前字符串 - string& assign(int n, char c); //用n个字符c赋给当前字符串 |\\n| vector | - vector& operator=(const vector \\\\&vec);//重载等号操作符 - assign(beg, end); //将[beg, end)区间中的数据拷贝赋值给本身。 - assign(n, elem); //将n个elem拷贝赋值给本身。 |\\n| deque  | - deque& operator=(const deque \\\\&deq); //重载等号操作符 - assign(beg, end); //将[beg, end)区间中的数据拷贝赋值给本身。 - assign(n, elem); //将n个elem拷贝赋值给本身。 |\\n| stack  | stack& operator=(const stack \\\\&stk); //重载等号操作符        |\\n| queue  | queue& operator=(const queue \\\\&que); //重载等号操作符        |\\n| List   | - assign(beg, end); //将[beg, end)区间中的数据拷贝赋值给本身。 - assign(n, elem); //将n个elem拷贝赋值给本身。 - list& operator=(const list \\\\&lst); //重载等号操作符 |\\n| set    | set& operator=(const set \\\\&st); //重载等号操作符             |\\n| map    | map& operator=(const map \\\\&mp); //重载等号操作符             |\\n\\n## 3、(string)查找、大小/容量与交换\\n\\n|        | **（3）（string）查找、容量/大小与交换**                     |\\n| ------ | ------------------------------------------------------------ |\\n| string | --查找 - int find(const string& str, int pos = 0) const; //查找str第一次出现位置,从pos开始查找 - int find(const char\\\\* s, int pos = 0) const; //查找s第一次出现位置,从pos开始查找 - int find(const char\\\\* s, int pos, int n) const;//从pos位置查找s的前n个字符第一次位置 - int find(const char c, int pos = 0) const; //查找字符c第一次出现位置 -int rfind(const string& str, int pos = npos) const;//查找str最后一次位置,从pos开始查找 -int rfind(const char\\\\* s, int pos = npos) const;//查找s最后一次出现位置,从pos开始查找 - int rfind(const char\\\\* s, int pos, int n) const; //从pos查找s的前n个字符最后一次位置 - int rfind(const char c, int pos = 0) const; //查找字符c最后一次出现位置 --容量/大小 无 --交换 - string& replace(int pos, int n, const string& str); //替换从pos开始n个字符为字符串str - string& replace(int pos, int n,const char\\\\* s); //替换从pos开始的n个字符为字符串s |\\n| vector | --查找 无 --容量/大小 - empty(); //判断容器是否为空 - capacity(); //容器的容量 - size(); //返回容器中元素的个数 - resize(int num); //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。//如果容器变短，则末尾超出容器长度的元素被删除。 -resize(int num, elem);//重新指定容器的长度为num，若容器变长，则以elem值填充新位置。//如果容器变短，则末尾超出容器长度的元素被删除 reserve(int len);//容器预留len个元素长度，预留位置不初始化，元素不可访问。自定义容器的容量 --交换 swap(vec); // 将vec与本身的元素互换 |\\n| deque  | --查找 无 --容量/大小 - deque.empty(); //判断容器是否为空 - deque.size(); //返回容器中元素的个数 - deque.resize(num); //重新指定容器的长度为num,若容器变长，则以默认值填充新位置。//如果容器变短，则末尾超出容器长度的元素被删除。 - deque.resize(num, elem); //重新指定容器的长度为num,若容器变长，则以elem值填充新位置。//如果容器变短，则末尾超出容器长度的元素被删除。 --交换 无 |\\n| stack  | --大小 - empty(); //判断堆栈是否为空 - size(); //返回栈的大小 |\\n| queue  | --大小 - empty(); //判断堆栈是否为空 - size(); //返回栈的大小 |\\n| List   | --大小 - size();//返回容器中元素的个数 - empty();//判断容器是否为空 - resize(num); //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。//如果容器变短，则末尾超出容器长度的元素被删除。 -resize(num, elem); //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。//如果容器变短，则末尾超出容器长度的元素被删除。 --交换 - swap(lst); //将lst与本身的元素互换。 |\\n| set    | --大小 - size(); //返回容器中元素的数目 - empty(); //判断容器是否为空 --交换 - swap(st); //交换两个集合容器 |\\n| map    | --大小 - size(); //返回容器中元素的数目 - empty(); //判断容器是否为空 --交换 - swap(st); //交换两个集合容器 |\\n\\n## 4、插入/删除\\n\\n|        | **（4）插入/删除**                                           |\\n| ------ | ------------------------------------------------------------ |\\n| string | - string& insert(int pos, const char\\\\* s); //插入字符串 - string& insert(int pos, const string& str); //插入字符串 - string& insert(int pos, int n, char c); //在指定位置插入n个字符c - string& erase(int pos, int n = npos); //删除从Pos开始的n个字符 |\\n| vector | - push_back(ele); //尾部插入元素ele - pop_back(); //删除最后一个元素 - insert(const_iterator pos, ele); //迭代器指向位置pos插入元素ele - insert(const_iterator pos, int count,ele);//迭代器指向位置pos插入count个元素ele - erase(const_iterator pos); //删除迭代器指向的元素 - erase(const_iterator start, const_iterator end);//删除迭代器从start到end之间的元素 - clear(); //删除容器中所有元素 |\\n| deque  | 两端插入操作： - push_back(elem); //在容器尾部添加一个数据 - push_front(elem); //在容器头部插入一个数据 - pop_back(); //删除容器最后一个数据 - pop_front(); //删除容器第一个数据 指定位置操作： - insert(pos,elem); //在pos位置插入一个elem元素的拷贝，返回新数据的位置。 - insert(pos,n,elem); //在pos位置插入n个elem数据，无返回值。 - insert(pos,beg,end); //在pos位置插入[beg,end)区间的数据，无返回值。 - clear(); //清空容器的所有数据 - erase(beg,end); //删除[beg,end)区间的数据，返回下一个数据的位置。 - erase(pos); //删除pos位置的数据，返回下一个数据的位置。 |\\n| stack  | 无                                                           |\\n| queue  | 无                                                           |\\n| List   | - push_back(elem);//在容器尾部加入一个元素 - pop_back();//删除容器中最后一个元素 - push_front(elem);//在容器开头插入一个元素 - pop_front();//从容器开头移除第一个元素 - insert(pos,elem);//在pos位置插elem元素的拷贝，返回新数据的位置。 - insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值。 - insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值。 - clear();//移除容器的所有数据 - erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置。 - erase(pos);//删除pos位置的数据，返回下一个数据的位置。 - remove(elem);//删除容器中所有与elem值匹配的元素。 |\\n| set    | - insert(elem); //在容器中插入元素。 - clear(); //清除所有元素 - erase(pos); //删除pos迭代器所指的元素，返回下一个元素的迭代器。 - erase(beg, end); //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。 - erase(elem); //删除容器中值为elem的元素。 |\\n| map    | - insert(elem); //在容器中插入元素。 - clear(); //清除所有元素 - erase(pos); //删除pos迭代器所指的元素，返回下一个元素的迭代器。 - erase(beg, end); //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。 - erase(key); //删除容器中值为key的元素。 |\\n\\n## 5、数据存取\\n\\n|        | **（5）数据存取**                                            |\\n| ------ | ------------------------------------------------------------ |\\n| string | - char& operator[](int n); //通过[]方式取字符 - char& at(int n); //通过at方法获取字符 |\\n| vector | - at(int idx); //返回索引idx所指的数据 - operator[]; //返回索引idx所指的数据 - front(); //返回容器中第一个数据元素 - back(); //返回容器中最后一个数据元素 |\\n| deque  | - at(int idx); //返回索引idx所指的数据 - operator[]; //返回索引idx所指的数据 - front(); //返回容器中第一个数据元素 - back(); //返回容器中最后一个数据元素 |\\n| stack  | - push(elem); //向栈顶添加元素 - pop(); //从栈顶移除第一个元素 - top(); //返回栈顶元素 |\\n| queue  | - push(elem); //往队尾添加元素 - pop(); //从队头移除第一个元素 - back(); //返回最后一个元素 - front(); //返回第一个元素 |\\n| List   | - front(); //返回第一个元素。 - back(); //返回最后一个元素。 |\\n| set    | 无                                                           |\\n| map    | 无                                                           |\\n\\n## 6、第六部分：补充内容\\n\\n注意：栈stack只有栈顶可以访问，所以不支持遍历行为；队列只有队头队尾才能被外界访问，因此队列也不支持遍历行为；\\n\\nvector很像数组，常称为单端数组，他和数组的最大区别是数组等长，而vector可以动态扩展长度。deque是双端数组，可以头/尾插入或删除，deque可以动态扩展长度。在头插入上，vector效率低，deque头插入效率高；另一方面，vector访问元素的速度要比deque快，这与vector/deque内部的实现有关。\\n\\nString、vector和deque的迭代器支持随机访问；stack/queue不提供迭代器，不支持随机访问；list容器的迭代器是双向迭代器，不支持随机访问\\n\\n注：随机访问迭代器 ：读写操作，可以以跳跃的方式访问任意数据，功能最强的迭代器\\n\\n**[string容器]**\\n\\n►string字符串的拼接\\n\\n\\\\- string& operator+=(const char\\\\* str); //重载+=操作符\\n\\n\\\\- string& operator+=(const char c); //重载+=操作符\\n\\n\\\\- string& operator+=(const string& str); //重载+=操作符\\n\\n\\\\- string& append(const char \\\\*s); //把字符串s连接到当前字符串结尾\\n\\n\\\\- string& append(const char \\\\*s, int n); //把字符串s的前n个字符连接到当前字符串结尾\\n\\n\\\\- string& append(const string \\\\&s); //同operator+=(const string& str)\\n\\n\\\\- string& append(const string \\\\&s, int pos, int n);//字符串s中从pos开始的n个字符连接到字符串结尾\\n\\n►string字符串的比较，按照字符的ASCII码值进行比较，相等返回0，大于返回1，小于返回-1\\n\\n\\\\- int compare(const string \\\\&s) const; //与字符串s比较\\n\\n\\\\- int compare(const char \\\\*s) const; //与字符串s比较\\n\\n►string字符串的子串\\n\\nstring substr(int pos = 0, int n = npos) const; //返回由pos开始的n个字符组成的字符串\\n\\n**[vector容器]**\\n\\n无\\n\\n**[deque容器]**\\n\\n**►deque排序**\\n\\nsort(iterator beg, iterator end) //对beg和end区间内元素进行排序\\n\\n[stack容器]\\n\\n无\\n\\n**[queue容器]**\\n\\n无\\n\\n**[list容器]**\\n\\n►list的翻转和排序\\n\\n\\\\- reverse(); //反转链表\\n\\n\\\\- sort(); //链表排序\\n\\n**[set容器]**\\n\\n►set的查找和统计\\n\\n\\\\- find(key); //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();\\n\\n\\\\- count(key); //统计key的元素个数\\n\\n►set的排序（默认为从小到大，可以使用仿函数来更改排序规则）\\n\\nclass MyCompare\\n\\n{\\n\\npublic:\\n\\nbool operator()(int v1, int v2) {\\n\\nreturn v1 \\\\> v2;\\n\\n}\\n\\n};\\n\\nset\\\\<int,MyCompare\\\\> s2; //自定义排序规则\\n\\n**[map容器]**\\n\\n►map的查找和统计\\n\\n\\\\- find(key); //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();\\n\\n\\\\- count(key); //统计key的元素个数\\n\\n►map的排序（使用自定义规则进行排序）\\n\\nclass MyCompare {\\n\\npublic:\\n\\nbool operator()(int v1, int v2) {\\n\\nreturn v1 \\\\> v2;\\n\\n}\\n\\n};\\n\\nmap\\\\<int, int, MyCompare\\\\> m; //自定义排序规则\\n\\n自定义函数用于排序的例子：\\n\\n**b**ool myCompare(int val1 , int val2)\\n\\n{\\n\\nreturn val1 \\\\> val2;\\n\\n}\\n\\n# 二、STL常用函数对象\\n\\n**1、函数对象**\\n\\n定义：重载函数调用操作符的类，其对象常称为函数对象。函数对象使用重载的（）号时，行为类似于函数调用，因此也称为仿函数。\\n\\n本质：函数对象（仿函数）是一个类，不是一个函数\\n\\n1.  函数对象的调用\\n\\n特点：\\n\\n函数对象在使用时，可以像普通函数那样调用，可以有参数，可以有返回值\\n\\n函数对象超出普通函数的概念，函数对象可以有自己的状态\\n\\n函数对象可以作为参数传递\\n\\n总结：仿函数写法非常灵活，可以作为参数进行传递。\\n\\n**2、谓语**\\n\\n返回值是bool类型的仿函数称为谓语，如果operator()接受一个参数，就是一元谓语；接受2个参数，就是二元谓语。\\n\\n**3、内建函数对象**\\n\\nSTL内建了一些函数对象，分为算术仿函数，关系仿函数，逻辑仿函数。\\n\\n这些仿函数所产生的对象，用法和普通函数一致，不过需要引入头文件\\\\<functional\\\\>\\n\\n3.1算术仿函数\\n\\n\\\\- template\\\\<class T\\\\> T plus\\\\<T\\\\> //加法仿函数\\n\\n\\\\- template\\\\<class T\\\\> T minus\\\\<T\\\\> //减法仿函数\\n\\n\\\\- template\\\\<class T\\\\> T multiplies\\\\<T\\\\> //乘法仿函数\\n\\n\\\\- template\\\\<class T\\\\> T divides\\\\<T\\\\> //除法仿函数\\n\\n\\\\- template\\\\<class T\\\\> T modulus\\\\<T\\\\> //取余仿函数%\\n\\n\\\\- template\\\\<class T\\\\> T negate\\\\<T\\\\> //取反仿函数\\n\\n3.2 关系仿函数 （谓语）\\n\\n\\\\- template\\\\<class T\\\\> bool equal_to\\\\<T\\\\> //等于\\n\\n\\\\- template\\\\<class T\\\\> bool not_equal_to\\\\<T\\\\> //不等于\\n\\n\\\\- template\\\\<class T\\\\> bool greater\\\\<T\\\\> //大于\\n\\n\\\\- template\\\\<class T\\\\> bool greater_equal\\\\<T\\\\> //大于等于\\n\\n\\\\- template\\\\<class T\\\\> bool less\\\\<T\\\\> //小于\\n\\n\\\\- template\\\\<class T\\\\> bool less_equal\\\\<T\\\\> //小于等于\\n\\n3.3 逻辑仿函数（应用较少） （谓语）\\n\\n\\\\- template\\\\<class T\\\\> bool logical_and\\\\<T\\\\> //逻辑与\\n\\n\\\\- template\\\\<class T\\\\> bool logical_or\\\\<T\\\\> //逻辑或\\n\\n\\\\- template\\\\<class T\\\\> bool logical_not\\\\<T\\\\> //逻辑非\\n\\n# 三、STL常用算法\\n\\n使用STL算法，需要包含头\\\\<algorithm\\\\>\\n\\n1、遍历算法\\n\\n**（1）for_each遍历容器**\\n\\n►for_each(iterator beg, iterator end, \\\\_func);\\n\\nfor_each是最常用的遍历算法，需要熟练掌握。功能函数有打印函数（自定义函数）、打印函数（类内函数，即仿函数）、算术操作函数或逻辑函数\\n\\n**（2）transform 搬运容器到另一个容器中**\\n\\n►transform(iterator beg1, iterator end1, iterator beg2, \\\\_func);\\n\\n源容器的起点，源容器的终点，目标容器的起点，功能函数同上。注意：搬运的目标函数必须提前开辟空间，否则不能正常搬运。\\n\\n2、查找算法\\n\\n►find(iterator beg, iterator end, value); //按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置，返回值类型是 ‘容器’\\\\<数据类型\\\\>::iterator it\\n\\n►find_if(iterator beg, iterator end, \\\\_Pred); //按条件查找元素(按值查找元素)，找到返回指定位置迭代器，找不到返回结束迭代器位置._Pred是函数或者谓词（谓词是返回bool类型的仿函数）\\n\\n► adjacent_find(iterator beg, iterator end); //查找相邻重复元素,返回相邻元素的第一个位置的迭代器\\n\\n► bool binary_search(iterator beg, iterator end, value); //二分查找法。查到返回true，否则返回false。注意在无序序列中不能用\\n\\n► count(iterator beg, iterator end, value); //统计指定元素出现的个数\\n\\n注意：统计自定义数据类型时，需要重载==\\n\\n► count_if(iterator beg, iterator end, \\\\_Pred); //按条件统计元素个数，_Pred是指返回值为bool类型的仿函数\\n\\n3、排序算法\\n\\n► sort(iterator beg, iterator end, \\\\_Pred); //对容器内元素进行排序\\n\\nsort属于开发中最常用的算法之一，需熟练掌握\\n\\n► random_shuffle(iterator beg, iterator end); //随机洗牌，指定范围内的元素随机调整次序\\n\\nrandom_shuffle洗牌算法比较实用，使用时记得加随机数种子\\n\\n► merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest); // 容器元素合并，并存储到另一容器中。Beg1/end1容器1的起止迭代器，beg2/end2容器2的起止迭代器，dest是目标容器的开始迭代器\\n\\n注意：两个容器必须是有序的，目标容器必须提前开辟空间\\n\\n► reverse(iterator beg, iterator end); // 反转指定范围的元素\\n\\n4、常用拷贝和替换算法\\n\\n► copy(iterator beg, iterator end, iterator dest); //容器内指定范围的元素拷贝到另一容器中\\n\\n► replace(iterator beg, iterator end, oldvalue, newvalue); //将容器内指定范围的旧元素修改为新元素\\n\\nreplace会替换区间内满足条件的元素\\n\\n► replace_if(iterator beg, iterator end, \\\\_pred, newvalue); // 容器内指定范围满足条件的元素替换为新元素\\n\\n按条件替换元素，满足条件的替换成指定元素。总结：replace_if按条件查找，可以利用仿函数灵活筛选满足的条件\\n\\n► swap(container c1, container c2); // 互换两个容器的元素\\n\\n总结：swap交换容器时，注意交换的容器要同种类型\\n\\n5、常用算术生成算法\\n\\n注意：算术生成算法属于小型算法，使用时包含的头文件为 \\\\#include \\\\<numeric\\\\>\\n\\n► accumulate(iterator beg, iterator end, value); // 计算容器元素累计总和，返回值为int\\n\\n► fill(iterator beg, iterator end, value); // 向容器中添加元素\\n\\n6、常用集合算法\\n\\n三个函数的返回值均是dest容器最后一个元素的迭代器iterator\\n\\n► set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest); // 求两个容器的交集\\n\\n注意:两个集合必须是有序序列。\\n\\n总结：-求交集的两个集合必须的有序序列\\n\\n\\\\- 目标容器开辟空间需要从两个容器中取小值\\n\\n\\\\- set_intersection返回值既是交集中最后一个元素的位置\\n\\n► set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest); //求两个容器的并集\\n\\n注意:两个集合必须是有序序列\\n\\n总结：- 求并集的两个集合必须的有序序列\\n\\n\\\\- 目标容器开辟空间需要两个容器相加\\n\\n\\\\- set_union返回值既是并集中最后一个元素的位置\\n\\n► set_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest); // 求两个容器的差集\\n\\n注意:两个集合必须是有序序列\\n\\n总结：- 求差集的两个集合必须的有序序列\\n\\n\\\\- 目标容器开辟空间需要从两个容器取较大值\\n\\n\\\\- set_difference返回值既是差集中最后一个元素的位置\",\"articleCover\":\"https://upload.haoxx.site/article/06d11f52c1fcd3abcda231e09209d1cd.jpg\",\"articleTitle\":\"C++STL常用容器知识点说明\",\"articleType\":1,\"categoryName\":\"编程语言基础\",\"id\":102,\"isRecommend\":0,\"isTop\":0,\"status\":1,\"tagNameList\":[]}]','PUT','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',25,'2023-06-07 19:57:49');
INSERT INTO `t_operation_log` VALUES (1370,'文章模块','上传','/admin/article/upload','com.ican.controller.ArticleController.saveArticleImages','上传文章图片','image_65.jpg','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/article/aed9e7f618becc093ba89e9e48e300ed.jpg\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',12,'2023-06-07 19:58:01');
INSERT INTO `t_operation_log` VALUES (1371,'文章模块','修改','/admin/article/update','com.ican.controller.ArticleController.updateArticle','修改文章','[{\"articleContent\":\"# 终端美化记录\\n\\n## 一、ubuntu安装zsh、powerlevel10k\\n\\n参考[csdn的教程](https://blog.51cto.com/sddai/3030120)：\\n\\n[ohmyzsh的github](https://github.com/ohmyzsh/ohmyzsh)\\n\\n[powerlevel10k的github](https://github.com/romkatv/powerlevel10k)\\n\\npowerline这个不需要安装（powerlevel10k就是基于powerline的）：\\n\\n[powerline的github](https://github.com/powerline/powerline)\\n\\n1、安装zsh\\n\\n```bash\\nsudo apt-get install zsh\\n```\\n\\n2、安装oh-my-zsh\\n\\n```bash\\n# 或者去仓库手动下载，然后运行install.sh\\nsh -c \\\"$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\\\"\\n```\\n\\n3、安装自动跳转插件和语法高亮插件、语法历史记录插件\\n\\n说明：zsh插件的位置在`/root/.oh-my-zsh//plugins`目录下。\\n\\n```bash\\nsudo apt-get install autojump\\n# 配置教程：cat /usr/share/doc/autojump/README.Debian\\nvim .zshrc\\n#在最后一行加入，注意点后面是一个空格\\n. /usr/share/autojump/autojump.sh\\nsource ~/.zshrc\\n```\\n\\n语法高亮：\\n\\n```bash\\n> git clone https://github.com/zsh-users/zsh-syntax-highlighting.git\\n> echo \\\"source ${(q-)PWD}/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh\\\" >> ${ZDOTDIR:-$HOME}/.zshrc\\n> source ~/.zshrc\\n```\\n\\nzsh-autosuggestions语法历史记录插件：\\n\\n```bash\\n> git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions\\n> plugins=(zsh-autosuggestions)\\n```\\n\\n4、安装powerlevel10k命令行显示主题：\\n\\n```bash\\n# 1） 安装Meslo字体\\n## 1.1）下载字体\\nhttps://github.com/ryanoasis/nerd-fonts/tree/master/patched-fonts/Meslo/M/Regular\\n## 1.2）安装字体\\n# 将*.ttf字体文件放在/usr/share/fonts/custom目录下，该目录是自己新建的，然后\\ncd /usr/share/fonts/agave\\nsudo mkfontscale # 生成核心字体信息\\nsudo mkfontdir # 生成字体文件夹\\nsudo fc-cache -fv # 刷新系统字体缓存\\n# 2）安装powerlevel10k\\n## 2.1）下载\\ngit clone --depth=1 https://gitee.com/romkatv/powerlevel10k.git ${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/themes/powerlevel10k\\n## 2.2）安装\\nSet ZSH_THEME=\\\"powerlevel10k/powerlevel10k\\\" in ~/.zshrc.\\n## 说明：或者手动从github上下载powerlebel10k，然后放在/root/.oh-my-zsh/custom/themes目录下，最后在.zshrc中设置主题即可\\n```\\n\\n### 1.1 powerlevel10k的配置\\n\\n见github仓库。  另外，您参考[CSDN的教程:powerlevel10k 颜色和图标的自定义设置](https://blog.csdn.net/qq_36835255/article/details/128101588)\\n\\n## 二、windows的powershell安装oh-my-posh\\n\\n1、查看官网：[oh-my-posh](https://ohmyposh.dev/)\\n\\n如果官网打不开的话就直接百度搜：oh my posh\\n\\n按照教程一步一步来：\\n\\n```powershell\\n# 0、安装MesloLGMNerdFontXXX.ttf字体(三个字体)在windows设置中安装\\nhttps://github.com/ryanoasis/nerd-fonts/tree/master/patched-fonts/Meslo/M/Regular\\n# 1、安装oh-my-posh\\nwinget install JanDeDobbeleer.OhMyPosh -s winget\\n# 2、更新\\nwinget upgrade JanDeDobbeleer.OhMyPosh -s winget\\n# 3、查看当前终端名\\noh-my-posh get shell\\n# 4、打开配置文件\\n## 4.1 查看配置文件是否存在：\\nTest-Path $profile\\n## 4.2 若不存在，就查看默认的配置文件路径：\\necho $profile\\n## 4.3 然后手动创建该路径和对应的配置文件\\n# windowsPowerShell配置文件：C:\\\\Users\\\\50850\\\\Documents\\\\WindowsPowerShell\\\\Microsoft.PowerShell_profile.ps1\\n# PowerShell配置文件：C:\\\\Users\\\\50850\\\\Documents\\\\PowerShell\\\\Microsoft.PowerShell_profile.ps1\\n# 5、在配置文件中写入：\\noh-my-posh init pwsh --config \\\"C:\\\\Users\\\\50850\\\\Documents\\\\WindowsPowerShell\\\\jandedobbeleer.omp.json\\\" | Invoke-Expression\\n## 5.1 说明该json文件原路径是在：C:\\\\Users\\\\50850\\\\AppData\\\\Local\\\\Programs\\\\oh-my-posh\\\\themes\\n## 5.2 请移动到自定义的位置，在更改\\n# 6、重启powershell，配置完成\\n# 7、补充，在vscode的powershell中的设置\\n#参考：https://blog.csdn.net/dietime1943/article/details/122968934\\n\\n```\\n\\n### 2.1 oh-my-posh的配置\\n\\n参考文档：[CSDN的教程](https://blog.csdn.net/qq_36835255/article/details/128101588)\\n\\n\\n2、自定义设置\\n\\n主要是对这个json文件进行修改，相关键名和参数值请参考官网。就当前配置而言，重点是更改blocks里面的东西。主要分为三块，由三个大括号包裹。type和alignment是配置提示符在终端的位置，newline选项相当于换行。\\n\\n然后的话，重点就在于segments数组的设置了：\\n\\n```markdown\\n\\\"segments\\\": [\\n        {\\n          \\\"background\\\": \\\"#101010\\\",\\n          \\\"foreground\\\": \\\"#ffffff\\\",\\n          \\\"leading_diamond\\\": \\\"\\\\ue0b6\\\",\\n          \\\"trailing_diamond\\\": \\\"\\\\ue0b4\\\",\\n          \\\"style\\\": \\\"diamond\\\",\\n          \\\"template\\\": \\\"\\\\uf007 {{ .UserName }}\\\",\\n          \\\"type\\\": \\\"session\\\"\\n        },\\n        {\\n        ...\\n        }\\n]\\n```\\n\\n上述代码块是其中的一部分，他是设置了提示符中“用户名”相关的设置。1）前景颜色、背景颜色，当类型为`\\\"style\\\"=\\\"diamond\\\"`时，可以设置前后的字符，2）然后template键值里设置了用户名的值和表示形式。3）最后，有关字符的代码，可以查看网站：[nerdfonts](https://www.nerdfonts.com/cheat-sheet)。\\n\\n\\n## 三、ubuntu安装lunar_vim插件管理器\\n\\n参考官网：[lunarvim](https://www.lunarvim.org/docs/installation) ，我感觉有点麻烦。\\n\\n\\n\\n\\n## 四、vim插件安装和配置\\n\\n使用的是程序员卡尔的配置[程序员卡尔的github仓库](https://github.com/youngyangyang04/PowerVim)\\n\\n\\n# 五、tmux的学习记录\\n\\n正在计划中...\\n\\n- [x] 完善tmux终端管理器的学习笔记\",\"articleCover\":\"https://upload.haoxx.site/article/aed9e7f618becc093ba89e9e48e300ed.jpg\",\"articleTitle\":\"Linux / Windows终端美化记录\",\"articleType\":1,\"categoryName\":\"Linux运维\",\"id\":101,\"isRecommend\":0,\"isTop\":0,\"status\":1,\"tagNameList\":[]}]','PUT','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',22,'2023-06-07 19:58:02');
INSERT INTO `t_operation_log` VALUES (1372,'文章模块','上传','/admin/article/upload','com.ican.controller.ArticleController.saveArticleImages','上传文章图片','image_74.jpg','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/article/979a9c0ee3f5bf324d916d6fac553317.jpg\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',14,'2023-06-07 19:58:13');
INSERT INTO `t_operation_log` VALUES (1373,'文章模块','修改','/admin/article/update','com.ican.controller.ArticleController.updateArticle','修改文章','[{\"articleContent\":\"# 常用命令\\n\\n参考：[CSDN网页](https://blog.csdn.net/weixin_46085718/article/details/127727204)\\n\\n1、ubuntu检查电脑上是否安装了mysql:\\n`dpkg -l|grep mysql` 或`netstat -tap|grep mysql`或`systemctl status mysql.service`\\n\\n2、登录mysql (账号root，密码为1)\\n`mysql -u root -p` 回车后，输入密码\\n\\n3、查看数据库命令(分号结尾)\\n`show databases;`\\n\\n4、创建数据库，创建一个node的数据库\\n`CREATE DATABASE IF NOT EXISTS node DEFAULT CHARSET utf8 COLLATE utf8_general_ci;`\\n\\n5、退出数据库\\n`exit`\\n\\n6、数据库的初始化命令 （脱出mysql后使用）\\n`mysql_secure_installation`\\n\\n7、配置mysql的远程访问\\n\\n1) 打开文件`vim /etc/mysql/mysql.conf.d/mysqld.cnf`，然后注释掉`#bind-address  = 127.0.0.1`\\n\\n2) 在[mysqld]条目下方，添加： \\n\\n```\\n[mysqld]\\nskip-grant-tables\\n```\\n\\n3) 在windows上使用Navicat软件来远程管理数据库\\n\\n## 进阶命令\\n\\n通过mysql -h 或man mysql查询\\n资料参考：[csdn](https://dablelv.blog.csdn.net/article/details/52106044?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2-52106044-blog-125246185.pc_relevant_multi_platform_whitelistv3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2-52106044-blog-125246185.pc_relevant_multi_platform_whitelistv3)\\n\\n这个连接里面的内容比较多，可以多看看\\n\\n\\n## 创建新用户\\n\\n1、创建新用户，并允许远程访问：\\n\\n```bash\\nCREATE USER \'<username>\'@\'%\' IDENTIFIED BY \'<password>\';\\n```\\n\\n2、允许新用户访问所有数据库：\\n\\n```bash\\nGRANT ALL PRIVILEGES ON *.* TO \'<username>\'@\'%\';\\n```\\n\\n只允许新用户访问指定数据库：\\n\\n```bash\\nGRANT ALL PRIVILEGES ON 指定数据库名.* TO \'<username>\'@\'%\';\\n```\\n\\n3、刷新权限\\n\\n```bash\\nFLUSH PRIVILEGES;\\n```\",\"articleCover\":\"https://upload.haoxx.site/article/979a9c0ee3f5bf324d916d6fac553317.jpg\",\"articleTitle\":\"MySql常用命令\",\"articleType\":1,\"categoryName\":\"Linux运维\",\"id\":100,\"isRecommend\":0,\"isTop\":0,\"status\":1,\"tagNameList\":[]}]','PUT','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',18,'2023-06-07 19:58:14');
INSERT INTO `t_operation_log` VALUES (1374,'文章模块','上传','/admin/article/upload','com.ican.controller.ArticleController.saveArticleImages','上传文章图片','image_84.jpg','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/article/e40b334765dcebff6d4f4b60544bcc7b.jpg\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',14,'2023-06-07 19:58:21');
INSERT INTO `t_operation_log` VALUES (1375,'文章模块','修改','/admin/article/update','com.ican.controller.ArticleController.updateArticle','修改文章','[{\"articleContent\":\"# GDB调试手册\\n\\n前提：gcc在编译时需要加上-g参数\\n\\n总结：\\n\\n> 说明：gdb -c /tmp/core-tuxclocker-19395-1584497577 xx(可执行程序名)\\n>\\n> <font color=\'red\'>list</font>命令(简写为l)查看源码\\n>\\n> <font color=\'red\'>layout src</font>显示源代码窗口 （ctrl + x + a 以关闭源代码界面）\\n>\\n> 运行程序命令<font color=\'red\'>run</font>(简写为r)\\n>\\n> 设置断点命令<font color=\'red\'>break</font>(简写为b) +行号  或b 函数名\\n>\\n> 查看断点信息：<font color=\'red\'> info b </font>\\n>\\n> 清除断点<font color=\'red\'>clear</font>(简写为c) +行号\\n>\\n> 单步调试：继续执行到下一个断点<font color=\'red\'>continue</font>(简写为c)；单步执行，跳过子函数<font color=\'red\'>next</font>(简写为n)；单步执行，进入子函数<font color=\'red\'>strp</font>(简写为s)\\n>\\n> 查看变量<font color=\'red\'>print 变量名</font>\\n>\\n> 运行至函数结束<font color=\'red\'>finish</font>\\n>\\n> 退出<font color=\'red\'>quit</font>\\n\\n```c\\n/*”核心文件已转储“的错误原因解析：\\n\\n原因一：内存访问越界\\n\\n  a) 使用错误的下标，导致数组访问越界；\\n\\n原因二：多线程程序使用了线程不安全的函数\\n\\n原因三：多线程读写的数据没有加锁保护；\\n\\n原因四：非法指针\\n\\n  a) 使用空指针，\\n\\n  b) 随意使用指针转换；\\n\\n原因五：堆栈溢出*/\\n```\\n\\n```c\\nlayout：用于分割窗口，可以一边查看代码，一边测试。主要有以下几种用法：\\nlayout src：显示源代码窗口\\nlayout asm：显示汇编窗口\\nlayout regs：显示源代码/汇编和寄存器窗口\\nlayout split：显示源代码和汇编窗口\\nlayout next：显示下一个layout\\nlayout prev：显示上一个layout\\nCtrl + L：刷新窗口\\nCtrl + x，再按1：单窗口模式，显示一个窗口\\nCtrl + x，再按2：双窗口模式，显示两个窗口\\n\\nCtrl + x，再按a：回到传统模式，即退出layout，回到执行layout之前的调试窗口。\\n\\n```\\n\\n##  一、基础入门\\n\\n```sh\\ngdb hello  #hello为程序名\\n```\\n\\n1.1 参数-q，可以再启动时不打印gdb的默认参数\\n\\n2 参看源码\\n\\n命令list (简写l)可以查看源码，默认显示10行，通过回车键不断查看剩余代码\\n\\n3 运行程序\\n\\n命令run  (简写r)用于运行代码，在程序结束或者遇到断点处停下\\n\\n4 设置断点\\n\\n运行break (简写b)命令可以在指定行设置一个断点，断点调试是程序调试里面使用频率最高的技巧\\n\\n使用方法：“b”命令后面加上相应的行号\\n\\n设置好断点后，执行一下命令查看断点信息：info b\\n![](https://s3.bmp.ovh/imgs/2022/11/12/9d9d4ba1565c9ad2.png)\\n\\n5 单步调试\\n\\n+ continue (简写c)：继续执行，到下一个断点处（或运行结束）。\\n+ next (简写n)：单步执行，跳过子函数\\n+ strp (简写s)：单步执行，进入子函数\\n\\n6 查看变量\\n\\n使用print (简写p)指令来查看变量的值，用法为\\\"print 变量名\\\"。\\n\\n7 清除断点\\n\\nclear + 行号以清除断点。\\n\\n8 运行至函数结束\\n\\n使用finish命令来运行程序至函数结束\\n\\n9 显示源代码窗口\\n\\n程序运行后，使用命令“layout src”可以显示源代码窗口，当前执行代码会高亮\\n\\n10 退出gdb\\n\\n执行quit (简写q)会退出gdb调试\\n\\n\\n11 附加说明\\n\\ncgdb是gdb的终端界面增强版，它有上下两栏窗口，上栏的窗口支持vi编辑器的语法， 可以方便的使用它来进行字符串定位等功能。在gdb下使用“layout src”时，界面往往容易花屏， 而cgbd更加的稳定可靠。还有一点，cgdb会给不同符号的不同类型辅以不同的颜色。\\n\\n使用`sudo apt install cgdb`来安装该软件。\\n\\n## 二、 gdb调试之函数调用栈——backtrace\\n\\n在写代码的时候，我们会封装很多函数，而这些函数之中又会调用其他的函数，当程序每次调用函数的时候，就会跳转到函数的地方去执行，那么这期间就有很多信息产生了，比如：调用函数的地方，函数的参数，被调用函数的变量等，这些信息其实是存储在栈中的，其实更确切地说，这些信息是存储在函数调用信息帧中的，每个函数及其变量都被分配了一个帧（frame），这些函数信息帧就组成了函数调用栈。我们使用 gdb 调试工具就可以查看函数调用栈的内容信息，可以清晰地看到各个函数的调用顺序以及各函数的输入形参值，是分析程序的执行流程和输入依赖的重要手段。\\n\\ngdb提供了一些指令可以查看这些帧中的信息，当查询函数变量的信息时，gdb就是从这个被选中的帧内获取信息，但是查看被选中帧外的变量信息是非法的，当程序运行停止的时候，gdb会自动选择当前被调用的函数帧，并且打印简单帧信息。\\n\\n2、gdb中函数调用栈的指令\\n\\n+ 2.1 查看栈信息\\n\\n> <font color=\'red\'>bt</font>：bt是` backtrace` 指令的缩写，显示所有的函数调用栈的信息，栈中的每个函数都被分配了一个编号，最近被调用的函数在 0 号帧中（栈顶），并且每个帧占用一行。\\n>\\n> <font color=\'red\'>bt n</font>：显示函数调用栈从栈顶算起的n帧信息（n 表示一个正整数）。\\n>\\n> <font color=\'red\'>bt -n</font>：显示函数调用栈从栈底算起的n帧信息。\\n>\\n> <font color=\'red\'>bt full</font>：显示栈中所有信息如：函数参数，本地变量等。\\n>\\n> <font color=\'red\'>bt full n</font>：显示函数调用栈从栈顶算起的n帧的所有信息。\\n>\\n> <font color=\'red\'>bt full -n</font>：显示函数调用栈从栈底算起的n帧的所有信息。\\n\\n+ 2.2 查看帧信息\\n\\n上面的bt指令主要是查看栈的信息，而每一帧都会有详细的信息，这些函数调用信息帧包括：调用函数的地方，函数的参数等。如果想查看栈中某一帧的信息，首先要做的是切换当前栈。这时候需用用到 frame 指令（缩写形式为 f）。\\n\\n> <font color=\'red\'>f  n</font> ： 它的功能是切换到编号为 n 的栈帧（n 表示一个正整数），并显示相关信息。\\n\\n![](https://s3.bmp.ovh/imgs/2022/11/13/a89a6a826e86a4be.png)\\n\\n+ 2.3 up/down指令\\n\\n除了使用 frame 指令切换栈帧外，还可以使用 up 和 down 指令。\\n\\n> <font color=\'red\'>down n</font> ： 表示往栈顶方向下移 n 层（n 表示一个正整数，默认值为 1）。\\n>\\n> <font color=\'red\'>up  n</font> ： 表示往栈底方向上移 n 层。\\n\\n\\n+ 2.4 查看更详细的帧信息\\n\\ninfo 指令是一个很强大的指令，使用它可以查看各种变量的值，如果我们希望看到详细的函数调用信息帧的信息，如：函数地址、调用函数的地址、被调用函数的地址、当前函数由哪种编程语言编写、函数参数地址及形参值、局部变量的地址、当前桢中存储的寄存器等，可以使用以下指令：\\n\\n> <font color=\'red\'>info frame</font> ：指令的缩写形式为 `i f` ，查看函数调用帧的所有信息。\\n>\\n> <font color=\'red\'>info args</font> ：查看函数变量的值。(与print args功能是一样的)\\n>\\n> <font color=\'red\'>info locals</font> ：查看函数变量的值。\\n\\n![](https://s3.bmp.ovh/imgs/2022/11/13/7c7dafcff67e8f53.png)\\n\\n这里面有很多信息：\\n\\n> + 当前桢的地址：0x7fffffffe030。\\n>\\n> + ip的值：0x400b58，此处引申介绍一下rip是什么：它是指令地址寄存器，用来存储 CPU 即将要执行的指令地址。每次 CPU 执行完相应的汇编指令之后，rip 寄存器的值就会自行累加，rip 无法直接赋值。\\n>\\n> + 当前桢函数：test1 (backtrace.c:9)。\\n>\\n> + 调用者的rip值：saved rip = 0x400bbe。\\n>\\n> + 调用者的帧地址：0x7fffffffe060。\\n>\\n> + 源代码所用的程序的语言: source language c。\\n>\\n> + 当前桢的参数的地址及值：Arglist at 0x7fffffffe020, args: arg=1。\\n>\\n> + 当前帧中局部变量的地址：Locals at 0x7fffffffe020, Previous frame’s sp is 0x7fffffffe030。\\n>\\n> + 当前桢中存储的寄存器：rbp at 0x7fffffffe020, rip at 0x7fffffffe028。\\n\\n除此之外 info 指令还可以查看当前寄存器的值：\\n\\n> <font color=\'red\'>info registers</font>：查看寄存器的情况（除了浮点寄存器）。\\n>\\n> <font color=\'red\'>info all-registers</font>：查看所有寄存器的情况（包括浮点寄存器）。\\n\\n### 2.2 gdb调试递归函数\\n\\n本小节的主题是教大家用gdb去调试递归函数，因为一步步去调试太麻烦了，也没法打断点，因为打断点每次递归时都会停下来，实在是难以调试，那么强大如gdb调试工具，对这种递归函数的调试也是轻而易举的。\\n\\n我们用递归算法计算斐波拉契数列，这是在大学C语言课本中的非常有名的递归算法——计算斐波拉契数列，我们回顾一下是什么是斐波拉契数列：斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。\\n\\n代码示例：\\n\\n```c\\nint fibonacci(int n) {\\n if (n == 1 || n == 2) {\\n return 1;\\n }\\n return fibonacci(n - 1) + fibonacci(n - 2);\\n}\\nint main()\\n{\\n\\tint n = 10;\\n\\tint ret = 0;\\n\\tret = fibonacci(n);\\n\\tprintf(\\\"fibonacci(%d)=%d\\\\n\\\", n, ret);\\n\\treturn 0;\\n}\\n```\\n\\n变异后用gdb调试：比如我想让递归调用，n=5时停下来，则有：\\n\\n```c\\ngdb ./test\\n(gdb) b fibonacci if n==5\\n```\\n\\n## 三、跟踪系统调用——strace\\n\\n\\n\\n\\n## GDB调试多线程\",\"articleCover\":\"https://upload.haoxx.site/article/e40b334765dcebff6d4f4b60544bcc7b.jpg\",\"articleTitle\":\"GDB调试\",\"articleType\":1,\"categoryName\":\"编程语言基础\",\"id\":96,\"isRecommend\":0,\"isTop\":0,\"status\":1,\"tagNameList\":[]}]','PUT','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',32,'2023-06-07 19:58:25');
INSERT INTO `t_operation_log` VALUES (1376,'文章模块','上传','/admin/article/upload','com.ican.controller.ArticleController.saveArticleImages','上传文章图片','image_76.jpg','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/article/060c7716645312017b87f5a2b0495bec.jpg\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',15,'2023-06-07 19:58:31');
INSERT INTO `t_operation_log` VALUES (1377,'文章模块','修改','/admin/article/update','com.ican.controller.ArticleController.updateArticle','修改文章','[{\"articleContent\":\"---\\ntitle: 关于cron和anacron的说明\\ndate: 2023-4-12\\ntags:\\n - cron和anacron\\ncategories:\\n - 未分类\\n\\n---\\n\\n用户自己建立的cronttab文件在这个目录下：/var/spool/cron (要创建一份个人 crontab 文件，只要输入： crontab -e)\\n\\n比较这个目录/var/spool/anacron/下的cron.daily cron.weekly cron.monthly与当前系统的时间，来判断定时任务是否需要执行。\\n\\n1、关于run-parts命令\\n\\n对于ubuntu来说，run-parts是个二进制文件，位于/bin/run-parts;对于centos来说，他是一个脚本。它的后面接一个目录名，功能就是运行这个\\n\\n目录下的第一层目录中的所有脚本文件。 就是遍历目标文件夹，执行第一层目录下的可执行权限的文件。\\n\\n参数 --test : run-parts --test /目录名 //打印会被run-parts运行的脚本的名称，但不会实际的运行这些脚本。\\n\\n参数 --list : run-parts --list /目录名 //打印所有匹配的文件名，不局限于可执行，没有执行权限的文件也会打印，但不会实际的去执行。\\n\\n该选项不能与–test一起使用。\\n\\n参数 --report : run-parts --report /目录名 //类似于–verbose，但只打印会生成输出的脚本的名称。脚本的名称被打印到脚本首先产生输出的STDUT或STDRR中的任何一个\\n\\n其它参数，略\\n\\n2、关于test命令\\n\\n在脚本中常用test测试命令。其中在crontab中的test -x 文件名 是在测试该文件是否具有可执行权限。\\n\\n3、cron和anacron的说明 /etc/anacrontab 和 /etc/crontab\\n\\n我们用 cron.daily 工作来说明一下 /etc/anacrontab 的执行过程:\\n\\n读取 /var/spool/anacron/cron.daily 文件中 anacron 上一次执行的时间。\\n\\n和当前时间比较，如果两个时间的差值超过 1 天，就执行 cron.daily 工作。\\n\\n只能在 03：00-22：00 执行这个工作。\\n\\n执行工作时强制延迟时间为 5 分钟，再随机延迟 0～45 分钟。\\n\\n使用 nice 命令指定默认优先级，使用 run-parts 脚本执行 /etc/cron.daily 目录中所有的可执行文件。\\n\\n大家会发现，/etc/cron.{daily，weekly，monthly} 目录中的脚本在当前的 Linux 中是被 anacron 调用的，不再依靠 cron 服务。不过，anacron 不用设置多余的配置，我们只需要把需要定时执行的脚本放入 /etc/cron.{daily，weekly，monthly} 目录中，就会每天、每周或每月执行，而且也不再需要启动 anacron 服务了。如果需要进行修改，则只需修改 /etc/anacrontab 配置文件即可。\\n\\n// /etc/crontab\\n\\n11 17 \\\\* \\\\* \\\\* \\\\* root cd / && run-parts --report /etc/cron.hourly\\n\\n12 25 6 \\\\* \\\\* \\\\* root test -x /usr/sbin/anacron \\\\|\\\\| ( cd / && run-parts --report /etc/cron.daily )\\n\\n13 47 6 \\\\* \\\\* 7 root test -x /usr/sbin/anacron \\\\|\\\\| ( cd / && run-parts --report /etc/cron.weekly )\\n\\n14 52 6 1 \\\\* \\\\* root test -x /usr/sbin/anacron \\\\|\\\\| ( cd / && run-parts --report /etc/cron.monthly )\\n\\n// /etc/anacrontab\\n\\nperiod delay job-identifier command\\n\\n10 \\\\# These replace cron\'s entries\\n\\n11 1 5 cron.daily run-parts --report /etc/cron.daily \\\\#每天开机 5 分钟后就检查 /etc/cron.daily 目录内的文件是否被执行，如果今天没有被执行，那就执行\\n\\n12 7 10 cron.weekly run-parts --report /etc/cron.weekly \\\\#每隔 7 天开机后 25 分钟检查 /etc/cron.weekly 目录内的文件是否被执行，如果一周内没有被执行，就会执行\\n\\n13 @monthly 15 cron.monthly run-parts --report /etc/cron.monthly \\\\#每隔一个月开机后 45 分钟检查 /etc/cron.monthly 目录内的文件是否被执行，如果一个月内没有被执行，那就执行\\n\\n//注：把5/10/45全改为0,anacron或cron的定时任务就会按照你指定的准确时间运行，否则默认会有一定的延迟\\n\\n4、cron和anacron的比较\\n\\n下面是 cron 以及 anacron 的比较，帮助你理解何时用他们其中一个。\\n\\n| cron                           | anacron                                                      |\\n| ------------------------------ | ------------------------------------------------------------ |\\n| 它是守护进程                   | 它不是守护进程                                               |\\n| 适合服务器                     | 适合桌面/笔记本电脑                                          |\\n| 可以让你以分钟级运行计划任务   | 只能让你以天为基础来运行计划任务                             |\\n| 关机时不会执行计划任务         | 如果计划任务到期，机器是关机的，那么它会在机器下次开机后执行计划任务 |\\n| 普通用户和 root 用户都可以使用 | 只有 root 用户可以使用（使用特定的配置启动普通任务）         |\",\"articleCover\":\"https://upload.haoxx.site/article/060c7716645312017b87f5a2b0495bec.jpg\",\"articleTitle\":\"关于cron和anacron的说明\",\"articleType\":1,\"categoryName\":\"Linux运维\",\"id\":98,\"isRecommend\":0,\"isTop\":0,\"status\":1,\"tagNameList\":[]}]','PUT','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',39,'2023-06-07 19:58:33');
INSERT INTO `t_operation_log` VALUES (1378,'文章模块','上传','/admin/article/upload','com.ican.controller.ArticleController.saveArticleImages','上传文章图片','image_82.jpg','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/article/fccca1c9e6eaddff6e7aea054d820878.jpg\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',12,'2023-06-07 19:58:55');
INSERT INTO `t_operation_log` VALUES (1379,'文章模块','修改','/admin/article/update','com.ican.controller.ArticleController.updateArticle','修改文章','[{\"articleContent\":\"# git提交命令\\n\\n[参考链接](https://blog.csdn.net/m0_46698504/article/details/129260726)\\n\\n\\n\\n## 1、设置用户名和邮箱\\n\\n```bash\\ngit config --global user.name \\\"HaoY\\\"\\ngit config --global user.email \\\"508506630@qq.com\\\"\\n# 查看git的配置\\ngit config --list\\n# 使用代理\\ngit clone https://github.com/twbs/bootstrap.git --config \\\"http.proxy=127.0.0.1:7890\\\"  \\n# 查看clash日志，有github相关字样\\n\\n#ubuntu系统设置git的全局代理\\n# 设置的是http的代理 fastgithub的端口是38457\\ngit config --global http.proxy \\\"http://127.0.0.1:7890\\\"     # 设置的是http的代理\\ngit config --global https.proxy \\\"http://127.0.0.1:7890\\\"    # 设置的是https的代理(clash和fastgithub不用设置这个)\\n# 清除代理\\ngit config --global --unset http.proxy\\n```\\n\\n## 2、在gitee上创建并初始化一个仓库\\n\\n在网站上手动进行\\n\\n## 3、将该仓库拉取到本地\\n\\n```git\\ngit clone https://xx.git\\n//此时该目录下会生成一个.git隐藏目录\\n//可以用vscode打开该目录，采用图形化界面来操作了\\n```\\n\\n## 4、将工程文件或目录放置到上述目录下，并上传\\n\\n使用此命令随时查看工作状态：\\n\\n`git status`\\n\\n1）添加文件到缓冲区\\n\\n`git add *  //或者git add 文件名/目录名`\\n\\n2）上传到git的本地版本库中，并做记录\\n\\n`git commit -m \\\"第一次提交\\\"`\\n\\n3）先做分支初始化，再上传到远程服务器中\\n\\n`git init`\\n\\n`git push origin`\\n\\n## 5、补充说明\\n\\n要么当前.git目录下的config文件文件如下：\\n\\n![](https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlHCHfRyOUR24-TBS/root/content)\\n\\n否则，.config文件中没有说明url的话，你可以这样(直接通过git push -f 命令指定仓库也是可以的)，下面是deploy.sh文件的部分内容：\\n\\n```bash\\ntimes=$(date \\\"+%Y-%m-%d__%H:%M:%S\\\")\\ngit init\\ngit add -A\\ngit commit -m $times\\ngit branch -M main\\ngit push -f git@github.com:XiaoYuer2022/XiaoYuer2022.github.io.git main\\n```\\n\\n## 6、git清空仓库\\n\\n```bash\\ngit status\\n# 创建一个新文件夹,或者手动删除本地所有文件在推送\\ngit add .\\ngit commit -m \\\"仓库已经清空\\\"\\n\\ngit push -f git@github.com:XiaoYuer2022/XiaoYuer2022.github.io.git main\\n\\n# 要么直接git push -f 或者下面两行\\n\\n#添加远程仓库(已添加可以跳过)\\ngit remote add origin git@github.com:username/repositoryname\\n#推送到远程仓库\\ngit push -u origin master\\n\\n# 强制推送\\ngit push --force origin main 或者 git push --force origin master\\n\\n# 从远端服务器拉取到本地\\ngit pull origin master\\n# 或者：\\n1）git fetch origin    # 下载最新代码，origin是远端仓库地址\\n2）git diff  HEAD origin/master # HEAD是本地分支，查看两者差异\\n3）git pull  # 合并\\n```\\n\\n手动删除文件的命令是：\\n\\n```bash\\ngit rm -r *\\n```\\n\\n恢复：\\n\\n```bash\\n# 把删除的文件恢复到最新版本 \\ngit checkout\\n```\\n\\n## 7、初始创建一个仓库后\\n\\n```git\\ngit init\\ngit add README.md\\ngit commit -m \\\"first commit\\\"\\ngit branch -M main\\ngit remote add origin git@github.com:XiaoYuer2022/chat.git\\ngit push -u origin main\\n```\\n\\n特别说明：除第一次上传外，后续都不需要`git remote add origin git@github.com:XiaoYuer2022/chat.git`命令了。\\n\\n## 8、使用代理\\n\\n```bash\\n# 使用代理\\ngit clone https://github.com/twbs/bootstrap.git --config \\\"http.proxy=127.0.0.1:7890\\\"  \\n# 查看clash日志，有github相关字样\\n```\\n\\n## 9、添加远端仓库\\n\\n```git\\ngit remote add origin git@github.com:XiaoYuer2022/TinyWebServer2023.git\\n## 如果重复的话,1)更改远端仓库：\\ngit remote set-url origin git@github.com:XiaoYuer2022/TinyWebServer2023.git\\n\\n```\\n\\n## 10、从远端github仓库更新代码\\n\\n```git\\ngit pull\\n```\",\"articleCover\":\"https://upload.haoxx.site/article/fccca1c9e6eaddff6e7aea054d820878.jpg\",\"articleTitle\":\" git提交命令\",\"articleType\":1,\"categoryName\":\"Linux运维\",\"id\":97,\"isRecommend\":0,\"isTop\":0,\"status\":1,\"tagNameList\":[]}]','PUT','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',19,'2023-06-07 19:58:58');
INSERT INTO `t_operation_log` VALUES (1380,'文章模块','上传','/admin/article/upload','com.ican.controller.ArticleController.saveArticleImages','上传文章图片','image_92.jpg','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/article/190eee4ddc61160d9293c95a65123531.jpg\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',14,'2023-06-07 19:59:08');
INSERT INTO `t_operation_log` VALUES (1381,'文章模块','修改','/admin/article/update','com.ican.controller.ArticleController.updateArticle','修改文章','[{\"articleContent\":\"# docker记录\\n\\n## 安装\\n\\n镜像  容器  仓库\\n略\\n\\n## 常用命令\\n\\ndocker rm container-id 删除指定 id 的容器\\n\\ndocker stop/start container-id 停止/启动指定 id 的容器\\n\\ndocker rmi image-id 删除指定 id 的镜像\\n\\ndocker volume ls 查看 volume 列表\\n\\ndocker network ls 查看网络列表\\n\\n镜像相关：\\n\\n导出镜像：docker iamge save centos:7.2.1511 > centos-7.2.1511.tgz\\n\\n导入镜像： docker image load -i centos-7.2.1511.tgz\\n\\n查看镜像详细信息：docker image inspect 镜像-ID\\n\\ndocker images 查看镜像列表\\n\\ndocker search XX 默认在本地，没有的话去docker hub上搜索\\n\\n容器相关：\\ndocker ps 查看当前运行中的容器(-a查看所有容器记录，包括死了的)\\n用镜像启动一个容器：docker run -d -p 80:80 nginx (-d表示后台运行，-p表示端口映射)\\n查看容器信息：docker container inspect 容器ID\\n进入容器空间1：docker run -it centos bash  （从镜像到容器）\\n进入容器空间2：docker exec -it 容器ID bash （从终端进入到一个活着的容器，比如后台容器）\\n\\n\\n容器端口映射：\\n\\n| 命令                              | 解释                              |\\n| --------------------------------- | --------------------------------- |\\n| -**p hostPort:containerPort**     | 端口映射-p 8080:80                |\\n| **-p ip:hostPort:containerPort**  | 配置监听地址-p 10.0.0.100:8080:80 |\\n| **p ip::containerPort**           | 随机分配端口 -p 10.0.0.100：：80  |\\n| **-p hostPort:containerPort:udp** | 指定协议 -p 8080:80:tcp           |\\n| **-p 81:80 -p 443:443**           | 指定多个                          |\\n\\n\\n\\n\\n## 写自己的镜像 Dockerfile\\n\\n```Dockerfile\\nFROM node:11\\nMAINTAINER easydoc.net\\n\\n# 复制代码\\nADD . /app\\n\\n# 设置容器启动后的默认运行目录\\nWORKDIR /app\\n\\n# 运行命令，安装依赖\\n# RUN 命令可以有多个，但是可以用 && 连接多个命令来减少层级。\\n# 例如 RUN npm install && cd /app && mkdir logs\\nRUN npm install --registry=https://registry.npm.taobao.org\\n\\n# CMD 指令只能一个，是容器启动后执行的命令，算是程序的入口。\\n# 如果还需要运行其他命令可以用 && 连接，也可以写成一个shell脚本去执行。\\n# 例如 CMD cd /app && ./start.sh\\nCMD node app.js\\n\\n```\\n\\n说明：\\nFROM 这个镜像的妈妈是谁？（指定基础镜像）\\nMAINTAINER告诉别人，谁负责养他？（指定维护者信息，可以没有）\\nRUN 你想让他干啥（在命令前加上RUN即可）\\nADD 给他一点创业资金（copy文件，会自动解压）\\nWORKDIR 我是cd，今天刚化了妆（设置当前工作目录）\\nVILUME 给他一个存放行李的地方（设置卷，挂载主机目录）\\nEXPOSE 他要打开的门是什么（指定对外的端口）\\nCMD 奔跑吧，兄弟 （指定容器启动后要干的事情）\\n**Docker的其他命令**：\\n\\n> CPOY 复制文件\\n>\\n> ENV 环境变量\\n>\\n> ENTRYPOINT 容器启动后执行的命令\\n\\n### Build为镜像（安装包）和运行\\n\\n编译 `docker build -t test:v1 .`\\n\\n> -t 设置镜像名字和版本号\\n\\n运行`docker run -p 8080:8080 --name test-hello test:v1`\\n\\n> -p 映射容器内端口到宿主机\\n>\\n> --name 容器名字\\n>\\n> -d 后台运行\\n\\n## 目录挂载\\n\\n现存问题：\\n\\n+ 使用 Docker 运行后，我们改了项目代码不会立刻生效，需要重新build和run，很是麻烦。\\n+ 容器里面产生的数据，例如 log 文件，数据库备份文件，容器删除后就丢失了。\\n\\n**目录挂载**以解决上述问题\\n\\n几种挂载方式：\\n\\n+ bind mount 直接把宿主机目录映射到容器内，适合挂代码目录和配置文件。可挂到多个容器上\\n+ volume 由容器创建和管理，创建在宿主机，所以删除容器不会丢失，官方推荐，更高效，Linux 文件系统，适合存储数据库数据。可挂到多个容器上\\n+ tmpfs mount 适合存储临时文件，存宿主机内存中。不可多容器共享。\\n\\n### 挂载演示\\n\\n`bind mount` 方式用绝对路径 -v D:/code:/app\\n\\n`volume` 方式，只需要一个名字 -v db-data:/app\\n\\n\\n## 2023/04/29 学习容器技术\\n\\n一种环境隔离的虚拟化技术，相比于传统的虚拟化技术，它拥有利用系统资源更高效、启动时间更快、持续交付和部署等特点。\\n\\n\\n\\n## 2023/06/06 使用\\n\\n在配置和使用[ttkican_Blog-master博客](https://github.com/ttkican/Blog)时的一些命令记录\\n\\n### 1、docker 与docker-compose的安装\\n\\n### 2、下载镜像\\n\\n```dockerfile\\ndocker pull 镜像名:属性\\ndocker pull canal/canal-server:latest\\n```\\n\\n### 3、运行镜像\\n\\n```dockerfile\\ndocker run --name canal -d canal/canal-server:latest\\n```\\n\\n注意：镜像只有一个，下载的就是镜像。但是可以用该镜像运行若干个不同的容器\\n\\n### 4、docker容器的操作：\\n\\n```bash\\n# 1) 查看正在运行的容器\\ndocker ps \\n# 1.2) 查看已经下载的镜像\\ndocker images\\n# 2）查看所有容器\\ndocker ps -a\\n# 3) 停止指定容器\\ndocker stop 容器名或容器ID\\n# 4）启动容器\\ndocker start 容器名和容器ID\\n# 5）进入容器终端，以mysql容器举例\\ndocker exec -it mysql bash\\n# 上述命令中 -it 表示以交互式的方式， bash 表示以bash终端的方式来交互\\n# 6）容器与本地Linux之间的文件拷贝\\ndocker cp /home/ubuntu/xxx.sql mysql:/\\ndocker cp mysql:/xx.sql /home/ubuntu/\\n# 7) 容器的删除和镜像的删除\\ndocker rm 容器名或容器ID\\ndocker rmi 镜像名或镜像ID\\n# 8) 使用docker-compose和对应的docker-compose.yml来启动docker容器\\ndocker-compose up -d --build  # 在有docker-compose.yml的同级目录下运行哦\\n# 9) 查看docker网络\\ndocker network ls\\n# 查看上述命令的输出，例如我在docker-compose.yml中设置了网络名为：blog-net，然后就能在docker network ls下看到有个NAME为docker_blog-net的网络，然后其NETWORK_ID为d32231f3430c，在然后使用ifconfig命令查看docker虚拟网卡(是类似于br-xxx这种，这里是br-d32231f3430c，而不是下面的veth8fad9XX等)，就知道了该docker网络下的IP为172.20.0.1，后面其他同docker network下的容器想要和mysql容器和redis容器通信的话就填172.20.0.1。注意：docker容器下的127.0.0.1是容器内部自身的回环地址，其他容器肯定访问不到。\\n```\\n\\ndocker-compose.yml文件示例：\\n\\n```dockerfile\\nversion: \\\"3\\\"\\nservices:\\n  blog-service:\\n    build: .\\n    image: blog-springboot:latest\\n    container_name: blog-springboot\\n    restart: always\\n    depends_on:\\n      - mysql\\n      - redis\\n      - rabbitmq\\n    volumes:\\n      - \\\"/usr/local/upload:/usr/local/upload\\\"\\n    ports:\\n      - \\\"8080:8080\\\"\\n    networks:\\n      - blog-net\\n  mysql:\\n    image: mysql:${MYSQL_VERSION}\\n    container_name: mysql\\n    restart: always\\n    environment:\\n      MYSQL_ROOT_PASSWORD: ${MYSQL_ROOT_PASSWORD}\\n      TZ: Asia/Shanghai\\n    ports:\\n      - \\\"3306:3306\\\"\\n    networks:\\n      - blog-net\\n  redis:\\n    image: redis:${REDIS_VERSION}\\n    container_name: redis\\n    restart: always\\n    command: --requirepass \\\"${REDIS_PASSWORD}\\\"\\n    ports:\\n      - \\\"6379:6379\\\"\\n    networks:\\n      - blog-net\\n  rabbitmq:\\n    image: rabbitmq:${RABBITMQ_VERSION}\\n    container_name: rabbitmq\\n    restart: always\\n    environment:\\n      RABBITMQ_DEFAULT_USER: ${RABBITMQ_USER}\\n      RABBITMQ_DEFAULT_PASS: ${RABBITMQ_PASSWORD}\\n    ports:\\n      - \\\"5672:5672\\\"\\n      - \\\"15672:15672\\\"\\n    networks:\\n      - blog-net\\n  elasticsearch:\\n    image: elasticsearch:${ELASTICSEARCH_VERSION}\\n    container_name: elasticsearch\\n    restart: always\\n    environment:\\n      discovery.type: \\\"single-node\\\"\\n      ES_JAVA_OPTS: \\\"-Xms64m -Xmx128m\\\"\\n      http.cors.enabled: \\\"true\\\"\\n      http.cors.allow-origin: \\\"*\\\"\\n      xpack.security.enabled: \\\"true\\\"\\n      ELASTIC_PASSWORD: \\\"${ELASTICSEARCH_PASSWORD}\\\"\\n    ports:\\n      - \\\"9200:9200\\\"\\n      - \\\"9300:9300\\\"\\n    networks:\\n      - es-net\\n      - blog-net\\n  kibana:\\n    image: kibana:${ELASTICSEARCH_VERSION}\\n    container_name: kibana\\n    volumes:\\n      - \\\"/usr/local/kibana/kibana.yml:/usr/share/kibana/config/kibana.yml\\\"\\n    depends_on:\\n      - elasticsearch\\n    ports:\\n      - \\\"5601:5601\\\"\\n    networks:\\n      - es-net\\n      - blog-net\\n  canal_server:\\n    image: canal/canal-server:${CANAL_VERSION}\\n    container_name: canal\\n    volumes:\\n      - \\\"/usr/local/canal/instance.properties:/home/admin/canal-server/conf/example/instance.properties\\\"\\n      - \\\"/usr/local/canal/canal.properties:/home/admin/canal-server/conf/canal.properties\\\"\\n    ports:\\n      - \\\"11111:11111\\\"\\n    networks:\\n      - blog-net\\n  nginx:\\n    image: nginx:${NGINX_VERSION}\\n    container_name: nginx\\n    restart: always\\n    volumes:\\n      - \\\"/usr/local/nginx/nginx.conf:/etc/nginx/nginx.conf\\\"\\n      - \\\"/etc/ssl/certs:/etc/ssl/certs\\\"\\n      - \\\"/usr/local/vue:/usr/local/vue\\\"\\n      - \\\"/usr/local/upload:/usr/local/upload\\\"\\n    privileged: true\\n    ports:\\n      - \\\"443:443\\\"\\n      - \\\"80:80\\\"\\n    networks:\\n      - blog-net\\nnetworks:\\n  es-net:\\n    driver: bridge\\n  blog-net:\\n    driver: bridge\\n```\\n\\n对应的启动脚本：\\n\\n```bash\\n#!/bin/bash\\n# 文件名：blog-start.sh\\n# 打包之后上传的jar包路径\\nSOURCE_PATH=/usr/local/docker\\n# docker的镜像和容器名称都命名为这个\\nSERVER_NAME=blog-springboot\\nTAG=latest\\n# 容器id\\nCID=$(docker ps | grep \\\"$SERVER_NAME\\\" | awk \'{print $1}\')\\n# 镜像id\\nIID=$(docker images | grep \\\"$SERVER_NAME\\\" | awk \'{print $3}\')\\nif [ -n \\\"$CID\\\" ]; then\\n  echo \\\"存在容器$SERVER_NAME, CID-$CID\\\"\\n  docker stop $CID\\n  docker rm $CID\\nfi\\n# 构建docker镜像\\nif [ -n \\\"$IID\\\" ]; then\\n  echo \\\"存在$SERVER_NAME:$TAG镜像，IID=$IID\\\"\\n  docker rmi $IID\\nfi\\n# 重新构建镜像并运行\\ndocker-compose up -d --build\\n```\\n\\n\\n\\n\\n\\n\\n\\n\",\"articleCover\":\"https://upload.haoxx.site/article/190eee4ddc61160d9293c95a65123531.jpg\",\"articleTitle\":\"docker使用记录\",\"articleType\":1,\"categoryName\":\"Linux运维\",\"id\":95,\"isRecommend\":0,\"isTop\":0,\"status\":1,\"tagNameList\":[]}]','PUT','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',23,'2023-06-07 19:59:11');
INSERT INTO `t_operation_log` VALUES (1382,'文章模块','上传','/admin/article/upload','com.ican.controller.ArticleController.saveArticleImages','上传文章图片','image_78.jpg','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/article/95bfa093fc995038d2b6e82aeab43625.jpg\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',19,'2023-06-07 19:59:19');
INSERT INTO `t_operation_log` VALUES (1383,'文章模块','修改','/admin/article/update','com.ican.controller.ArticleController.updateArticle','修改文章','[{\"articleContent\":\"![](https://files.mdnice.com/logo.svg)\\n\\n请使用 **Chrome** 浏览器。\\n\\n请阅读下方文本熟悉工具使用方法，本文可直接拷贝到微信中预览。点击[墨滴官网](https://mdnice.com/)查看更多信息，注意：需要注册登录后才能看到编辑页面。其他微信公众号编辑工具（包含无需注册的）详见：[知乎文章](https://zhuanlan.zhihu.com/p/385098206)\\n\\n\\n[TOC]\\n\\n\\n## 1 Markdown Nice 简介\\n\\n- 支持自定义样式的 Markdown 编辑器\\n- 支持微信公众号、知乎和稀土掘金\\n- 欢迎扫码回复「排版」加入推文群\\n\\n![](https://files.mdnice.com/pic/cd3ca20c-896f-4cfc-9bdd-c4c58e69ba26.jpg)\\n\\n## 2 主题\\n\\n**https://product.mdnice.com/themes/**\\n\\n欢迎提交主题，提供更多文章示例~~\\n\\n## 3 通用语法\\n\\n### 3.1 标题\\n\\n在文字写书写不同数量的`#`可以完成不同的标题，如下：\\n\\n# 一级标题\\n\\n## 二级标题\\n\\n### 三级标题\\n\\n### 3.2 无序列表\\n\\n无序列表的使用，在符号`-`后加空格使用。如下：\\n\\n- 无序列表 1\\n- 无序列表 2\\n- 无序列表 3\\n\\n如果要控制列表的层级，则需要在符号`-`前使用空格。如下：\\n\\n- 无序列表 1\\n- 无序列表 2\\n  - 无序列表 2.1\\n  - 无序列表 2.2\\n\\n**由于微信原因，最多支持到二级列表**。\\n\\n### 3.3 有序列表\\n\\n有序列表的使用，在数字及符号`.`后加空格后输入内容，如下：\\n\\n1. 有序列表 1\\n2. 有序列表 2\\n3. 有序列表 3\\n\\n### 3.4 粗体和斜体\\n\\n粗体的使用是在需要加粗的文字前后各加两个`*`。\\n\\n而斜体的使用则是在需要斜体的文字前后各加一个`*`。\\n\\n如果要使用粗体和斜体，那么就是在需要操作的文字前后加三个`*`。如下：\\n\\n**这个是粗体**\\n\\n_这个是斜体_\\n\\n**_这个是粗体加斜体_**\\n\\n### 3.5 链接\\n\\n微信公众号仅支持公众号文章链接，即域名为`https://mp.weixin.qq.com/`的合法链接。使用方法如下所示：\\n\\n对于该论述，欢迎读者查阅之前发过的文章，[你是《未来世界的幸存者》么？](https://mp.weixin.qq.com/s/s5IhxV2ooX3JN_X416nidA)\\n\\n### 3.6 引用\\n\\n引用的格式是在符号 `>` 后面书写文字，文字的内容可以包含标题、链接、图片、粗体和斜体等。\\n\\n一级引用如下：\\n\\n> ### 一级引用示例\\n>\\n> 读一本好书，就是在和高尚的人谈话。 **——歌德**\\n>\\n> [Markdown Nice最全功能介绍](https://mp.weixin.qq.com/s/lM808MxUu6tp8zU8SBu3sg)\\n>\\n> ![这里写图片描述](https://files.mdnice.com/pic/cd3ca20c-896f-4cfc-9bdd-c4c58e69ba26.jpg)\\n\\n当使用多个 `>` 符号时，就会变成多级引用\\n\\n二级引用如下：\\n\\n>> ### 二级引用示例\\n>\\n>> 读一本好书，就是在和高尚的人谈话。 **——歌德**\\n>\\n>> [Markdown Nice最全功能介绍](https://mp.weixin.qq.com/s/lM808MxUu6tp8zU8SBu3sg)\\n>\\n>> ![这里写图片描述](https://files.mdnice.com/pic/cd3ca20c-896f-4cfc-9bdd-c4c58e69ba26.jpg)\\n\\n三级引用如下：\\n\\n>>> ### 三级引用示例\\n>\\n>>> 读一本好书，就是在和高尚的人谈话。 **——歌德**\\n>\\n>>> [Markdown Nice最全功能介绍](https://mp.weixin.qq.com/s/lM808MxUu6tp8zU8SBu3sg)\\n>\\n>>> ![这里写图片描述](https://files.mdnice.com/pic/cd3ca20c-896f-4cfc-9bdd-c4c58e69ba26.jpg)\\n\\n### 3.7 分割线\\n\\n可以在一行中用三个以上的减号来建立一个分隔线，同时需要在分隔线的上面空一行。如下：\\n\\n---\\n\\n### 3.8 删除线\\n\\n删除线的使用，在需要删除的文字前后各使用两个`~`，如下：\\n\\n~~这是要被删除的内容。~~\\n\\n### 3.9 表格\\n\\n可以使用冒号来定义表格的对齐方式，如下：\\n\\n| 姓名       | 年龄 |         工作 |\\n| :--------- | :--: | -----------: |\\n| 小可爱     |  18  |     吃可爱多 |\\n| 小小勇敢   |  20  |   爬棵勇敢树 |\\n| 小小小机智 |  22  | 看一本机智书 |\\n\\n宽度过长的表格可以滚动，可在自定义主题中调节宽度：\\n\\n| 姓名       | 年龄 |         工作 |      邮箱       |    手机     |\\n| :--------- | :--: | -----------: | :-------------: | :---------: |\\n| 小可爱     |  18  |     吃可爱多 | lovely@test.com | 18812345678 |\\n| 小小勇敢   |  20  |   爬棵勇敢树 | brave@test.com  | 17712345678 |\\n| 小小小机智 |  22  | 看一本机智书 | smart@test.com  | 16612345678 |\\n\\n### 3.10 图片\\n\\n插入图片，如果是行内图片则无图例，否则有图例，格式如下：\\n\\n![这里写图片描述](https://files.mdnice.com/pic/cd3ca20c-896f-4cfc-9bdd-c4c58e69ba26.jpg)\\n\\n可以通过在图片尾部添加宽度和高度控制图片大小，用法如下：\\n\\n![同时设置宽度和高度](https://files.mdnice.com/logo.png =150x150)\\n\\n![只设置宽度，推荐使用百分比](https://files.mdnice.com/logo.png =40%x)\\n\\n该语法比较特殊，其他 Markdown 编辑器不完全通用。\\n\\n支持 jpg、png、gif、svg 等图片格式，**其中 svg 文件仅可在微信公众平台中使用**，svg 文件示例如下：\\n\\n![](https://files.mdnice.com/i-am-svg.svg)\\n\\n- 支持图片**拖拽和截图粘贴**到编辑器中上传，上传时使用当前选择的图床。\\n- 可使用**格式->图片**上传本地图片，网站目前支持「图壳」图床，失败率低，但是只可保存一天用于排版\\n\\n**注：仅支持 https 的图片，图片粘贴到微信、知乎或掘金时会自动上传其服务器，不必担心使用上述图床会导致图片丢失**。\\n\\n图片还可以和链接嵌套使用，能够实现推荐卡片的效果，用法如下：\\n\\n[![Markdown Nice 最全功能介绍](https://files.mdnice.com/dance.gif)](https://mp.weixin.qq.com/s/lM808MxUu6tp8zU8SBu3sg)\\n\\n## 4. 特殊语法\\n\\n### 4.1 脚注\\n\\n> 支持平台：微信公众号、知乎。\\n\\n脚注与链接的区别如下所示：\\n\\n```markdown\\n链接：[文字](链接)\\n脚注：[文字](脚注解释 \\\"脚注名字\\\")\\n```\\n\\n有人认为在[大前端时代](https://en.wikipedia.org/wiki/Front-end_web_development \\\"Front-end web development\\\")的背景下，移动端开发（Android、IOS）将逐步退出历史舞台。\\n\\n[全栈工程师](是指掌握多种技能，并能利用多种技能独立完成产品的人。 \\\"什么是全栈工程师\\\")在业务开发流程中起到了至关重要的作用。\\n\\n脚注内容请拉到最下面观看。\\n\\n### 4.2 代码块\\n\\n> 支持平台：微信公众号、知乎。\\n\\n如果在一个行内需要引用代码，只要用反引号引起来就好，如下：\\n\\nUse the `printf()` function.\\n\\n在需要高亮的代码块的前一行及后一行使用三个反引号，同时**第一行反引号后面表示代码块所使用的语言**，如下：\\n\\n```java\\n// FileName: HelloWorld.java\\npublic class HelloWorld {\\n  // Java 入口程序，程序从此入口\\n  public static void main(String[] args) {\\n    System.out.println(\\\"Hello,World!\\\"); // 向控制台打印一条语句\\n  }\\n}\\n```\\n\\n支持以下语言种类：\\n\\n```\\nbash\\nclojure，cpp，cs，css\\ndart，dockerfile, diff\\nerlang\\ngo，gradle，groovy\\nhaskell\\njava，javascript，json，julia\\nkotlin\\nlisp，lua\\nmakefile，markdown，matlab\\nobjectivec\\nperl，php，python\\nr，ruby，rust\\nscala，shell，sql，swift\\ntex，typescript\\nverilog，vhdl\\nxml\\nyaml\\n```\\n\\n如果想要更换代码主题，可在上方挑选，不支持代码主题自定义。\\n\\n其中**微信代码主题与微信官方一致**，有以下注意事项：\\n\\n- 带行号且不换行，代码大小与官方一致\\n- 需要在代码块处标志语言，否则无法高亮\\n- 粘贴到公众号后，用鼠标点代码块内外一次，完成高亮\\n\\ndiff 不能同时和其他语言的高亮同时显示，且需要调整代码主题为微信代码主题以外的代码主题才能看到 diff 效果，使用效果如下:\\n\\n```diff\\n+ 新增项\\n- 删除项\\n```\\n\\n**其他主题不带行号，可自定义是否换行，代码大小与当前编辑器一致**\\n\\n### 4.3 数学公式\\n\\n> 支持平台：微信公众号、知乎。\\n\\n行内公式使用方法，比如这个化学公式：$\\\\ce{Hg^2+ ->[I-] HgI2 ->[I-] [Hg^{II}I4]^2-}$\\n\\n块公式使用方法如下：\\n\\n$$H(D_2) = -\\\\left(\\\\frac{2}{4}\\\\log_2 \\\\frac{2}{4} + \\\\frac{2}{4}\\\\log_2 \\\\frac{2}{4}\\\\right) = 1$$\\n\\n矩阵：\\n\\n$$\\n  \\\\begin{pmatrix}\\n  1 & a_1 & a_1^2 & \\\\cdots & a_1^n \\\\\\\\\\n  1 & a_2 & a_2^2 & \\\\cdots & a_2^n \\\\\\\\\\n  \\\\vdots & \\\\vdots & \\\\vdots & \\\\ddots & \\\\vdots \\\\\\\\\\n  1 & a_m & a_m^2 & \\\\cdots & a_m^n \\\\\\\\\\n  \\\\end{pmatrix}\\n$$\\n\\n公式由于微信不支持，目前的解决方案是转成 svg 放到微信中，无需调整，矢量不失真。\\n\\n目前测试如果公式量过大，在 Chrome 下会存在粘贴后无响应，但是在 Firefox 中始终能够成功。\\n\\n### 4.4 TOC\\n\\n> 支持平台：微信公众号、知乎。\\n\\nTOC 全称为 Table of Content，列出全部标题。由于示例标题过多，需要使用将下方代码段去除即可。\\n\\n```\\n[TOC]\\n```\\n\\n由于微信只支持到二级列表，本工具仅支持二级标题和三级标题的显示。\\n\\n### 4.5 注音符号\\n\\n> 支持平台：微信公众号。\\n\\n支持注音符号，用法如下：\\n\\nMarkdown Nice 这么好用，简直是{喜大普奔|hē hē hē hē}呀！\\n\\n### 4.6 横屏滑动幻灯片\\n\\n> 支持平台：微信公众号。\\n\\n通过`<![](url),![](url)>`这种语法设置横屏滑动滑动片，具体用法如下：\\n\\n<![蓝1](https://files.mdnice.com/blue.jpg),![绿2](https://files.mdnice.com/green.jpg),![红3](https://files.mdnice.com/red.jpg)>\\n\\n### 4.7 容器块\\n\\n> 支持平台：微信公众号。\\n\\n通过`::: block-1`开头，`:::`结尾，来设置容器块，容器块内可以使用任意 markdown 语法，容器块内显示样式可自定义，不会被外部干扰\\n\\n目前仅支持三种容器块，`block-1`、`block-2`和`block-3`\\n\\n::: block-1\\n\\n### 容器块 1 示例\\n\\n> 读一本好书，就是在和高尚的人谈话。 **——歌德**\\n> :::\\n\\n::: block-2\\n\\n### 容器块 2 示例\\n\\n> 读一本好书，就是在和高尚的人谈话。 **——歌德**\\n> :::\\n\\n::: block-3\\n\\n### 容器块 3 示例\\n\\n> 读一本好书，就是在和高尚的人谈话。 **——歌德**\\n> :::\\n\\n### 4.8 分列\\n\\n> 支持平台：微信公众号。\\n\\n对于需要 2 列展示的内容，可以通过分列语法实现，可以设置左右比例，不设置时默认各为50%，示例如下：\\n\\n:::: column\\n::: column-left\\n\\n**左边的内容**\\n\\n![左边的图片](https://files.mdnice.com/blue.jpg)\\n\\n:::\\n::: column-right\\n\\n**右边的内容**\\n\\n![右边的图片](https://files.mdnice.com/green.jpg)\\n\\n:::\\n::::\\n\\n设置百分比示例如下：\\n\\n:::: column\\n::: column-left 30%\\n\\n**左边的内容**\\n\\n![左边的图片](https://files.mdnice.com/blue.jpg)\\n\\n:::\\n::: column-right 70%\\n\\n**右边的内容**\\n\\n![右边的图片](https://files.mdnice.com/green.jpg)\\n\\n:::\\n::::\\n\\n## 5 其他语法\\n\\n### 5.1 HTML\\n\\n支持原生 HTML 语法，请写内联样式，如下：\\n\\n<span style=\\\"display:block;text-align:right;color:orangered;\\\">橙色居右</span>\\n<span style=\\\"display:block;text-align:center;color:orangered;\\\">橙色居中</span>\\n\\n### 5.2 UML\\n\\n不支持，推荐使用开源工具`https://draw.io/`制作后再导入图片\\n\\n### 5.3 更多文档\\n\\n更多文档请参考 [mdnice 产品主页](https://product.mdnice.com/articles/ \\\"更多文档\\\")\",\"articleCover\":\"https://upload.haoxx.site/article/95bfa093fc995038d2b6e82aeab43625.jpg\",\"articleTitle\":\"微信公众号写文章工具墨滴\",\"articleType\":1,\"categoryName\":\"博客相关\",\"id\":94,\"isRecommend\":0,\"isTop\":0,\"status\":1,\"tagNameList\":[]}]','PUT','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',20,'2023-06-07 19:59:21');
INSERT INTO `t_operation_log` VALUES (1384,'文章模块','上传','/admin/article/upload','com.ican.controller.ArticleController.saveArticleImages','上传文章图片','image_86.jpg','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/article/716ceea8febe298c99a60b324b168a7e.jpg\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',13,'2023-06-07 19:59:30');
INSERT INTO `t_operation_log` VALUES (1385,'文章模块','修改','/admin/article/update','com.ican.controller.ArticleController.updateArticle','修改文章','[{\"articleContent\":\"# 网站导航记录\\n\\n来源于：CodeSheep的github：https://github.com/rd2coding/Road2Coding\\n\\n1、数据结构\\n\\nhttps://mp.weixin.qq.com/s/f9dfQQbpKjMopH6m2Gjiiw\\n\\n2、编程自学网站\\n\\nhttps://mp.weixin.qq.com/s/jFc-6QK2Mv1zHuhuFrqhog\\n\\n3、Linux系统性能监控小工具\\n\\ntop、htop、iftop等等\\nhttps://mp.weixin.qq.com/s/zWIv5yBTD0Tvt8txb8znrA\\n\\n4、程序员命令行生产力！：终端和命令\\n\\nhttps://mp.weixin.qq.com/s/k19ZT_yH4lzNLUYkH2GUJA\\n\\nCLI指的是： command-line  interface\\n\\n5、git官方中文说明文档\\n\\nhttps://developers.weixin.qq.com/miniprogram/dev/framework/\\n\\n6、微信小程序官方开发文档\\n\\nhttps://developers.weixin.qq.com/miniprogram/dev/framework/\\n\\n\\n\\n\\n\\n\",\"articleCover\":\"https://upload.haoxx.site/article/716ceea8febe298c99a60b324b168a7e.jpg\",\"articleTitle\":\"部分有用的网站记录\",\"articleType\":1,\"categoryName\":\"其他\",\"id\":93,\"isRecommend\":0,\"isTop\":0,\"status\":1,\"tagNameList\":[]}]','PUT','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',18,'2023-06-07 19:59:31');
INSERT INTO `t_operation_log` VALUES (1386,'文章模块','上传','/admin/article/upload','com.ican.controller.ArticleController.saveArticleImages','上传文章图片','image_93.jpg','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/article/2fcfdfae4d9133ae7d74c18af1dcf632.jpg\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',20,'2023-06-07 19:59:48');
INSERT INTO `t_operation_log` VALUES (1387,'文章模块','修改','/admin/article/update','com.ican.controller.ArticleController.updateArticle','修改文章','[{\"articleContent\":\"---\\ntitle: markdown之frontmatter设置\\ndate: 2021-2-15 20:00:01\\ntag:\\n - tag4\\ncategory: \\n - markdown基本规则\\npublish: true\\nfooter: <a href=\\\"https://beian.miit.gov.cn/#/Integrated/index\\\">渝ICP备2023001651号</a>\\n\\n---\\n\\n:::tip\\n这篇文档主要是总结文章的前页（frontmatter）参数设置。参考了vuepress-theme-hope官网上的资料[点击查看](https://theme-hope.vuejs.press/zh/config/frontmatter/info.html)\\n:::\\n\\n<!-- more -->\\n\\n## 注意！\\n\\n文章的前页使用yaml语言来设计的，其格式为`选项:[空格]选项值`。\\n\\n## 基本设置\\n\\n建议的选项有：\\n\\n- title：文章标题（当前页面内容标题，默认为 Markdown 文件中的第一个 h1 标签内容。）\\n- description：当前页面内容描述，字符串类型\\n  -icon：图标，字符串，[图标指南](https://theme-hope.vuejs.press/zh/guide/interface/icon.html) ，一共有三类图标，我们在主题配置文件中选择的是Iconfont，所以在[这个图标网站](https://www.iconfont.cn/)上去找我们需要的图标名。\\n- author：作者，字符串类型\\n- isOriginal：是否原创，布尔，默认为false\\n- date：时间，注意格式为`YYYY-MM-DD` 或`YYYY-MM-DD hh:mm:ss`\\n- category：分类，字符串或字符串数组\\n- tag：标签，字符串或字符串数组\\n- sticky：是否在列表中指定，类型为`boolean | number`，当填入数字时，取值越大排名越靠前，默认为false\\n- star：是否收藏进博客的文章列表，类型为`boolean | number`，当填入数字时，取值越大排名越靠前，默认为false\\n\\n## 其他设置--信息类的frontmatter\\n\\n下面这些是扩展性设置\\n\\n- article：是否将该文章添加至文章列表中，布尔，默认为true\\n- timeline：是否将该文章添加至时间线中。布尔，默认为true\\n- image：设置预览图 (分享图)，请填入绝对路径，字符串\\n- banner：设置横幅图片 (宽屏分享图)，请填入绝对路径，字符串\\n\\n## 其他设置--布局的frontmatter\\n\\n下面这些是扩展性设置\\n\\n- pageview：是否开启浏览量显示，布尔，默认为true\\n- comment：是否开启评论显示，布尔，默认为true\\n- breadcrumb：是否开启路径导航\\n- breadcrumbIcon：是否开启路径导航图标\\n- navbar：导航栏配置，填入 false 会禁用导航栏\\n- sidebar：侧边栏配置选项。支持 \\\"heading\\\" 或 false\\n- headerDepth：标题渲染深度，默认为2\\n- index：是否在侧边栏中索引当前页面，布尔，默认为true\\n- order：指定当前页面在侧边栏中的排序\\n  - 当填写正数的时候，页面将排在靠前的位置，数字越小出现的位置越前。\\n  - 当填写负数的时候，页面将排在靠后的位置，数字越大出现的位置越前（比如 -1 在 -2 之后）。\\n- lastUpdated：是否显示最后更新时间，默认值: 主题选项中的值\\n- editLink：是否显示编辑链接，布尔，默认值: 主题选项中的值\\n- contributors：是否显示贡献者，布尔，默认值: 主题选项中的值\\n- footer：设置页脚内容。\\n  - 设置为 false 以禁用页脚\\n  - 设置为 \\\"\\\" 以移除默认的页脚内容，\\n  - 设置为 true 以使用默认页脚。\\n\\n更多详情请看 [页面 → 页脚支持](https://theme-hope.vuejs.press/zh/guide/layout/footer.html)\\n\\n- copyright：设置版权信息，更多详情请看[页面，页脚支持](https://theme-hope.vuejs.press/zh/guide/layout/footer.html)\\n\\n## 文档主页的frontmatter设置\\n\\n## 博客主页的frontmatter设置\\n\\n## 某些插件的frontmatter设置\\n\\n版权页copyroght2插件，feed2插件，sitmap2插件\\n\",\"articleCover\":\"https://upload.haoxx.site/article/2fcfdfae4d9133ae7d74c18af1dcf632.jpg\",\"articleTitle\":\"markdown之脚注设置\",\"articleType\":1,\"categoryName\":\"markdown\",\"id\":92,\"isRecommend\":0,\"isTop\":0,\"status\":1,\"tagNameList\":[]}]','PUT','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',17,'2023-06-07 19:59:49');
INSERT INTO `t_operation_log` VALUES (1388,'文章模块','上传','/admin/article/upload','com.ican.controller.ArticleController.saveArticleImages','上传文章图片','image_94.jpg','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/article/93c917e6b636c7a56c9473e6c29a3081.jpg\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',14,'2023-06-07 19:59:56');
INSERT INTO `t_operation_log` VALUES (1389,'文章模块','修改','/admin/article/update','com.ican.controller.ArticleController.updateArticle','修改文章','[{\"articleContent\":\"---\\ntitle: markdown基本规则学习笔记\\ndate: 2021-2-15 20:00:01\\ntag:\\n - tag4\\ncategory: \\n - markdown基本规则\\npublish: true\\nfooter: <a href=\\\"https://beian.miit.gov.cn/#/Integrated/index\\\">渝ICP备2023001651号</a>\\n\\n---\\n\\n:::tip\\nMakeDown的基本书写规则\\n:::\\n\\n<!-- more -->\\n\\n\\n\\n@(示例笔记)[马克飞象|帮助|Markdown]\\n说明：TOC为table of contents，即目录表，语法为：`[[TOC]]`\\n\\n是撒啊阿萨\\n\\n飒飒飒订单\\n\\n\\n\\n[[TOC]]\\n\\n\\n<Boxx  changeTime=\\\"5000\\\" />\\n\\n\\n```yaml\\n插入名人名言：<Boxx />\\n\\n使用title和content属性自定义文字：<Boxx type=\'tip\' tilte=\'Haoxx\' content=\'勤能补拙，懒惰则一事无成\' />\\n```\\n\\n<Boxx type=\'tip\' tilte=\'Haoxx\' content=\'勤能补拙，懒惰则一事无成\'/>\\n\\nchangeTime=\\\"1000\\\" 指定更新时间，单位为ms\\n\\n<Boxx type=\\\"danger\\\" changeTime=\\\"5000\\\"    title=\\\"我是一个大大的且变化的 title\\\" content=\'文本\' />\\n\\n## 1、标题\\n\\n标题：一级标题用“#+**空格**+文字”的格式，二级标题用“##+**空格**+文字”的格式，以此类推。\\n\\n## 1.1 新增（vuepress中可用）\\n\\n你可以在标题中，使用这个Badge组件来为某些 API（标题） 添加一些状态：\\n\\n```yaml\\n### 标题名 <标题名 text=\\\"beta\\\" type=\\\"warning\\\"/> <标题名 text=\\\"默认主题\\\"/>\\n\\ntype可以换成tip、warning、danger  details\\n```\\n\\n## 2、粗体\\n\\n* 粗体\\n  粗体的格式是：前后各两个星号 `**测试**` ，效果为：**测试**\\n* 斜体\\n  斜体的格式是：前后各一个星号 `*测试*`，效果为：*测试*\\n* 分隔符\\n  分隔符的格式是：三个星号 `***` ,或者连续三个短横线`---`，效果为：\\n\\n***\\n\\n## 3、换行\\n\\n1. 段内换行\\n   段内换行使用“结尾空两个空格再回车”的方式。\\n\\n2. 段落换行\\n   向下空一行\\n\\n3. 空多行\\n   使用HTML的\\\\<br>标签来实现\\n\\n4. 附加说明\\n   在使用typora软件时，`三个换行`表示真正的换行；\\\"四个空格\\\"功能未知。\\n\\n   \\n\\n## 4、列表\\n\\n1. 无序列表\\n   一般用“\\\\*号+**空格**+内容”或者“+号+**空格**+内容”，再或者“-号+**空格**+内容”。\\n\\n&emsp;&emsp;<font color=\'red\'>怎么做</font>：`* 列表内容`或`+ 列表内容`或`- 列表内容` ，效果为：\\n\\n- 列表测试\\n\\n\\n2. 有序列表\\n   格式为：\\\"1.+空格+项目1\\\"\\n\\n&emsp;&emsp;<font color=\'red\'>怎么做</font>：`1. 有序列表`\\n\\n3. 列表嵌套\\n   在上层列表下“添加四个空格”即可。\\n\\n&emsp;&emsp;<font color=\'red\'>怎么做</font>：\\n\\n```markdown\\n- 列表1\\n[四个空格]- 列表1.1\\n```\\n\\n效果为：\\n\\n- 列表1\\n  - 列表1.1\\n\\n## 5、引用\\n\\n1. 引用\\n   “>”加上空格，就是引用。\\n2. 多层引用\\n   “>>”加上空格，就是多层引用。\\n\\n> 引用1\\n> 继续\\n\\n>> 二级引用\\n>\\n>>> 三级引用\\n\\n## 6、代码\\n\\n1. 段落文字中的代码\\n   文字中的代码，用反引号`printf(\\\"hello,world!\\\");`包裹。\\n2. 独立代码块\\n   独立的代码块用三个反引号包含，并指明类型，如：\\n\\n```c\\nprintf(\\\"hello,world!\\\");\\n```\\n\\n\\n\\n## 7、链接\\n\\n1. 方式1 []和（）\\n   格式为：\\\\[链接名](链接地址)\\n   圆括号中可以为网络地址，也可以为本地的绝对地址、相对地址。\\n   例如：[VSCode背景图](C:\\\\backgroud.jpg)  ，\\n   可以添加链接的标题：\\\\[VSCode背景图](C:\\\\backgroud.jpg \\\"链接的标题\\\") \\n2. 方式2 采用类似参考文献的格式\\n   类似于参考文献，\\\\[链接名][1]   ,然后在文件内容的最后面，写上[1]:链接地址\\n\\n\\n\\n## 8、图片\\n\\n图片的插入和链接类似，可以网络，也可以本地。\\n格式为：\\\\!\\\\[图片名](图片的地址)\\n例如：\\\\!\\\\[VSCode背景图](C:\\\\backgroud.jpg)\\n再比如：![网络图片](https://imgtu.com/i/ObErMq)\\n\\n## 9、表格\\n\\n表格用“|”来分隔。&emsp;&emsp;<font color=\'red\'>怎么做</font>：\\n\\n```markdown\\n|表头1|表头2|\\n|---|:----:|\\n|单元格1|单元格2|\\n```\\n\\n效果如下所示：\\n\\n| 表头1   |  表头2  |\\n| ------- | :-----: |\\n| 单元格1 | 单元格2 |\\n\\n注意：（空一行表示表格结束）短横线做分割线，至少要三个。\\n说明：用冒号:来设置左右对齐方式，如`左对齐：\\\":单元格\\\" `；`右对齐 “单元格:”`；`居中： “:单元格:”`。\\n\\n\\n\\n## 10、markdown高级\\n\\n1、支持使用HTML标签\\n除了用过的`<br>`表示换行以外，`<kbd>`表示用小框框把指定文字框起来，如<kbd>测试</kbd>\\n其他的还有，如 \\\\<kbd>  \\\\<b> \\\\<i> \\\\<em> \\\\<sup>  \\\\<sub>,还有\\\\<img src = https://xx.png alt=\\\"我的图片\\\" style=\\\"zoom:33%\\\">\\\\</img>\\n2、双`$`符号\\n`$$`符号用来表示公式，格式如：\\n\\n```latex\\n$$\\n-xxx-\\n$$\\n```\\n\\n此外，行间公式`$a+b=c$`  ，或者块级公式：\\n`$$ a+b=c $$`\\n\\n## 11、markdown语法的后续补充\\n\\n(1)、**高亮**格式： ==高亮的内容==  ，说明：该部分内容在“typora->文件->偏好设置->Markdown->Markdown扩展语法”中的对应选项要先勾选上才会生效。\\n\\n&emsp;&emsp;<font color=\'red\'>怎么做</font>：`==高亮的内容== `\\n\\n(2)、**删除线**：~~alt+shift+5~~  ，文字的前后加上两个波浪号。\\n\\n&emsp;&emsp;<font color=\'red\'>怎么做</font>：`~~alt+shift+5~~`\\n\\n(3)、**加粗**：前后两个星号,ctrl+B\\n\\n&emsp;&emsp;<font color=\'red\'>怎么做</font>：`**ctrl+b**`\\n\\n(4)、**斜体**：前后一个星号,ctrl+I\\n\\n&emsp;&emsp;<font color=\'red\'>怎么做</font>：`*ctrl+b*`\\n\\n(5)、**下划线**：<u>ctrl+u</u>   前后加上\\\\<u>和\\\\</u>\\n\\n&emsp;&emsp;<font color=\'red\'>怎么做</font>：`<u>ctrl+u</u>`\\n\\n(6)、**表格** ctrl+t\\n\\n&emsp;&emsp;<font color=\'red\'>怎么做</font>：1) 使用`ctrl+t`弹出表格创建提示框； 2) 使用以下语法来创建表格：\\n\\n```markdown\\n|英文代码|对应颜色|----|英文代码|对应颜色|\\n|:-----|:-----:|:--:|:----:|:-----:|  //表头和内容的分割符号\\n\\n//其中：|:--:|表示居中对齐，|:--|表示左对齐\\n\\n|red|红色|----|purple|紫色|\\n|green|绿色|----|skyblue|天蓝色|\\n|blue|蓝色|----|lightgreen|淡绿色|\\n|Gold|金色|----|grey|灰色|\\n|Orange|橙色|----|blueviolet|深紫罗兰色|\\n```\\n\\n效果为：\\n\\n| 英文代码 | 对应颜色 | ---- |  英文代码  |  对应颜色  |\\n| :------- | :------: | :--: | :--------: | :--------: |\\n| red      |   红色   | ---- |   purple   |    紫色    |\\n| green    |   绿色   | ---- |  skyblue   |   天蓝色   |\\n| blue     |   蓝色   | ---- | lightgreen |   淡绿色   |\\n| Gold     |   金色   | ---- |    grey    |    灰色    |\\n| Orange   |   橙色   | ---- | blueviolet | 深紫罗兰色 |\\n\\n(7)、**流程图**\\n\\n&emsp;&emsp;<font color=\'red\'>怎么做</font>： 使用以下语法来创建表格：\\n\\n```markdown\\n//[这里有三个反引号]flow\\nst=>start: Start\\ne=>end\\nop=>operation: My Operation\\ncond=>condition: Yes or No?\\n\\nst->op->cond\\ncond(yes)->e\\ncond(no)->op\\n[这里有三个反引号]\\n```\\n\\n下面就是上述代码的渲染效果了：\\n\\n```flow\\nst=>start: Start\\ne=>end\\nop=>operation: My Operation\\ncond=>condition: Yes or No?\\n\\nst->op->cond\\ncond(yes)->e\\ncond(no)->op\\n```\\n\\n(8)、**时序图**\\n\\n&emsp;&emsp;<font color=\'red\'>怎么做</font>： 使用以下语法来创建表格：\\n\\n```markdown\\n[这里有三个反引号]sequence\\nAlice->Bob: Hello Bob, how are you?\\nNote right of Bob: Bob thinks\\nBob-->Alice: I am good thanks!\\n[这里有三个反引号]\\n```\\n\\n下面就是上述代码的渲染效果了：\\n\\n```sequence\\nAlice->Bob: Hello Bob, how are you?\\nNote right of Bob: Bob thinks\\nBob-->Alice: I am good thanks!\\n```\\n\\n(9)、**复选框**\\n\\n&emsp;&emsp;<font color=\'red\'>怎么做</font>： 使用`- []`和`- [x]`语法来创建复选框，实现todo-list功能。\\n\\n- [x] 已完成事项\\n- [ ] 代办事项 \\n\\n(10)、**上下标**\\n\\n&emsp;&emsp;<font color=\'red\'>怎么做</font>： 上标：`x^2^`，下标：`H~2~O`。\\n\\n效果如下：\\n\\n上标： x^2^\\n下标：H~2~O\\n\\n(11)、**链接和脚注**\\n\\n链接在前面已经说过了，这里简单再提一下：\\\\[链接名](链接地址)\\n\\n&emsp;&emsp;<font color=\'red\'>怎么做</font>：脚注的格式是： \\n\\n```markdown\\n在待脚注的位置写上A`[^1]`。是多少\\n\\n然后在后文，空一行，再加上：B`[^1]:脚注的内容`\\n\\n这部分脚注B的内容会被移动到文章的最末尾显示，并且会在A处留校一个可以跳转的链接，同时B处也有往回跳转的链接。主要注意的是，上述A和B仅是为了方便说明，实际使用是不要加上这两个字符。\\n\\n```\\n\\n下面是脚注的效果：\\n\\n脚注的格式是： 在待脚注的位置写上[^1]。是多少\\n\\n[^1]: 示例：脚注的内容\\n\\n(12)、**实现空格**\\n\\n&emsp;&emsp;<font color=\'red\'>怎么做</font>：用该字符`&emsp;`来实现一个空字符，对于某些需要首行缩进两个字符的情况，使用两个字符来实现：`&emsp;&emsp;`\\n\\n\\n\\n## 12、修改字体颜色\\n\\n格式为：`<font color=\'orange\'>并发</font>`\\n效果为：<font color=\'blueviolet\'>测试</font>\\n里面可以找找好看的颜色对应的标签名：[配色网](https://www.flatuicolorpicker.com/)\\n常用的标签如下表格所示：\\n\\n| 英文代码 | 对应颜色 | ---- |  英文代码  |  对应颜色  |\\n| :------: | :------: | :--: | :--------: | :--------: |\\n|   red    |   红色   | ---- |   purple   |    紫色    |\\n|  green   |   绿色   | ---- |  skyblue   |   天蓝色   |\\n|   blue   |   蓝色   | ---- | lightgreen |   淡绿色   |\\n|   Gold   |   金色   | ---- |    grey    |    灰色    |\\n|  Orange  |   橙色   | ---- | blueviolet | 深紫罗兰色 |\\n\\n**说明**：标签首字母的大写可以不用大写，但是为了单词的可读性，建议首字母大写，如BlueViolet。\\n\\n\\n## 13、分割线\\n\\n可以在一行中用三个以上的减号来建立一个分隔线，同时需要在分隔线的上面空一行。\\n\\n## 14、makedown在vuepress中的扩展语法--之容器\\n\\n::: info\\n信息容器。\\n:::\\n\\n::: note\\n注释容器。\\n:::\\n\\n::: tip\\n提示容器\\n:::\\n\\n::: warning\\n警告容器\\n:::\\n\\n::: danger\\n危险容器\\n:::\\n\\n::: details\\n详情容器\\n:::\\n\\n\\n::: theorem 牛顿第一定律\\n假若施加于某物体的外力为零，则该物体的运动速度不变。\\n:::\\n\\n\\n::: right\\n来自 [维基百科](https://zh.wikipedia.org/wiki/%E7%89%9B%E9%A1%BF%E8%BF%90%E5%8A%A8%E5%AE%9A%E5%BE%8B)\\n:::\\n\\n补充说明，对于badge标签，支持的类型有：类型: \\\"tip\\\" | \\\"warning\\\" | \\\"danger\\\" | \\\"info\\\" | \\\"note\\\"，默认值为info\\n\\n## 15、流程图\\n\\n下面这个流程图的代码为：\\n\\n```markdown\\n[这里有三个反引号]flow\\ncond=>condition: Process?\\nprocess=>operation: Process\\ne=>end: End\\n\\ncond(yes)->process->e\\ncond(no)->e\\n[这里有三个反引号]\\n```\\n\\n效果为：\\n\\n```flow\\ncond=>condition: Process?\\nprocess=>operation: Process\\ne=>end: End\\n\\ncond(yes)->process->e\\ncond(no)->e\\n```\",\"articleCover\":\"https://upload.haoxx.site/article/93c917e6b636c7a56c9473e6c29a3081.jpg\",\"articleTitle\":\"markdown基本规则学习笔记\",\"articleType\":1,\"categoryName\":\"markdown\",\"id\":91,\"isRecommend\":0,\"isTop\":0,\"status\":1,\"tagNameList\":[]}]','PUT','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',23,'2023-06-07 19:59:58');
INSERT INTO `t_operation_log` VALUES (1390,'文章模块','上传','/admin/article/upload','com.ican.controller.ArticleController.saveArticleImages','上传文章图片','image_80.jpg','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/article/da9646e2e30563537d21e5a36a4ac461.jpg\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',17,'2023-06-07 20:00:06');
INSERT INTO `t_operation_log` VALUES (1391,'文章模块','修改','/admin/article/update','com.ican.controller.ArticleController.updateArticle','修改文章','[{\"articleContent\":\"---\\ntitle: 代码随想录学习笔记[总结]\\ndate: 2023-04-12\\ncategory:\\n - 找工作相关\\nstar: true\\ncover: \\\"https://w.wallhaven.cc/full/72/wallhaven-7286w9.png\\\"\\narticle: true\\nfooter: <a href=\\\"https://beian.miit.gov.cn/#/Integrated/index\\\">渝ICP备2023001651号</a>\\n\\n---\\n\\n:::tip\\n这是在学习代码随想录网站上的知识时，所做的一部分笔记\\n:::\\n\\n<!-- more -->\\n\\n\\n代码随想录学习笔记--文章修订记录：\\n\\n+ 2023/04/11 第一版仍在撰写\\n\\n\\n[[TOC]]\\n\\n## 一、数组\\n\\n数组和链表是数组结构中的基本数据结构。数组的特点是查询方便，链表的特点是插入/删除方便。还有个特点是，数组一般长度固定，二链表长度可以扩展。在存储方面的特点是，数组元素连续存储，链表元素不连续。\\n\\n数组是存放在连续内存空间上的想同类型数据的集合。数组的特点是元素下标从0开始，元素存储空间连续。数组的元素不能删，只能覆盖。\\n\\n二维数组在内存中如何存储的？对于cpp而言，二维数组在内存空间中也是连续存储的。对于Java而言，同一行下的数组元素存储式连续的，二不同行之间的数据不是连续存储的。类似于哈希表一样，用链表将多个行数组串联起来。\\n\\n在数组部分的知识点有：\\n\\n+ 二分查找\\n+ 移除元素\\n+ 有序数组的平方\\n+ 长度最小的子数组\\n+ 螺旋矩阵2\\n\\n### 1.1 二分查找\\n\\n前提必须是有序、不重复数组才能使用二分查找（已经按照从小到大或者从大到小的顺序排好了）。通过将数组中间元素值作为分割点，将数组分割为两部分，来减小一半的搜索量。通过比较数组中间元素值和target值，来更新left和right索引值。\\n\\n这里强调无重复元素是因为一旦有重复元素就会使得二分查找的返回值不唯一。二分查找的关键在于边界条件的框定。区间的定义是不变量，在循环过程中要遵循循环不变量原则。如果一开始就定义区间为左闭右闭，那就在循环中移植保持这种状态不改变。\\n\\n1. 第一种写法：左闭右闭。定义target在[left,right]区间中，所以有以下两点：\\n\\n+ `while(left <= right) `要用` <=` ，因为`left == right`是有意义的；\\n+ `if (nums[middle] > target)` 目标值偏小，搜索区间选择左侧子空间。那么right要赋值为`middle-1`，因为当前这个`nums[middle]`一定不是target，那么接下来要查找的左侧子区间的右端下标位置就从`middle-1`开始。\\n\\n2. 第二种写法：左闭右开。定义target在[left,right )区间中，所以有以下两点：\\n\\n+ `while(left < right)` 要用 < ，因为`left == right`是没有意义的，数组值不能够取值right；\\n+ `if (nums[middle] > target) `目标值偏小，搜索区间选择左侧子空间。那么right要赋值为middle，因为当前这个`nums[middle]`不等于target，那么接下来要查找的左侧子区间的右端下标位置就从middle开始。\\n\\n### 1.2 移除元素\\n\\n**问题描述**：给你一个数组和一个val，你需要原地移除数组中所有值等于val的元素，并返回移除后数组的新长度。要求：不能使用额外的数组空间，你必须使用O(1)额外空间并原地修改输入数组。例如，给定数组nums=[0,1,2,3,0,2,1,0,9,8,0,3],val=0,则新数组为[1,2,3,2,1,9,8,3]，返回长度为8。当然，返回数组的元素是否需要保存原有的相对位置并未作出限制。\\n\\n如何解决呢？1）使用双层for循环的暴力解法可以解决。外层for循环用来遍历数组，内层for循环用来更新删除元素后面的数组元素，将后面的元素依次向前挪一位来覆盖待删除的元素。时间复杂度为O(n2)。\\n\\n```cpp\\nint removeElement(vector<int>&nums, int val) {\\n\\tint size = nums.size();\\n\\tfor (int i = 0; i < size; i++) {\\n\\t\\tif (val == nums[i]) {\\n\\t\\t\\tfor (int j = i; j < size-1; j++) {\\n\\t\\t\\t\\t\\tnums[j] = nums[j+1];\\n\\t\\t\\t}\\n\\t\\ti--; //因为下标i以后的数据往前挪了一位，所以i也往前挪一位\\n\\t\\tsize--;\\n\\t\\t}\\n\\t} \\n\\treturn size;\\n}\\n```\\n\\n//上述代码的时间复杂度为O(n^2)，空间复杂度为O(1)。\\n\\n2）使用双指针法。通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。**快指针**：遍历整个数组，用来寻找新数组的元素，新数组就是不含目标元素值的数组。**慢指针**：指向更新后的新数组最后元素的下标。\\n\\n```cpp\\nfor (int fastIndex = 0; fastIndex < nums.size(); fastIndex++) {\\n    if (val != nums[fastIndex]) {\\n    \\tnums[slowIndex++] = nums[fastIndex];\\n    }\\n}\\n```\\n\\n//上述代码的时间复杂度为O(n)，空间复杂度为O(1)。\\n\\n### 1.3 有序数组的平方\\n\\n在这部分，主要考虑不管是包含负数还是不包含负数，数组元素的平方最大值一定在两端，绝不会在中间。所以对于题目要求的给定一个非递减顺序排序的整数数组，返回每个元素的平方组成的新数组，要求也按照非递减的顺序排序。可以确定的是，平方后的元素最大值一定在两端，所以最后的结果数组可以先从nums.size()-1元素先填值，最后在填充nums[0]的值。综上所述，有：\\n\\n```cpp\\nvector<int> sortedSquares(vector<int>&A) {\\n\\tvector<int> result(A.size(),0);\\n\\tint k = A.size() – 1;\\n\\t//注意：这里要i <= j，因为最后要处理两个元素\\n\\tfor(int i = 0,int j = A.size()-1; i < A.size();i <= j) {\\n\\t\\tif (A[i]*A[i] > A[j]*A[j]) {\\n\\t\\t\\t\\tresult[k--] = A[i]*A[i];\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tresult[k--] = A[j]*A[j];\\n\\t\\t\\tj--;\\n\\t\\t}\\n\\t}\\n\\treturn result;\\n}\\n```\\n\\n双指针法的时间复杂度为O(n)。\\n\\n补充说明：暴力解法：先平方，再排序。\\n\\n```cpp\\nvector<int> sortedSquares(vector<int>& A) {\\n\\tfor(int i = 0; i < A.size();i++) {\\n\\tA[i]*=A[i];\\n\\t}\\n\\tsort(A.begin(),A,end()); //快速排序\\n\\treturn A;\\n}\\n```\\n\\n时间复杂度为`O(n+nlogn)`，可以说是`O(nlogn)`。\\n\\n### 1.4 长度最小的子数组\\n\\n**题目**：给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。例如输入：s = 7, nums = [2,3,1,2,4,3] 输出：2 解释：子数组 [4,3] 是该条件下的长度最小的子数组。\\n\\n先介绍暴力解法：使用双层for循环来求解。外层for[i]循环用来遍历整个数组，内层for[j]循环从i开始遍历，直至元素之和大于等于s后才停止，然后此时就计算单次数组长度subLength，并更新整体最小数组长度result。\\n\\n```cpp\\nint minSubArrayLen(int s, vector<int> &nums) {\\nint result = INT32_MAX;\\nint subLength = 0;\\nint sum = 0;\\nfor(int i = 0; i < nums.size(); i++) {\\n\\tsum = 0;\\n\\tfor(int j=i ; j< nums.size();j++) {\\n\\t\\tsum += nums[j];\\n\\t\\tif (sum >= s) {\\n\\t\\t\\tsubLength = j-i+1;\\n\\t\\t\\tresult = result < subLength ? result : subLength;\\n\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\nreturn result == INT32_MAX? 0 : result;\\n}\\n```\\n\\n前面讲了暴力算法是用两个for循环来实现的，外层的for[i]的作用是遍历整个数组并提供窗口的起始位置，内层for[j]的作用设置满足条件的窗口终止位置。这样的缺点就是时间复杂度高，为O(n2)。类似的，我们可以考虑用滑动窗口来替换一个for循环，降低时间复杂度。那个滑动窗口的起始点如何确定呢？\\n\\n接下来就开始介绍数组操作中另一个重要的方法：滑动窗口。所谓滑动窗口，**就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果**。\\n\\n在暴力解法中，是一个for循环滑动窗口的起始位置，一个for循环为滑动窗口的终止位置，用两个for循环完成了一个不断搜索区间的过程。那么滑动窗口如何用一个for循环来完成这个操作呢。首先要思考如果用一个for循环，那么应该表示滑动窗口的起始位置，还是终止位置。\\n\\n如果用for[i]来指定滑动窗口的起始位置，那最终就会陷入暴力算法的怪圈，所以for[i]应当是来指定滑动窗口的终止位置。\\n\\n> 滑动窗口的终止位置（如何移动）：由for[i]指定，就是遍历数组的指针\\n> 滑动窗口内的元素：满足其和大于等于s条件最短子数组\\n> 滑动窗口的起始条件（如何移动）：如果窗口内的元素之和大于等于s之后，需要向前进来缩小窗口内的值。\\n\\n下面这段代码就是滑动窗口，此代码的精髓就在于动态调节滑动窗口的起始位置：\\n\\n```cpp\\nwhile(sum >= s) {\\n\\tsubLength = j – i + 1; //取子序列的长度\\n\\tresult = result < subLength ? result : subLength;\\n\\tsum -= nums[i++]; //这里体现出滑动窗口的精髓之处，不断变更i（子序列的起始位置）\\n}\\n```\\n\\n使用滑动窗口法（单for循环）来解题：\\n\\n```cpp\\nint minSubArrayLen(int s,vector<int> &nums) {\\n\\tint subLength = 0;\\n\\tint result = INT32_MAX;\\n\\tint sum = 0;\\n\\tint i = 0; //窗口的起始位置\\n\\tfor(int j = 0; j < nums.size(); j++) {\\n\\t\\tsum+=nums[j];\\n\\t\\twhile (sum >= s) {\\n\\t\\t\\tsubLength = j – i + 1;\\n\\t\\t\\tresult = result < subLength ? result : subLength;\\n\\t\\t\\tsum-=nums[i++];// 这里体现出滑动窗口的精髓之处，不断变更i（子序列的起始位置）\\n\\t\\t}\\n\\t}\\n\\treturn result == INT32_MAX ? 0 : result;\\n}\\n```\\n\\n### 1.5 螺旋矩阵2\\n\\n**题目**：给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。例如，给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。\\n\\n这道题目可以说在面试中出现频率较高的题目，本题并不涉及到什么算法，就是模拟过程，但却十分考察对代码的掌控能力。\\n\\n在之前二分查找法中就提到过的循环不变量原则，这里同样适用。这里是模拟顺时针画矩阵的过程：\\n\\n+ 填充上行从左到右；\\n+ 填充右行从上到下；\\n+ 填充下行从右到左；\\n+ 填充左行从下到上；\\n\\n由外向内一圈一圈这样画下去。这里一圈下来，我们要画每四条边，这四条边怎么画，每画一条边都要坚持一致的左闭右开，或者左开右闭的原则，这样这一圈才能按照统一的规则画下来。下图是按照左闭右开的原则来画的。\\n\\n<div align=center>\\n<img src = \'https://s3.bmp.ovh/imgs/2023/03/24/eea1feac93f415db.png\' >\\n</div>\\n\\n最后，整体cpp代码如下所示：\\n\\n```cpp\\nvector<vector<int>> generateMatrix(int n) {\\n\\tvector<vector<int>> res(n, vector<int>(n, 0)); // 使用vector定义一个二维数组\\n\\tint startx = 0, starty = 0; // 定义每循环一个圈的起始位置\\n\\tint loop =n/2;//每个圈循环几次，例如n为奇数3，那么loop=1只是循环一圈，矩阵中间的值需要单独处理\\n\\tint mid = n / 2; // 矩阵中间的位置，例如：n为3， 中间的位置就是(1，1)，n为5，中间位置为(2, 2)\\n\\tint count = 1; // 用来给矩阵中每一个空格赋值\\n\\tint offset = 1; // 需要控制每一条边遍历的长度，每次循环右边界收缩一位\\n\\tint i,j;\\n\\twhile (loop --) {\\n\\t\\ti = startx;\\n\\t\\tj = starty;\\n\\t\\t// 下面开始的四个for就是模拟转了一圈\\n\\t\\t// 模拟填充上行从左到右(左闭右开)\\n\\t\\tfor (j = starty; j < n - offset; j++) {\\n\\t\\t\\tres[startx][j] = count++;\\n\\t\\t}\\n\\t\\t// 模拟填充右列从上到下(左闭右开)\\n\\t\\tfor (i = startx; i < n - offset; i++) {\\n\\t\\t\\tres[i][j] = count++;\\n\\t\\t}\\n\\t\\t// 模拟填充下行从右到左(左闭右开)\\n\\t\\tfor (; j > starty; j--) {\\n\\t\\t\\tres[i][j] = count++;\\n\\t\\t}\\n\\t\\t// 模拟填充左列从下到上(左闭右开)\\n\\t\\tfor (; i > startx; i--) {\\n\\t\\t\\tres[i][j] = count++;\\n\\t\\t}\\n\\t\\t// 第二圈开始的时候，起始位置要各自加1，例如：第一圈起始位置是(0, 0)，第二圈起始位置是(1, 1)\\n\\t\\tstartx++;\\n\\t\\tstarty++;\\n\\t\\t// offset 控制每一圈里每一条边遍历的长度\\n\\t\\toffset += 1;\\n\\t}\\n\\t// 如果n为奇数的话，需要单独给矩阵最中间的位置赋值\\n\\tif (n % 2) {\\n\\t\\t res[mid][mid] = count;\\n\\t}\\n\\treturn res;\\n}\\n```\\n\\n### 1.6 总结篇\\n\\n数组是非常基础的数据结构，它是存放在连续内存空间上的相同类型数据的集合。需要注意的是，数组下标从0开始，且数组内存空间地址都是连续的。正因为数组在内存空间上的地址是连续的，所以在增删元素时就难免需要移动其他元素。数组元素不能删除，只能覆盖。对于二维数组，在cpp中是连续存储的，而Java中单行数组是连续存储的，而行与行之间是连接在一个链表上，并非连续存储。所以Java的二维数组在内存中不是完全连续的地址空间，而是由（行数）条连续地址空间构成，每个连续地址空间的长度是列数。\\n\\n<div align=center>\\n<img src = \'https://s3.bmp.ovh/imgs/2023/03/24/f9f79f108b25c45d.png\' >\\n</div>\\n\\n数组基础的一些经典题目有二分查找、双指针法、滑动窗口法还有模拟行为。\\n\\n<div align=center>\\n<img src = \'https://s3.bmp.ovh/imgs/2023/03/24/65074287759d1295.png\' >\\n</div>\\n\\n## 二、链表\\n\\n链表与数组一样，都是线性结构，不过数组各个元素之间是连续存储，而链表是分散存储。也正因为该特性，链表在增删方面的效率要高于数组，但是相对的在查找方面的效率要低于数组。链表的种类有：单链表、双向链表、循环链表。循环链表可以用来解决约瑟夫环问题。\\n\\n约瑟夫环问题：0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。**例如**：0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。\\n\\n链表的定义(//单链表)：\\n\\n```cpp\\nstruct ListNode {\\n\\tint val;\\n\\tListNode *next;\\n\\tListNode(int x) : val(x),next(NULL) {} //节点的构造函数\\n}；\\n```\\n\\n注意，你也可以不定义构造函数，cpp会自动生成默认的构造函数，但该构造函数不会初始化任何成员变量。使用默认的构造函数来初始化节点：`ListNode* head = new ListNode(),head->val = 5`。使用自定的节点构造函数则为：`ListNode* head = new ListNode(5)`;所以，对于使用默认的构造函数，是不能再定义时直接赋值的。链表的头指针是一定存在的，它指向第一个节点，是链表的标志。头结点不一定存在，**但是如果头结点存在，那么操作第一个节点的增删就和其他节点的增删操作是一样的了**。如果在链表的listcreat创建函数中有开辟空间的操作，一般就是有头结点的（例如以前写的C语言链表操作）。在这里的cpp代码中链表的创建是通过结构体和new操作的，没有创建额外的空间，是没有头结点的。头结点就是在头指针和第一个节点之间，添加的节点值为无效值的节点。\\n\\n**链表的操作**：删除节点、增加节点。对于C/cpp的链表删除节点操作，最好要进行内存的手动释放，避免内存泄漏，而Java和Python无需手动释放。下面是单链表的添加节点和删除节点操作。\\n\\n<div align=center>\\n<img src = \'https://s3.bmp.ovh/imgs/2023/03/24/8564202a88941271.png\' >\\n</div>\\n\\nF节点为new节点，C节点为p，则**添加**新节点可以表达为1）`new->next=p->next;2）p->next=new`。\\n\\n<div align=center>\\n<img src = \'https://s3.bmp.ovh/imgs/2023/03/24/9cb09bc8cb8823ba.png\' >\\n</div>\\n\\n**删除**节点可以表达为：`if(p->next->val == val)，ListNode* tmp=p->next;1）p->next=p->next->next;2）delete tmp`;\\n\\n循环链表就是头尾相连的链表，将单链表的尾结点的next指针从NULL指向头结点，便使得整个单链表形成了一个环，这种头尾相接的单链表称为单循环链表，简称循环链表。为了使得空链表的处理与非空链表一致，我们通常设置一个头结点，但是不是说循环链表一定要头结点，这点要注意。\\n\\n其实，循环链表与单链表的差异就在循环的判断条件上，原来试试判断`p->next==NULL`，现在是判断`p->next`等于头结点，则循环结束。\\n\\n对循环链表进行改造，使用尾指针而非头指针，可以使得对尾结点的访问为O(1)，并且对头结点的访问也是O(1)。举个程序的例子，需要将两个循环链表合并为一个链表时，使用为指针就十分方便了。\\n\\n<div align=center>\\n<img src = \'https://s3.bmp.ovh/imgs/2023/03/24/ef20cbea2d6919e6.png\' >\\n</div>\\n<div align=center>\\n<img src = \'https://s3.bmp.ovh/imgs/2023/03/24/28e9daa9809379b3.png\' >\\n</div>\\n\\n使用以下代码块来实现：\\n\\n```cpp\\np=rearA->next; //保存A表的头结点，即①\\nrearA->next=rearB->next->next; //舍弃B表的头结点，将本是指向B表的第一个节点（不是头结点）赋值给rearA->next，即②\\nrearB->next=p; //将原来A表的头结点赋值给rearB->next，即③\\nfree(p); //释放p\\n```\\n\\n双向链表就是在单链表的基础上新增了一个向前的指针，有双指针prior和next，还可以组合成双向循环链表。另外，对于双向链表，节点后继的前驱、节点前驱的后继都是节点本身，如：`p->next->prior=p=p->prior->next`。下面开始介绍双向链表的插入和删除操作。\\n\\n我们假设存储元素e的新节点为s，要将新节点插入到节点p和p->next之间有以下几步，如下图所示。\\n\\n<div align=center>\\n<img src = \'https://s3.bmp.ovh/imgs/2023/03/24/cd2a6675b201a79d.png\' >\\n</div>\\n\\n代码块如下所示：\\n\\n```cpp\\ns->prior=p;\\ns->next=p->next;\\np->next->prior=s;\\np->next=s;\\n```\\n\\n关键点在于它们的顺序，由于最后三步都用到了p->next，所以如果第四步先执行会出错。注意：如果把第四步提前，会失去对a~i+1~节点的控制，造成插入节点出错的问题。\\n\\n<div align=center>\\n<img src = \'https://s3.bmp.ovh/imgs/2023/03/24/d5b28bb5a3bf7c52.png\' >\\n</div>\\n\\n代码块如下所示：\\n\\n```cpp\\np->prior-next=p->next; //仔细观察，删除节点p对外指向的指针不需要变动\\np->next->prior=p->prior;//主要变动指向节点p的指针，即ai-1->next和ai+1->prior\\nfree(p);\\n```\\n\\n### 2.1移除链表元素\\n\\n**题意**：删除链表中等于给定值 val 的所有节点\\n\\n注意：对于含头结点的节点删除，第一个节点的操作与其他节点的操作是一致的；对于不含头结点的节点删除，删除第一个节点的操作就是头指针后移+第一个节点内存释放。下面是cpp代码示例。\\n\\n**直接使用原来的链表进行节点删除操作**\\n\\n```cpp\\nListNode* removeElements(ListNode* head, int val) {\\n// 删除头结点\\nwhile (head != NULL && head->val == val) { // 注意这里不是if\\n\\tListNode* tmp = head;\\n\\thead = head->next;\\n\\tdelete tmp;\\n}\\n// 删除非头结点\\nListNode* cur = head;\\nwhile (cur != NULL && cur->next!= NULL) {\\n\\tif (cur->next->val == val) {\\n\\t\\tListNode* tmp = cur->next;\\n\\t\\tcur->next = cur->next->next;\\n\\t\\tdelete tmp;\\n} else {\\n\\tcur = cur->next;\\n\\t}\\n}\\nreturn head;\\n}\\n```\\n\\n**直接使用原来的链表进行节点删除操作**\\n\\n```cpp\\nListNode* removeElements(ListNode* head, int val) {\\n\\tListNode* dummyHead = new ListNode(0); // 设置一个虚拟头结点\\n\\tdummyHead->next = head; // 将虚拟头结点指向head，这样方面后面做删除操作\\n\\tListNode* cur = dummyHead;\\n\\twhile (cur->next != NULL) {\\n\\t\\tif(cur->next->val == val) {\\n\\t\\t\\tListNode* tmp = cur->next;\\n\\t\\t\\tcur->next = cur->next->next;\\n\\t\\t\\tdelete tmp;\\n\\t\\t} else {\\n\\t\\t\\tcur = cur->next;\\n\\t\\t}\\n\\t}\\n\\thead = dummyHead->next;\\n\\tdelete dummyHead;\\n\\treturn head;\\n}\\n```\\n\\n### 2.2 设计链表\\n\\n**题意**：设计一个基本的链表类，它应当具有以下功能：\\n\\n+ `get(index)`：获取链表中第index个节点的值。如果索引无效，则返回-1。\\n+ `addAtHead(val)`：在链表的第一个元素之前添加一个值为val的节点。插入后，新节点将成为链表的第一个节点。\\n+ `addAtTail(val)`：将值为val的节点追加到链表的最后一个元素。\\n+ `addAtIndex(index,val)`：在链表中的第index个节点之前添加值为val的节点。如果index等于链表的长度，则该节点将附加到链表的末尾。如果index大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。\\n+ `deleteAtIndex(index)`：如果索引index有效，则删除链表中的第index个节点。\\n\\n示例：\\n\\n<div align=center>\\n<img src = \'https://s3.bmp.ovh/imgs/2023/03/24/ee4506ef4a51361b.png\' >\\n</div>\\n\\n\\n这道题目设计链表的五个接口：\\n\\n+ 获取链表第index个节点的数值\\n+ 在链表的最前面插入一个节点\\n+ 在链表的最后面插入一个节点\\n+ 在链表第index个节点前面插入一个节点\\n+ 删除链表的第index个节点\\n\\n可以说这五个接口，已经覆盖了链表的常见操作，是练习链表操作非常好的一道题目。\\n\\n**链表操作的两种方式**\\n\\n1.\\t直接使用原来的链表进行操作\\n2.\\t设置一个虚拟的头结点在进行操作\\n\\n下面分别是cpp和C语言的链表设计：\\n\\n```cpp\\n/*************cpp实现链表设计****************/\\nclass MyLinkedList {\\npublic:\\n// 定义链表节点结构体\\nstruct LinkedNode {\\n\\tint val;\\n\\tLinkedNode* next;\\n\\tLinkedNode(int val):val(val), next(nullptr){}\\n};\\n// 初始化链表\\nMyLinkedList() {\\n\\t_dummyHead = new LinkedNode(0); // 这里定义的头结点是一个虚拟头结点，而不是真正的链表头结点\\n\\t_size = 0;\\n}\\n// 获取到第index个节点数值，如果index是非法数值直接返回-1， 注意index是从0开始的，第0个节点就是头结点\\nint get(int index) {\\n\\tif (index > (_size - 1) || index < 0) {\\n\\t\\treturn -1;\\n\\t}\\n\\tLinkedNode* cur = _dummyHead->next;\\n\\twhile(index--){ // 如果--index 就会陷入死循环\\n\\t\\tcur = cur->next;\\n\\t}\\n\\treturn cur->val;\\n}\\n// 在链表最前面插入一个节点，插入完成后，新插入的节点为链表的新的头结点\\nvoid addAtHead(int val) {\\n\\tLinkedNode* newNode = new LinkedNode(val);\\n\\tnewNode->next = _dummyHead->next;\\n\\t_dummyHead->next = newNode;\\n\\t_size++;\\n}\\n// 在链表最后面添加一个节点\\nvoid addAtTail(int val) {\\n\\tLinkedNode* newNode = new LinkedNode(val);\\n\\tLinkedNode* cur = _dummyHead;\\n\\twhile(cur->next != nullptr){\\n\\t\\tcur = cur->next;\\n\\t}\\n\\tcur->next = newNode;\\n\\t_size++;\\n}\\n// 在第index个节点之前插入一个新节点，例如index为0，那么新插入的节点为链表的新头节点。\\n// 如果index 等于链表的长度，则说明是新插入的节点为链表的尾结点\\n// 如果index大于链表的长度，则返回空\\n// 如果index小于0，则在头部插入节点\\nvoid addAtIndex(int index, int val) {\\n\\tif(index > _size) return;\\n\\tif(index < 0) index = 0;        \\n\\tLinkedNode* newNode = new LinkedNode(val);\\n\\tLinkedNode* cur = _dummyHead;\\n\\twhile(index--) {\\n\\tcur = cur->next;\\n\\t}\\n\\tnewNode->next = cur->next;\\n\\tcur->next = newNode;\\n\\t_size++;\\n}\\n//删除第index个节点，如果index大于等于链表的长度，直接return，注意index是从0开始的\\nvoid deleteAtIndex(int index) {\\n\\tif (index >= _size || index < 0) {\\n\\t\\treturn;\\n\\t}\\n\\tLinkedNode* cur = _dummyHead;\\n\\twhile(index--) {\\n\\t\\tcur = cur ->next;\\n\\t}\\n\\tLinkedNode* tmp = cur->next;\\n\\tcur->next = cur->next->next;\\n\\tdelete tmp;\\n\\t_size--;\\n}\\n\\n// 打印链表\\nvoid printLinkedList() {\\n\\tLinkedNode* cur = _dummyHead;\\n\\twhile (cur->next != nullptr) {\\n\\t\\tcout << cur->next->val << \\\" \\\";\\n\\t\\tcur = cur->next;\\n\\t}\\n\\tcout << endl;\\n}\\nprivate:\\n\\tint _size;\\n\\tLinkedNode* _dummyHead;\\n};\\n```\\n\\n下面是用C语言来实现链表：\\n\\n```c\\n/*************C语言实现链表设计****************/\\ntypedef struct MyLinkedList {\\n\\tint val;\\n\\tstruct MyLinkedList* next;\\n}MyLinkedList;\\n/**在这里初始化你的结构体数据**/\\nMyLinkedList* myLinkedListCreate() {\\n//这个题必须用虚拟头指针,参数都是一级指针,头节点确定后没法改指向了!!!\\n\\tMyLinkedList* head = (MyLinkedList *)malloc(sizeof (MyLinkedList));\\n\\thead->next = NULL;\\n\\treturn head;\\n}\\n/**根据索引获取到链表的值**/\\nint myLinkedListGet(MyLinkedList* obj, int index) {\\n\\tMyLinkedList *cur = obj->next;\\n\\tfor (int i = 0; cur != NULL; i++){\\n\\t\\tif (i == index){\\n\\t\\t\\treturn cur->val;\\n\\t\\t}\\n\\t\\telse{\\n\\t\\t\\tcur = cur->next;\\n\\t\\t}\\n\\t}\\n\\treturn -1;\\n}\\n/**在头节点前添加新节点**/\\nvoid myLinkedListAddAtHead(MyLinkedList* obj, int val) {\\n\\tMyLinkedList *nhead = (MyLinkedList *)malloc(sizeof (MyLinkedList));\\n\\tnhead->val = val;\\n\\tnhead->next = obj->next;\\n\\tobj->next = nhead;\\n}\\n/**在尾部插入新节点**/\\nvoid myLinkedListAddAtTail(MyLinkedList* obj, int val) {\\n\\tMyLinkedList *cur = obj;\\n\\twhile(cur->next != NULL){\\n\\t\\tcur = cur->next;\\n\\t}\\n\\tMyLinkedList *ntail = (MyLinkedList *)malloc(sizeof (MyLinkedList));\\n\\tntail->val = val;\\n\\tntail->next = NULL;\\n\\tcur->next = ntail;\\n}\\n/**在指定索引节点后插入，如果索引值为0表示头插，如果索引值大于长度就插入无效*/\\nvoid myLinkedListAddAtIndex(MyLinkedList* obj, int index, int val) {\\n\\tif (index == 0){\\n\\t\\tmyLinkedListAddAtHead(obj, val);\\n\\t\\treturn;\\n\\t}\\n\\tMyLinkedList *cur = obj->next;\\n\\tfor (int i = 1 ;cur != NULL; i++){\\n\\t\\tif (i == index){\\n\\t\\t\\tMyLinkedList* newnode = (MyLinkedList *)malloc(sizeof (MyLinkedList));\\n\\t\\t\\tnewnode->val = val;\\n\\t\\t\\tnewnode->next = cur->next;\\n\\t\\t\\tcur->next = newnode;\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\telse{\\n\\t\\t\\tcur = cur->next;\\n\\t\\t}\\n\\t}\\n}\\n/** 按索引来删除节点，删除索引值后的一个节点 **/\\nvoid myLinkedListDeleteAtIndex(MyLinkedList* obj, int index) {\\n\\tif (index == 0){\\n\\t\\tMyLinkedList *tmp = obj->next;\\n\\t\\tif (tmp != NULL){\\n\\t\\t\\tobj->next = tmp->next;\\n\\t\\t\\tfree(tmp);     \\n\\t \\t}\\n\\t\\treturn;\\n\\t}\\n\\tMyLinkedList *cur = obj->next;\\n\\tfor (int i = 1 ;cur != NULL && cur->next != NULL; i++){\\n\\t\\tif (i == index){\\n\\t\\t\\tMyLinkedList *tmp = cur->next;\\n\\t\\t\\tif (tmp != NULL) {\\n\\t\\t\\t\\tcur->next = tmp->next;\\n\\t\\t\\t\\tfree(tmp);\\n\\t\\t\\t}\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\telse{\\n\\t\\t\\tcur = cur->next;\\n\\t\\t}\\n\\t}\\n}\\nvoid myLinkedListFree(MyLinkedList* obj) {\\n\\twhile(obj != NULL){\\n\\t\\tMyLinkedList *tmp = obj;\\n\\t\\tobj = obj->next;\\n\\t\\tfree(tmp);\\n\\t}\\n}\\n/**\\n *你可以如此调用你的程序:\\n * MyLinkedList* obj = myLinkedListCreate();\\n * int param_1 = myLinkedListGet(obj, index);\\n * myLinkedListAddAtHead(obj, val);\\n * myLinkedListAddAtTail(obj, val);\\n * myLinkedListAddAtIndex(obj, index, val);\\n * myLinkedListDeleteAtIndex(obj, index);\\n * myLinkedListFree(obj);\\n*/\\n```\\n\\n### 2.3 翻转链表\\n\\n**题意**：翻转链表，即输入：1->2->3->4->5->NULL 输出: 5->4->3->2->1->NULL\\n**思路**：关键在于链表next指针的翻转。\\n\\n<div align=center>\\n<img src = \'https://s3.bmp.ovh/imgs/2023/03/24/abb4acd8d087c152.png\' >\\n</div>\\n\\n+ 首先定义一个cur指针，指向头结点，再定义一个pre指针，初始化为null。\\n+ 然后就要开始反转了，首先要把 cur->next 节点用tmp指针保存一下，也就是保存一下这个节点。\\n+ 为什么要保存一下这个节点呢，因为接下来要改变 cur->next 的指向了，将cur->next 指向pre ，此时已经反转了第一个节点了。\\n+ 接下来，就是循环走如下代码逻辑了，继续移动pre和cur指针。\\n+ 最后，cur 指针已经指向了null，循环结束，链表也反转完毕了。 此时我们return pre指针就可以了，pre指针就指向了新的头结点。\\n\\n<font color=\'orange\'>==1）下面是cpp双指针法的代码实现==</font>：\\n\\n```cpp\\nListNode* reverseList(ListNode* head) {\\n\\tListNode* tmp; //保存cur的下一个节点\\n\\tListNode* cur = head;\\n\\tListNode* pre = NULL;\\n\\twhile(cur) {\\n\\ttmp = cur->next;\\n\\tcur->next = pre; \\t// 翻转操作\\n\\tpre = cur;\\n\\tcur = tmp;\\n\\t}\\n\\treturn pre;\\n}\\n```\\n\\n<font color=\'orange\'>==2）下面是cpp递归法的实现==</font>：\\n\\n递归法相对抽象一些，但是其实和双指针法是一样的逻辑，同样是当cur为空的时候循环结束，不断将cur指向pre的过程。\\n关键是初始化的地方，可能有的同学会不理解，可以看到双指针法中初始化 cur = head，pre = NULL，在递归法中可以从如下代码看出初始化的逻辑也是一样的，只不过写法变了。**双指针法写出来之后，理解如下递归写法就不难了，代码逻辑都是一样的**。\\n\\n```cpp\\nListNode* reverse(ListNode* pre,ListNode* cur) {\\n\\tif(cur == NULL) return pre;\\n\\tListNode *tmp = cur->next;\\n\\tcur->next = pre;\\n\\treturn reverse(cur,tmp);\\n}\\nListNode* reverseList(ListNode* head) {\\n\\treturn reverse(NULL,head);\\n}\\n```\\n\\n我们可以发现，上面的递归写法和双指针法实质上都是从前往后翻转指针指向，其实还有另外一种与双指针法不同思路的递归写法：从后往前翻转指针指向。\\n\\n<font color=\'orange\'>==3）下面是从后往前翻转指针指向(十分精巧)==</font>：\\n\\n```cpp\\nListNode* reverseList() {\\n\\t//边缘条件检测\\n\\tif(head == NULL) return NULL;\\n\\tif(head->next == NULL ) return head;\\n\\t//递归调用\\n\\tListNode* last = reverseList(head->next);\\n\\thead->next->next = head;\\n\\thead->next = NULL;\\n\\treturn last;\\n}\\n```\\n\\n<font color=\'orange\'>==4）是用虚拟节点和头插法来解决链表翻转问题（不需要栈）==</font>：\\n\\n```cpp\\nListNode* reverseList(ListNode* head) {\\n\\tListNode* dumpyHead = new ListNode(-1);\\n\\tdumpyHead->next = NULL;\\n\\tListNode* cur = head;\\n\\twhile(cur!=NULL) {\\n\\t\\tListNode* tmp = cur->next;\\n\\t\\t//头插法：把第一个节点拆下来，插在虚拟头结点后头；把第二个节点拆下来，再插在虚拟头结点后头。就实现节点1和2的翻转，后面的类似操作即可。\\n\\t\\t//感觉和双指针法差不多，cur指向当前，tmp保存cur->next，然后cur指向pre，最后pre由cur更新，cur由tmp更新。而这里的虚拟头插法相当于把pre换成了虚拟头dumptHead。\\n\\t\\tcur->next = dumpyHead->next;\\n\\t\\tdumpyHead ->next = cur;\\n\\t\\tcur = tmp;\\n\\t}\\n\\treturn dumpyHead ->next;\\n}\\n```\\n\\n<font color=\'orange\'>==5）使用栈来解决链表翻转问题（本质也是和递归一样的）==</font>：\\n\\n首先把所有节点入栈，然后cur指向虚拟头结点，再然后循环出栈，每出来一个元素就把它加入到虚拟头结点为头结点的链表当中，最后返回即可。\\n\\n**采用这种方法需要注意一点。就是当整个出栈循环结束以后，cur正好指向原来链表的第一个结点，而此时结点1中的next指向的是结点2，因此最后还需要`cur.next = null`**。\\n\\n<div align=center>\\n<img src = \'https://s3.bmp.ovh/imgs/2023/03/24/f35d9150f6961bd6.png\' >\\n</div>\\n\\n\\n![](https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlHgdz7m76yDUi9PH/root/content)\\n\\n**注意**：代码随想录的上述原代码在力扣实际测试时，有些问题，更正为上述代码后正常运行（实际上网站提供的是Java代码，我改成了cpp，所以有些方法名不对头）。例如在STL中的栈名字叫stack而非Stack，且没有isEmpty()方法而是empty()方法。此外第三点就是pop()方法的返回值是void，要想获取栈顶值应当使用top()方法，在使用pop()方法弹出元素。\\n\\n### 2.4 两两交换链表中的节点\\n\\n**题目**：给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。*你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换*。\\n\\n示例：\\n\\n<div align=center>\\n<img src = \'https://s3.bmp.ovh/imgs/2023/03/24/a14cd19641a753e9.png\' >\\n</div>\\n\\n对于输入head=[1,2,3,4],输出为[2,1,4,3]\\n\\n**思路**：建议使用虚拟头结点，这样会方便很多，要不然每次针对头结点（没有前一个指针指向头结点），还要单独处理。\\n![两两交换链表中的节点--程序设计示意图](https://s3.bmp.ovh/imgs/2023/03/24/c5275104b2c0b5f5.png)\\n\\n仔细分析上述示意图，可以知道至少需要两个tmp临时指针来保存节点指针才能正确实现“每两个节点进行一次互换”的操作，cpp代码如下：\\n\\n```cpp\\nListNode* swapPairs(ListNode* head) {\\n\\tListNode* dummyHead = new ListNode(0);\\n\\tdummyHead->next = head;\\n\\tListNode* cur = dummyHead;//设置虚拟节点，并为cur指针赋初始值\\n\\twhile (cur->next!=NULL&&cur->next->next!=NULL) {\\n\\t\\tListNode* tmp = cur->next; //cur后的第一个节点\\n\\t\\tListNode* tmp2 = cur->next->next->next;//cur后的第三个节点\\n\\t\\t\\n\\t\\tcur->next = cur->next->next; //步骤一\\n\\t\\tcur->next->next = tmp; //步骤二\\n\\t\\tcur->next->next->next = tmp2; //步骤三\\n\\t\\t\\n\\t\\tcur = cur->next->next;\\n\\t}\\n\\treturn dummyHead->next;\\n\\t//时间复杂度O(n)，空间复杂度O(1)\\n}\\n```\\n\\n【关于<font color=\\\"red\\\">递归</font>】\\n\\n在代码随想录二叉树递归遍历那一章，讲了一下递归的三要素：\\n\\n1. **确定递归函数的参数和返回值**： 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。\\n\\n2. **确定终止条件**： 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。\\n\\n3. **确定单层递归的逻辑**： 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。\\n\\n下面以本次两两交换链表中的节点为例，再来强化一遍。本次递归程序设计中，1）递归的参数和返回值都是链表头指针。2）终止条件就是链表访问结束，有NULL。就是cur->next和cur->next->next为NULL。3）单层递归的逻辑，就是每两个节点为一对，1）本对的第一个节点指向下一对，2）对内，第二个节点指向第一个节点，3）第二个节点坐标作为一个结构体返回。下图是程序设计示意图。\\n\\n![程序设计示意图](https://s3.bmp.ovh/imgs/2023/03/24/67a571af0d281e5a.png)\\n\\nC语言实现两两交换链表中的节点（递归版本)\\n\\n```c\\n//单链表的格式为：\\ntypedef struct node {\\n\\tint val;\\n\\tstruct node *next;\\n}ListNode;\\n//递归版本 （该代码认为链表没有头结点，第一个head节点就是有效节点）\\nListNode* swapPairs(ListNode* head) {\\n//递归结束条件：头节点不存在或头节点的下一个节点不存在。此时不需要交换，直接返回head\\n\\tif (!head || !head->next)\\n\\t\\treturn head;\\n\\t//创建一个节点指针类型保存头结点下一个节点\\n\\tListNode* newHead = head->next;\\n\\t//更改头结点+2位节点后的值，并将头结点的next指针指向这个更改过的list\\n\\thead->next = swapPairs(newHead->next);\\n\\t//将新的头结点的next指针指向老的头节点\\n\\tnewHead->next = head;\\n\\treturn newHead;\\n}\\n```\\n\\nC语言实现两两交换链表中的节点（迭代版本）\\n\\n```c\\n//迭代版本\\nstruct ListNode* swapPairs(struct ListNode* head){\\n    //使用双指针避免使用中间变量\\n    typedef struct ListNode ListNode;\\n    ListNode *fakehead = (ListNode *)malloc(sizeof(ListNode));\\n    fakehead->next = head;\\n    ListNode* right = fakehead->next;\\n    ListNode* left = fakehead;\\n    while(left && right && right->next ){\\n        left->next = right->next;\\n        right->next = left->next->next;\\n        left->next->next = right;\\n        left = right;\\n        right = left->next;\\n    }\\n    return fakehead->next;\\n}\\n```\\n\\n### 2.5 删除链表的倒数第N个节点\\n\\n**题意**：删除链表的倒数第N个节点\\n\\n**思路**：采用双指针的方法来实现：定义两个指针，fast指针先走N+1步，然后slow指针再走。当fast指针走到NULL时，slow指针刚好就在待删除节点的前一个节点。\\n\\n### 2.6 链表相交\\n\\n**题意**：给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。\\n\\n题目数据 保证 整个链式结构中不存在环。注意，函数返回结果后，链表必须 保持其原始结构 。图示两个链表在节点 c1 开始相交：\\n![](https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlEiHrW36nF7-bhD4/root/content)\\n**思路**：采用双指针的方法来解决，考虑到两链表相交一定是在后面有相同点，所以1）将两链表尾端对齐，2）然后长链表的指针移动（两个链表长度之差的）距离，3）循环，判断什么时候两指针相等。此时我们就可以比较curA和curB是否相同，如果不相同，同时向后移动curA和curB，如果遇到curA == curB，则找到交点。如果`curA == NULL`则说明链表不相交思路如下图所示：\\n\\n![链表相交的思路](https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlEn2uZpsaGxK5jgn/root/content)\\n\\ncpp代码示例：\\n\\n```cpp\\nListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode* curA = headA;\\n        ListNode* curB = headB;\\n        int lenA = 0, lenB = 0;\\n        while (curA != NULL) { // 求链表A的长度\\n            lenA++;\\n            curA = curA->next;\\n        }\\n        while (curB != NULL) { // 求链表B的长度\\n            lenB++;\\n            curB = curB->next;\\n        }\\n        curA = headA;\\n        curB = headB;\\n        // 让curA为最长链表的头，lenA为其长度\\n        if (lenB > lenA) {\\n            swap (lenA, lenB);\\n            swap (curA, curB);\\n        }\\n        // 求长度差\\n        int gap = lenA - lenB;\\n        // 让curA和curB在同一起点上（末尾位置对齐）\\n        while (gap--) {\\n            curA = curA->next;\\n        }\\n        // 遍历curA 和 curB，遇到相同则直接返回\\n        while (curA != NULL) {\\n            if (curA == curB) {\\n                return curA;\\n            }\\n            curA = curA->next;\\n            curB = curB->next;\\n        }\\n        return NULL;\\n    }\\n```\\n\\n注意：时间复杂度是O(m+n)\\n\\n### 2.7 环形链表2\\n\\n**题意**：环形链表2，这题是给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。为了表示给定链表中的环，使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。【给定一个链表，判断是否有环，有环的话返回环的入口节点地址】\\n\\n**说明**：不允许修改给定的链表\\n\\n**示例**：输入：head = [3,2,0,-4], pos = 1 ; 输出 tail connects to node index 1 ; 解释：链表中有一个环，其尾部连接到第二个节点。本示例的图示如下：\\n\\n![示例](https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlEpR5iFQiiqqWqzH/root/content)\\n\\n**思路**：这道题不仅要考链表操作，还考察数学运算。主要考察两个知识点：\\n\\n+  判断链表是否有环；\\n+  如果有环，如何找到这个环的入口\\n\\n1）**判断链表是否有环**\\n\\n方法：可以使用快慢指针法，分别定义 fast 和 slow 指针，从头结点出发，fast指针每次移动两个节点，slow指针每次移动一个节点，如果 fast 和 slow指针在途中相遇 ，说明这个链表有环。\\n\\n原理：首先第一点：**fast指针一定先进入环中，如果fast指针和slow指针相遇的话，一定是在环中相遇，这是毋庸置疑的**。其实相对于slow来说，**fast是一个节点一个节点的靠近slow的，所以fast一定可以和slow重合**。\\n\\n![双指针法：判断是否有环](https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlEyj6F0jegrnBGxW/root/content)\\n\\n2）**如果有环，如何找到这个环的入口** （要用到数学知识了）\\n\\n**方法&&原理**：假设从头结点到环形入口节点 的节点数为x。 **环形入口**节点到 fast指针与slow指针**相遇节点**节点数为y。 从相遇节点 再到环形入口节点节点数为 z。 如图所示：\\n\\n![](https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlE0iChKekHjyQs1F/root/content)\\n\\n那么相遇时：slow指针走过的节点数位`x+y`，fast指针走过的节点数为：`x+y+n(y+z)`，n为fast指针在环内走了n圈才遇到slow指针， （y+z）为 一圈内节点的个数A。因为fast指针是一步走两个节点，slow指针一步走一个节点， 所以 fast指针走过的节点数 = slow指针走过的节点数 * 2：\\n\\n                                        `(x+y)*2 = x+y+n(y+z)`\\n\\n两边消掉一个`(x+y)`：即：`x+y = n (y+z)`\\n\\n因为要找环形的入口，那么要求的是x，因为x表示 头结点到 环形入口节点的的距离。\\n\\n所以要求x ，将x单独放在左面：x = n (y + z) - y ,\\n\\n再从n(y+z)中提出一个 （y+z）来，整理公式之后为如下公式：x = (n - 1) (y + z) + z 注意这里n一定是大于等于1的，因为 fast指针至少要多走一圈才能相遇slow指针。\\n\\n这个公式说明什么呢？\\n\\n**情况1）**：先拿n为1的情况来举例，意味着fast指针在环形里转了一圈之后，就遇到了 slow指针了。当 n为1的时候，公式就化解为 x = z，这就意味着，**从头结点出发一个指针，从相遇节点 也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是 环形入口的节点**。\\n\\n也就是在相遇节点处，定义一个指针index1，在头结点处定一个指针index2。让index1和index2同时移动，每次移动一个节点， 那么他们相遇的地方就是 环形入口的节点。如下面的动图所示：\\n\\n![](https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlE7bx0qLRJ9_JVDz/root/content)\\n\\n**情况2）**：那么 n如果大于1是什么情况呢，就是fast指针在环形转n圈之后才遇到 slow指针。\\n\\n其实这种情况和n为1的时候 效果是一样的，一样可以通过这个方法找到 环形的入口节点，只不过，index1 指针在环里 多转了(n-1)圈，然后再遇到index2，相遇点依然是环形的入口节点。\\n\\n代码如下：\\n\\n```cpp\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        ListNode* fast = head;\\n        ListNode* slow = head;\\n        while(fast != NULL && fast->next != NULL) {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            // 快慢指针相遇，此时从head 和 相遇点，同时查找直至相遇\\n            if (slow == fast) {\\n                ListNode* index1 = fast;\\n                ListNode* index2 = head;\\n                while (index1 != index2) {\\n                    index1 = index1->next;\\n                    index2 = index2->next;\\n                }\\n                return index2; // 返回环的入口\\n            }\\n        }\\n        return NULL;\\n    }\\n};\\n```\\n\\n**补充**：\\n\\n在推理过程中，大家可能有一个疑问就是：为什么第一次在环中相遇，slow的步数是 x+y 而不是 x + 若干环的长度 + y 呢？\\n\\n首先slow进环的时候，fast一定是先进环来了。如果slow进环入口，fast也在环入口，那么把这个环展开成直线，就是如下图的样子：\\n\\n![](https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlE_T1DmcUQ4sVEFJ/root/content)\\n\\n可以看出如果slow 和 fast同时在环入口开始走，一定会在环入口3相遇，slow走了一圈，fast走了两圈。重点来了，slow进环的时候，fast一定是在环的任意一个位置，如图：\\n\\n![](https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlFDmQaMBFYVeFEDo/root/content)\\n\\n那么fast指针走到环入口3的时候，已经走了k + n 个节点，slow相应的应该走了(k + n) / 2 个节点。\\n\\n因为k是小于n的（图中可以看出），所以(k + n) / 2 一定小于n。\\n\\n也就是说slow一定没有走到环入口3，而fast已经到环入口3了。\\n\\n这说明什么呢？\\n\\n在slow开始走的那一环已经和fast相遇了。\\n\\n那有同学又说了，为什么fast不能跳过去呢？ 在刚刚已经说过一次了，fast相对于slow是一次移动一个节点，所以不可能跳过去。\\n\\n### 2.8 总结篇\\n\\n在本章，主要讲了链表的基础知识，讲了链表的基本构造，还有移除链表元素、翻转链表（双指针法或递归法）、两两交换链表中的节点、删除链表的倒数第N个节点、链表相交（双指针法）、环形链表2等题目。上述问题都能通过双指针法解决：\\n\\n+ ** 翻转链表**：一个cur指向当前指针，一个pre在前一个指针，还需要tmp指针记录下一次cur跳转的位置。趁cur指向还没改变，先记录tmp即cur的下一跳。然后，原来是pre指向cur的，现在将cur指向pre即可，最后给cur、pre赋值，进行下一次循环；\\n+ **两两交换链表中的节点**：两两个节点一对来进行操作，但是为了和下一对联系起来，实际上操作时需要有三个节点参与。同时需要两个临时指针来记录节点1和节点3的地址。\\n\\n```cpp\\ntmp1 = cur->next;\\ntmp2 = cur->next->next->next;\\ncur->next = cur->next->next;\\ncur->next->next = tmp1;\\ncur->next->next->next = tmp2;\\n```\\n\\n+ **删除链表的倒数第N个节点**：双指针法，让fast指针先出发N+1步，然后slow指针再出发。当fast到达NULL时，slow刚好就在待删除节点的前一个位置；\\n+ **链表相交**：先求两个链表的长度，然后链表尾端对齐。长链表那个指针先移动两个链表长度之差的步数，然后两个链表指针在同时移动。当两个链表指针相等时，即为找到相交节点地址了；\\n+ **环形链表2**：思路是fast指针每次走两步，slow指针每次走一步，如果他两相遇了则存在环。然后，指针index1从头结点出发，指针index2从相遇节点出发，他们两个的再次相遇点就是环的入口节点地址了。\\n\\n另外，对于**反转链表**问题，建议先学透迭代法，然后再看递归法，因为递归法比较绕，如果迭代还写不明白，递归基本也写不明白了。\\n\\n最后，下图是对上述知识点的总结：\\n\\n![](https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlFEAlN4E-tIPYtjg/root/content)\\n\\n## 三、哈希表\\n\\n### 3.1 哈希表的理论基础\\n\\n哈希表，又或称散列表，它是**根据关键码的值而直接进行访问的数据结构**。它主要解决的问题就是元素的快速搜索，用来快速判断一个元素是否出现集合里。直白来讲，数组就是一张哈希表，哈希表的关键码就是数组索引下标，然后通过下标来直接访问数组元素。然后，将元素值映射到哈希表上与特定的关键码对应，就用到了**哈希函数**。\\n\\n特点：查找元素的速度很快，但是牺牲了空间来换取时间。\\n\\n哈希函数与哈希碰撞，哈希碰撞的解决方法有：拉链法和线性探测法。拉链法：多个元素在一个哈希值上冲突，就把这多个元素做成一个链表插在该位置上；线性探测法：当前位置冲突了，就顺次找下一个不冲突的位置，这种方法就要求哈希表长度必须大于数据个数才行。（略）\\n\\n常见的哈希结构：当我们想使用哈希法来解决问题的时候，我们一般会选择如下三种数据结构。\\n\\n+ 数组\\n+ set集合\\n+ map映射\\n\\n这里数据就没啥好说的了，我们来看看set和map。在cpp中，set 和 map 分别提供以下三种数据结构，其底层实现以及优劣如下表所示：\\n\\n| 集合               | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 | 增删效率 |\\n| ------------------ | -------- | -------- | ---------------- | ------------ | -------- | -------- |\\n| std::set           | 红黑树   | 有序     | 否               | 否           | O(log n) | O(log n) |\\n| std::multiset      | 红黑树   | 有序     | 是               | 否           | O(logn)  | O(logn)  |\\n| std::unordered_set | 哈希表   | 无序     | 否               | 否           | O(1)     | O(1)     |\\n\\nstd::unordered_set底层实现为哈希表，std::set 和std::multiset 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。\\n\\n| 映射               | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 | 增删效率 |\\n| ------------------ | -------- | -------- | ---------------- | ------------ | -------- | -------- |\\n| std::map           | 红黑树   | key有序  | key不可重复      | key不可修改  | O(logn)  | O(logn)  |\\n| std::multimap      | 红黑树   | key有序  | key可重复        | key不可修改  | O(log n) | O(log n) |\\n| std::unordered_map | 哈希表   | key无序  | key不可重复      | key不可修改  | O(1)     | O(1)     |\\n\\nstd::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）\\n\\n当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset。\\n\\n那么再来看一下map ，在map 是一个key value 的数据结构，map中，对key是有限制，对value没有限制的，因为key的存储方式使用红黑树实现的。\\n\\n其他语言例如：java里的HashMap ，TreeMap 都是一样的原理。可以灵活贯通。\\n\\n虽然std::set、std::multiset 的底层实现是红黑树，不是哈希表，std::set、std::multiset 使用红黑树来索引和存储，不过给我们的使用方式，还是哈希法的使用方式，即key和value。所以使用这些数据结构来解决映射问题的方法，我们依然称之为哈希法。 map也是一样的道理。\\n\\n这里在说一下，一些cpp的经典书籍上 例如STL源码剖析，说到了hash_set hash_map，这个与unordered_set，unordered_map又有什么关系呢？\\n\\n实际上功能都是一样一样的， 但是unordered_set在cpp11的时候被引入标准库了，而hash_set并没有，所以建议还是使用unordered_set比较好，这就好比一个是官方认证的，hash_set，hash_map 是cpp11标准之前民间高手自发造的轮子。\\n\\n![](https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlFLHzQIWbM3ru_iG/root/content)\\n\\n总结一下，**当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法**。\\n\\n但是哈希法也是**牺牲了空间换取了时间**，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。\\n\\n如果在做面试题目的时候遇到需要判断一个元素是否出现过的场景也应该第一时间想到哈希法！\\n\\n### 3.2 有效的字母异位词\\n\\n**题意**：给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。示例 1: 输入: s = \\\"anagram\\\", t = \\\"nagaram\\\" 输出: true。示例 2: 输入: s = \\\"rat\\\", t = \\\"car\\\" 输出: false。**说明**: 你可以假设字符串只包含小写字母。【字母异位词，即字母的种类和个数全部相同，只是字母的位置不相同的两个单词，可以用哈希表或map存储起来比较，得出结论】\\n\\n**思路**：1）暴力解法就是两层for循环；2）**数组其实就是一个简单哈希表**，而且这道题目中字母串只有小写字符，那么就可以定义一个数组record，来记录字符串s中字符的出现次数，定义数组长度为26。例如：对于字符串a=\\\"aea\\\"，有record[0]=2,record[4]=1；同样的，对于字符串b=\\\"eaa\\\"，也有record[0]=2,record[4]=1。所以字符串a和b是字母异位词。\\n\\n**步骤**：1）不需要记住具体是哪个字符a-z，只需要判断字符的相对位置，定义数组record[26]，字符\'a\'对应record[0]，字符record[25]对应\'z\'。2）在遍历字符串a时，只需要将record[a[i]-\'a\']元素值+1即可，并不需要记住字符a的ASCII值。这样就把字符串a中字符出现的次数统计出来了。\\n\\n3）在遍历字符串b，将record[b[i]-\'a\']的值-1，如果每一个数组元素的值不为0，那就是某个位多了一个字符或少了一个字符，则返回false，如果每一个数组元素都为0，满足题意返回true。\\n\\ncpp代码块如下所示：\\n\\n```cpp\\nbool isAnagram(string s, string t) {\\n    int record[26] = {0};\\n    for (int i = 0; i < s.size(); i++) {\\n        // 并不需要记住字符a的ASCII，只要求出一个相对数值就可以了\\n        record[s[i] - \'a\']++;\\n    }\\n    for (int i = 0; i < t.size(); i++) {\\n    \\trecord[t[i] - \'a\']--;\\n    }\\n    for (int i = 0; i < 26; i++) {\\n    \\tif (record[i] != 0) {\\n// record数组如果有的元素不为零0，说明字符串s和t 一定是谁多了字符或者谁少了字符。\\n    \\treturn false;\\n    \\t}\\n    }\\n// record数组所有元素都为零0，说明字符串s和t是字母异位词\\n    return true;\\n}\\n```\\n\\n### 3.3 两个数组的交集\\n\\n**题意**：编写一个函数，来判断两个数组的交集。注意：输出结果中的每个元素应当是唯一的，且不考虑输出结果的顺序。举例：输入nums1=[1,2,2,1]，nums2=[2,2]，输出：[2]；举例2：nums1=[4,9,5]，nums2=[9,4,9,8,4]，输出：[9,4]。\\n\\n**思路**：注意：前一题使用数组来做哈希表是因为题目限定了数值的大小，元素最大不会超过26。但是这里的话，1）**数值没有明显边界**，不建议使用数组。2）其次，**如果哈希值比较少、特别分散、跨度特别大**，也无法使用数组来做哈希表。\\n\\n此时就要使用另一种结构体了，set ，关于set，cpp 给提供了如下三种可用的数据结构：\\n\\n+ std::set\\n+ std::multiset\\n+ std::unordered_set\\n\\nstd::set和std::multiset底层实现都是红黑树，std::unordered_set的底层实现是哈希表， 使用unordered_set 读写效率是最高的，并不需要对数据进行排序，而且还不要让数据重复，所以选择unordered_set。这里主要是学会使用一种哈希数据结构：**unordered_set**。该数据结构无序、不允许重复。\\n\\n思路如下图所示：\\n\\n![](https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlFN3LVBY8kwU0hs1/root/content)\\n\\n```cpp\\nVector<int> intersection(vector<int>& nums1, vecotr<int>& nums2) {\\n\\tunordered_set<int> result_set; //存放结果，之所以用unordered_set是为了去重\\n\\t//第一步，将nums1将存入unordered_set中，这里是使用迭代器构造\\n\\tunordered_set<int> nums_set(nums1.begin(),nums1.end());\\n\\t//第二步，比较unordered_set和nums2\\n\\tfor (int num : nums2) {\\n\\t\\tif (nums_set.find(num) != nums_set.end()) {\\n\\t\\t\\tresult_set.insert(num);\\n\\t\\t}\\n\\t}\\n\\treturn vector<int>(result_set.begin(),result_set.end());\\n}\\n```\\n\\n无序集合unordered_set内部元素不可重复，没有顺序，值也不可修改。对于无序集合unordered_set，有以下几种初始化方法：\\n\\n+ 直接创建空的set：`unordered_set<int> set1;`\\n+ 拷贝构造：`unordered_set<int> set2(set1);`\\n+ 使用迭代器构造：`unordered_set<int> set3(set1.begin(),set1.end());`\\n+ 使用数组作为其初始值进行构造：`unordered_set<int> set4(arr,arr+5);`\\n+ 移动构造：`unordered_set<int> set5(move(set2));`\\n+ 使用初值列表来进行构造：`unordered_set<int> set6 {1,2,10,10};`\\n\\n**注意**：学到这，我们已经学习了unordered_set和数组两种哈希数据结构，但是要注意各自存在的缺点，数组对数据的长度有限制，且对于分布离散的数据而言存取效率低。而unordered_set内部元素不重复，不排序，十分适合需要数据去重的情况。但是相对于数组而言，不仅占用空间比数组大，而且速度要比数组慢，set把数值映射到key上都要做hash计算的。\\n\\n**说明**：后来力扣改了数据，对数组的长度做了限制，数据长度在0~1000，所以可以考虑用数组来做哈希算法。\\n\\n```cpp\\nvector<int> intersection(vector<int>&nums1,vector<int>&nums2) {\\n\\tunordered_set<int> result_set; //选择set是为了去重\\n\\tint hash[1005]={0};\\n\\tfor (int num : nums1) {\\n\\t\\thash[num] = 1;\\n\\t}\\n\\tfor (int num : nums2) {\\n\\t\\tif (hash[num] == 1) {\\n\\t\\t\\tresult_set.insert(num);\\n\\t\\t}\\n\\t}\\n\\treturn vector<int>(result_set.begin(),result_set.end());\\n}\\n```\\n\\n### 3.4 快乐数\\n\\n**题意**:编写一个算法来判断一个数是不是快乐数。**快乐数**：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为  1，那么这个数就是快乐数。\\n\\n如果是快乐数就返回True，否则返回False。\\n\\n**示例**：\\n`输入`：19\\n`输出`：true\\n`解释`：\\n1^2 + 9^2 = 82\\n8^2 + 2^2 = 68\\n6^2 + 8^2 = 100\\n1^2 + 0^2 + 0^2 = 1\\n\\n**思路**:这道题目看上去貌似一道数学问题，其实并不是！题目中说了会**无限循环**，那么也就是说**求和的过程中，sum会重复出现，这对解题很重要**！\\n\\n难点1）判断一个数是否重复出现？难点2）就是对一个数每个位上的操作，求和的过程。\\n\\n**当我们遇到需要快速判断一个元素是否存在与一个集合中时，就要用到哈希算法了**。所以这道题目使用哈希法，来判断这个sum是否重复出现，如果重复了就是return false， 否则一直找到sum为1为止。\\n\\n```cpp\\n//求每个位上的单数之和\\nint getSum(int n) {\\n\\tint sum = 0;\\n\\twhile (n) {\\n\\t\\tsum += (n % 10)*(n % 10);\\n\\t\\tn /= 10;\\n\\t}\\n\\treturn sum;\\n}\\n\\nbool isHappy(int n) {\\n\\tunordered_set<int> set;\\n\\tint n_temp = n;\\n\\twhile(1) {\\n\\t\\tint sum = getSum(n_temp);\\n\\t\\tif (sum == 1) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n        // 如果这个sum曾经出现过，说明已经陷入了无限循环了，立即return false\\n        if (set.find(sum) != set.end()) {\\n            return false;\\n        } else {\\n            set.insert(sum);\\n        }\\n\\t\\tn_temp = sum;\\n\\t}\\n}\\n```\\n\\n### 3.5 两数之和\\n\\n**题意**:给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那**两个**整数，并返回他们的数组下标。假设每种输入只会对应一个答案。注意，数组中同一个元素不能使用两遍。例如，给定 nums = [2, 7, 11, 15], target = 9，因为 nums[0] + nums[1] = 2 + 7 = 9，所以返回 [0, 1]。\\n\\n在强调一下**什么时候使用哈希法**，当我们需要查询一个元素是否出现过，或者一个元素是否在集合里的时候，就要第一时间想到哈希法。\\n\\n本题需要一个集合来存放我们遍历过的元素，然后在遍历数组的时候去询问这个集合，某元素是否遍历过，也就是是否出现在这个集合。\\n\\n因为本题中不仅要知道元素的值，还要记录元素的下标索引，所以用map更加合适。\\n\\n再来看一下使用数组和set来做哈希法的局限。\\n\\n+ **数组**的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。\\n+ **set**是一个集合，里面放的元素只能是一个key，而两数之和这道题目，不仅要判断y是否存在而且还要记录y的下标位置，因为要返回x 和 y的下标。所以set 也不能用。\\n\\ncpp中的map，有三种类型：\\n\\n| **映射**           | **底层实现** | **是否有序**                     | **数值是否可以重复**               | **能否更改数值** | **查询效率** | **增删效率** |\\n| ------------------ | ------------ | -------------------------------- | ---------------------------------- | ---------------- | ------------ | ------------ |\\n| std::map           | 红黑树       | key有序                          | key不可重复                        | key不可修改      | `O(logn)`    | `O(logn)`    |\\n| std::mutilmap      | 红黑树       | key有序                          | <font color=\\\"red\\\">key可重复</font> | key不可修改      | `O(logn)`    | `O(logn)`    |\\n| std::unordered_map | 红黑树       | <font color=\\\"red\\\">key无序</font> | key不可重复                        | key不可修改      | `O(1)`       | `O(1)`       |\\n\\n\\n这道题目中并不需要key有序，选择std::unordered_map 效率更高！ \\n\\n接下来需要明确两点：\\n\\n+ **map用来做什么**\\n+ **map中key和value分别表示什么**\\n\\nmap目的用来存放我们访问过的元素，因为遍历数组的时候，需要记录我们之前遍历过哪些元素和对应的下标，这样才能找到与当前元素相匹配的（也就是相加等于target）\\n\\nmap中key和value分别表示什么?这道题 我们需要处理数组的每个元素，判断这个元素是否出现过，如果出现过，返回这个元素的下标。那么判断元素是否出现，这个元素就要作为key，所以数组中的元素作为key，有key对应的就是value，value用来存下标。所以 map中的存储结构为`{key：数据元素，value：数组元素对应的下标}`。\\n\\n在遍历数组的时候，只需要向map去查询是否有和目前遍历元素匹配的数值，如果有，就找到的匹配对，如果没有，就把目前遍历的元素放进map中，因为map存放的就是我们访问过的元素。\\n\\n过程如下：\\n\\n![](https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlFS9JsCzF1wX-qId/root/content)\\n\\n![](https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlFUyAhmd6WUtK3mO/root/content)\\n\\n```cpp\\n//注意：map的key为元素值，value为元素下标\\nvector<int> twoSum(vector<int>& nums, int target) {\\n\\tstd::unordered_map <int,int> map;\\n\\tfor(int i = 0; i < nums.size(); i++) {\\n\\t\\t// 遍历当前元素，并在map中寻找是否有匹配的key。找到一个合适的，立即返回\\n        auto iter = map.find(target - nums[i]); \\n        if(iter != map.end()) {\\n        \\treturn {iter->second, i};\\n\\t\\t}\\n\\t\\t// 如果没找到匹配对，就把访问过的元素和下标加入到map中\\n\\t\\tmap.insert(pair<int, int>(nums[i], i)); \\n\\t}\\n\\t//循环结束后还没return说明没找到，就返回空vector\\n\\treturn {};\\n}\\n```\\n\\n**总结**:\\n本题其实有四个重点：\\n\\n+ 为什么会想到用哈希表\\n+ 哈希表为什么用map\\n+ 本题map是用来存什么的\\n+ map中的key和value用来存什么的\\n\\n本题的目的就是从一个数组中找到两个不同的元素，要求他们的和满足target。换句话说，我们拧着一个元素，然后在map中去找`target - 元素值`，如果找到了就直接返回。如果没找到，就将当前元素值存入map，然后进入下一次循环。最终循环结束后，没有返回return，说明没找到。\\n\\n### 3.6 四数相加2\\n\\n**题意**：给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -2^28 到 2^28 - 1 之间，最终结果不会超过 2^31 - 1 。\\n\\n例如：\\n\\n输入：\\n\\n+ A = [ 1, 2]  B = [-2,-1]  C = [-1, 2]  D = [ 0, 2]\\n\\n输出：\\n\\n+ 2\\n\\n**解释**：两个元组如下：\\n\\n1. (0, 0, 0, 1) -> A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0\\n2. (1, 1, 0, 0) -> A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0\\n\\n**思路**：本题是使用哈希法的经典题目，而后面的**三数之和**、**四数之和**并不适合使用哈希法。因为三数之和和四数之和这两道题目使用哈希法在不超时的情况下做到对结果去重是很困难的，很有多细节需要处理。\\n\\n而这道题目是四个独立的数组，只要找到A[i] + B[j] + C[k] + D[l] = 0就可以，不用考虑有重复的四个元素相加等于0的情况，所以相对于题目18. 四数之和，题目15.三数之和，还是简单了不少！\\n\\n如果本题想难度升级：就是给出一个数组（而不是四个数组），在这里找出四个元素相加等于0，答案中不可以包含重复的四元组，大家可以思考一下，后续的文章我也会讲到的。\\n\\n**本题解题步骤**：\\n\\n1. 首先定义 一个unordered_map，key放a和b两数之和，value 放a和b两数之和出现的次数。\\n2. 遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中。\\n3. 定义int变量count，用来统计 a+b+c+d = 0 出现的次数。\\n4. 在遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就用count把map中key对应的value也就是出现次数统计出来。\\n5. 最后返回统计值 count 就可以了\\n\\n```cpp\\n//这道题相对于“四数之和”，简单点在于不需要去重。本次时间复杂度为O(n^2)\\nint fourSumCount(vector<int>& A,vector<int>& B,vector<int>& C,vector<int>& D) {\\n\\tunordered_map<int,int> umap;\\n\\tfor (int a : A) {\\n\\t\\tfor (int b : B) {\\n\\t\\t\\tumap[a+b]++;\\n\\t\\t}\\n\\t}\\n\\tint count = 0;\\n\\tfor (int c : C) {\\n\\t\\tfor (int d : D) {\\n\\t\\t\\tif (umap.find(0-(c+d)) != umap.end()) {\\n\\t\\t\\t\\tcount += umap[0-(c+d)];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn count;\\n}\\n```\\n\\n### 3.7 赎金信\\n\\n**题意**：给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串 ransom 能不能由第二个字符串 magazines 里面的字符构成。如果可以构成，返回 true ；否则返回 false。\\n\\n(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。杂志字符串中的每个字符只能在赎金信字符串中使用一次。)\\n\\n注意：\\n\\n你可以假设两个字符串均只含有小写字母，下面三个是示例：\\n`canConstruct(\\\"a\\\", \\\"b\\\") -> false`\\n`canConstruct(\\\"aa\\\", \\\"ab\\\") -> false`\\n`canConstruct(\\\"aa\\\", \\\"aab\\\") -> true`\\n\\n**思路**：这道题和“有效的字母异位词”很像。**字母异位词**是字符串a和b的字符类型和数量应当完全相同，才能相互组成，而这里只需要保证字符串a中的字符类型和数量`<=`字符串b中的字符类型和数量，即字符串b完全能组成a，而a能否组成b不需要考虑。\\n\\n方法1：暴力解法，直接用双重for循环解决。外层循环是长字符串，内层循环是短字符串，每找到一个字符，就在对应位置删除掉短字符串上对应的字符，当短字符串长度为0时，返回true，否则返回false。\\n\\n```cpp\\nbool canConstruct(string ransomNote, string magazine) {\\n\\tfor (int i = 0; i < magazine.length(); i++) {\\n\\t\\tfor (int j = 0; j < ransomNote.lenth(); j++) {\\n\\t\\t\\tif (magazine[i] == ransomNote[j]) {\\n\\t\\t\\t\\transomNote.erase(ransomNote.begin()+j);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tif (ransomNote.length() == 0) {\\n\\t\\treturn true;\\n\\t}\\n\\treturn false;\\n//这里时间复杂度是比较高的O(n^2)，而且里面还有一个字符串删除也就是erase的操作，也是费时的\\n}\\n```\\n\\n方法2：哈希解法（大的是magazine，小的字符串是ransomNote）\\n\\n因为题目所只有小写字母，那可以采用空间换取时间的哈希策略， 用一个长度为26的数组还记录magazine里字母出现的次数。然后再用ransomNote去验证这个数组是否包含了ransomNote所需要的所有字母。一般来说，哈希数据结构的话，能用数组就用数组。使用map的空间消耗要比数组大一些的，因为map要维护红黑树或者哈希表，而且还要做哈希函数，是费时的！数据量大的话就能体现出来差别了。\\n\\n```cpp\\n//补充说明：string容器求长度用length()或size()方法都可以\\nbool canConstruct(string ransomNote, string magazine) {\\n\\tint record[26]={0};\\n\\tif (ransomNote.length() > magazine.length()) {\\n\\t\\treturn false;\\n\\t}\\n\\tfor (int i=0; i < magazine.length(); i++) {\\n\\t\\trecord[magazine[i]-\'a\']++;\\n\\t}\\n\\tfor (int j=0; j < ransomNote.length(); j++) {\\n\\t\\trecord[ransomNote[j] -\'a\']--;\\n\\t\\tif (record[ransomNote[j] -\'a\'] < 0) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n\\treturn true;\\n}\\n```\\n\\n### 3.8 三数之和\\n\\n**题意**：给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。 **注意**：答案中不可以包含重复的三元组。**再次注意**：注意[0,0,0,0]这组数据。\\n\\n示例：给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ]\\n\\n**回忆**：两数之和也是在一个数组中找到两个不同的元素，其和为target。该题的做法建立一个map数据结构，key为元素值，value为下标索引。然后遍历每个元素，在map中寻找是否存在[target-key]的值存在；如果存在就找到，直接返回；如果不存在就将当前元素存入map，继续遍历。遍历结束后仍为返回就return {}空vector。\\n\\n**解法1）哈希法**（不推荐）：\\n\\n两层for循环就可以确定 a 和b 的数值了，可以使用哈希法来确定 0-(a+b) 是否在 数组里出现过，其实这个思路是正确的，但是我们有一个非常棘手的问题，就是题目中说的不可以包含重复的三元组。把符合条件的三元组放进vector中，然后再去重，这样是非常费时的，很容易超时，也是这道题目通过率如此之低的根源所在。\\n\\n时间复杂度可以做到O(n^2)，但还是比较费时的，因为不好做剪枝操作。\\n\\n```cpp\\nvector<vector<int>> threeSum(vector<int>& nums) {\\n\\tvector<vector<int>> result;\\n\\tunordered_set<int> set;\\n\\tsort(nums.begin(),nums.end());\\n\\tfor (int i=0; i<nums.size();i++) {\\n\\t\\t// 排序之后如果第一个元素已经大于零，那么不可能凑成三元组\\n\\t\\tif (nums[i] > 0) {\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\tif (i > 0 && nums[i] == nums[i - 1]) { //三元组元素a去重\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\tfor (int j =i+1; j < nums.size();j++) {\\n\\t\\t\\tif ( j > i + 2 && nums[j] == nums[j-1] && nums[j-1] == nums[j-2]) {\\n\\t\\t\\t\\tcontinue; //三元组的元素b去重\\n\\t\\t\\t}\\n\\t\\tint c = 0 -(nums[i]+nums[j]);\\n\\t\\tif (set.find(c) != set.end()) {\\n\\t\\t\\tresult.push_back({nums[i],nums[j],c});\\n\\t\\t\\tset.erase(c);  //三元组去重c\\n\\t\\t} else {\\n\\t\\t\\tset.insert(nums[j]);\\n\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result;\\n} \\n```\\n\\n**解法2）双指针**：\\n\\n动画效果如下：\\n\\n![](https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlFh1FaSArZZ1UxyE/root/content)\\n\\n拿这个nums数组来举例，首先将数组排序，然后有一层for循环，i从下标0的地方开始，同时定一个下标left 定义在i+1的位置上，定义下标right 在数组结尾的位置上。依然还是在数组中找到 abc 使得a + b +c =0，我们这里相当于 a = nums[i]，b = nums[left]，c = nums[right]。\\n\\n接下来如何移动left 和right呢？1） 如果nums[i] + nums[left] + nums[right] > 0 就说明 此时三数之和大了，因为数组是排序后了，所以right下标就应该向左移动，这样才能让三数之和小一些。2）如果 nums[i] + nums[left] + nums[right] < 0 说明 此时 三数之和小了，left 就向右移动，才能让三数之和大一些，直到left与right相遇为止。时间复杂度：O(n^2)。\\n\\n```cpp\\nvector<vector<int>> threeSum(vector<int>& nums) {\\n\\tvector<vector<int>> result;\\n\\tsort(nums.begin(),nums.end());\\n\\tfor (int i = 0; i < nums.size(); i++) {\\n        // 排序之后如果第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，直接返回结果就可以了\\n        if (nums[i] > 0) {\\n            return result;\\n        }\\n        // 错误去重a方法，将会漏掉-1,-1,2 这种情况\\n        /*\\n        if (nums[i] == nums[i + 1]) {\\n        continue;\\n        }\\n        */\\n        // 正确去重a方法\\n        if (i > 0 && nums[i] == nums[i - 1]) {\\n        continue;\\n        }\\n        int left = i+1;\\n        int right = nums.size() -1;\\n        while (right > left) {\\n// 去重复逻辑如果放在这里，0，0，0 的情况，可能直接导致 right<=left 了，从而漏掉了 0,0,0 这种三元组\\t\\n\\t\\t\\t/*\\n\\t\\t\\twhile (right > left && nums[right] == nums[right - 1]) right--;\\n\\t\\t\\twhile (right > left && nums[left] == nums[left + 1]) left++;\\n\\t\\t\\t*/\\n\\t\\t\\tif (nums[i]+nums[left]+nums[right] > 0) right--;\\n\\t\\t\\telse if (nums[i]+nums[left]+nums[right] < 0) left++;\\n\\t\\t\\telse {\\n\\t\\t\\t\\tresult.push_back(vector<int>{nums[i],nums[left],nums[right]});\\n\\t\\t\\t\\t//去重逻辑应该放在找到一个三元组后，对b和c去重\\n\\t\\t\\t\\twhile(right > left && nums[right] == nums[right-1]) right--;\\n\\t\\t\\t\\twhile(right > left && nums[left] == nums[left+1]) left++;\\n\\t\\t\\t\\t找到答案时，双指针同时收缩\\n\\t\\t\\t\\tleft++;\\n\\t\\t\\t\\tright--;\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result;\\n} \\n```\\n\\n**去重逻辑的思考**：\\n\\n**a的去重**：\\n\\n说到去重，其实主要考虑三个数的去重。 a, b ,c, 对应的就是 nums[i]，nums[left]，nums[right]。\\n\\na 如果重复了怎么办，a是nums里遍历的元素，那么应该直接跳过去。但这里有一个问题，是判断 nums[i] 与 nums[i + 1]是否相同，还是判断 nums[i] 与 nums[i-1] 是否相同。有同学可能想，这不都一样吗。其实不一样！都是和 nums[i]进行比较，是比较它的前一个，还是比较他的后一个。如果我们的写法是：\\n\\n```cpp\\nif (nums[i] == nums[i+1]) {\\n\\tcontinue;\\n}\\n```\\n\\n那就我们就把三元组中出现重复元素的情况直接pass掉了。 例如{-1, -1 ,2} 这组数据，当遍历到第一个-1 的时候，判断下一个也是-1，那这组数据就pass了。这样就会出现漏判。**我们要做的是不能有重复的三元组，但三元组内的元素是可以重复的！** 那么应该这么写：\\n\\n```cpp\\nif (i > 0 && nums[i] == nums[i-1]) {\\n\\tcontinue;\\n}\\n```\\n\\n这么写就是当前使用 nums[i]，我们判断前一位是不是一样的元素，在看 {-1, -1 ,2} 这组数据，当遍历到 第一个 -1 的时候，只要前一位没有-1，那么 {-1, -1 ,2} 这组数据一样可以收录到结果集里。\\n\\n**b与c的去重**：\\n\\n类似于a的考虑，遍历b和c的时候，是不是也需要在每一步进行去重呢？代码如下：\\n\\n```cpp\\nwhile (eight > left) {\\n\\tif (nums[i] + nums[left] + nums[right] > 0) {\\n\\t\\tright--;\\n\\t\\t//while(left < right && nums[right]==nums[right+1]) right--;\\n\\t} else if (nums[i] + nums[left] + nums[right] < 0) {\\n\\t\\tleft++;\\n\\t\\t//while(left < eight && nums[left] == nums[left-1]) left++;\\n\\t} else {\\n\\t\\t//Todo\\n\\t}\\n}\\n```\\n\\n上文注释掉的部分就是思考的过程，似乎按照a的思路，在每次遍历的时候，需要与前一个已经遍历过的值进行比较，若相同就需要去重（不能与后一个值进行比较去重，不然会丢失诸如-1，-1，2这组值）。但仔细观察又会发现，b和c遍历的过程本身就是去重的过程，在遍历b和c时，如果三数之和大于0，则按照规则应该是右指针right左移++，类似的，下一次循环时，如果righ是重复值，也会走这个if语句，继续right++。所以遍历时就已经去重，不需要额外在用while来去重了（上述代码中被注释掉的部分）。\\n\\n**思考**：\\n\\n既然三数之和可以使用哈希法和双指针法，那我们之前讲过的两数之和可以使用双指针法吗？\\n\\n**回忆**：两数之和：从一个数组中找到两个不同的值，其和为target。只需要找到一组答案即可。**解法**：以元素值为map的key，以元素下标作为map的value，建立哈希数据结构unordered_map来求解。遍历整个数组，如果找到`map.find(target-nums[i])!=map.end()`，就直接返回`vector<int>{iter->second,i}`；如果未找到就将当前`nums[i]`和`i`存入`ma`p并进行下一次循环。循环结束后仍为`return`就直接返回空`vector{}`，表示未找到。\\n\\n本题三数之和也是从一个数组中找多个不同元素满足其和为target，但是本体的返回结果有多个且不允许重复。所以单纯使用哈希法来求解需要多考虑去重的问题，更麻烦。那两数之和能用双指针法求解吗？**不能**：因为两数之和返回的是元素下标，而在本题中使用双指针法必须对数组元素进行排序，一旦排序，下标就变了。如果两数之和的题目改成返回元素值那么就可以使用双指针法。\\n\\n### 3.9 四数之和\\n\\n**题意**：给定一个数组nums和一个target目标值，判断nums中是否存在四个元素满足其和为target，找出所有满足条件且不重复的四元组。\\n\\n**注意**：\\n\\n答案中不可以包含重复的四元组。示例： 给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。 满足要求的四元组集合为： [ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2] ]\\n\\n\\n**回忆**：前面两数之和、三数之和都是从一个数组中找到k个元素满足其和为target，两数之和是找到任意一对且返回元素下标；三数之和是找到全部且返回的是由元素组成的vector。还有四数之和2是从四个数组中分别找到四个数满足其和为target的条件，且返回的值是满足条件的元组个数。\\n\\n**回忆2**：四数之和2是采用的哈希法，a组和b组用双for循环和unordered_map来统计，c组和d组也用双for循环和unordered_map[0-(a+b)]来找符合条件的元组，并统计个数，最后的返回值是满足条件的元组个数。\\n\\n**思路**： \\n\\n\\n四数之和，和15.三数之和是一个思路，都是使用双指针法, 基本解法就是在15.三数之和的基础上再套一层for循环。\\n\\n```cpp\\nvector<vector<int>> fourSum(vector<int>& nums, int target) {\\n\\tvector<vector<int>> result;\\n\\tsort(nums.begin(),nums.end());\\n\\tfor (int k=0;k<nums.size();k++) {\\n\\t\\t//剪枝处理\\n\\t\\tif (nums[k]> target && nums[k]>=0){\\n\\t\\t\\tbreak;//这里使用break统一最后return处理\\n\\t\\t}\\n\\t\\t//对nums[k]去重\\n\\t\\tif(k>0&&nums[k] == nums[k-1]) {\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\t\\n\\t\\tfor(int i=k+1;i<nums.size();i++) {\\n\\t\\t\\t//2级剪枝处理\\n\\t\\t\\tif (nums[k]+nums[i]>target && nums[i]>=0) {\\n\\t\\t\\tbreak; //已经不满足条件了\\n\\t\\t\\t}\\n\\t\\t\\t//对nums[i]去重\\n\\t\\t\\tif (i>k+1;nms[i]==nums[i-1]) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tint left=i+1;\\n\\t\\t\\tint right = nums.size()-1;\\n\\t\\t\\twhile(right > left) {\\n\\t\\t\\t\\tif((long)nums[i]+nums[k]+nums[left]+nums[right] > target) {\\n\\t\\t\\t\\t\\tright--;\\n\\t\\t\\t\\t} else if((long)nums[i]+nums[k]+nums[left]+nums[right] < target) {\\n\\t\\t\\t\\t\\tleft++;\\n\\t\\t\\t\\t} else {\\n                    result.push_back(vector<int>{nums[i],nums[k],nums[left],nums[right]});\\n                    while(righ>left && nums[left] ==nums[left++]){\\n                        left++;\\n                    }\\n                    while(right>left && nums[right]== nums[right--]) {\\n                        right--;\\n                    }\\n                    right--;\\n                    left++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result;\\n}\\n```\\n\\n### 3.10 总结\\n\\n在哈希表这部分，我们主要介绍了数据、集合和映射三种哈希数据结构，并解决了字母异位词、两个数组交集、快乐数、四数相加2、书尽心和两数之和、三数之和、四数之和等问题。\\n\\n数组作为最基础最简单的哈希数据结构，应用简单且广泛，但也有它的局限性。首先，他只适合于数据长度有限且分布不要太过分散的情况。如果数据分散的太开，反而会造成效率和内存上的浪费。unordered_set（注：set和mutilset使用的是红黑树，unordered_set使用的是哈希表）就没有数据长度上的限制了，但是它的存储数据知识值类型，对于既要存储数组元素值又要存储数组下标的情况就得使用map映射了。类似的，只有unordered_map的底层是使用的哈希表，map和mutilmap使用的都是红黑树。使用map或set既要维护哈希表（或红黑树），又要去做哈希函数，所以效率上肯定是比不过数组的。综上，三种数据结构各有优劣，应该要视情况来选定。\\n\\n字母异位词和赎金信都是字母，而且还是小写字母，这样的话用长度为26的字符数组来做哈希算法的话就很容易了。这两者不同的是，字母异位是两个字符串的字符种类和数量要完全相同，而赎金信则是b的字符和数量要大于等于字符串a才行。\\n\\n快乐数是求一个数的每一位上数值的平方值和，其和是否为1，若不为1就再次进行计算。如果最终为1了就是快乐数，如果后面陷入了死循环就是非快乐数。这里的数据长度不固定，不能用数组，且数组为单一数值类型，还有解题的关键点在于从已有数据中找某个元素，因此选用哈希法解题，且使用unordered_set来解决。\\n\\n两个数组的交集，这题也是使用unordered_set来解题。先将nums1数组中的元素全部存入set中，然后在遍历数组nums2，查看nums2中的元素是否在set中，存在就加入result，最后再返回return result即可。\\n\\n四数相加2是从四个数组中找四个数，要找满足这四个数之和为target的元组个数。这里可以使用哈希法解决，且又要记录元素又要记录次数，所以采用unordered_map的数据结构。数组a和B使用双层for循环来统计（a+b)和的次数，如：`umap[a+b]++;`，初始化count值，然后数组c和d组成一个双层for循环，在umap中寻找满足元素值等于`target-(c+d)`的键值对，并用count变量将该键值对的值累加，最后返回count即可。\\n\\n两数之和、三数之和、四数之和都是从一个数组里面，找k个不重复的元素，要求其和为target。两数之和要求找出至少一队并返回该元组，三数之和、四数之和要求返回所有满足条件且不重复的元组集合。\\n\\n+ 两数之和因为只需找出一队，且返回的是元素下标，所以采用unordered_map来求解。遍历数组，如果在umap中找到了满足条件`umap.find(target-nums[i])`的元素，就返回`vector<int>{i,iter->second}`，否则就将当前元素存入umap:`map.insert(pair<int,int>(nums[i],i))`。\\n+ 三数之和可以使用哈希法，但是针对去重这个问题就比较麻烦。1）哈希法：第一层for，索引为i，从0到nums.size()-1;第二层for，索引为j，从i+1到nums.size()-1；然后在定义一个uset，从这个uset里面找满足条件`0-(nums[i]+nums[j])`的元素，找到了就插入到result中，代码片段如：`1/int c=0-nums[i]-nums[j]；2/if(uset.find(c)!=set.end()) 3/result.push_back({nums[i],nums[j],c});`(代码中还有对元素a,b,c的去重操作，这里未展示)。2）使用双指针法：使用双指针法的时间复杂度也是O(n^2)，但没有使用umap，少去了维护哈希表和做哈希映射的操作，更加高效。第一层for，索引为i，从0到nums.size()-1；定义left为i+1;定义right为nums.size()-1;然后第二层while(left<right)循环。在第二层循环中做这几样事：1/判断三数之和是否大于target，是的话就让right--；2/判断三数之和是否小于target，是的话就让left++；3/三数之和恰好等于target，满足题意，存入result(代码中还有对元素a,b,c的去重操作，这里未展示)。\\n+ 四数之和类似的道理，只不过增加了一层循环。第一层for，索引为i，从0到nums.size()-1；第二层for，索引为j，从i+1到nums.size()-1；然后定义left为j+1;定义right为nums.size()-1;然后第三层while(left<right)循环。\\n\\n## 四、字符串\\n\\n### 4.1 反转字符串1\\n\\n**题意**：对于用char[]给出的字符串，如果反转字符串，使用输入[\'H\',\'e\',\'l\',\'l\',\'o\']，输出[\'o\',\'l\',\'l\',\'e\',\'H\']?且要求不分配额外的内存空间。\\n\\n\\n**思路**：可以直接用库函数reverse()解决，但是有些场合不建议直接套用库函数。这里的反转字符串和反转链表很像，可以用双指针法解决。使用swap()函数来调换两个字符。\\n\\nswap有两种实现方式：1）使用tmp变量的值替换和2）通过为运算。\\n\\n```cpp\\n//1、值替换\\nint tmp=s[i];\\ns[i]=s[j];\\ns[j]=tmp;\\n//2、位运算\\ns[i] ^= s[j];\\ns[j] ^= s[i];\\ns[i] ^= s[j];\\n```\\n\\n最终的cpp代码如下：\\n\\n```cpp\\nvoid reverseString(vector<char>& s) {\\n\\tfor(int i=0,j=s.size()-1;i<s.size()/2;i++,j--) {\\n\\t\\tswap(nums[i],nums[j]);\\n\\t}\\n}\\n```\\n\\n### 4.2 反转字符串2\\n\\n**题意**： 给定一个字符串 s 和一个整数 k，从字符串开头算起, 每计数至 2k 个字符，就反转这 2k 个字符中的前 k 个字符。如果剩余字符少于 k 个，则将剩余字符全部反转。如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。\\n\\n示例：\\n\\n输入：s=\\\"abcdefg\\\",k=2\\n\\n输出：\\\"bacdfeg\\\"\\n\\n**思路**：这里的终点就是i+=(2\\\\*k)，i 每次移动 2 \\\\* k 就可以了，然后判断是否需要有反转的区间。\\n使用库函数reverse来求解（reverse函数不是本题的问题核心，可以使用）：\\n\\n```cpp\\nstring reverseStr(string s,int k) {\\n\\tfor (int i=0 ;i<s.zise();i+=2*k) {\\n\\t\\t//1. 每隔2k个字符的前k个字符进行反转\\n\\t\\t//2. 剩余字符小于2k但大于等于k个的，则反转前k个\\n\\t\\tif (i+k <= s.size()) {\\n\\t\\t\\treverse(s.begin()+i,s.begin()+i+k);\\n\\t\\t} else {\\n\\t\\t\\t//3. 剩余字符小于k，就全部翻转\\n\\t\\t\\treverse(s.begin()+i,s.end());\\n\\t\\t}\\n\\t}\\n\\treturn s;\\n}\\n```\\n\\n另一种方法是实现自己的reverse函数，下面的reverse函数时左闭右闭区间的，代码如下：\\n\\n```cpp\\nvoid reverse(string& s,int start,int end) {\\n\\tfor(int i=start,j=end;i<j;i++,j--)\\n\\t\\tswap(s[i],s[j]);\\n}\\nstring reverseStr(string s, int k) {\\n\\tfor (int i = 0; i < s.size(); i += (2 * k)) {\\n        // 1. 每隔 2k 个字符的前 k 个字符进行反转\\n        // 2. 剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符\\n        if (i + k <= s.size()) {\\n            reverse(s, i, i + k - 1);\\n            continue;\\n        }\\n        // 3. 剩余字符少于 k 个，则将剩余字符全部反转。\\n        reverse(s, i, s.size() - 1);\\n\\t}\\n\\treturn s;\\n}\\n```\\n\\n### 4.3 替换空格\\n\\n**题意**:将字符串中的空格替换成\\\"%20\\\"。\\n\\n**思路**：不使用额外的辅助空间。首先，扩充数组到每隔空格替换成\\\"%20\\\"之后的大小，然后从后往前替换空格，也就是双指针法。i指向新长度的末尾，j指向旧长度的末尾，过程如下：\\n\\n![](https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlFkgwS4cMqYe6Hq2/root/content)\\n\\n**其实很多数组填充类的问题，都可以先预先给数组扩容带填充后的大小，然后在从后向前进行操作**。\\n\\n这么做有两个好处：\\n\\n1. 不用申请新数组。\\n2. 从后向前填充元素，避免了从前向后填充元素时，每次添加元素都要将添加元素之后的所有元素向后移动的问题。\\n\\n```cpp\\nstring replaceSpace(string s){\\n\\tint count = 0; //统计空格的数量\\n\\tint sOldSize = s.size();\\n\\tfor(int i=0;i<sOldSize;i++) {\\n\\t\\tif(s[i] == \' \') count++;\\n\\t}\\n\\t//扩充字符串的大小，也就是每个空格替换成\\\"%20\\\"之后的大小\\n\\ts.resize(s.size()+count*2);\\n\\tint sNewSize = s.size();\\n\\t//从后往前将空格替换成\\\"%20\\\"\\n\\tfor(int i=sNewSize-1,j=sOldSize-1;j<i;i--,j--) {\\n\\t\\tif(s[j]!=\' \'){\\n\\t\\t\\ts[i]=s[j];\\n\\t\\t} else {\\n\\t\\t\\ts[i]=\'0\';\\n\\t\\t\\ts[i-1]=\'2\';\\n\\t\\t\\ts[i-2]=\'%\';\\n\\t\\t\\ti-=2;\\n\\t\\t}\\n\\t}\\n\\treturn s;//时间和空间复杂度都为O(1)\\n}\\n```\\n\\n### 4.4 翻转字符串里的单词\\n\\n+ 这是一道考察字符串操作的好题。\\n\\n**题意**：给定一个字符串，逐个翻转字符串中的每个单词。请注意，是反转单词，而非字符，示例：输入\\\"hello  world!  \\\"，输出：\\\"world! hello\\\"。说明：若两个单词之间有多个空格，应减少到只包含一个，若字符串末尾有多余的空格，也应该删掉。\\n\\n**思路**：这道题综合考察了字符串的许多操作。一些同学会使用split库函数，分隔单词，然后定义一个新的string字符串，最后再把单词倒序相加，那么这道题题目就是一道水题了，失去了它的意义。所以，提高一下本题的难度：**不要使用辅助空间，空间复杂度为O(1)**。\\n\\n想一下，我们将整个字符串都反转过来，那么单词的顺序指定是倒序了，只不过单词本身也倒序了，那么再把单词反转一下，单词不就正过来了。所以解题思路如下：\\n\\n+ 移除多余空格\\n+ 将整个字符串反转\\n+ 将每个单词反转\\n\\n举个例子，源字符串为：\\\"the sky is blue \\\":\\n\\n+ 移除多余空格 : \\\"the sky is blue\\\"\\n+ 字符串反转：\\\"eulb si yks eht\\\"\\n+ 单词反转：\\\"blue is sky the\\\"\\n\\n代码上的细节：\\n\\n1）移除多余空格：一些同学可能会上来写如下代码（使用erase的方法来删除空格，时间复杂度会很高）：\\n\\n```cpp\\nvoid removeExtraSpaces(string& s) {\\n\\tfor(int i=s.size()-1;i>0;i--) {\\n\\t\\tif(s[i]==s[i--]&&s[i]==\' \') {\\n\\t\\t\\ts.erase(s.begin()+i);\\n\\t\\t}\\n\\t}\\n\\t//删除字符串最后面的空格\\n\\tif(s.size()>0 && s[s.size()-1] ==\' \') {\\n\\t\\ts.erase(s.begin()+s.size()-1);\\n\\t}\\n\\t//删除最前面的空格\\n\\tif(s.size()>0 && s[0] == \' \') {\\n\\t\\ts.erase(s.begin());\\n\\t}\\n}\\n```\\n\\n**问题在哪**:上述代码一琢磨似乎时间复杂度为O(n)，但其实erase()的时间复杂度为也是O(n)，所以实际的时间复杂度就是O(n^2)。有的同学可能发现用erase来移除空格，在leetcode上性能也还行。主要是以下几点：\\n\\n+ leetcode上的测试集里，字符串的长度不够长，如果足够长，性能差距会非常明显。\\n+ leetcode的测程序耗时不是很准确的。\\n\\n2）使用双指针的方法按照去除最前面的空格、中间部分的空格和末尾空格的思路来写代码\\n\\n```cpp\\n//版本一 \\nvoid removeExtraSpaces(string& s) {\\n    int slowIndex = 0, fastIndex = 0; // 定义快指针，慢指针\\n    // 去掉字符串前面的空格\\n    while (s.size() > 0 && fastIndex < s.size() && s[fastIndex] == \' \') {\\n        fastIndex++;\\n    }\\n    for (; fastIndex < s.size(); fastIndex++) {\\n        // 去掉字符串中间部分的冗余空格\\n        if (fastIndex - 1 > 0\\n                && s[fastIndex - 1] == s[fastIndex]\\n                && s[fastIndex] == \' \') {\\n            continue;\\n        } else {\\n            s[slowIndex++] = s[fastIndex];\\n        }\\n    }\\n    if (slowIndex - 1 > 0 && s[slowIndex - 1] == \' \') { // 去掉字符串末尾的空格\\n        s.resize(slowIndex - 1);\\n    } else {\\n        s.resize(slowIndex); // 重新设置字符串大小\\n    }\\n}\\n```\\n\\n仔细考虑这个问题，是不是和数组操作的\\\"移除指定元素\\\"这个操作比较像？还是使用双指针法，将所有空格都视作需要被移除的对象，然后手动为每个单词后添加空格：\\n\\n```cpp\\n// 版本二 使用双指针法，快指针为索引，遍历所有元素，慢指针只接受满足条件的元素\\nvoid removeExtraSpaces(string& s) {//去除所有空格并在相邻单词之间添加空格, 快慢指针。\\n    int slow = 0;   //整体思想参考https://programmercarl.com/0027.移除元素.html\\n    for (int i = 0; i < s.size(); ++i) { \\n        if (s[i] != \' \') { //遇到非空格就处理，即删除所有空格。\\n            if (slow != 0) s[slow++] = \' \'; //手动控制空格，给单词之间添加空格。slow != 0说明不是第一个单词，需要在单词前添加空格。\\n            while (i < s.size() && s[i] != \' \') { //补上该单词，遇到空格说明单词结束。\\n                s[slow++] = s[i++];\\n            }\\n        }\\n    }\\n    s.resize(slow); //slow的大小即为去除多余空格后的大小。\\n}\\n```\\n\\n3）实现反转字符串的功能，这在上文已经讲了：\\n\\n```cpp\\n// 反转字符串s中左闭右闭的区间[start, end]\\nvoid reverse(string& s, int start, int end) {\\n    for (int i = start, j = end; i < j; i++, j--) {\\n        swap(s[i], s[j]);\\n    }\\n}\\n```\\n\\n综上，翻转字符串里的单词这道题的最终代码为：\\n\\n```cpp\\nvoid reverse(string& s, int start, int end){ //翻转，区间写法：左闭右闭 []\\n\\tfor (int i = start, j = end; i < j; i++, j--) {\\n\\t\\tswap(s[i], s[j]);\\n\\t}\\n}\\n\\nvoid removeExtraSpaces(string& s) {//去除所有空格并在相邻单词之间添加空格, 快慢指针。\\n\\tint slow = 0;   //整体思想参考https://programmercarl.com/0027.移除元素.html\\n\\tfor (int i = 0; i < s.size(); ++i) { //\\n\\t\\tif (s[i] != \' \') { //遇到非空格就处理，即删除所有空格。\\n\\t\\t\\tif (slow != 0) s[slow++] = \' \'; //手动控制空格，给单词之间添加空格。slow != 0说明不是第一个单词，需要在单词前添加空格。\\n\\t\\t\\twhile (i < s.size() && s[i] != \' \') { //补上该单词，遇到空格说明单词结束。\\n\\t\\t\\t\\ts[slow++] = s[i++];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\ts.resize(slow); //slow的大小即为去除多余空格后的大小。\\n}\\n\\nstring reverseWords(string s) {\\n\\tremoveExtraSpaces(s); //去除多余空格，保证单词之间之只有一个空格，且字符串首尾没空格。\\n\\treverse(s, 0, s.size() - 1);\\n\\tint start = 0; //removeExtraSpaces后保证第一个单词的开始下标一定是0。\\n\\tfor (int i = 0; i <= s.size(); ++i) {\\n\\t\\tif (i == s.size() || s[i] == \' \') { //到达空格或者串尾，说明一个单词结束。进行翻转。\\n\\t\\t\\treverse(s, start, i - 1); //翻转，注意是左闭右闭 []的翻转。\\n\\t\\t\\tstart = i + 1; //更新下一个单词的开始下标start\\n\\t\\t}\\n\\t}\\n\\treturn s;\\n}\\n```\\n\\n### 4.5 左旋转字符串\\n\\n**题意**：字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串\\\"abcdefg\\\"和数字2，该函数将返回左旋转两位得到的结果\\\"cdefgab\\\"。\\n\\n**思路**：如果能申请额外空间的话，就可以用提取子串的方法substr()将前n个字符提取出来，然后在追加到原字符串末尾就行了(但是substr()方法需要申请额外的空间)。为了让本题更有意义，提升一下本题难度：**不能申请额外空间，只能在本串上操作**。回顾上一题，翻转字符串里的单词，是使用整体反转+局部反转的方式来实现反转单词顺序的目的。这道题也类似，具体步骤为：\\n\\n1. 反转区间为前n的子串；\\n2. 反转区间为n到末尾的子串；\\n3. 反转整个字符串\\n\\n![](https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlFpfBs6U4gvnd_wZ/root/content)\\n\\ncpp代码如下所示：\\n\\n```cpp\\nstring reverseLeftWords(string s, int n) {\\n\\treverse(s.begin(), s.begin() + n);\\n\\treverse(s.begin() + n, s.end());\\n\\treverse(s.begin(), s.end());\\n\\treturn s;\\n }\\n```\\n\\n**总结**：\\n\\n此时我们已经反转过很多次字符串了，一起来回顾一下。\\n\\n在\\\"反转字符串1\\\"中，第一次降到反转一个字符串该怎么做，使用了双指针法。\\n\\n在\\\"反转字符串2\\\"中，对反转限定了条件，要求前2k个字符只翻转前k个，需要固定规律一段一段去处理字符串的时候，就要在for循环的表达式上去做文章。\\n\\n在\\\"反转字符串里的单词\\\"中，要对一句话里的单词顺序进行反转，发现先整体反转、在局部反转是个不错的思路。\\n\\n最后在讲到本题，本题是先局部反转再整体反转，也是一种新思路。\\n\\n最后补充说明一下，substr()这个方法和反转时间复杂度都是一样的，都是O(n)，但是substr()需要申请额外空间。\\n\\n\\n### 4.6 实现strStr()\\n\\n**题意**：实现 strStr() 函数。给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。例如：输入: haystack = \\\"hello\\\", needle = \\\"ll\\\" 输出: 2。说明: 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。\\n\\n**思路**：本题是KMP的经典题目。KMP的经典思想就是:**当出现字符串不匹配时，可以记录一部分之前已经匹配的文本内容，利用这些信息避免从头再去做匹配**。\\n\\n**KMP算法**：\\n字符串的匹配算法有两种：1）BF算法(Brute-Force，暴力解法)，就是目标串和模式串都从0开始比较，当遇到不匹配的字符时，模式串索引值j直接返回到起点0，而目标串的索引`i=i-j+2`。为什么加2呢？如下图所示，因为理论上模式串匹配完一次后，如果没匹配上，模式串j直接回到0，而目标串i回到遍历的下一个位置（下图中手写笔画的位置，也就是索引1的位置）。但是在上一次的匹配过程中，i已经走到了3号的位置，所以不仅是j要回头开头，i也要回溯。这也是暴力解法时间复杂度高的原因所在O(m\\\\*n)。\\n\\n![](https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlFxIwhkqFTYq0xCx/root/content)\\n\\n2）KMP算法原理：KMP算法就是让目标串的i不要回溯，向遍历指针一样一直往前走。并且分析模式串字符构成特点，尽量让j不要回到0处重复匹配来提高匹配效率。通过分析模式串的字符构成特点，来设计一个\\\"如果匹配失败就指示下次跳转的位置的数组\\\"，这个数组就是next[]数组。KMP的主要思想是**当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了**。\\n\\n前缀表：前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。前缀表是**记录下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。**\\n\\n前缀：是指不包含最后一个字符的所有以第一个字符开头的连续子串。\\n\\n后缀：是指不包含第一个字符的所有以最后一个字符结尾的连续子串。\\n\\n前缀表：要求的就是最大的相同前后缀的长度。\\n\\n**为什么一定要使用前缀表**：\\n\\n刚刚匹配的过程在下标5的地方遇到不匹配，模式串是指向f，如下图：\\n\\n![](https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlF2fBMmjPS2yUa3A/root/content)\\n\\n然后就找到了下标2，指向b，继续匹配：如图：\\n\\n![](https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlF5rdletPm7T6ZJH/root/content)\\n\\n以下这句话，对于理解为什么使用前缀表可以告诉我们匹配失败之后跳到哪里重新匹配 非常重要！\\n\\n**下标5之前这部分的字符串（也就是字符串`aabaa`）的最长相等的前缀 和 后缀字符串是 子字符串`aa` ，因为找到了最长相等的前缀和后缀，匹配失败的位置是后缀子串的后面，那么我们找到与其相同的前缀的后面重新匹配就可以了。**\\n\\n所以前缀表具有告诉我们当前位置匹配失败，跳到之前已经匹配过的地方的能力。\\n\\n前缀表与next数组：\\n\\n有的是直接把next数组做前缀表，有的是把next数组每一位减一后的数组做next数组，有的是把next数组统一右移一位做next数组。注意：这题的next数组是从下表索引0开始计算的，而很多课程或教材，例如《大话数据结构》是从数组下标1开始计算的。\\n\\n**时间复杂度分析**：\\n\\n暴力算法是O(m\\\\*n)，使用KMP算法是O(m+n)，不过KMP算法针对模式串中有较多重复字符时才能提高搜索效率，这点也需注意。\\n\\n**一、构造next数组**：\\n\\n**构造next数组其实就是计算模式串s，前缀表的过程**。 主要有如下三步：\\n\\n+ 初始化\\n+ 处理前后缀不相同的情况\\n+ 处理前后缀相同的情况\\n\\n接下来详细叙述一下（直接使用next数组做前缀表，且next数组从数组下标0开始）：\\n\\n1. 初始化\\n\\n定义两个指针i和j，j指向前缀末尾位置，i指向后缀末尾位置。然后还要对next数组进行初始化赋值，如下：\\n\\n```cpp\\nint j = 0;\\nnext[0] = 0;//next[i] 表示 i（包括i）之前最长相等的前后缀长度（其实就是j）所以初始化next[0] = j 。\\n```\\n\\n2. 处理前后缀不相同的情况\\n\\n遍历模式串的循环下标索引从1开始，因为下标为0时，显然最大公共前后缀为0，即next[0]的初始值；\\n`for(int i=1;i<s.size();i++) {`\\n如果 s[i] 与 s[j]不相同，也就是遇到前后缀末尾不相同的情况，就要向前回退。使用next数组来回退：`j=next[j-1]`。\\n\\n3. 处理前后缀相同的情况\\n   如果 s[i] 与 s[j + 1] 相同，那么就同时向后移动i 和j 说明找到了相同的前后缀，同时还要将j（前缀的长度）赋给next[i], 因为next[i]要记录相同前后缀的长度。\\n\\n```cpp\\nif(s[i] == s[j]) {\\n\\tj++;\\n}\\nnext[i]=j;\\n```\\n\\n**二、使用next数组来做匹配**：\\n\\n1. 目标串（主串）从0开始遍历字符串数组：\\n\\n```cpp\\nfor(int i=0;i<s.size();i++)\\n```\\n\\n2. 接下来就是`s[i]` 与 `t[j]` （因为j从0开始的） 进行比较。\\n\\n如果 `s[i]` 与 `t[j + 1]` 不相同，j就要从next数组里寻找下一个匹配的位置。\\n\\n```cpp\\nwhile(j>=0 && s[i]!=t[j]) {\\n\\tj=next[j];\\n}\\n```\\n\\n3. 如果s[i]和t[j]相同，那么i和j同时往后移动\\n\\n```\\nif (s[i] == t[j]) {\\n\\tj++;\\n}\\n```\\n\\n如何判断在文本串s里出现了模式串t呢，如果j指向了模式串t的末尾，那么就说明模式串t完全匹配文本串s里的某个子串了。\\n\\n本题要在文本串字符串中找出模式串出现的第一个位置 (从0开始)，所以返回当前在文本串匹配模式串的位置i 减去 模式串的长度，就是文本串字符串中出现模式串的第一个位置。\\n\\n代码如下：\\n\\n```cpp\\nif (j == (t.size() - 1) ) {\\n    return (i - t.size() + 1);\\n}\\n```\\n\\n所有代码如下：\\n\\n```cpp\\nvoid getNext(int* next, const string& s) {\\n\\tint j = 0;\\n\\tnext[0] = 0;\\n\\tfor(int i = 1; i < s.size(); i++) {\\n\\t\\twhile (j > 0 && s[i] != s[j]) {\\n\\t\\t\\tj = next[j - 1];\\n\\t\\t}\\n\\t\\tif (s[i] == s[j]) {\\n\\t\\t\\tj++;\\n\\t\\t}\\n\\t\\tnext[i] = j;\\n\\t}\\n}\\nint strStr(string haystack, string needle) {\\n\\tif (needle.size() == 0) {\\n\\t\\treturn 0;\\n\\t}\\n\\tint next[needle.size()];\\n\\tgetNext(next, needle);\\n\\tint j = 0;\\n\\tfor (int i = 0; i < haystack.size(); i++) {\\n\\t\\twhile(j > 0 && haystack[i] != needle[j]) {\\n\\t\\tj = next[j - 1];\\n\\t\\t}\\n\\t\\tif (haystack[i] == needle[j]) {\\n\\t\\t\\tj++;\\n\\t\\t}\\n\\t\\tif (j == needle.size() ) {\\n\\t\\t\\treturn (i - needle.size() + 1);\\n\\t\\t}\\n\\t}\\n\\treturn -1;\\n}\\n```\\n\\n**总结**：\\n\\n我们介绍了什么是KMP，KMP可以解决什么问题，然后分析KMP算法里的next数组，知道了next数组就是前缀表，再分析为什么要是前缀表而不是什么其他表。\\n\\n接着从给出的模式串中，我们一步一步的推导出了前缀表，得出前缀表无论是统一减一还是不减一得到的next数组仅仅是kmp的实现方式的不同。\\n\\n其中还分析了KMP算法的时间复杂度，并且和暴力方法做了对比。\\n\\n然后先用前缀表统一减一得到的next数组，求得文本串s里是否出现过模式串t，并给出了具体分析代码。\\n\\n又给出了直接用前缀表作为next数组，来做匹配的实现代码。\\n\\n**求next数组的小技巧（以下图为例）**：\\n\\n![](https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlGG-X8nEvHZ1plBp/root/content)\\n\\n第一个字符a，无前缀后缀，所以为0；\\n第二个字符串as，无最长公共前后缀，所以为0；\\n第三个字符串asd，无最长公共前后缀，所以为0；\\n...\\n第五个字符串asdfa,最长公共前后缀是a，所以是1；\\n类似的，第9个字符串asdfasdfa,（最长前缀是asdfasdf，最长后缀是sdfasdfa。不相同，所以不是8）最长公共前后缀asdfa：前缀是asdfa(从[0]到[4]),后缀是asdfa(从[4]到[8])，随意最长公共前后缀为5\\n...\\n上述计算结束后，每一位在统一减一，就可以得到上图中的next数组了。\\n\\n### 4.7 重复的子字符串\\n\\n**题意**：给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。示例：输入：\\\"abab\\\"，输出True.\\n**思路**：主要有三种方法：1）暴力解法：第一层循环遍历整个字符串，第二层来寻找最小子串，子串的起点始终为起点，终点为当前遍历点，然后看这个子串能否构成整个大串。2）移动匹配法；3）KMP算法。\\n\\n**移动匹配**：\\n\\n当一个字符串s：`abcabc`，内部由重复的子串组成，那么这个字符串的结构一定是由前后相同的子串组成。那么既然前面有相同的子串，后面有相同的子串，用 s + s，这样组成的字符串中，后面的子串做前串，前后的子串做后串，就一定还能组成一个s。**所以判断字符串s是否由重复子串组成，只要两个s拼接在一起，里面还出现一个s的话，就说明是由重复子串组成**。也就是说，假设字符串s由a和b组成，若`s=a+b`，当`a+b+a+b`中仍然存在一个s时，说明`s=b+a`，说明a和b是一样的，也就是说s可以由重复子串a(或b)构成。\\n\\n当然，我们在判断 s + s 拼接的字符串里是否出现一个s的的时候，**要刨除 s + s 的首字符和尾字符**，这样避免在s+s中搜索出原来的s，我们要保证搜索的是中间拼接出来的s。\\n\\n```cpp\\nbool repeatedSubstringPattern(string s) {\\n\\tstring t = s + s;\\n\\tt.erase(t.begin());//掐头去尾\\n\\tt.erase(t.end()-1);\\n\\tif(t.find(s) != std::string::npos)//std::string::npos\\n\\t\\treturn true;\\n\\treturn false;\\n}\\n```\\n\\n注：\\n\\n关于std::string::npos的使用说明：\\n\\n+ （1）它是一个常量静态成员值，对于 size_t 类型的元素具有最高可能值。\\n+ （2）它实际上意味着直到字符串的末尾。\\n+ （3）它用作字符串成员函数中长度参数的值。\\n+ （4）作为返回值，它通常用于表示没有匹配项。\\n+ （5）数据类型为size_t的话string:npos常量被定义为-1，因为size_t是无符号整数类型，-1是该类型的最大可能表示值。\\n\\n```cpp\\n//1、std::string::npos一般最常见用于表示未找到的情况\\nstring str = \\\"I am cver\\\";\\nsize_t index = str.find(\'.\');\\n//字符没找到\\nif (index == string::npos) {\\n\\tcout<<\\\"this does not contain any period!\\\"<<endl;\\n\\tcout<<index<<endl;\\n}\\n//2、作字符串成员函数中长度参数的值\\n#include <iostream>\\n#include <string>\\nusing namespace std;\\nint main()\\n{\\n\\tstring str = \\\"I am cver.\\\";\\n\\tsize_t index = str.find(\'.\'); \\n\\tif(index == string::npos)\\n\\t{\\n\\t\\tcout << \\\"This does not contain any period!\\\" << endl;\\n\\t\\tcout << index << endl;\\n\\t}\\n\\telse\\n\\t{\\n\\t\\tstr.replace(index, string::npos, \\\"!\\\"); //string& replace(int p0, int n0,const char *s);删除从p0开始的n0个字符，然后在p0处插入串s\\n\\t\\tcout << str << endl;\\n\\t\\tcout << index << endl;\\n\\t}\\t\\t\\n}\\n```\\n\\n不过这种解法还有一个问题，就是 我们最终还是要判断 一个字符串（s + s）是否出现过 s 的过程，大家可能直接用contains，find 之类的库函数。 却忽略了实现这些函数的时间复杂度（暴力解法是m * n，一般库函数实现为 O(m + n)）。如果我们做过 28.实现strStr (opens new window)题目的话，其实就知道，实现一个 高效的算法来判断 一个字符串中是否出现另一个字符串是很复杂的，这里就涉及到了KMP算法。\\n\\n**KMP**：\\n\\n<为什么使用MKP算法>？\\n\\n在一个串中查找是否出现过另一个串，这是KMP的看家本领。那么寻找重复子串怎么也涉及到KMP算法了呢？\\n\\n在由重复子串组成的字符串中，最长相等前后缀不包含的子串就是最小重复子串，这里拿字符串s：abababab 来举例，ab就是最小重复单位，如图所示：\\n\\n![](https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlF8PCVBCA1rDlM4M/root/content)\\n\\n<如何找到最小重复子串>？\\n\\n步骤一：因为 这是相等的前缀和后缀，t[0] 与 k[0]相同， t[1] 与 k[1]相同，所以 s[0] 一定和 s[2]相同，s[1] 一定和 s[3]相同，即：，s[0]s[1]与s[2]s[3]相同 。\\n\\n步骤二： 因为在同一个字符串位置，所以 t[2] 与 k[0]相同，t[3] 与 k[1]相同。\\n\\n步骤三： 因为 这是相等的前缀和后缀，t[2] 与 k[2]相同 ，t[3]与k[3] 相同，所以，s[2]一定和s[4]相同，s[3]一定和s[5]相同，即：s[2]s[3] 与 s[4]s[5]相同。\\n\\n步骤四：循环往复。\\n\\n所以字符串s，s[0]s[1]与s[2]s[3]相同， s[2]s[3] 与 s[4]s[5]相同，s[4]s[5] 与 s[6]s[7] 相同。\\n\\n正是因为 最长相等前后缀的规则，当一个字符串由重复子串组成的，最长相等前后缀不包含的子串就是最小重复子串。\\n\\n![](https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlGCHOJOsongi-3Eh/root/content)\\n\\n**简单推理**：\\n\\n这里再给出一个数学推导，就容易理解很多。\\n\\n假设字符串s使用多个重复子串构成（这个子串是最小重复单位），重复出现的子字符串长度是x，所以s是由n * x组成。\\n\\n因为字符串s的最长相同前后缀的长度一定是不包含s本身，所以 最长相同前后缀长度必然是m * x，而且 n - m = 1，（这里如果不懂，看上面的推理）\\n\\n所以如果 nx % (n - m)x = 0，就可以判定有重复出现的子字符串。\\n\\nnext 数组记录的就是最长相同前后缀 字符串：KMP算法精讲 (opens new window)这里介绍了什么是前缀，什么是后缀，什么又是最长相同前后缀)， 如果 next[len - 1] != -1，则说明字符串有最长相同的前后缀（就是字符串里的前缀子串和后缀子串相同的最长长度）。\\n\\n最长相等前后缀的长度为：next[len - 1] + 1。(这里的next数组是以统一减一的方式计算的，因此需要+1，两种计算next数组的具体区别看这里：字符串：KMP算法精讲 (opens new window))\\n\\n数组长度为：len。\\n\\n如果len % (len - (next[len - 1] + 1)) == 0 ，则说明数组的长度正好可以被 (数组长度-最长相等前后缀的长度) 整除 ，说明该字符串有重复的子字符串。\\n\\n**数组长度减去最长相同前后缀的长度相当于是第一个周期的长度，也就是一个周期的长度，如果这个周期可以被整除，就说明整个数组就是这个周期的循环。**\\n\\n例如下图：\\n\\n![](https://api.onedrive.com/v1.0/shares/s!An8j80bjmrTdlGG-X8nEvHZ1plBp/root/content)\\n\\n`next[len - 1] = 7，next[len - 1] + 1 = 8`，8就是此时字符串asdfasdfasdf的最长相同前后缀的长度。\\n\\n`(len - (next[len - 1] + 1))` 也就是： 12(字符串的长度) - 8(最长公共前后缀的长度) = 4， 4正好可以被 12(字符串的长度) 整除，所以说明有重复的子字符串（asdf）。\\n\\ncpp代码实现：\\n\\n```cpp\\nvoid getNext (int* next, const string& s){\\n\\tnext[0] = 0;\\n\\tint j = 0;\\n\\tfor(int i = 1;i < s.size(); i++){\\n\\t\\t while(j > 0 && s[i] != s[j]) {\\n\\t\\t\\t j = next[j - 1];\\n\\t\\t}\\n\\t\\tif(s[i] == s[j]) {\\n\\t\\t\\tj++;\\n\\t\\t}\\n\\t\\tnext[i] = j;\\n\\t}\\n}\\nbool repeatedSubstringPattern (string s) {\\n\\tif (s.size() == 0) {\\n\\t\\treturn false;\\n\\t}\\n\\tint next[s.size()];\\n\\tgetNext(next, s);\\n\\tint len = s.size();\\n\\tif (next[len - 1] != 0 && len % (len - (next[len - 1] )) == 0) {\\n\\t\\treturn true;\\n\\t}\\n\\treturn false;\\n}\\n```\\n\\n### 4.8 总结\\n\\n**什么是字符串**：\\n\\n字符串是若干字符组成的有限序列，也可以理解为是一个字符数组，但是很多语言对字符串做了特殊的规定，接下来我来说一说C/cpp中的字符串。在C语言中，把一个字符串存入一个数组时，也把结束符 \'\\\\0\'存入数组，并以此作为该字符串是否结束的标志。\\n\\n在cpp中，提供一个string类，string类会提供 size接口，可以用来判断string类字符串是否结束，就不用\'\\\\0\'来判断是否结束。\\n\\n字符串的长度计算有`size()`也可以用`length()`，那么`vector<char>`和string的区别在哪？基本上没差别，不过string提供了更多的字符串处理的相关接口，例如string重载了+，而vector却没有。\\n\\n**双指针法**：\\n\\n在**反转字符串1**中，是反转字符串中的所有字符，可以使用双指针，两个指针一个从头开始，一个从未开始进行交换，以实现题目的功能。\\n\\n在**字符串：替换空格**中，我们需要将空格全部替换成指定的字符串，本题中是将空格替换成“%20”。**其实很多数组填充类的问题，都可以先预先给数组扩容带填充后的大小，然后在从后向前进行操作**。\\n\\n在**翻转字符串中的单词**中，与之前**移除数组元素**类似，双指针法，一个快指针做遍历，另一个慢指针来保留有用的元素。在这里，我们将空格全部当成需要移除的元素来处理，就与以前移除数组元素的操作相同了。然后，后面在对每个单词后面添加一个空格。这样就达到了“移除字符串中多余空格的目的”。\\n\\n需要注意的是，库函数erase()的时间复杂度为O(n)。\\n\\n**反转系列**：\\n\\n反转其实实在考察队代码的掌控能力。\\n\\n在**反转字符串2**中，每隔2k字符就翻转前k个字符，不足k的话就翻转全部字符。其实，当需要固定规律一段一段去处理字符串时，可以在for循环的表达式上坐坐文章。\\n\\n在**翻转字符串里的单词**中要求翻转字符串里面的单词，这道题目可以说是考察了字符串的多种操作，是考察字符串的一道好题。解法是：1）先去掉多余的空格；2）在整体反转，3）再局部反转。\\n\\n还有一个字符串的左转：剑指Offer58-II.左旋转字符串：给定字符串和一个数字，实现将数字前的字符移动到字符串末尾，如：输入\\\"abcdefg\\\"和2，得到\\\"cdefgab\\\"。这道题的思路是：1）先反转前n个字符，2）再反转n到末尾的字符，3）最后在反转整个字符串。而这三步骤，其核心就是”给定一个字符串，反转其全部字符“，就是本章节的第一题，使用双指针从头和从尾两端同时替换即可。\\n\\n**KMP系列**：\\n\\n问题1是实现子串问题，判断字符串2是不是字符串1的子串。采用KMP的方法，先对子串2进行分析，得到其next数组（该next数组反映了子串2的字符排列特点，可以在与主串的匹配查找过程中提供指针跳转的参考依据）。然后就是在next数组的基础上进行两字符串匹配的过程了。\\n\\n问题2是重复子串问题，就是说一个字符串能否由它的子串完整构成，例如主串\\\"abababab\\\"可以有子串\\\"ab\\\"完整构成。方法主要有移动匹配和KMP算法。移动构造：判断字符串s是否可以由子串构成，就1）构造s+s的字符串，2）刨除首字符和尾字符，3）判断剩余的字符中有无字符串s。有就是满足题意。\\n\\n```cpp\\nbool repeatSubstring(string s) {\\n\\tstring t = s + s;\\n\\tt.erase(t.begin());\\n\\tt.erase(t.end()-1);\\n\\tif(t.find(s) != std::string::npos) \\n\\t\\treturn true;\\n\\treturn false;\\n}\\n```\\n\\n注意，一般暴力解法的复杂度是O(N^2)，库函数（如contains、find)的复杂度是O(m+n)。\\n\\n## 五、双指针法\\n\\n本章节主要是复习前面的内容。双指针法在数组、链表和字符串中很常用。\\n\\n**数组**：\\n\\n1. 移除元素\\n\\n**链表**：\\n\\n1. 翻转链表\\n2. 删除链表的倒数第N个节点\\n3. 链表相交\\n4. 环形链表2\\n\\n**哈希表**：\\n\\n1. 三数之和\\n2. 四数之和\\n\\n**字符串**：\\n\\n1. 反转字符串(单个字符串内的全部字符)\\n2. 替换空格\\n3. 反转字符串中的单词\\n\\n**__总结__**：\\n在【数组篇】中有删除元素一节，一些同学可能会写出下列代码(伪代码)：\\n\\n```cpp\\nfor (int i = 0; i>array.size(); i++) {\\n\\tif (array[i] == target) {\\n\\t\\tarray.erase(i);\\n\\t}\\n}\\n```\\n\\n这个代码看着是只有O(n)的复杂度，其实是O(n^2)的复杂度，因为erase操作也是O(n)的操作。数组本身不能真正的删除元素，只能覆盖。\\n\\n在【链表篇】中，使用双指针法来翻转链表、确定单链表是否有环和环入口。\\n\\n在【哈希表篇】中，使用双指针法实现了N数之和。\\n\\n在【字符串篇】中，使用双指针法实现了反转字符串、替换空格和删除冗余空格。\\n\\n## 六、栈与队列\\n\\n\\n\\n\\n\\n\\n## 七、二叉树\\n\\n## 八、回溯算法\\n\\n## 九、贪心算法\\n\\n## 十、动态规划\\n\\n## 十一、单调栈\\n\\n## 十二、额外题目\\n\\n\",\"articleCover\":\"https://upload.haoxx.site/article/da9646e2e30563537d21e5a36a4ac461.jpg\",\"articleTitle\":\"代码随想录学习笔记_第一部分[总结]\",\"articleType\":1,\"categoryName\":\"找工作\",\"id\":90,\"isRecommend\":0,\"isTop\":0,\"status\":1,\"tagNameList\":[]}]','PUT','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',31,'2023-06-07 20:00:08');
INSERT INTO `t_operation_log` VALUES (1392,'文章模块','上传','/admin/article/upload','com.ican.controller.ArticleController.saveArticleImages','上传文章图片','image_72.jpg','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/article/0ee03ae43908303571e0982183382565.jpg\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',12,'2023-06-07 20:00:31');
INSERT INTO `t_operation_log` VALUES (1393,'文章模块','修改','/admin/article/update','com.ican.controller.ArticleController.updateArticle','修改文章','[{\"articleContent\":\"---\\ntitle: 设计模式总结\\ndate: 2022-10-30\\ncategory:\\n - 5设计模式\\n\\nfooter: <a href=\\\"https://beian.miit.gov.cn/#/Integrated/index\\\">渝ICP备2023001651号</a>\\n\\n---\\n\\n:::tip\\n设计模式总结\\n:::\\n\\n<!-- more -->\\n\\n\\n由GoF提出的设计模式有23种，再加上一种简单工厂模式，一共有24种模式，并大致分为三类。内容参考了[BiliBili视频黑马程序员(学完c++提高后在学这个)](https://www.bilibili.com/video/BV1Mb411t7ut?p=11&vd_source=d0ee64ac63fa4af6553687c1e0a80570)，以及热心网友整理的学习笔记：[CSDN博客](https://blog.csdn.net/weixin_42636062/category_11313224.html)，此外，程杰的《大话设计模式》一书也给此次笔记整理提供了巨大的帮助。\\n\\n| 创建型模式                            | 描述 |\\n| ------------------------------------- | ---- |\\n| <font color=\'red\'>简单工厂模式</font> |      |\\n| <font color=\'red\'>工厂方法模式</font> |      |\\n| <font color=\'red\'>抽象工厂模式</font> |      |\\n| <font color=\'red\'>单例模式</font>     |      |\\n| 原型模式                              |      |\\n| 建造者模式                            |      |\\n\\n\\n结构型模式，就是让类和类进行组合，获得更大的结构。\\n\\n| 结构型模式                          | 描述 |\\n| ----------------------------------- | ---- |\\n| <font color=\'red\'>代理模式</font>   |      |\\n| <font color=\'red\'>装饰模式</font>   |      |\\n| <font color=\'red\'>外观模式</font>   |      |\\n| <font color=\'red\'>适配器模式</font> |      |\\n| 桥接模式                            |      |\\n| 组合模式                            |      |\\n| 享元模式（共享）                    |      |\\n\\n\\n行为型模式，用来对类或对象怎样交互和怎样分配职责进行描述。\\n\\n| 行为型模式                          | 描述 |\\n| ----------------------------------- | ---- |\\n| <font color=\'red\'>模板模式</font>   |      |\\n| <font color=\'red\'>命令模式</font>   |      |\\n| <font color=\'red\'>策略模式</font>   |      |\\n| <font color=\'red\'>观察者模式</font> |      |\\n| 职责链模式                          |      |\\n| 解释器模式                          |      |\\n| 迭代器模式                          |      |\\n| 中介者模式                          |      |\\n| 备忘录模式                          |      |\\n| 状态模式                            |      |\\n| 访问者模式                          |      |\\n\\n\",\"articleCover\":\"https://upload.haoxx.site/article/0ee03ae43908303571e0982183382565.jpg\",\"articleTitle\":\"设计模式总结\",\"articleType\":1,\"categoryName\":\"设计模式\",\"id\":89,\"isRecommend\":0,\"isTop\":0,\"status\":1,\"tagNameList\":[]}]','PUT','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',17,'2023-06-07 20:00:32');
INSERT INTO `t_operation_log` VALUES (1394,'文章模块','上传','/admin/article/upload','com.ican.controller.ArticleController.saveArticleImages','上传文章图片','image_48.jpg','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/article/370336be7166eb151f9877379c989b33.jpg\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',13,'2023-06-07 20:00:41');
INSERT INTO `t_operation_log` VALUES (1395,'文章模块','修改','/admin/article/update','com.ican.controller.ArticleController.updateArticle','修改文章','[{\"articleContent\":\"---\\ntitle: UML图图示\\ndate: 2022-10-30\\ncategory:\\n - 5设计模式\\n\\nfooter: <a href=\\\"https://beian.miit.gov.cn/#/Integrated/index\\\">渝ICP备2023001651号</a>\\n\\n---\\n\\n:::tip\\nUML图图示\\n:::\\n\\n<!-- more -->\\n\\n\\n基本关系预览图如下：\\n![图1](https://s3.bmp.ovh/imgs/2022/08/26/b5cd7823d6081560.png)\\n\\n首先，一个矩形就表示一个类，分为三行。第一行为类名，如果为斜体就是抽象类，第二行为类的属性（变量），第三行为类的方法（函数）。第二行的属性名和第三行的方法名前，+表示public，-表示private，#表示protected。如下图所示。\\n![图2](https://s3.bmp.ovh/imgs/2022/08/26/31e4605813d2c887.jpg)\\n\\n然后，是接口。接口有两种表示方法。方法一：矩阵表示法。矩阵第一行顶端有《interface》,第一行还有接口的名称，第二行是接口的方法。方法二：棒棒糖表示法：圆圈旁为接口名称，接口方法在实现类中出现。见下图所示：\\n![图3](https://s3.bmp.ovh/imgs/2022/08/26/65811fa415ced78b.png)\\n\\n再然后，是类与类之间和类与接口之间的关系。类与类之间，有继承关系、关联关系、聚合关系、合成（组合）关系和依赖关系。类与接口之间有实现接口关系。\\n\\n|            关系            |     表示方式      |\\n| :------------------------: | :---------------: |\\n|          继承关系          |  空心三角形+实线  |\\n|          关联关系          |     实线箭头      |\\n|          聚合关系          | 空心菱形+实线箭头 |\\n|          组合关系          | 实心菱形+实线箭头 |\\n|          依赖关系          |     虚线箭头      |\\n| （类与接口）实现接口的关系 |  空心三角形+虚线  |\\n\\n1.1  类一类之间的继承关系。用**空心三角形+实线**来表示。\\n![图4](https://s3.bmp.ovh/imgs/2022/08/26/04d598806cfc056e.png)\\n1.2  类一类之间的关联关系。用**实心箭头**来表示。\\n\\n企鹅与气候有很大的关联，企鹅需要知道气候的变化，需要了解气候规律。所以，企鹅继承于鸟基类，且有一个私有属性：气候。\\n![图5](https://s3.bmp.ovh/imgs/2022/08/26/21502e3c6a8adcef.jpg)\\n1.3  类一类之间的聚合关系。用**空心的菱形+实线箭头**来表示。\\n\\n聚合表示一种弱的拥有关系。体现的是A对象可以包含B对象，但B对象不是A对象的一部分。大雁可以聚合起来，称为大雁群，也可以不聚合，称为单雁。\\n![图6](https://s3.bmp.ovh/imgs/2022/08/26/cb326bbfa3cfd4ac.jpg)\\n1.4  类一类之间的合成（组合）关系。用**实心菱形+实线箭头**来表示。\\n\\n合成关系与聚合关系不同，合成关系表示一种强的拥有关系。鸟拥有羽毛，这是必然的，他们两是整体与部分的关系，并且生命周期相同。合成关系用**实心菱形和实线箭头**来表示，另外，你会注意到合成关系的连线两端还有一个数字‘1’和\'2\'，这被称为基数，表明这一段的类可以有几个实例。很显然，一只鸟应该有两只翅膀。注意：关联关系、聚合关系也可以有基数。\\n![图7](https://s3.bmp.ovh/imgs/2022/08/26/454c5f84f6533087.png)\\n1.5  类一类之间的依赖关系。用**虚线箭头**来表示。\\n\\n依赖关系就如字面意思，动物依赖于水，依赖于氧气。依赖关系用**虚线箭头**表示。\\n![图8](https://s3.bmp.ovh/imgs/2022/08/26/1fe1c94bb8cb10bd.jpg)\\n2.1 类与接口之间的实现接口关系，用空心三角形+虚线表示。\\n\\n实现接口和继承很类似，继承关系是空心三角形+实线来表示的。注意，仅当用矩阵表示法来表示接口时采用空心三角形+虚线表示，用棒棒糖法来表示接口时，无需其他说明。\\n![图9](https://s3.bmp.ovh/imgs/2022/08/26/022180a1216da787.png)\\n\\n**总结**：\\n更一般地，一个小总结：继承关系/关联关系/聚合关系/合成关系/依赖关系，以及一个实现接口关系。\\n\\n继承关系就是在子类名的定义中，类名后加上：public 基类名。\\n\\n关联关系就是在类中定义一个私有属性，例如企鹅和气候有关联关系，那么就在企鹅类中定义一个气候的私有变量。\\n\\n聚合关系就是在B类中定义一个私有数组变量，该数组变量的类型是A类。\\n\\n合成关系就是在B类中定义一个A类的私有变量，并在B类的构造函数中完成A类对象的实例化。他们两同时生成，同时死亡。\\n\\n依赖关系：动物类的属性是有生命，方法是新陈代谢。氧气类和水类是与方法--新陈代谢有关，所以在动物类的新陈代谢方法里，氧气类和水类作为方法的形参进行传递。\\n\\n\",\"articleCover\":\"https://upload.haoxx.site/article/370336be7166eb151f9877379c989b33.jpg\",\"articleTitle\":\"UML图图示\",\"articleType\":1,\"categoryName\":\"设计模式\",\"id\":88,\"isRecommend\":0,\"isTop\":0,\"status\":1,\"tagNameList\":[]}]','PUT','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',25,'2023-06-07 20:00:43');
INSERT INTO `t_operation_log` VALUES (1396,'文章模块','上传','/admin/article/upload','com.ican.controller.ArticleController.saveArticleImages','上传文章图片','image_24.jpg','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/article/9c533384183255ee7a33c3f702e1a718.jpg\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',15,'2023-06-07 20:00:56');
INSERT INTO `t_operation_log` VALUES (1397,'文章模块','修改','/admin/article/update','com.ican.controller.ArticleController.updateArticle','修改文章','[{\"articleContent\":\"---\\ntitle: IPv4学习记录\\ndate: 2020-12-15\\ntag:\\n - tag3\\ncategory: \\n - 4计算机网络\\n\\nfooter: <a href=\\\"https://beian.miit.gov.cn/#/Integrated/index\\\">渝ICP备2023001651号</a>\\n\\n---\\n\\n:::tip\\nIPv4学习记录\\n:::\\n\\n<!-- more -->\\n\\n\\n[参考资料](https://space.bilibili.com/360996402/channel/seriesdetail?sid=1721882)  B站up主：湖科大教书匠，计算机网络微课堂，第47-53讲，加上第60讲。\\n1、第47讲：IPv4地址概述\\n2、第48讲：分类编址的IPv4地址（分为ABCDE五类）\\n3、第49讲：划分子网的IPv4地址\\n4、第50讲：无分类编址的IPv4地址（无分类域间路由选择CIDR、斜线记法）\\n5、第51讲：IP地址的应用规划\\n6、第52讲：IP数据包的发送和转发过程\\n7、第53讲：静态路由的配置及其可能产生的路由环路问题\\n8、第60讲：虚拟专用网络VPN和网络地址转换NAT\\n\\n1、IPv4地址概述\\n分为三个历史阶段：分类编址、划分子网和五分类编址三个阶段。\\n\\n2、分类编址的IPv4地址\\n![图1](https://s3.bmp.ovh/imgs/2022/10/11/7a8cc0531f1d06f7.png)\\n![图2](https://s3.bmp.ovh/imgs/2022/10/11/a1a7e6a41ac812a8.png)\\n![图3](https://s3.bmp.ovh/imgs/2022/10/11/76aa90cdc5048e17.png)\\n![图4](https://s3.bmp.ovh/imgs/2022/10/11/813f395e6ae9d19c.png)\\n![图5](https://s3.bmp.ovh/imgs/2022/10/11/859076c54f7efad2.png)\\n\\n3、划分子网\\n\\n将划分子网的IP地址与相对应的子网掩码进行逻辑与运算就可得到IPv4地址所在<font color=\'red\'>子网的网络地址</font>。\\n\\n网络地址：仅包含网络号，主机号全部清零后的IP地址\\n\\n给定一个分类的IP和对应的子网掩码，就可以知道子网划分的细节：\\n\\n+ 划分区子网的数量\\n+ 每个子网可分配IP的数量\\n+ 每个子网的网络地址和广播地址\\n+ 每个子网可分配的最小和最大地址\\n\\n例：已知某个网络的地址是218.75.230.0，使用子网掩码255.255.255.192对其进行子网划分，请给出划分细节。\\n解析：\\n\\n首先，A类网是1 ~ 126，127作为本地回环地址，不指派。B类网是128 ~ 191，C类网是192 ~ 223，D类网是组播地址，E类网保留未使用。还有0号开头的为网络IP地址，127开头的为本地回环测试地址，不对外使用。10/8开头的、172.16/12开头和192.168/16的IP自由分配，可做局域网IP使用。\\n![图](https://s3.bmp.ovh/imgs/2022/10/12/b3644b1fd443eb7a.png)\\n\\n前往[IANA官网](https://www.iana.org/assignments/iana-ipv4-special-registry/iana-ipv4-special-registry.xhtml)查看IPv4分配细节。\\n\\n其次，题中的218为C类地址，网络号占3个字节（24bits），主机号占一个字节（8bits），子网掩码没设定的话，默认为255.255.255.0，而题目中为255.255.255.192,其中192的二进制为1100 0000，即网络号由26位bits构成，主机号由6位bits构成，如果用CIDR斜线记法表示为218.75.230.0/26。\\n\\n可划分子网数量2^2^=4个子网，每个子网可分配IP地址数量为2^(8-2)^-2=2^6^-2=62个。\\n![图6](https://s3.bmp.ovh/imgs/2022/10/12/e689726999c60be1.png)\\n\\n4、无分类的IPv4地址\\n\\n划分子网划分子网在一定程度上缓解了因特网在发展中晕倒的瓶颈，但是数量巨大的C类网因为其地址空间太小而没有得到充分的利用。\\n\\n为此，因特网工程任务组有提出了采用无分类编制的方法解决IP地址紧张的问题。无分类域间路由选择CIDR\\n\\nCIDR消除了划分IP地址分类和划分子网的概念，可以更有效地分配IPv4的地址空间。CISR采用斜线记法，即在IP地址后面写上斜线，斜线后加上网络前缀的数量。\\n\\n我们只要知道CIDR地址块中的任何一个地址，就可以知道该地址块的全部细节：\\n\\n+ 地址块的最小地址\\n+ 地址块的最大地址\\n+ 地址块的地址数量\\n+ 地址块聚合某类网络（A类、B类或C类）的数量\\n+ 地址掩码（也可继续称为子网掩码）\\n\\n例：请给出CIDR地址块128.14.35.7/20的全部细节（最小地址，最大地址，地址数量，聚合C类网数量，地址掩码）\\n\\t解析：\\n20位网络号，所以子网掩码为255.255.240.0，(B类IP，16bits网络号，16bits主机号)\\nIPv4地址：128.14.35.7  =  <font color=\'red\'>1000 0000. 0000 1110. 0010 </font>0011. 0000 0111 \\n掩码：    255.255.240.0 =   1111 1111.  1111  1111. 1111  0000. 0000 0000\\n逻辑按位与的结果为：        <font color=\'red\'>1000 0000. 0000 1110. 0010</font> 0000. 0000 0000 = 128.14.32.0\\n\\n所以，总共有2^(32-20)^=4096个IP地址,因为是聚合C类网，主机号：网络号=24:8，所以，每个子网的IP地址数量为2^8^个地址，聚合C类网的数量为总IP地址数量除以单个子网IP地址数量，即为2^(32-20)^ / 2^8^ =2^12^ / 2^8^ = 2^4^=16个聚合C类子网。\\n将主机号全部取零，得到最小地址128.14.32.0；将主机号全部取1，得到最大地址128.14.47.255。\\n\\n无分类编址的IPv4地址还可以用来构成超网：路由聚合\\n举例：172.1.4.0/25  172.1.4.128/25   \\n\\t172.1.5.0/24 172.1.6.0/24  172.1.7.0/24\\n找网络号的共同前缀：主要在于第三个字节：\\n172.1.4.0/25  -->   172.1.0000  0100.0\\n172.1.4.128/25 -> 172.1.0000  0100.128\\n172.1.5.0/24  -->  172.1.0000   0101.0\\n172.1.6.0/24  -->  172.1.0000   0110.0\\n172.1.7.0/24  -->  172.1.0000   0111.0\\n找共同前缀----->   172.1.4.0/22\\n注意，<font color=\'red\'>在网关路由中，网络前缀越长，地址块越小，路由越具体</font>。若路由器查表转发分组时发现有多条路由可选，则选择网络前缀最长的那条，这称为<font color=\'red\'>最长前缀匹配</font>。\\n\\n举例：在子网192.168.4.0/30中，能接受目的地址为192.168.4.3的IP分组的最大主机数为：____\\n解析：\\n\\n子网192.168.4.0，即：192.168.0000 0100.0000 0000  ，其中192.168.4.0000 00位网络号，最后两位00表示主机号，所以主机数量为4，但是主机号为0的主机只能做源IP地址，不能做目的IP地址；主机号全为1的地址，只能做广播地址，所以符合条件的主机号为2。\\n\\n最长前缀匹配(最佳匹配)：使用 CIDR 时，路由表中的每个项目由 \\\"网络前缀\\\" 和 \\\"下一跳地址\\\" 组成。在查询路由表时可能会得到不止一个匹配结果。应当从匹配结果中选择具有最长网络前缀的路由，因为网络前缀越长，其地址块越小，因此路由就越具体。\\n\\n**路由聚合的优点**：减小路由规模，加快路由匹配速度；降低路由更新时的流量开销。\\n\\n注意：\\n\\n(1) 划分子网只是把IP地址的主机号这部分进行再划分，而不是改变IP地址原来的网络号。因此，从一个IP地址本身或IP数据报的首部，并无法判断源主机或目的主机所连接的网络是否进行了子网划分。\\n\\n(2) 对分类的IPv4地址进行子网划分时，子网号不能为全0或全1。但随着CIDR的广泛使用，现在全0和全1的子网号也可以使用了。\\n\\n(3) 无论是分类IPv4地址还是CIDR，其子网中的主机号为全0或全1的地址都不能被指派。\\n\\n5、IPv4的应用规划\\n定长的子网掩码FLSM  /  变长的子网掩码VLSM\\n举例：使用定长的子网掩码FLSM方式来将218.75.230.0进行子网划分：\\n![图](https://s3.bmp.ovh/imgs/2022/10/12/caf1ef498ee2d87c.png)\\n解析：\\n\\n题目内容如上图所示，用定长的子网掩码来进行子网划分，考虑到N2子网数最多，为28台，并且218为C类网络，网络号24位，主机号为8位。综上，从8个主机号中划分5个做主机号，可满足最多32个主机，符合题目要求；剩余3个做子网号，可满足最多8个子网，满足题目中5个子网的要求。最终，定长子网划分结果如下：\\n子网划分依据：  218.75.230. 000<font color=\'red\'>0   0000</font>\\nN1： 218.75.230.1 ~ ~ 218.75.230.9    （9个IP）\\nN2： 218.75.230.33 ~ ~ 218.75.230.60  (28个IP)\\nN3： 218.75.230.65 ~ ~ 218.75.230.79  （15个IP）\\nN4： 218.75.230.97 ~ ~ 218.75.230.109   (13个IP)\\nN5： 218.75.230.129 ~ ~ 218.75.230.132 （4个IP)\\n![](https://s3.bmp.ovh/imgs/2022/10/12/fe7eb0646e3b1f63.png)\\n\\n\\n![](https://s3.bmp.ovh/imgs/2022/10/12/11e458750a1cc671.png)\\n\\n显然，使用定长的子网掩码来进行分组会极大地浪费IP，故而采用变长的子网掩码分组，按需使用IP。\\n\\n使用变长的子网掩码VLSM  --- IP： 218.75.230.0/24\\n分析题目中各个局域网的情况：\\nN1：6台主机，一个路由器，一个网络IP(全0)，一个广播IP(全1)，一共9个IP\\nN2：25台主机，需要28个IP\\nN3：12台主机，需要15个IP\\nN4：10台主机，需要13个IP\\nN5：0个主机，两个路由器，一个网络地址，一个广播地址，一共4个IP\\n\\n分配结果：\\nN1：9个IP，用4个主机号表示，即：/28\\nN2：28个IP，用5个主机号表示，即：/27\\nN3：15个IP，用4个主机号表示，即：/28\\nN4：13个IP，用4个主机号表示，即：/28\\nN5：4个IP，用2个主机号表示，即：/30\\n最终，从地址块中划分出5个子网地址块：1个/27地址块，3个/28地址块，1个/30地址块。先从主机号最多的子网开始分配。\\nN2：28个IP，子网地址块218.75.230.0 ~ ~ 218.75.230.31\\nN1：9个IP，子网地址块218.75.230.32 ~ ~ 218.75.230.47\\nN3：15个IP，子网地址块218.75.230.48 ~ ~ 218.75.230.63\\nN4：13个IP，子网地址块218.75.230.64 ~ ~ 218.75.230.79\\nN5：4个IP，子网地址块218.75.230.80 ~ ~ 218.75.230.83\\n其他子网地址块待分配\\n![](https://s3.bmp.ovh/imgs/2022/10/12/d0e1a20bba0a0c96.png)\\n![](https://s3.bmp.ovh/imgs/2022/10/12/0d6b104fe4c200a5.png)\\n\\n6、第52讲：IP数据包的发送和转发过程\\n![](https://s3.bmp.ovh/imgs/2022/10/12/63899dae2a42cd37.png)\\nIP路由器工作在TCP/IP体系结构的网际层（或称IP层），TCP/IP体系结构的网际层并不负责可靠传输，也就是不能确保传输的IP分组不丢失。IP路由器会对收到的IP分组头进行差错校验，当发现错误是会丢弃并报告源主机。\\n\\n\\nIP数据报的发送和转发过程包含以下两部分：\\n主机发送IP数据报；路由器转发IP数据报。\\n![](https://s3.bmp.ovh/imgs/2022/10/12/aa24315f888d2a56.png)\\n\\n**FAQ**\\n1、怎么判断发送主机IP和目的主机IP处于同一网络？\\n答：发送主机将自身掩码与自身IP相与，得到自己所处的网络地址；然后发送主机将自己掩码与目的主机在相与，得到目的主机在该掩码下的网络地址。\\n\\n如果两个网络地址相同，则表示处于同一网段，同一网段的主机可以直接通信，这是“直接交付”。\\n\\n如果两个网络地址不同，则IP数据报先交给局域网的网关，听过路由表查询前往目的主机IP的下一跳，然后离开本局域网，前往下一跳的局域网，最终达到目的主机，这是“间接交付”。\\n\\n2、路由器怎么根据IP数据报的目的地址，在路由表中查找匹配的条目呢？\\n答：①路由器先从数据报中得到源地址和目的地址；\\n②路由器根据其接口以及用户手动配置的路由表，可以得到所有的目的网络（如下图所示）。\\n![](https://s3.bmp.ovh/imgs/2022/10/12/a72362ec7a303a1a.png)\\n③将目的地址与路由表中的地址掩码相与，得到目的网络地址，然后检查得到的这个目的网络地址与路由表中的目的网络地址是否相同，相同就转发。\\n![](https://s3.bmp.ovh/imgs/2022/10/12/1513533a674d6acf.png)\\n\\n![](https://s3.bmp.ovh/imgs/2022/10/12/1e84edfd2f92a8c6.png)\\n\\n注意！局域网下的广播数据包交付给路由器后，路由器不会转发。也正因此，路由器可以有效地遏制网络风暴。\\n\\n中继器和集线器工作在物理层，既不隔离冲突域，也不隔离广播域；\\n网桥和交换机（多端口网桥）工作在数据链路层，可以隔离冲突域，不能隔离广播域。\\n路由器工作在网络层，既隔离冲突域，也隔离广播域。\\n\\n7、第53讲：静态路由的配置及其可能产生的路由环路问题\\n略\\n注意，手动添加路由表时，可以指定笼统的目的网络（即多个网络IP，取其相同数据的位，然后后面用斜线加数字来表示），可以指定特定的主机路由，例如192.168.1.1/32，可以指定默认路由0.0.0.0。但是需要注意，网络前缀越长，路由越具体；网络前缀越短，路由越模糊。多条路由可选时。最长前缀匹配！\\n\\n8、第60讲：虚拟专用网络VPN和网络地址转换NAT\\n以下三个地址块可以设置为局域网IP：\\n![](https://s3.bmp.ovh/imgs/2022/10/12/f99009b18204f73f.png)\\nNAT：网络地址转换，当专用网内部的主机已经分配了本地IP，但又想和因特网上的主机通信时，可使用NAT方法。这种方法需要安装NAT软件，且该软件至少拥有一个有效的公网IP，当本地地址想与外界通信时，都要在NAT路由器上将本地地址转换成临时的公网全球IP地址。\\n\\n\",\"articleCover\":\"https://upload.haoxx.site/article/9c533384183255ee7a33c3f702e1a718.jpg\",\"articleTitle\":\"IPv4学习记录\",\"articleType\":1,\"categoryName\":\"计算机网络\",\"id\":87,\"isRecommend\":0,\"isTop\":0,\"status\":1,\"tagNameList\":[]}]','PUT','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',22,'2023-06-07 20:00:58');
INSERT INTO `t_operation_log` VALUES (1398,'文章模块','上传','/admin/article/upload','com.ican.controller.ArticleController.saveArticleImages','上传文章图片','image_45.jpg','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/article/916b2acdd31a579849fb9f1e706fd1ac.jpg\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',17,'2023-06-07 20:01:04');
INSERT INTO `t_operation_log` VALUES (1399,'文章模块','修改','/admin/article/update','com.ican.controller.ArticleController.updateArticle','修改文章','[{\"articleContent\":\"---\\ntitle: IP地址说明\\ndate: 2022-10-30\\ncategory:\\n - 4计算机网络\\n\\nfooter: <a href=\\\"https://beian.miit.gov.cn/#/Integrated/index\\\">渝ICP备2023001651号</a>\\n\\n---\\n\\n:::tip\\nIP地址说明\\n:::\\n\\n<!-- more -->\\n\\n\\n[参考资料](https://www.cnblogs.com/zpcdbky/p/16107981.html)\",\"articleCover\":\"https://upload.haoxx.site/article/916b2acdd31a579849fb9f1e706fd1ac.jpg\",\"articleTitle\":\"IP地址说明\",\"articleType\":1,\"categoryName\":\"计算机网络\",\"id\":86,\"isRecommend\":0,\"isTop\":0,\"status\":1,\"tagNameList\":[]}]','PUT','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',24,'2023-06-07 20:01:05');
INSERT INTO `t_operation_log` VALUES (1400,'文章模块','上传','/admin/article/upload','com.ican.controller.ArticleController.saveArticleImages','上传文章图片','image_22.jpg','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/article/a9ac1c3c7feb616dd40892fdb8fdf1ec.jpg\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',12,'2023-06-07 20:01:24');
INSERT INTO `t_operation_log` VALUES (1401,'文章模块','修改','/admin/article/update','com.ican.controller.ArticleController.updateArticle','修改文章','[{\"articleContent\":\"---\\ntitle: 进程与线程\\ndate: 2022-10-30\\ncategory:\\n - 3操作系统与计算机组成原理\\n\\nfooter: <a href=\\\"https://beian.miit.gov.cn/#/Integrated/index\\\">渝ICP备2023001651号</a>\\n\\n---\\n\\n:::tip\\n进程与线程\\n:::\\n\\n<!-- more -->\\n\\n\\n“进程是操作系统分配资源的单位，线程是调度的基本单位，线程之间共享进程资源。”\\n进程是拥有资源的最小单位，线程是参与内核调度的最小单位。\\n\\n## 1、同一进程的不同线程之间，共享的资源有：\\n\\n+ 可执行的指令\\n+ 静态数据\\n+ 进程中打开的文件描述符\\n+ 当前工作目录\\n+ 用户ID\\n+ 用户组\\n\\n## 2、同一进程的不同线程之间，私有的资源有：\\n\\n+ 线程ID\\n+ PC程序寄存器和 其他相关寄存器\\n+ 堆栈\\n+ 每个线程中的局部变量是私有的\\n+ 错误号\\n+ 优先级\\n+ 执行状态和属性\",\"articleCover\":\"https://upload.haoxx.site/article/a9ac1c3c7feb616dd40892fdb8fdf1ec.jpg\",\"articleTitle\":\"进程与线程\",\"articleType\":1,\"categoryName\":\"操作系统与计算机组成原理\",\"id\":85,\"isRecommend\":0,\"isTop\":0,\"status\":1,\"tagNameList\":[]}]','PUT','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',19,'2023-06-07 20:01:25');
INSERT INTO `t_operation_log` VALUES (1402,'文章模块','上传','/admin/article/upload','com.ican.controller.ArticleController.saveArticleImages','上传文章图片','image_20.jpg','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/article/ca35f9ff3043e951a604aeee51064499.jpg\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',13,'2023-06-07 20:01:35');
INSERT INTO `t_operation_log` VALUES (1403,'文章模块','修改','/admin/article/update','com.ican.controller.ArticleController.updateArticle','修改文章','[{\"articleContent\":\"---\\ntitle: 内存分区问题\\ndate: 2023-04-01\\ncategory:\\n - 1编程语言基础\\n\\nfooter: <a href=\\\"https://beian.miit.gov.cn/#/Integrated/index\\\">渝ICP备2023001651号</a>\\n\\n---\\n\\n:::tip\\n内存分区问题\\n:::\\n\\n<!-- more -->\\n\\n## 1、自动存储、静态存储和动态存储\\n\\n(第四章内容)4.8.5\\n自动存储：用时创建，结束时销毁。一般存储在栈区。在c语言和C++11之前，auto关键字表示变量为自动存储类型，auto可缺省。在C++11新标准中，auto的意思改为了“自动推导变量类型”。\\n\\n静态存储：变量定义在函数外，或者用static关键字修饰时为静态存储。在c语言古老版本中，智能初始化静态数组和静态结构，在C++Release2.0及以后和ANSI C中，也可以初始化自动数组和自动结构。\\n\\n动态存储：用new/delete来管理堆区空间。\\n\\n\\n（第九章内容）9.2\\n\\n## 2、存储持续性、作用域和链接性\\n\\n注意，C++使用三种不同的方案来管理存储数据，这些方案的区别就在于数据保留在内存中的时间。但是在C++11新标准中，新增加了一种“线程存储持续性”：`当前，多核处理器很常见，这些CPU可同时处理多个执行任务。这让程序能够将计算放在可并行处理的不同线程中。如果变量是使用关键字thread_local 声明的，则其生命周期与所属的线程一样长。本书不探讨并行编程。`\\n\\n自动存储持续性：C++中有两种存储持续性为自动的变量：auto自动变量（栈）和寄存器变量(register)。不过register也只是建议编译器将这个变量存储在cpu的寄存器中，以提高对变量的访问速度，但具体是否实现有编译器决定。\\n\\n静态存储持续性：C++为静态存储持续性提供了3种链接性：外部链接性（可在其他文件中访问）、内部连接性（只能在当前文件中访问）、无连接性（只能在函数或当前块中访问）。这些变量在程序执行期间一直存在。\\n\\n原文：\\n\\n```cpp\\n参考：C++ Primer Plus第9.2章的内容和[CSDN](https://blog.csdn.net/EJoft/article/details/122703902)\\nC++为在内存中存储数据提供了多种选择，可以选择数据保存在内存中的时间长度（存储持续性 storage duration）以及程序哪一部分可以访问数据（作用域 scope 和链接 linkage）\\n\\nC++中有四种不同的方案来存储数据，这些方案的区别就在于数据保留在内存中的时间\\n\\n**自动存储持续性(Automatic Storage Duration)：**在函数定义中声明的变量（包括函数参数）在存储持续性上是自动的。它们在程序开始执行其所属的函数或者代码块时被创建，在执行完函数或代码块时，他们使用的内存被释放。C++有两种存储持续性为自动的变量：自动变量和寄存器变量。\\n静态存储持续性(Static Storage Duration)：在函数定义外定义的变量和使用关键字 static 定义的变量。它们在程序运行的运行的整个过程中都存在，C++有三种该变量。\\n线程存储持续性(C++11 Thread Storage Duration)：多核处理器很常见，这些CPU能同时处理多个执行任务，这让程序能将计算放在可并行处理的不同线程中。如果变量用 thread_local 声明，那么其生命周期和所属的线程一样长。\\n动态存储持续性(Dynamic Storage Duration)：用 new 运算符分配的内存将一直存在，直到使用 delete 运算符将其释放或程序结束为止，有时被称为 自由存储 (free store)或 堆 (heap)\\n\\n```\\n\\n表格总结：\\n![图1](https://s3.bmp.ovh/imgs/2022/08/11/86e4ae613499dbe6.png)\\n![图2](https://s3.bmp.ovh/imgs/2022/08/11/52776a151f9c0f98.png)\\n\\n[参考CSDN](https://blog.csdn.net/qq_40739219/article/details/121436579)\\n\\n## 3、C/C++内存分区\\n\\n局部变量：栈（即：我们常说的堆栈）\\nstatic变量：数据区、data区和.bss区\\n静态局部变量和全局变量：静态存储区\\n常量：位于常量区，ro.data区\\n\\n堆：一种内存管理机制，通过malloc、calloc或realloc申请内存，free释放内存（new/delete)\\n以下图片来源于《嵌入式linux与c语言内核》P92左右：\\n![图1](https://s3.bmp.ovh/imgs/2022/08/24/1cddf7efc782aa82.jpg)\\n![图2](https://s3.bmp.ovh/imgs/2022/08/24/2af970a315cb201d.jpg)\\n![图3](https://s3.bmp.ovh/imgs/2022/08/24/cee421c0402b884a.jpg)\\n\\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\\n\\n程序的内存五区:\\n\\n全局区（静态数据区），存放全局变量、静态变量。初始化的\\n全局变量和静态变量在一块区域.Data段， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域.bss段。 程序结束后由系统释放。注意，显式初始化的全局变量和静态变量存放在.Data段，未显式初始化的变量存放在.bss段，并由编译器自动初始化为0。\\n堆，程序员管理。\\n栈，存放程序局部变量。\\n文字常量区:—常量字符串就是放在这里的。 程序结束后由系统释放。还有const关键字修饰的值也是存放在此。\\n代码区.text:  存放函数体的二进制代码\\n\\n\\n\\n还有一种内存四分区: 将全局（静态）变量和常量结合到一起，归结为“数据区”。 \\n栈区: 系统使用\\n堆区: 程序员使用\\n数据区: 由全局变量/静态变量（.Data段和.bss段）和常量组成。\\n代码区（.text）:存放函数的二进制代码\",\"articleCover\":\"https://upload.haoxx.site/article/ca35f9ff3043e951a604aeee51064499.jpg\",\"articleTitle\":\"内存分区问题\",\"articleType\":1,\"categoryName\":\"编程语言基础\",\"id\":82,\"isRecommend\":0,\"isTop\":0,\"status\":1,\"tagNameList\":[]}]','PUT','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',20,'2023-06-07 20:01:38');
INSERT INTO `t_operation_log` VALUES (1404,'文章模块','上传','/admin/article/upload','com.ican.controller.ArticleController.saveArticleImages','上传文章图片','image_9.jpg','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/article/b6877ebd88b9d69396333c5769e07c05.jpg\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',5,'2023-06-07 20:01:49');
INSERT INTO `t_operation_log` VALUES (1405,'文章模块','修改','/admin/article/update','com.ican.controller.ArticleController.updateArticle','修改文章','[{\"articleContent\":\"---\\ntitle: 综合资料（待完善待补充）\\ndate: 2022-10-30\\ncategory:\\n - 1编程语言基础\\n\\nfooter: <a href=\\\"https://beian.miit.gov.cn/#/Integrated/index\\\">渝ICP备2023001651号</a>\\n\\n---\\n\\n:::tip\\n综合资料（待完善待补充）\\n:::\\n\\n<!-- more -->\\n\\n\\n# 待完成待补充\\n\\n来源，参考：[公众号](https://mp.weixin.qq.com/s/joFBDntI9PmyVRiKPHwpRg)\\n\\n### 1、C/C++相关\\n\\n+ C++虚函数原理\\n+ 智能指针\\n+ c语言如何实现C++对象以及私有成员\\n+ C++多态实现\\n+ new和malloc的区别以及底层实现原理\\n+ STL中的vector怎么扩容\\n+ 虚函数指针的初始化过程\\n+ C++11原子变量介绍\\n+ C++11特性有哪些，说用过的\\n+ 怎么理解重载与重写\\n+ 怎么理解C++中的static关键字\\n+ vector和list 的区别\\n+ C++的内存分配\\n+ map与set的底层实现\\n+ 类静态变量的初始化\\n+ 析构函数可以是虚函数？为什么\\n+ 深拷贝与浅拷贝\\n+ 指针常量，常量指针的区别\\n\\n> c语言语法推荐书籍: 《c专家编程》《c与指针》\\n>\\n> C++语言语言推荐书籍:《C++ primer》《effect C++》\\n>\\n> C++语言stl底层原理：《STL源码剖析》\\n\\n\\n### 2、计算机网络\\n\\n+ 介绍下proactor和reactor\\n+ reactor的组成\\n+ TIME_WAIT危害\\n+ TIME_WAIT时长，为什么？\\n+ IP为什么要分片\\n+ 项目中说用到线程池，开多大，为什么运用线程池？\\n+ select和epoll区别\\n+ select什么情况返回0\\n+ epoll可读情况有哪些\\n+ 什么时候需要TCP四次挥手？\\n+ 如何设置非阻塞\\n+ 什么是零拷贝？\\n+ tcp与udp的区别以及应用场景\\n+ 如何设计一个可靠的udp\\n+ 粘包如何解决\\n+ 讲一下拥塞控制和流量控制\\n+ http和https区别\\n+ 是否了解中间人劫持原理\\n+ http协议格式，几种方法，功能是什么\\n+ chunked块了解？介绍下\\n+ 有chunked的时候contentlength是什么样子\\n+ 半连接在哪个阶段\\n+ 三次握手四次握手详细过程，越详细越好\\n+ libevent结构，内部实现\\n+ tcp的可靠性体现在哪里\\n+ ARP协议工作流程\\n+ epoll中的ET和LT模式\\n+ 介绍下滑动窗口\\n+ 指针与引用的区别\\n+ Accept发生在三次握手哪个阶段\\n+ Udp的接收缓冲区和发送缓冲区和tcp的区别\\n+ http长连接与短连接的区别\\n+ udp包长度\\n+ 一次url访问会经历哪些过程\\n+ 数据包乱序会处理？\\n+ seq为1000，发送了1000个数据，下一个seq是多少?\\n+ syn如果丢了，重传多少次\\n\\n> tcp/ip相关推荐书籍:《tcp/详解：1》\\n>\\n> 熟悉使用wireshark捕包工具，加深印象可以使用python的一个库，scapy/dpkt.\\n\\n\\n\\n### 3、数据结构相关\\n\\n+ hash处理冲突的方法\\n+ 二分查找及其变种\\n+ 数组与链表的区别\\n+ redis数据结构用过哪些，了解跳表？\\n+ 红黑树比平衡二叉树有哪些优点\\n+ 二叉树，b+树，hash，二叉查找树区别\\n+ 说说红黑树的特性\\n+ 各种树，排序的时间复杂度\\n+ 数据库索引，事务，事务级别\\n+ 不考虑事务的隔离性会出现什么问题\\n+ 事务隔离级别\\n+ 索引的类型\\n+ AC自动机时间复杂度\\n\\n> 数据结构书籍《大话数据结构》\\n>\\n> 极客时间王大佬/谭大佬专栏\\n\\n### 4、操作系统相关\\n\\n+ 进程与线程的区别\\n+ 多进程与多线程区别，应用场景\\n+ volatile和原子变量的区别\\n+ proc文件系统\\n+ 自旋锁与普通锁的区别\\n+ 虚拟内存\\n+ 进程的内存分布\\n+ 栈内存为什么由系统自动分配和释放\\n+ 守护进程如何创建\\n+ 进程间的通信方式及其区别，应用场景\\n+ 死锁条件和解除\\n+ 进程调度方式\\n+ 对编译连接的理解\\n+ 共享内存实现原理\\n+ 僵尸进程是什么，如何处理\\n+ 自旋锁在单cpu与多cpu下的使用\\n+ 用户态与内核态\\n\\n> 操作系统推荐书籍:《深入理解操作系统》，《Linux内核设计与实现》\\n\\n\\n\\n### 5、Linux基础知识及应用编程\\n\\n+ 如何查看进程打开的文件\\n+ 介绍下nm与ldd命令\\n+ shell命令查内存，端口 ，io访问量，读写速率\\n+ awk grep具体应用\\n+ 硬链接与软连接，目录可不可以用硬链接\\n+ 常见命令netstat iptable tcpdump top\\n+ makefile介绍下(cmake介绍下)\\n+ gdb查看堆栈中所有遍历\\n+ gdb查看shared_ptr指向的内容\\n+ gdb如何调试多进程多线程\\n+ g++和gcc编译出来有什么区别\\n+ 死锁怎么调试\\n+ core文件中是什么，gdb调试core文件\\n+ 如何读取一个10G文件，cat一个10g文件会发生什么\\n\\n> Linux基础命令推荐书籍:《Linux就该这么学》\\n>\\n> Linux应用编程推荐书籍：《后台开发核心技术与应用实践》《Linux多线程服务端编程》《高性能Linux服务器编程》 《linux环境编程:从应用到内核》《unix高级环境编程》\\n>\\n> 补充资料:gdb手册和makefile详解\\n\\n\",\"articleCover\":\"https://upload.haoxx.site/article/b6877ebd88b9d69396333c5769e07c05.jpg\",\"articleTitle\":\"综合资料（待完善待补充）\",\"articleType\":1,\"categoryName\":\"编程语言基础\",\"id\":83,\"isRecommend\":0,\"isTop\":0,\"status\":1,\"tagNameList\":[]}]','PUT','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',19,'2023-06-07 20:01:51');
INSERT INTO `t_operation_log` VALUES (1406,'文章模块','上传','/admin/article/upload','com.ican.controller.ArticleController.saveArticleImages','上传文章图片','image_14.jpg','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/article/2ec42f646cb85e6554ab21b4e9bc6c19.jpg\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',4,'2023-06-07 20:02:03');
INSERT INTO `t_operation_log` VALUES (1407,'文章模块','修改','/admin/article/update','com.ican.controller.ArticleController.updateArticle','修改文章','[{\"articleContent\":\"---\\ntitle: 参考资料汇总\\ndate: 2022-10-30\\nauthor: HaoXX\\ncategory:\\n - 1编程语言基础\\n\\nfooter: <a href=\\\"https://beian.miit.gov.cn/#/Integrated/index\\\">渝ICP备2023001651号</a>\\n\\n---\\n\\n:::tip\\n参考资料汇总\\n:::\\n\\n<!-- more -->\\n\\n<p align=\\\"center\\\" style=\\\"color:blue\\\">\\n  <a href=\\\"https://mp.weixin.qq.com/s/ePhaYezFblgt0NgbvtWqww\\\" target=\\\"_blank\\\">\\n    <h2 align=\\\"center\\\">\\n        仓库内容持续更新中...\\n    </h2>\\n  </a>\\n</p>\\n\\n\\n<!-- <p>\\n  <br>\\n</p> -->\\n\\n<p align=\\\"center\\\">\\n    <a href=\\\"https://mp.weixin.qq.com/s/ePhaYezFblgt0NgbvtWqww\\\" target=\\\"_blank\\\">\\n        <img src=\\\"https://cdn.jsdelivr.net/gh/justacoder99/r2coding@master/img/r2coding_logo_index.15y992dieibg.png\\\" width=\\\"\\\"/>\\n    </a>\\n</p>\\n\\n\\n\\n<p align=\\\"center\\\">\\n  <a href=\\\"https://github.com/rd2coding/Road2Coding\\\" target=\\\"_blank\\\"><img src=\\\"https://img.shields.io/badge/Github-r2coding-red.svg\\\"></a>\\n  <a href=\\\"https://gitee.com/rd2coding/Road2Coding\\\" target=\\\"_blank\\\"><img src=\\\"https://img.shields.io/badge/Gitee-r2coding-blue.svg\\\"></a>\\n  <a href=\\\"https://space.bilibili.com/384068749\\\" target=\\\"_blank\\\"><img src=\\\"https://img.shields.io/badge/bilibili-哔哩哔哩-critical\\\"></a>\\n  <a href=\\\"https://mp.weixin.qq.com/s/ePhaYezFblgt0NgbvtWqww\\\" target=\\\"_blank\\\">\\n    <img src=\\\"https://img.shields.io/badge/微信联系作者-WeChat-green.svg\\\" alt=\\\"微信联系\\\">\\n  </a>\\n</p>\\n\\n\\n自学之路漫又长，唯有不断总结，不断回味，不断分享，才能成长！\\n\\n联系我可以[【微信】](#微信)私我\\n\\n---\\n\\n# **为什么会有这个开源仓库**\\n\\n---\\n\\n本仓库取名 **r2coding**，即 **Road To Coding**，意为「编程自学之路」，是自学编程以来所用资源和分享内容的大聚合。\\n\\n旨在为编程自学者提供一系列：\\n\\n>  - **清晰的编程自学路线**\\n>  - **各编程岗位方向的知识点梳理**\\n>  - **靠谱的资源**\\n>  - **高效的工具**\\n>  - **务实的技术文章**\\n\\n方便自己也方便他人。仓库内容会保持**持续更新**，欢迎收藏品鉴！\\n\\n---\\n\\n# **本仓库内容地图**\\n\\n---\\n\\n![](https://cdn.jsdelivr.net/gh/justacoder99/r2coding@master/img/contentmap.3sdmma4od740.png)\\n\\n---\\n\\n# **编程自学路线+知识大梳理**\\n\\n---\\n\\n本仓库目前整理收录了6个大方向（岗位）的学习路线+知识点大梳理，分别为：\\n\\n- **Java后端开发**\\n- **前端开发**\\n- **C/C++后台开发**\\n- **大数据开发**\\n- **嵌入式开发**\\n- **网络安全方向**\\n\\n\\n后续本仓库也会持续更新和增加更多方向岗位的学习路线...\\n\\n---\\n\\n<!-- tabs:start -->\\n\\n### **Java后端开发**\\n\\n详情链接 **→** [《Java后端开发学习路线+知识点大梳理》](https://mp.weixin.qq.com/s/rAoamIey7cARMES7kfIaLw)\\n\\n![](https://cdn.jsdelivr.net/gh/justacoder99/r2coding@master/img/jawa.391vqmg83lc0.png)\\n\\n> 注：图片上传后可能被压缩，如需无损版高清大图，可去微信公众号「**CodeSheep**」后台回复「**后端开发**」四个字获取即可\\n\\n详情链接 **→** [《Java后端开发学习路线+知识点大梳理》](https://mp.weixin.qq.com/s/rAoamIey7cARMES7kfIaLw)\\n\\n### **前端开发**\\n\\n详情链接 **→** [《前端开发学习路线+知识点大梳理》](https://mp.weixin.qq.com/s/_8lvpPDArM_Z-MI9iul1AA)\\n\\n![](https://cdn.jsdelivr.net/gh/justacoder99/r2coding@master/img/front.6uquir77a6c0.png)\\n\\n> 注：图片上传后可能被压缩，如需无损版高清大图，可去微信公众号「**CodeSheep**」后台回复「**前端开发**」四个字获取即可\\n\\n详情链接 **→** [《前端开发学习路线+知识点大梳理》](https://mp.weixin.qq.com/s/_8lvpPDArM_Z-MI9iul1AA)\\n\\n### **大数据开发**\\n\\n详情链接 **→** [《大数据开发学习路线+知识点大梳理》](https://mp.weixin.qq.com/s/dm2Qm4zZhHxEvcFgNS_mrA)\\n\\n![](https://cdn.jsdelivr.net/gh/justacoder99/r2coding@master/img/bigdata.21roso2lxdsw.png)\\n\\n> 注：图片上传后可能被压缩，如需无损版高清大图，可去微信公众号「**CodeSheep**」后台回复「**大数据**」三个字获取即可\\n\\n详情链接 **→** [《大数据开发学习路线+知识点大梳理》](https://mp.weixin.qq.com/s/dm2Qm4zZhHxEvcFgNS_mrA)\\n\\n### **嵌入式开发**\\n\\n详情链接 **→** [《嵌入式开发学习路线+知识点大梳理》](https://mp.weixin.qq.com/s/AJqbhz3InV3G8TVjTHn6dg)\\n\\n![](https://cdn.jsdelivr.net/gh/justacoder99/r2coding@master/img/embed.2kqjbi961600.png)\\n\\n> 注：图片上传后可能被压缩，如需无损版高清大图，可去微信公众号「**CodeSheep**」后台回复「**嵌入式**」三个字获取即可。\\n\\n详情链接 **→** [《嵌入式开发学习路线+知识点大梳理》](https://mp.weixin.qq.com/s/AJqbhz3InV3G8TVjTHn6dg)\\n\\n### **C/C++后台开发**\\n\\n详情链接 **→** [《C/C++（偏后台）开发学习路线+知识点大梳理》](https://mp.weixin.qq.com/s/tXilzUzN7cDhnc3ztw4Vlw)\\n\\n### **网络安全方向**\\n\\n详情链接 **→** [《网络安全方向学习路线+知识点大梳理》](https://mp.weixin.qq.com/s/pPs5Gm9I3a6-nMZQ42kaWg)\\n\\n<!-- tabs:end -->\\n\\n---\\n\\n# **常用编程软件和工具**\\n\\n---\\n\\n> [!NOTE]\\n>\\n>  - [**【置顶笔记下载1】熬10天夜，我肝出了这个PDF版「服务器软件安装手册」**](https://mp.weixin.qq.com/s/YNOZSQ5smo1uGE5ZttUZ_w)\\n>\\n>  - [**【置顶笔记下载2】再肝两夜，写了个「服务器项目部署」实战PDF手册**](https://mp.weixin.qq.com/s/JUJ6qu_ec3s1JmTxQt_V3g)\\n\\n> **工欲善其事，必先利其器！**\\n\\n一个易上手、好用、高效的软件工具对于程序员工作效率的提升是不言而喻的，这些常用开发软件和工具比如：\\n\\n> - 基础的软件开发环境和设施\\n> - 好用高效的在线工具和网站\\n> - 本地常用的一些编程软件\\n> - Linux操作系统\\n> - 版本控制工具\\n> - 高效的IDE和编辑器\\n> - API管理工具/文档管理工具\\n> - CI守护系统\\n> - ...... 等等\\n\\n接下来我们一项一项详细盘点。\\n\\n---\\n\\n## 常用在线工具集\\n\\n---\\n\\n> [!NOTE]\\n>\\n>  - [**【本章节置顶资源下载】自学编程一路走来，这些私藏工具和网站我全贡献出来了！（附我的浏览器书签下载）**](https://mp.weixin.qq.com/s/XUHnLCbq7mDWhOc9imTVzg)\\n\\n程序员在平时的日常**工作**、**学习**、**开发**、**做笔记**、**写博客**等过程中还是有很多好用并且高效的**在线工具推荐**的，毕竟我们不是每时每刻我们都需要那种很重量级的本地软件。\\n\\n下面将分成**16个大类**，共整理了约**130+个**常用的在线工具和网站供大家食用。\\n\\n---\\n\\n<!-- tabs:start -->\\n\\n#### **在线画图工具**\\n\\n程序员经常接触的无非也就是流程图、思维导图、原型图、UML图、网络拓扑图、组织结构图等等这些。\\n\\n下面这四个在线画图网站我想应该足够了，其中那个processon是我用得最多的，历史文章中几乎所有相关的图形都是用它绘制，然后导出图片的。\\n\\n- [在线画图工具ProcessOn](https://www.processon.com/)\\n- [在线画图工具Draw.io](https://app.diagrams.net/)\\n- [在线思维导图工具MindLine](http://www.mindline.cn/webapp)\\n- [PlantUML在线编辑器](http://haha98k.com/)\\n\\n#### **在线编解码工具**\\n\\n- [BASE64编解码工具](https://base64.supfree.net/)\\n- [MD5编码工具](https://www.zxgj.cn/g/md5)\\n- [AES/DES加解密](http://www.fly63.com/tool/cipher/)\\n- [JWT解码工具](http://jwt.calebb.net/)\\n- [ASCII编解码工具](https://www.matools.com/code-convert-ascii)\\n- [Unicode编解码工具](https://www.zxgj.cn/g/unicode)\\n- [UTF-8编解码工具](https://www.zxgj.cn/g/utf8)\\n- [字符串编解码工具](https://www.zxgj.cn/g/enstring)\\n- [URL编解码工具](http://tool.chinaz.com/tools/urlencode.aspx?jdfwkey=lbixz1)\\n\\n#### **在线转换工具**\\n\\n- [在线ASCII码对照表](http://www.fly63.com/tool/ascii/)\\n- [通用进制转换工具](https://www.zxgj.cn/g/jinzhi)\\n- [在线浮点数十进制转换](http://www.binaryconvert.com/)\\n- [RGB颜色转换](https://www.zxgj.cn/g/yansezhi)\\n- [时间戳转换工具](https://www.zxgj.cn/g/unix)\\n- [计量单位换算工具](http://www.fly63.com/tool/unitable/)\\n- [在线JSON解析](http://www.json.cn/)\\n- [在线JS代码格式化工具](https://prettier.io/playground/)\\n- [SQL压缩/格式化工具](https://www.zxgj.cn/g/sqlformat)\\n- [JSON和XML在线转换](https://www.zxgj.cn/g/jsonxml)\\n- [JSON/YAML在线转换](http://www.fly63.com/tool/jsonyaml/)\\n- [人民币大小写转换工具](http://www.fly63.com/tool/renmingbi/)\\n\\n#### **正则表达式工具**\\n\\n- [正则表达式调试工具](https://regexr.com/)\\n- [正则表达式可视化工具](https://jex.im/regulex/)\\n\\n#### **网络工具**\\n\\n- [IP地址归属地查询](https://www.ip138.com/)\\n- [IP地址查询](https://www.ipip.net/ip.html)\\n- [HTTP在线接口测试工具](http://www.fly63.com/php/http/)\\n\\n#### **在线编译运行工具**\\n\\n- [C#在线编译运行](https://rextester.com/)\\n- [C/C++在线编译调试](https://www.onlinegdb.com/)\\n- [在线编译工具套装](https://c.runoob.com/)\\n\\n#### **可视化/格式化工具**\\n\\n- [在线前端编辑器](https://codepen.io/)\\n- [在线数据可视化](https://flourish.studio/)\\n- [在线JSON解析](http://www.json.cn/)\\n- [在线CSS代码可视化工具](https://enjoycss.com/)\\n- [XML格式化工具](https://www.zxgj.cn/g/xmlformat)\\n- [在线JS代码格式化工具](https://prettier.io/playground/)\\n- [SQL压缩/格式化工具](https://www.zxgj.cn/g/sqlformat)\\n- [JSON和XML在线转换](https://www.zxgj.cn/g/jsonxml)\\n- [JSON/YAML在线转换](http://www.fly63.com/tool/jsonyaml/)\\n\\n#### **在线生成器**\\n\\n- [UUID在线生成器](https://www.zxgj.cn/g/uuid)\\n- [随机数生成器](https://www.zxgj.cn/g/suijishu)\\n\\n#### **其他常用在线开发相关工具**\\n\\n- [在线Nginx配置工具](https://nginxconfig.io/)\\n- [在线文本代码比对工具](http://www.fly63.com/tool/textdiff/)\\n- [在线Chrome浏览器插件](https://www.crx4chrome.com/)\\n- [在线接口文档管理工具](http://www.docway.net/)\\n\\n#### **在线素材工具**\\n\\n如果你也写文章，或者做视频，那就一定少不了要找素材，包括各种图片、背景、emoji表情、表情包、壁纸、视频、gif图等等。\\n\\n如此一来，那些好用的在线素材工具就必不可少了，比如像各种表情包工具、icon图标库、矢量图库、图片素材库、壁纸库等等。\\n\\n- [免费透明背景图片素材](http://pngimg.com/)\\n- [Emoji表情包下载](https://emojiisland.com/)\\n- [open source icons](https://feathericons.com/)\\n- [阿里巴巴矢量图标库](https://www.iconfont.cn/)\\n- [表情包在线网站](https://fabiaoqing.com/)\\n- [免费PNG图片库](https://pluspng.com/)\\n- [ICON图标在线下载](https://www.iconfinder.com/)\\n- [极简壁纸](https://bz.zzzmh.cn/)\\n- [Wallpaper Abyss壁纸](https://wall.alphacoders.com)\\n- [Pixabay图片素材库](https://pixabay.com/zh/)\\n- [Unsplash图片素材库](https://unsplash.com)\\n- [Pexels图片素材库](http://www.pexels.com)\\n- [NASA图片视频素材库](https://images.nasa.gov)\\n\\n#### **设计制作类工具**\\n\\n对于那些文章创作者和视频创作者而言，设计封面，做海报，设计LOGO，图片美化等等基本也是刚需。\\n\\n这样大概率日常会用到一些简易好上手的在线设计制作类工具，比如在线P图、音/视频轻量化剪辑、logo制作、海报设计制作、图片美化、在线图片转换或生成等等，毕竟不是每时每刻我们都需要那种重量级的本地软件。\\n\\n- [在线PS](https://www.uupoop.com/)\\n- [在线音频剪辑](https://www.weixinsyt.com/)\\n- [在线视频剪辑](https://www.kapwing.com/)\\n- [免费logo在线制作](http://www.uugai.com/)\\n- [艺术字体在线生成](https://www.qt86.com/)\\n- [在线表格转换工具](https://tableconvert.com/)\\n- [在线海报设计工具](https://www.designcap.com/)\\n- [图片智能放大工具](https://bigjpg.com/)\\n- [二维码美化器](https://mh.cli.im/)\\n- [在线代码截图工具](https://carbon.now.sh/)\\n- [在线抠图工具](https://www.remove.bg/zh)\\n- [ICO图标在线生成](http://www.fly63.com/php/ico/)\\n- [SVG转PNG工具](http://www.fly63.com/tool/svg2img/)\\n- [视频转GIF工具](http://www.fly63.com/tool/giftxt/)\\n- [二维码在线生成器](http://www.fly63.com/tool/ewm/)\\n- [二维码在线解码](http://www.fly63.com/php/decoder/)\\n\\n#### **写作辅助工具**\\n\\n在我写文章的过程中经常会用到和写作相关的辅助工具，比方说：字数统计工具、Markdown格式的文章排版工具、图床网站、代码截图工具等等，所以下面这些在线工具就能很好地满足我的需求。\\n\\n- [在线字数统计](https://www.eteste.com/)\\n- [mdnice markdown排版工具](https://mdnice.com/)\\n- [md2all markdown排版工具](http://md.aclickall.com/)\\n- [在线图床神器](https://picx.xpoet.cn/)\\n- [在线免费图床](https://sm.ms/)\\n- [图壳图床](https://imgkr.com/)\\n- [在线代码截图工具](https://carbon.now.sh/)\\n- [在线短链接工具](https://urlify.cn/)\\n- [在线文本替换](http://www.fly63.com/tool/textreplace/)\\n\\n#### **在线办公工具**\\n\\n这部分在线工具主要用来处理一些和文档以及文稿相关的事情，经常用到的比如：在线的全套pdf处理和转换工具、各种各样多媒体文件间的相互转换工具、在线识别工具、在线压缩工具等等。\\n\\n- [pdf在线处理工具套装1](https://smallpdf.com/cn/pdf-tools)\\n- [pdf在线处理工具套装2](https://tools.pdf24.org/zh/)\\n- [pdf转word在线工具](https://www.pdftoword.com/)\\n- [在线多媒体转换器合集](https://cn.office-converter.com/)\\n- [在线文字识别工具](https://ocr.wdku.net/)\\n- [在线文件压缩工具](https://docsmall.com/)\\n\\n#### **文档笔记工具**\\n\\n好记性不如烂笔头，作为一个学习者，我觉得记笔记是必不可少的步骤。当然现在基本都做电子笔记和电子文档比较多。\\n\\n现如今各式各样优秀的文档工具和笔记软件鳞次栉比，好用的也有很多，整理成如下列表，这东西各有长处，使用哪个最合意还得看个人习惯和需求了。\\n\\n- [印象笔记](https://www.yinxiang.com/)\\n- [有道笔记](https://note.youdao.com/)\\n- [OneNote](https://www.onenote.com/)\\n- [幕布](https://mubu.com/)\\n- [为知笔记](https://www.wiz.cn/)\\n- [石墨文档](https://shimo.im/)\\n- [Simplenote](https://simplenote.com/)\\n- [语雀](https://www.yuque.com/)\\n\\n#### **编程学习网**\\n\\n- [哔哩哔哩](https://www.bilibili.com/)\\n- [C语言网](https://www.dotcpp.com/)\\n- [cppreference](http://zh.cppreference.com/)\\n- [中国大学MOOC](https://www.icourse163.org/)\\n- [牛客网](www.nowcoder.com)\\n- [网易公开课](https://open.163.com/)\\n- [CodeGym](https://codegym.cc/)\\n- [BeginnersBook](https://beginnersbook.com/)\\n- [JavaSED](http://www.javased.com/)\\n- [codecademy](https://www.codecademy.com/)\\n- [Coursera](https://www.coursera.org/)\\n- [StackOverFlow](https://stackoverflow.com/)\\n- [LeetCode](https://leetcode-cn.com/)\\n- [LintCode](https://www.lintcode.com/)\\n\\n#### **在线教程和文档**\\n\\n这部分主要集中了我在做开发过程中随手参考所要用到的几乎所有在线教程和官方文档，有中文版文档的我基本都优先列出来了，但更多时候是英文的官方文档。\\n\\n<!-- panels:start -->\\n\\n<!-- div:left-panel -->\\n\\n- [Git中文教程](https://git-scm.com/book/zh/v2)\\n- [SVN中文手册](http://svnbook.red-bean.com/nightly/zh/index.html)\\n- [jQuery API中文文档](https://jquery.cuishifeng.cn/)\\n- [Nginx中文文档](https://www.nginx.cn/doc/index.html)\\n- [Kafka中文文档](https://kafka.apachecn.org/)\\n- [Mybatis中文文档](https://mybatis.org/mybatis-3/zh/index.html)\\n- [微信小程序官方文档](https://developers.weixin.qq.com/miniprogram/dev/framework/)\\n- [Nodejs中文教程文档](http://nodejs.cn/learn)\\n- [Apache Web Server文档](http://httpd.apache.org/docs/)\\n- [Spring文档中文版](https://www.springcloud.cc/spring-reference.html)\\n- [Golang标准库文档中文版](https://studygolang.com/pkgdoc)\\n- [Java 8官方文档](https://docs.oracle.com/javase/8/docs/api/index.html)\\n- [Maven官方文档](http://maven.apache.org/guides/)\\n- [Tomcat 8官方文档](http://tomcat.apache.org/tomcat-8.0-doc/index.html)\\n\\n<!-- div:right-panel -->\\n\\n- [Spring Boot官方文档](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/)\\n- [RabbitMQ官方文档](https://www.rabbitmq.com/documentation.html)\\n- [RocketMQ官方文档](http://rocketmq.apache.org/docs/quick-start/)\\n- [Dubbo中文文档](https://dubbo.apache.org/zh/docs/)\\n- [Netty官方文档](https://netty.io/wiki/index.html)\\n- [Elasticsearch官方文档](https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html)\\n- [Spring Cloud官方文档](https://spring.io/projects/spring-cloud)\\n- [Docker官方文档](https://docs.docker.com/get-started/)\\n- [Kubernetes中文文档](https://kubernetes.io/zh/docs/home/)\\n- [Thymeleaf官方文档](https://www.thymeleaf.org/documentation.html)\\n- [Vue.js中文文档](https://cn.vuejs.org/v2/guide/)\\n- [React.js官方文档](https://reactjs.org/docs/getting-started.html)\\n- [Jenkins中文文档](https://www.jenkins.io/zh/doc/)\\n\\n<!-- panels:end -->\\n\\n<!-- tabs:end -->\\n\\n---\\n\\n## 常用本地软件\\n\\n---\\n\\n<p align=\\\"left\\\">\\n    <a href=\\\"https://mp.weixin.qq.com/s/ePhaYezFblgt0NgbvtWqww\\\" target=\\\"_blank\\\">\\n        <img src=\\\"https://cdn.jsdelivr.net/gh/justacoder99/r2coding@master/img/localsoftware.2x9vakmja2g.png\\\" width=\\\"\\\"/>\\n    </a>\\n</p>\\n\\n\\n这里将常用软件分为了5大类，包括：\\n\\n> - 社交/娱乐/上网\\n> - 办公软件\\n> - 效率和美化软件\\n> - UP主必备\\n> - 程序员生产力工具\\n\\n- [点击查看：我的常用软件大公开！](https://mp.weixin.qq.com/s/ONx6wjGjQSvOOIgnEBTNJQ)\\n\\n---\\n\\n## 基础软件开发环境和设施\\n\\n---\\n\\n**什么叫基础软件开发环境？**\\n\\n很好理解。学Java得要装JDK吧？学Python得要Python环境吧？学数据库得要MySQL吧？等等，这些在学习编程之前都是应该提前在自己的电脑上准备好的，而且尽量把全套都先备好，后面直接就用了。\\n\\n经常听到有小伙伴反馈和提问有关编程环境搭建和基础软件设施安装的相关问题。\\n\\n> - 啥？JDK明明装了，为啥还是not found？ \\n> - 咦？Maven明明配了加速，咋下载依赖还这么慢？ \\n> - 诶？MySQL明明装了，咋Navicat连会报错？ \\n> - 哦？Tomcat咋出不来页面？......\\n\\n每次都是照着网上现搜的帖子操作，一顿操作猛如虎，一看结果各种有问题，要不报错，要不环境起不来，等等。装个环境就浪费了很多时间，而且过了一段时间又忘，还得重新搜帖子，该踩的坑一个都不少...\\n\\n既然大家有这方面需求，想来想去，关于这个问题，我还是决定写一个事无巨细的PDF文档，把所有编程环境和基础软件设施的安装过程给详细地记录下来了。\\n\\n[熬10天夜，我肝出了这个PDF版「编程软件（环境）安装手册」](https://mp.weixin.qq.com/s/YNOZSQ5smo1uGE5ZttUZ_w)\\n\\n内容包含常见基础开发环境和设施的安装部署，包括：\\n\\n> - Linux操作系统\\n> - Git工具\\n> - Java环境JDK\\n> - Node基础环境\\n> - Python基础环境\\n> - Maven项目构建和管理\\n> - MySQL数据库\\n> - Redis缓存\\n> - RabbitMQ消息队列\\n> - Tomcat应用服务器\\n> - Nginx Web服务器\\n> - Docker环境\\n> - Kubernetes环境\\n> - Elasticsearch搜索引擎\\n> - ZooKeeer环境\\n> - Kafka消息队列\\n\\n大家有需要的可以：[点击此处 → 下载获取](https://mp.weixin.qq.com/s/YNOZSQ5smo1uGE5ZttUZ_w)！\\n\\n---\\n\\n## Linux操作系统\\n\\n---\\n\\n<p align=\\\"left\\\">\\n    <a href=\\\"https://mp.weixin.qq.com/s/ePhaYezFblgt0NgbvtWqww\\\" target=\\\"_blank\\\">\\n        <img src=\\\"https://cdn.jsdelivr.net/gh/justacoder99/r2coding@master/img/linuxos.qciprfz30dc.png\\\" width=\\\"\\\"/>\\n    </a>\\n</p>\\n\\n\\n实际企业级开发和项目部署，大部分情况下基本都是基于Linux环境进行的，所以掌握常用的命令、配置、网络和系统管理、基本的Shell编程等尽量还是要熟练一些，对后续项目实践都大有裨益。\\n\\n> [!Note]\\n>\\n>  - [**本章节置顶资源1：《Linux命令速查备忘手册.pdf》下载**](https://mp.weixin.qq.com/s/GJYVt376C_g4406ux5uw0Q)\\n>  - [**本章节置顶资源2：《Linux命令行大全.pdf》下载**](https://mp.weixin.qq.com/s/3rV556_0piRNsSpDYwuZ8g)\\n\\n- [常用Linux操作系统大盘点](https://mp.weixin.qq.com/s/x8rwsIOzYEPXmEVXmWJ4Tg)\\n- [人手一套Linux环境之：macOS版教程](https://mp.weixin.qq.com/s/WeZLtfrMdnISpX3v5WpJfA)\\n- [人手一套Linux环境之：Windows版教程](https://mp.weixin.qq.com/s/onVwwEQ1DAwbvK7qS2YNxg)\\n- [69张图：详细记录Ubuntu 20.04安装配置过程](https://mp.weixin.qq.com/s/vkLZ_3Jp4HdQ8PDIMYsGEw)\\n- [废柴电脑拯救计划：借助Debian搭建个人专属云服务器](https://mp.weixin.qq.com/s/YpWp-b3vcAtb_jBwCM7wtg)\\n- [常用Linux命令大整理](https://mp.weixin.qq.com/s/Kog6AfXYINIDwKMpJMkGFQ)\\n- [面试常问的20个Linux命令](https://mp.weixin.qq.com/s/3NI4FWuOfYMJBiKqqnpqMA)\\n- [Linux 桌面进化史](https://mp.weixin.qq.com/s/jQAJQo28UsY3YIxC5ci1sA)\\n- [Linux迎来29岁：从个人爱好到统治世界的操作系统内核！](https://mp.weixin.qq.com/s/6-yb1N-SwHr4EaQ-fvU4Ow)\\n- [漫画：Linux 内核到底长啥样？](https://mp.weixin.qq.com/s/4G6re30hxAacxmCLjP8KpQ)\\n- [资源下载 → 《Linux命令速查备忘手册.pdf》](https://mp.weixin.qq.com/s/GJYVt376C_g4406ux5uw0Q)\\n- [资源下载 → 《Linux命令行大全.pdf》](https://mp.weixin.qq.com/s/3rV556_0piRNsSpDYwuZ8g)\\n\\n---\\n\\n## 版本控制工具\\n\\n---\\n\\n<p align=\\\"left\\\">\\n    <a href=\\\"https://mp.weixin.qq.com/s/ePhaYezFblgt0NgbvtWqww\\\" target=\\\"_blank\\\">\\n        <img src=\\\"https://cdn.jsdelivr.net/gh/justacoder99/r2coding@master/img/gcm.1sv6s8asfzc0.jpeg\\\" width=\\\"\\\"/>\\n    </a>\\n</p>\\n\\n\\n- [资源下载 → 豆瓣9.1分的Pro Git学习手册YYDS！](https://mp.weixin.qq.com/s/xDYSG4uDz9rgNCuk0RxLjg)\\n- [科普篇：Git和SVN对比](https://mp.weixin.qq.com/s/bUYz9JwqAYH_Fn6nHPSmTg)\\n- [科普篇：5分钟了解Git的前世今生](https://mp.weixin.qq.com/s/VvpjFUXd6jcatACHyFPHfg)\\n- [科普篇：Git操作与常用命令集锦](https://mp.weixin.qq.com/s/swnwBiuyVmhs5iPqv3H6BQ)\\n- [原理篇：图解Git中的最常用命令](https://mp.weixin.qq.com/s/DRCeDhYiwQQToKukk4RM4g)\\n- [原理篇：从原理角度理解记忆Git常见命令](https://mp.weixin.qq.com/s/DQVVYOWdOPuRsy3m0fg6Xg)\\n- [实践篇：从实践中彻底上手Git](https://mp.weixin.qq.com/s/sp1YUQ2vnQaIGH4tO3j1Vw)\\n- [实践篇：Git分支开发](https://mp.weixin.qq.com/s/touo-rygtz0tG6y8NKw65A)\\n- [实践篇：如何使用GitHub Flow给开源项目贡献代码](https://mp.weixin.qq.com/s/JMNQi3BSTmKpF9vXMEdKHw)\\n- [技巧篇：一招搞定GitHub下载加速！](https://mp.weixin.qq.com/s/SYR4zvjhAH1mX9fxdp8cbA)\\n- [技巧篇：如何在同一台电脑上同时使用多个Git账号](https://mp.weixin.qq.com/s/Qt4bqReZU3ydIsMtCVC0eA)\\n\\n---\\n\\n## IDE/编辑器\\n\\n<p align=\\\"left\\\">\\n    <a href=\\\"https://mp.weixin.qq.com/s/ePhaYezFblgt0NgbvtWqww\\\" target=\\\"_blank\\\">\\n        <img src=\\\"https://cdn.jsdelivr.net/gh/justacoder99/r2coding@master/img/ide.720nw0czwbs0.png\\\" width=\\\"\\\"/>\\n    </a>\\n</p>\\n\\n\\n- [IDEA 2021.3升级发布](https://mp.weixin.qq.com/s/9Ar4KhQYSEP8B2mBaudWpQ)\\n- [IDEA 2021.2升级体验](https://mp.weixin.qq.com/s/WQiHpAv4bjEIz3fghzamEA)\\n- [IDEA 2021.1升级体验](https://mp.weixin.qq.com/s/dojfVvkrxru1eH8Pep7irw)\\n- [IDEA 2020.3升级体验](https://mp.weixin.qq.com/s/FhURpMKa9oi2FrV_0woOtw)\\n- [IDEA 2020.1升级体验](https://mp.weixin.qq.com/s/Ua4TYlcNntLr-x9WQirHyg)\\n- [IDEA插件分享：开发必备的IDEA神级插件大分享](https://mp.weixin.qq.com/s/xMwGAL_7sGkmnFvWZroVPw)\\n- [我的IDEA写代码小技巧：幸福感+效率爆棚](https://mp.weixin.qq.com/s/V2uAxmdq2e0Hl-y5GaD-Qw)\\n- [为啥我的IDEA Maven依赖下载总是失败？](https://mp.weixin.qq.com/s/KNk04dv6Z-ERrHiY03qdAw)\\n- [试水JetBrains官方新编程字体](https://mp.weixin.qq.com/s/RK_ygHgMjayL5-qTnlHbeg)\\n- [如何使用IDEA远程调试线上代码](https://mp.weixin.qq.com/s/WLTfgkPnJYJf9PZM8d8w4Q)\\n- [利用VS Code进行远程开发教程](https://mp.weixin.qq.com/s/ZDVYk188oPLugRI6oeVYIQ)\\n- [VS Code常用插件+快捷键整理](https://mp.weixin.qq.com/s/_3mwj5_MNln__3SSI8BJ3Q)\\n\\n---\\n\\n## API管理/文档管理\\n\\n---\\n\\n<p align=\\\"left\\\">\\n    <a href=\\\"https://mp.weixin.qq.com/s/ePhaYezFblgt0NgbvtWqww\\\" target=\\\"_blank\\\">\\n        <img src=\\\"https://cdn.jsdelivr.net/gh/justacoder99/r2coding@master/img/apidocs.2qlxsrvx2vy0.png\\\" width=\\\"\\\"/>\\n    </a>\\n</p>\\n\\n\\n- [科普篇：前后端都分离了，有哪些好用的API管理系统？](https://mp.weixin.qq.com/s/Ahs6fnIfFVVPOn3NZpIsNA)\\n- [科普篇：几款常用的在线文档神器](https://mp.weixin.qq.com/s/G6-6gqYnTvEsWOGIoj16ZQ)\\n- [一款零注解API接口文档生成工具](https://mp.weixin.qq.com/s/I_pH1V9iUu-IUayMA5oQSg)\\n\\n---\\n\\n## CI系统\\n\\n---\\n\\n<p align=\\\"left\\\">\\n    <a href=\\\"https://mp.weixin.qq.com/s/ePhaYezFblgt0NgbvtWqww\\\" target=\\\"_blank\\\">\\n        <img src=\\\"https://cdn.jsdelivr.net/gh/justacoder99/r2coding@master/img/ci.3iokn4xypxy0.png\\\" width=\\\"\\\"/>\\n    </a>\\n</p>\\n\\n\\n- [常用CI工具大盘点](https://mp.weixin.qq.com/s/PgoXJcJX_sm5132VGQoZ1w)\\n- [Jenkins Pipeline使用入门](https://mp.weixin.qq.com/s/Y2gxBmBK2HPvr1uKUUxRYA)\\n- [讨论：你们公司用啥CI守护系统？](https://mp.weixin.qq.com/s/4NlLEyy2QXX5_snX4r7FSw)\\n\\n## 其他软件/工具/网站\\n\\n- [自学数据结构和算法的9大工具和网站](https://mp.weixin.qq.com/s/f9dfQQbpKjMopH6m2Gjiiw)\\n- [12个常见的编程开发自学网站汇总](https://mp.weixin.qq.com/s/jFc-6QK2Mv1zHuhuFrqhog)\\n- [常用Web服务器软件大盘点](https://mp.weixin.qq.com/s/J1XjIwtEKjaltqWH-0qmgw)\\n- [9款最佳编程字体推荐](https://mp.weixin.qq.com/s/VB1jGIWWp4XdsLwXe-PKlQ)\\n- [5款时间管理工具推荐](https://mp.weixin.qq.com/s/71Cr9UxvQc6CdmguQIh-IA)\\n- [一个程序员的常用在线工具网站分享](https://mp.weixin.qq.com/s/oMAJaKDfr_bmgCVD0CX1oA)\\n- [2020年度开发者工具Top 100名单](https://mp.weixin.qq.com/s/VtmcuYGt96S4750UFYKnXQ)\\n- [Linux服务器上几个常用的监控小工具整理](https://mp.weixin.qq.com/s/zWIv5yBTD0Tvt8txb8znrA)\\n- [效率神器PowerToys使用攻略](https://mp.weixin.qq.com/s/LUPa_uSEd91Pj08VwxsxEQ)\\n- [22款适合程序员的终端生产力小工具推荐](https://mp.weixin.qq.com/s/k19ZT_yH4lzNLUYkH2GUJA)\\n- [9款优秀的代码比对工具推荐](https://mp.weixin.qq.com/s/IU5mmLxflgswICEo3BCWLA)\\n- [几款提升效率的软件神器](https://mp.weixin.qq.com/s/HZRz_A8bLcOTuzcezYEFZg)\\n- [命令行效率神器 NuShell ！](https://mp.weixin.qq.com/s/0f6JpBiPqCY8cZ2Ich0Lmg)\\n\\n---\\n\\n---\\n\\n# **计算机基础**\\n\\n---\\n\\n**计算机基础是最最重要的！** 即使后面的东西都没学（或者来不及学），基础部分是肯定需要完成的，这也是后面所有应用框架学习和做项目的基石；反之，在应用框架的学习或者做项目时如果感觉吃力，那就可能非常有必要回过头再来巩固对应的基础知识。\\n\\n计算机基础的学习不是一蹴而就的，需要一定的反复和回炉才能做到真正的融会贯通，需要一个过程。珍惜每一次回顾和复习基础的机会，应扎实精进，步步为营。\\n\\n那我们口口声声所说的编程基础（计算机基础）到底指是什么呢？\\n\\n此处整理为**六大方面：**\\n\\n- 一两门你最熟悉的编程语言（不求多，但求精！）\\n- 数据结构和算法\\n- 计算机网络\\n- 操作系统（计组）\\n- 数据库/SQL\\n- 设计模式\\n\\n---\\n\\n## 编程语言\\n\\n---\\n\\n语言在精不在多，切记！完全掌握了一门语言，上手其他的都不难！\\n\\n---\\n\\n<!-- tabs:start -->\\n\\n#### **Java**\\n\\n\\n- **基本功趣味学习（精讲）**\\n\\n  - [资源下载 → Java基础核心知识大总结pdf笔记下载](https://mp.weixin.qq.com/s/jn7oraFlhRkOmiv3rh74WA)\\n  - [夯实基本功之：Java程序员找对象攻虐！](https://mp.weixin.qq.com/s/aZg9SZT3DWkCkEsjlUjTtQ)\\n  - [夯实基本功之：浮点数在计算机中是如何表示的](https://mp.weixin.qq.com/s/LVpvmBO0GY6TC4gwL_12Yw)\\n  - [夯实基本功之：flaot和double使用时的大坑](https://mp.weixin.qq.com/s/UyYDt3HB8IO_AoSDLndhxA)\\n  - [夯实基本功之：为什么要面向接口编程](https://mp.weixin.qq.com/s/Dg9LcKJBrabcnvC_6wga-A)\\n  - [夯实基本功之：枚举精讲](https://mp.weixin.qq.com/s/DgOr7cat8SP0zoY7Ke3toQ)\\n  - [夯实基本功之：深拷贝/浅拷贝精讲](https://mp.weixin.qq.com/s/ypCIMGxyp7AX5cxG5UJ1Hg)\\n  - [夯实基本功之：序列化和反序列化精讲](https://mp.weixin.qq.com/s/0EfIUB9E-0Oh_Clwuxswuw)\\n  - [夯实基本功之：函数式编程例析](https://mp.weixin.qq.com/s/yI82juBiirJ56BZfGJezLw)\\n  - [夯实基本功之：如何去掉冗长的if/else代码](https://mp.weixin.qq.com/s/ufRf8DQQRYQI0q2VxG3hQg)\\n  - [夯实基本功之：注解精讲](https://mp.weixin.qq.com/s/gdYysBB3aD_HmPyvEThFXw)\\n  - [夯实基本功之：为什么不要用Date表示时间](https://mp.weixin.qq.com/s/v-Va_GuSUGr9HVAW84kloQ)\\n  - [夯实基本功之：去除烦人的NullPointerException空指针异常](https://mp.weixin.qq.com/s/RsC7peRsFaJAEcG2eTJb0Q)\\n  - [夯实基本功之：为什么要重写hashcode和equals方法](https://mp.weixin.qq.com/s/QZPezSruj0qvBUJEM4jB0g)\\n  - [夯实基本功之：Object类精讲](https://mp.weixin.qq.com/s/eJy74CbzthHMgRPOA_4wEA)\\n  - [夯实基本功之：List使用踩坑记录](https://mp.weixin.qq.com/s/9bw2-pkuYSKEnstb4KGsqQ)\\n  - [夯实基本功之：Map使用踩坑记录](https://mp.weixin.qq.com/s/D21mcfI4cxNf4D9ukjESog)\\n  - [夯实基本功之：面试必问的ConcurrentHashMap精讲](https://mp.weixin.qq.com/s/cnpfLL4TeL2oyEcHia6Bmg)\\n  - [夯实基本功之：死磕Java I/O流知识](https://mp.weixin.qq.com/s/xzV0uiQ0Q2ii5I54f8DPWQ)\\n  - [夯实基本功之：你一般是怎么遍历HashMap的](https://mp.weixin.qq.com/s/d93H9TwJKSnpkSBMYJ7QWQ)\\n  - [夯实基本功之：try-catch的使用姿势](https://mp.weixin.qq.com/s/AbZH57nUtePC728XfCvrcw)\\n  - [夯实基本功之：if和swictch性能例析](https://mp.weixin.qq.com/s/YbXBWhSlZTwY_bBqpNP2YA)\\n  - [夯实基本功之：Java HashMap源码剖析](https://mp.weixin.qq.com/s/xv0GmAU8fVlS_sxWKWUWYw)\\n  - [夯实基本功之：String性能提升10倍的几个用法](https://mp.weixin.qq.com/s/KRRLt0EaIwDEPCTGvqnWJA)\\n  - [实践篇：Java源码编译实战](https://mp.weixin.qq.com/s/K0ehqbxrzSz07nqnqRvn5A)\\n  - [面试篇：这10道基础Java面试题，虐哭了多少人](https://mp.weixin.qq.com/s/oBDrFnuk1lbfuNHkrhAC5w)\\n  - [面试篇：Java基础知识面试题大集合](https://mp.weixin.qq.com/s/f-qIQGbzwHcW5Ur51rCqgg)\\n  - [Java 11新特性例析](https://mp.weixin.qq.com/s/kNMQp-vjVK6Fq07xalZkng)\\n  - [Java 15新特性例析](https://mp.weixin.qq.com/s/1SVao6dMMLhNoFTOvnLy8g)\\n  - [科普：Java收不收费跟我们有毛关系吗？](https://mp.weixin.qq.com/s/QrWASACHkMGVop7gNe2DOA)\\n\\n\\n- **多线程和并发**\\n\\n  - [资源下载 → Java多线程+并发编程知识点详细总结PDF文档下载！](https://mp.weixin.qq.com/s/EGQAuvITVJT3fZUdQG84sw)\\n  - [夯实基本功之：Java并发之原子性、有序性、可见性](https://mp.weixin.qq.com/s/30__VavtpJxEojUjYglGhQ)\\n  - [夯实基本功之：ThreadLocal源码剖析](https://mp.weixin.qq.com/s/ND-nUCGvXTHkEClKqN1qrQ)\\n  - [夯实基本功之：Java线程池使用例析](https://mp.weixin.qq.com/s/TF04dB-i0q0-dOTqlprmYA)\\n  - [夯实基本功之：彻底搞懂多线程中的volatile](https://mp.weixin.qq.com/s/fxl3od5UObRrPGe2AVvAPA)\\n  - [夯实基本功之：面试必问的ConcurrentHashMap精讲](https://mp.weixin.qq.com/s/cnpfLL4TeL2oyEcHia6Bmg)\\n  - [夯实基本功之：详解Java并发编程中的各种锁](https://mp.weixin.qq.com/s/Sb1tZC_6CWE57TKvJeMmkA)\\n  - [Java并发和多线程基础面试题大集合](https://mp.weixin.qq.com/s/pIVf97W4DuAPNxq6zgRvsQ)\\n  - [科普向：Java线程和操作系统的线程到底有啥区别？](https://mp.weixin.qq.com/s/ykQ8wkBr-jHzbcD-7HGMEQ)\\n\\n\\n- **JVM虚拟机**\\n\\n  - [夯实基本功之：Java内存模型精讲](https://mp.weixin.qq.com/s/lEgHPertXyguZIkv61LlKQ)\\n  - [夯实基本功之：面试必问的JVM GC机制](https://mp.weixin.qq.com/s/bHkgpznnqixDNyDKwdAbOg)\\n  - [夯实基本功之：JVM垃圾回收硬核18问（附答案）](https://mp.weixin.qq.com/s/XsZUF2nBUSEJoGIA8RimJw)\\n  - [夯实基本功之：搞懂JVM的三大参数类型](https://mp.weixin.qq.com/s/TlX81xJ9fnuDIOTkDxrd1Q)\\n  - [夯实基本功之：了解G1垃圾收集器](https://mp.weixin.qq.com/s/KASLkkZnjGwVgm_1jbe-mA)\\n  - [实践篇：JDK源码编译上手实践](https://mp.weixin.qq.com/s/MDM6w2Dw_HYc9XzZevQNeA)\\n  - [实践篇：线上服务的YGC问题排查例析](https://mp.weixin.qq.com/s/-8xYoAkBUoavcSl69I0XJw)\\n  - [实践篇：线上服务的FGC问题排查例析](https://mp.weixin.qq.com/s/Sjh9qFPKF250vLQGZig6nw)\\n  - [面试题：Java虚拟机（JVM）面试题大集合1](https://mp.weixin.qq.com/s/T2DqgJ9-0QiRZQYUeR3c8w)\\n  - [面试题：Java虚拟机（JVM）面试题大集合2](https://mp.weixin.qq.com/s/ZYoeC8yyfReEJDFSqiW8hw)\\n\\n\\n<!-- tabs:end -->\\n\\n---\\n\\n## 数据结构+算法题\\n\\n---\\n\\n数据结构和算法题对于程序员的重要性不言而喻。参加过笔试或者面试过的小伙伴应该知道，可以说这个东西某一程度上直接决定了面试的成败，现在的互联网公司技术岗面试，数据结构+算法题基本都是必选项。\\n\\n除了几种基础数据结构类型得烂熟于心，基本的几大算法(或者说算法思想)也要了如指掌之外，参加求职前，不论是校招还是社招，非常有必要好好刷一刷LeetCode上的数据结构和算法题，以保持题感。\\n\\n---\\n\\n- [资源下载 → LeetCode算法刷题Golang版答案PDF文档](https://mp.weixin.qq.com/s/EaDLaLy3YjrNiSoNofwMMA)\\n- [资源下载 → LeetCode算法刷题C++版答案PDF文档](https://mp.weixin.qq.com/s/qR6KTfldk41lsOj1Ghp6Og)\\n- [资源下载 → LeetCode算法刷题Java版答案PDF文档](https://mp.weixin.qq.com/s/kWTJ9640mPegr5wqVE0GMg)\\n- [资源下载 → 谷歌学长的数据结构+算法题代码笔记手册](https://mp.weixin.qq.com/s/gXH98f1p5cCYVETCn9w9kA)\\n- [数据结构：24张图详解九大数据结构](https://mp.weixin.qq.com/s/ZVwIUN-xf9FuxOFXW8H3Nw)\\n- [数据结构：哈希表详解](https://mp.weixin.qq.com/s/UanDueZi3MwlcKYGMNQPGg)\\n- [数据结构：栈Stack的几种含义理解](https://mp.weixin.qq.com/s/v6rr0M9AW_kSMEtjkc-Mqw)\\n- [数据结构：各种树详解](https://mp.weixin.qq.com/s/k4-RaW4ROlo6chSXsO_4AA)\\n- [数据结构：跳表精讲](https://mp.weixin.qq.com/s/czkZcQL8mEqG2xeX8huqsA)\\n- [数据结构：数组和链表的性能对比](https://mp.weixin.qq.com/s/iG9zNHYLkEyHF3M4RpoWKw)\\n- [算法：十大经典排序算法大梳理 (动图+代码)](https://mp.weixin.qq.com/s/ekGdneZrMa23ALxt5mvKpQ)\\n- [算法：排序算法趣味对比](https://mp.weixin.qq.com/s/za_MJY3-r9Gfiu3BJfej7Q)\\n- [算法：二分法及其变种](https://mp.weixin.qq.com/s/1ExIav9uK4bvVnnf4t0H2Q)\\n- [算法：10张图搞定KMP算法](https://mp.weixin.qq.com/s/H1ttBFuBY5n3Dbh3YaTmlw)\\n- [算法：面试官最爱的字符串匹配算法精讲](https://mp.weixin.qq.com/s/FYx3acRh9JXAIb7y97G39A)\\n- [算法：8大常见算法思想总结](https://mp.weixin.qq.com/s/vGjcX4nHv6QT2-qKHZM8Dw)\\n- [算法：一文彻底学会递归思路解题](https://mp.weixin.qq.com/s/JLbjzCdVlJ_de2uGgBsUzw)\\n- [算法：10张动图理解递归](https://mp.weixin.qq.com/s/uuNaZfzhG3KaoEtez8Migw)\\n- [算法：分治算法详解](https://mp.weixin.qq.com/s/a3_bMRmTqZxMBruYsPC9-w)\\n- [算法：递归算法详解](https://mp.weixin.qq.com/s/tqGKHZzSyDBgEp-oWsOztQ)\\n- [算法：动态规划常见算法题例析](https://mp.weixin.qq.com/s/bGH_o1BsJtgnC2rFugtsRw)\\n- [算法：搞定算法复杂度分析](https://mp.weixin.qq.com/s/mBTyBkeNHoW7-Rcbv2Exwg)\\n- [算法：常用算法复杂度速查表](https://mp.weixin.qq.com/s/U6D1PNjuBAcRd5UZRr0F3w)\\n- [算法：常见刷题模式套路分析](https://mp.weixin.qq.com/s/JhHPAaOInIi4lZ-UrCLdgg)\\n- [算法：算法题刷题的心得和建议](https://mp.weixin.qq.com/s/Gz9-f_G6P-0tKrReAinw0A)\\n- [算法：求职必刷算法题大集锦](https://mp.weixin.qq.com/s/HUS12phrTbNzAE6uFHO9lg)\\n- [工具推荐：自学数据结构和算法的9大工具和网站](https://mp.weixin.qq.com/s/f9dfQQbpKjMopH6m2Gjiiw)\\n\\n---\\n\\n## 计算机网络\\n\\n---\\n\\n**为什么一定要学好计算机网络？**\\n\\n原因很简单，因为计算机网络中的各种协议栈是当下繁荣的互联网通信的基石，尤其建议要牢固熟练地掌握TCP/IP协议栈。\\n\\n---\\n\\n- [视频科普：计算机网络该怎么学](https://www.bilibili.com/video/BV1U4411M71p)\\n- [概念科普：如何系统地学习计算机网络](https://mp.weixin.qq.com/s/v34D8xWGPW8LgENy3G2QZA)\\n- [概念科普：计算机网络的89个核心概念](https://mp.weixin.qq.com/s/t8Dz-4D6BuBevZYz5Jhklg)\\n- [概念科普: 为什么网络IO会被阻塞](https://mp.weixin.qq.com/s/M9DANSrACS4xUt6UM03IxA)\\n- [工具科普：学网络时，可以先落实这几款利器工具](https://mp.weixin.qq.com/s/hZF2P4oQE6dsuXKWLEgDKA)\\n- [探究原理：浏览器输入网址一回车，后面到底发生了什么](https://mp.weixin.qq.com/s/t2Csrl7idUXISKW54cpV1g)\\n- [探究原理：你可能没有细究过的TCP/IP](https://mp.weixin.qq.com/s/AjcW7ELOTTqqdnUHpMbccQ)\\n- [探究原理：一个数据包在网络中到底是怎么游走的](https://mp.weixin.qq.com/s/07zloKKMUl-RHN6tWqZIJQ)\\n- [探究原理：两台计算机之间究竟是如何通信的](https://mp.weixin.qq.com/s/ZCddesfN0qISh3Rqo2jbWA)\\n- [探究原理：ping命令用得这么6，原理知道不](https://mp.weixin.qq.com/s/55bbQX2-SUNe6PEI9My5fA)\\n- [探究原理：一台Linux服务器最多能支撑多少个TCP连接](https://mp.weixin.qq.com/s/QuCxkSjdM_E12lXlpnhKIQ)\\n- [探究原理：都说HTTP协议无状态，这里的「状态」到底指什么](https://mp.weixin.qq.com/s/EZwOUGMrGKEF_POisJKmuw)\\n- [探究原理：Session/Cookie/Token](https://mp.weixin.qq.com/s/5oFKdbFWgZrwqESNTZn77w)\\n- [探究原理：Cookie、Session、Token 背后的故事](https://mp.weixin.qq.com/s/oMDCi0kLpn31T00QkxfkQA)\\n- [探究原理：三次握手底层深度理解](https://mp.weixin.qq.com/s/u242LSHnePBg_KbMc0ioTA)\\n- [知识总结：计网IP部分知识总结](https://mp.weixin.qq.com/s/21Tk-8gxpDoH9DNWNYCWmA)\\n- [知识总结：图解HTTP的前世今生](https://mp.weixin.qq.com/s/vk_QZDpJLVEXXNe1jYzd8w)\\n- [知识总结：HTTP和HTTPS协议大总结](https://mp.weixin.qq.com/s/8HJ-V1BbV9wp89HS-XulXw)\\n- [面试相关：2w+字的计算机网络常见面试题整理](https://mp.weixin.qq.com/s/C82YpO0gwC8LHcJSHbR81A)\\n- [面试相关：GET和POST到底有什么区别](https://mp.weixin.qq.com/s/H4gbg7bfnw61jZQcapTnMw)\\n- [面试相关：面试最爱问的三次握手和四次挥手问题](https://mp.weixin.qq.com/s/lFnyBaaP3f0eNcKGW5RtCg)\\n- [面试相关：HTTP常见面试题集合](https://mp.weixin.qq.com/s/FJGKObVnU61ve_ioejLrtw)\\n- [面试相关：计网TCP/UDP部分高频面试题集合](https://mp.weixin.qq.com/s/doxVJZ1G6187B4AOXb0JlA)\\n- [面试相关：计算机网络高频12问](https://mp.weixin.qq.com/s/PIGfhMaAx9R5C4x5eJQnIw)\\n- [实践系列：网络排错思路大总结](https://mp.weixin.qq.com/s/L8jmABzoI_e4dCcECenHtQ)\\n- [实践系列：抓个包看一看浏览器里的HTTP请求到底是如何完成的](https://mp.weixin.qq.com/s/_fB7r53BGZRvpG9YAPRQ8A)\\n\\n---\\n\\n## 操作系统\\n\\n---\\n\\n学好操作系统有利于我们深入理解计算机底层，这样平时在遇到疑难杂症时，能够更容易看到问题的本质，并高效解决；另外操作系统里的很多优秀的设计思想、经典的架构、算法、思路也值得我们反复理解和思考，很多思想在平时的工作中也可以借鉴和运用。\\n\\n---\\n\\n- [知识总结：学编程要懂的操作系统基础](https://mp.weixin.qq.com/s/ttncekujB82g88GRx3a6lQ)\\n- [知识总结：程序员必知的89个操作系统核心概念](https://mp.weixin.qq.com/s/VsQ7IpP-jnXSjJhOAzl-ew)\\n- [知识总结：操作系统主要概念硬核讲解](https://mp.weixin.qq.com/s/1Rzvu9uCTef5l_8Qw3ff0A)\\n- [知识总结：20张图详解操作系统内存管理部分知识点](https://mp.weixin.qq.com/s/m-AmxDVUfko7OTUsCapnPA)\\n- [知识总结：这才是对进程和线程最通俗易懂的解释](https://mp.weixin.qq.com/s/FoYiPB-2LuIpnTW8gck2EQ)\\n- [知识总结：操作系统并发三剑客之进程/线程/协程](https://mp.weixin.qq.com/s/Pfc31qoWfL6_uva6ePBmVA)\\n- [知识总结：操作系统高并发服务模型大科普](https://mp.weixin.qq.com/s/yXMgpAhz3JhtCtutMQnXvQ)\\n- [知识总结：这可能是讲死锁最通俗的一篇文章](https://mp.weixin.qq.com/s/7AHS5AlY2OaiLO4ag6zVMQ)\\n- [知识总结：一举拿下网络IO模型](https://mp.weixin.qq.com/s/vwJ5T7x1Jv4wa_x7nwr54Q)\\n- [知识总结：用一个故事来感受一下什么叫NIO](https://mp.weixin.qq.com/s/iFIt8t-q6hU-Ghwlj0hohw0)\\n- [知识总结：多路复用、非阻塞、线程与协程](https://mp.weixin.qq.com/s/xIfxzxCfbvBvQ2c0aUuA0A)\\n- [知识总结：搞懂原码/反码/补码](https://mp.weixin.qq.com/s/laP7Vxl6o40mIYBS7Cuj7A)\\n- [知识总结：30张图解高并发服务模型哪家强](https://mp.weixin.qq.com/s/a2Q1DQqOHdhtGEjJ4QxPew)\\n- [原理探究：新建一个空文件到底会占用多少磁盘空间？](https://mp.weixin.qq.com/s/vMvAgo9IWaLtDwxW1627YA)\\n- [面试相关：2.5w字+36张图+1周时间：爆肝操作系统面试题！](https://mp.weixin.qq.com/s/lR_A3jbfRiRjchz_lyyKxw)\\n- [面试相关：1.3w字的操作系统高频面试题大分享](https://mp.weixin.qq.com/s/oTEMOQY1xcG8uVceW-kLDA)\\n- [面试相关：学完操作系统内存管理，能回答这8个问题吗](https://mp.weixin.qq.com/s/5f3ku77xSO8UlaOsTkOnHQ)\\n\\n---\\n\\n## 数据库/SQL\\n\\n- [原理探究：详解一条SQL的执行过程](https://mp.weixin.qq.com/s/OnGaqyUpB58pC2rqqzIzgw)\\n- [原理探究：MySQL的数据存在磁盘上到底长什么样](https://mp.weixin.qq.com/s/36Jaj79Y8BxFoDB3Bwe7mg)\\n- [原理探究：数据库索引到底是什么](https://mp.weixin.qq.com/s/WMuxdG3ymNMWWDk1XhLwZQ)\\n- [原理探究：为什么MySQL索引要用B+ tree](https://mp.weixin.qq.com/s/d7Zfat2fP6IX5DMKKtEIjQ)\\n- [原理探究：为什么用了索引，SQL查询还是慢](https://mp.weixin.qq.com/s/-mOOchaXx_pKI6qWhohEnA)\\n- [原理探究：数据库索引的原理和使用准则](https://mp.weixin.qq.com/s/4K3borSZXt-yc5t5UJnJpQ)\\n- [原理探究：为什么你写的SQL那么慢](https://mp.weixin.qq.com/s/iBnav_WPrX5vjR-NbdNeQg)\\n- [原理探究：count(1)和count(*)到底哪个效率高](https://mp.weixin.qq.com/s/lyAFcnZIoyhACw78Nf9xQg)\\n- [原理探究：为什么阿里规定超过三张表禁止join](https://mp.weixin.qq.com/s/7vN9Nf20NGnvLKALHw_O1Q)\\n- [原理研究：什么是MySQL索引下推？](https://mp.weixin.qq.com/s/aPVs9Jrk07KsXcXdPOpx5A)\\n- [原理探究：为什么大公司后台数据库都要搞分库分表？](https://mp.weixin.qq.com/s/yflzIQFiNa3tDJm7U9P8ig)\\n- [原理探究：MySQL不会丢失数据的奥秘就藏在这里](https://mp.weixin.qq.com/s/QBeyJz2gVq1p7wBxcY1Gfw)\\n- [原理探究：MySQL主从复制那些事儿](https://mp.weixin.qq.com/s/CCLsmKSsodtkz4iX84Cdig)\\n- [实践应用：常见的SQL错误（不当）写法例析](https://mp.weixin.qq.com/s/caBYeVtZvNzbSs4q-6710Q)\\n- [实践应用：SQL优化的几个角度](https://mp.weixin.qq.com/s/hl11JYMwl30FsDVZ40CLVQ)\\n- [实践应用：数据库、数据表设计规范例析](https://mp.weixin.qq.com/s/hE2uKE2ffNCmeHLRn2KSTQ)\\n- [实践应用：梳理开发中常用的SQL优化途径](https://mp.weixin.qq.com/s/jl0j-T6XldN6Nq-jYoQ-gA)\\n- [实践应用：先更新数据库还是先更新缓存？](https://mp.weixin.qq.com/s/SPgtpfgv6bz2AfPa1CYYeQ)\\n- [实践应用：百亿级数据分表后如何分页查](https://mp.weixin.qq.com/s/EplL3kBx5vOXGDhDOP8NjQ)\\n- [实践应用：什么是SQL注入攻击](https://mp.weixin.qq.com/s/mnZT0Z5L6Hi6gRgEO1C9tg)\\n- [实践应用：用对这些场景下的数据库索引，领导说我有点东西](https://mp.weixin.qq.com/s/4K3borSZXt-yc5t5UJnJpQ)\\n- [实践应用：一个遗留项目的SQL优化实战录](https://mp.weixin.qq.com/s/MA7FVeJDMg8WDJABiBWpBA)\\n- [实践应用：误删数据库后该如何恢复](https://mp.weixin.qq.com/s/UYZZkrbAetgnPUjGa71fJA)\\n- [实践应用：如何科学根治慢SQL？](https://mp.weixin.qq.com/s/eQKphrkPeN_-EcWIxETz9Q)\\n- [面试相关：面试官最爱的数据库索引连环问](https://mp.weixin.qq.com/s/MLvJsJuFAHHcllqvk1nVRQ)\\n- [面试相关：30道保底的MySQL数据库面试题集合](https://mp.weixin.qq.com/s/aBboeqEphejICklAKLqS2Q)\\n- [面试相关：数据库自增ID用完了会怎样](https://mp.weixin.qq.com/s/WqM5mhnLOqZhcdzPLeWh5w)\\n- [面试相关：如何保证缓存和数据库的一致性问题？](https://mp.weixin.qq.com/s/RDOKLnG7P1j5Ehu3EyrsCQ)\\n- [面试相关：面试官最爱的MySQL连环问](https://mp.weixin.qq.com/s/8ddEzG-NzzFD35ehvbER7A)\\n- [面试相关：如何实现丝滑的数据库扩容](https://mp.weixin.qq.com/s/1VCC3i6ZCk7sb9kVRZ1czQ)\\n\\n---\\n\\n## 设计模式\\n\\n  - [资源下载 → 23种设计模式学习笔记PDF文档](https://mp.weixin.qq.com/s/miV4SH1Eb_FMogQ2XYvPuA)\\n  - [单例模式详解](https://mp.weixin.qq.com/s/dXUgiMacKjwTBwX16cXNBA)\\n  - [工厂模式讲解, 引入Spring IOC](https://mp.weixin.qq.com/s/8TfJ1uhMiKHnTmlF9D0L2Q)\\n  - [什么是动态代理模式](https://mp.weixin.qq.com/s/GT1-yrxJ5KF0xeMydbJDCQ)\\n  - [经典面试题：Spring用到了哪些设计模式](https://mp.weixin.qq.com/s/ZcKqGT2Sn4wVScExSF9Alg)\\n\\n## 其他\\n\\n- [每个开发人员都应该了解一点的UML规范](https://mp.weixin.qq.com/s/7-CTSWN-VLYgPH5H2nPU8w)\\n- [计算机时间到底是怎么来的](https://mp.weixin.qq.com/s/VFUg1S0ApuFzlTNYSCLkMQ)\\n- [乱码问题科普：“锟斤拷”的前世今生~](https://mp.weixin.qq.com/s/kTADQtTeOWPuXsvR9HsUIg)\\n- [从一个面试题看程序员的几项基本功](https://mp.weixin.qq.com/s/dVgDv1bNH8ivO0Ft0FtmZg)\\n\\n---\\n\\n# **应用框架和工具**\\n\\n---\\n\\n计算机基础聊完了，接下来就是应用和实践的环节了。这部分通常会涉及到一些**工具**、**编程环境**、以及**应用框架**。\\n\\n企业级开发不同于个人自学，出于**可复用性**、**稳定性**、**开发成本**、**开发效率**、**质量保证**等一系列因素的考量，不可能每一个功能、每一个组件都从0开始徒手造轮子，所以这时候各种应用框架和工具的出现就非常有帮助了。\\n\\n其实框架讲白了就是别人经过多年迭代写好的一套**工具**、**代码库**、**逻辑**、亦或是**流程**，把原本都需要从0开始手写的基本功能和组件都给封装进去，用户只要符合框架约定的规则进行编码，或者调用框架提供的方法或者工具，就能快速拉起业务功能，创造实际经济价值。\\n\\n所以框架的出现从不同的角度看也是有多面性的：对于企业级开发效率提升而言肯定是有帮助的，但是对于程序员个人思考编码能力提升却未必是好事，所以多注重基础、深挖原理，提升自身竞争力还是非常有必要的。\\n\\n\\n## Spring系列框架\\n\\n<!-- panels:start -->\\n\\n<!-- div:left-panel -->\\n\\n- [原理探究：Spring Boot项目究竟是怎么启动的？源码剖析](https://mp.weixin.qq.com/s/-MYQ-meSUcr-wZhfUbGq3Q)\\n- [原理探究：SpringBoot中@SpringBootApplication注解探秘](https://mp.weixin.qq.com/s/NqG7GzsPhwI76h3nujTCgQ)\\n- [原理探究：Spring @Autowired注解详解](https://mp.weixin.qq.com/s/uYNpoxcZ22goiev3uSus2w)\\n- [原理探究：Spring @Value注解详解](https://mp.weixin.qq.com/s/LGYSChfDLKuCQVMYGi0Omg)\\n- [原理探究：Spring框架是如何解决循环依赖问题的](https://mp.weixin.qq.com/s/m2DrtDxBzShtNF2Uk6zSAg)\\n- [原理探究：Spring中竟然有12种定义Bean的方法](https://mp.weixin.qq.com/s/YZT7NURQsNBSoSNsWBciQg)\\n- [原理探究：Spring的Controller究竟是单例还是多例，如何保证并发安全](https://mp.weixin.qq.com/s/PNmlpv786kgk5Pyhr5XSsw)\\n- [原理探究：为什么Spring的Bean默认是单例的](https://mp.weixin.qq.com/s/uQxxGpJJo4XfkLfHHp8nHw)\\n- [原理探究：单点登录(SSO)原理和实现](https://mp.weixin.qq.com/s/8brVERYV-XMIGB0Qly_mOg)\\n- [原理探究：面试常问的Spring IoC原理解析](https://mp.weixin.qq.com/s/0zRks2Cz36S8N70Uonb0OA)\\n- [原理探究：了解这些，就可以在Spring启动时为所欲为了](https://mp.weixin.qq.com/s/yXKPNB2dB99K_9gOWw6UHg)\\n- [实践应用：Spring Boot日志框架实践](https://mp.weixin.qq.com/s/uVqkLkkxot-zsoVPo1ri1A)\\n- [实践应用：利用神器BTrace追踪线上Spring Boot应用运行时信息](https://mp.weixin.qq.com/s/NH7ck79I3U0bJTEv37aECw)\\n- [实践应用：Spring Boot项目集成全局唯一ID生成器UidGenerator](https://mp.weixin.qq.com/s/GGeavPrGAzF1YOxCSk3YrQ)\\n- [实践应用：Spring Boot Admin2.0开箱体验](https://mp.weixin.qq.com/s/jdV8X_R9eeZRus5bfoSNNg)\\n- [实践应用：Spring Boot项目传参校验最佳实践](https://mp.weixin.qq.com/s/WQ-2fPOxk0GvSHiRR5-kQw)\\n- [实践应用：Spring Boot项目优雅传参方式讨论与实践](https://mp.weixin.qq.com/s/AdtUX9davFH-C60gBypnoA)\\n- [实践应用：基于Spring Security Oauth2的SSO单点登录+JWT权限控制实践](hhttps://mp.weixin.qq.com/s/ZLUOWYVsf6gDcT94X_saJg)\\n- [实践应用：封装一个好用的流水号ID生成器id-spring-boot-starter](https://mp.weixin.qq.com/s/AEWjwIEjVMf_cRixiIb7-Q)\\n- [实践应用：封装一个好用的elasticsearch-spring-boot-starter](https://mp.weixin.qq.com/s/V2jGlNn4EsM-_RheIk0TYg)\\n- [实践应用：Spring Boot项目集成jasypt-spring-boot加密组件](https://mp.weixin.qq.com/s/CTDEFxTKdk0qxK9VNSEIqw)\\n- [实践应用：基于Spring Security+JWT的权限系统设计](https://mp.weixin.qq.com/s/sMi1__Rw_s75YDaIdmTWKw)\\n  <!-- div:right-panel -->\\n- [实践应用：Spring Boot项目集成全局唯一ID生成器Vesta](https://mp.weixin.qq.com/s/u3ioahBPOno81dp3f2IDJA)\\n- [实践应用：Spring Boot项目集成Mybatis-Plus](https://mp.weixin.qq.com/s/SeXKbp9ee-FMNKfuSqpZFw)\\n- [实践应用：如何自制一个Spring Boot Starter并推到远端公服](https://mp.weixin.qq.com/s/J0UcedPhgHiTndk80CNikA)\\n- [实践应用：Spring Boot项目集成Ehcache缓存](https://mp.weixin.qq.com/s/OWX-hsk1F11Bvk2PWmnzxA)\\n- [实践应用：Spring Boot项目集成自然语言处理工具包HanLP](https://mp.weixin.qq.com/s/2-HdLggtBSmiyJI449cLow)\\n- [实践应用：基于Spring Boot实现图片上传/加水印一把梭操作](https://mp.weixin.qq.com/s/PGFDNoNuzlOR0m-tiIQGWw)\\n- [实践应用：Spring Boot项目集成EVCache缓存实践](https://mp.weixin.qq.com/s/d7do5NZeu4-yRo2RfJK7uA)\\n- [实践应用：Spring Boot项目集成Guava Cache本地缓存实践](https://mp.weixin.qq.com/s/C4VBAm4N3AjvXJ303wdV5A)\\n- [实践应用：Spring Boot项目集成MyBatis Generator进行数据层代码自动生成](https://mp.weixin.qq.com/s/ehe7Ub5RAYAql_oPZmerAQ)\\n- [实践应用：初探Kotlin+SpringBoot联合编程](http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247484900&idx=2&sn=45df41412575afb244f75de08b6bbe7f&chksm=fdded320caa95a36e85c510a1a72951b97a579511db7bd58aba2270020434b5579b8c3ce578f&scene=21#wechat_redirect)\\n- [实践应用：Spring Boot项目集成神器Lombok实践](http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247485020&idx=1&sn=3c3405807f96a597398f513c48bb094e&chksm=fdded098caa9598e6159bd7315180e149e6a789a3ee75d42b4acaaae96669504e08378eeddae&scene=21#wechat_redirect)\\n- [实践应用：Spring项目集成Lombok插件的优缺点分析](https://mp.weixin.qq.com/s/7pv9TwWHzF624sVMFDypvQ)\\n- [实践应用：Spring Boot应用监控实战](https://mp.weixin.qq.com/s/dt2B8Pku1dSXQuzDJYiEgQ)\\n- [实践应用：Spring Boot项目部署于外置Tomcat容器](https://mp.weixin.qq.com/s/UvFWTyFUUwfRXi1ZqmZdGA)\\n- [实践应用：Spring Boot热部署加持](https://mp.weixin.qq.com/s/M5Y1VInGRkx_RHJn9KWBpA)\\n- [实践应用：Spring Boot高效数据聚合之道](https://mp.weixin.qq.com/s/N7hzj4IR-di_KEgOts5OBg)\\n- [实践应用：Spring项目日志打印常见问题](https://mp.weixin.qq.com/s/p5LTCPgsGoEjuKL0F65PAg)\\n- [面试相关：Spring面试夺命连环10连问](https://mp.weixin.qq.com/s/euzbHPpQG2BSKl93N5L1Hg)\\n- [面试相关：Spring经典面试题集合](https://mp.weixin.qq.com/s/q4CajkpSUC8TCgv55VK5aQ)\\n- [面试相关：Spring Boot基础面试题集合](https://mp.weixin.qq.com/s/cLh9xCDkVG0KV-uaX8PkNw)\\n- [面试相关：Spring Cloud基础面试题集合](https://mp.weixin.qq.com/s/g0br3PfTmm8C_nkKbzE_ig)\\n- [面试相关：说说Spring用到了哪些设计模式？](https://mp.weixin.qq.com/s/ZcKqGT2Sn4wVScExSF9Alg)\\n- 内容持续更新中...\\n\\n\\n<!-- panels:end -->\\n\\n<!-- panels:start -->\\n\\n<!-- div:left-panel -->\\n\\n## 前后端分离\\n\\n- [概念科普：到底什么是RESTful ？](https://mp.weixin.qq.com/s/um5kDYBscf5sy7FUhmP7ww)\\n- [概念科普：RESTful风格的前世今生](https://mp.weixin.qq.com/s/lrFQUEITm_3zASIBR1mcQw)\\n- [概念科普：为什么需要前后端分离？](https://mp.weixin.qq.com/s/Y0z-3r_Mdm-etCwa0GmQmQ)\\n- [实践应用：前后端分离的接口规范，我们是如何做的？](https://mp.weixin.qq.com/s/zAOYAcR-6DEJU_s0qXe91g)\\n- [实践应用：前后端分离式开发：高效协作10条准则](https://mp.weixin.qq.com/s/niYHlrCDIkA1NqPVI_VJ8w)\\n- [实践应用：前后端分离后，接口联调总是甩锅怎么办？](https://mp.weixin.qq.com/s/TqSQ21nNvV5WwWDY_WItQA)\\n- [实践应用：前后端分离项目接口优雅数据交互例析](https://mp.weixin.qq.com/s/B-mJjBeJy5W7s2O79Iitqg)\\n- [实践应用：前后端分离实践中常遇到的跨域问题](https://mp.weixin.qq.com/s/Sjrgf3Tp3vR5zsNIiYzdpA)\\n- [工具推荐：前后端都分离了，该搞个好用的API管理系统了](https://mp.weixin.qq.com/s/Ahs6fnIfFVVPOn3NZpIsNA)\\n\\n<!-- div:right-panel -->\\n\\n## 分布式/微服务\\n\\n- [科普篇：企业里常用的软件架构剖析](https://mp.weixin.qq.com/s/NJFJ5UrzGk0cMGL1oZe0Bg)\\n- [科普篇：单体→分布式→微服务，这些年的软件架构是如何发育的](https://mp.weixin.qq.com/s/kfhCEDSUGwnNUbtGDL_rvQ)\\n- [科普篇：微服务架构的全局图景分析](https://mp.weixin.qq.com/s/Iy1dguNFkU73r1FxYIvlIQ)\\n- [科普篇：分布式架构负载均衡的几种方式](https://mp.weixin.qq.com/s/8CvoGCtGDvMHR91Lx89pxQ)\\n- [科普篇：RPC 技术(框架) 大科普](https://mp.weixin.qq.com/s/iTnKumgre3SzrBuWf8KB6g)\\n- [原理探究：什么是分布式事务](https://mp.weixin.qq.com/s/_56jq_p_nDUiBwaI2MTlmA)\\n- [原理探究：Redis分布式锁保姆级无死角分析](https://mp.weixin.qq.com/s/RViDM1WHE61SDLNKzUmTAg)\\n- [原理探究：如何设计一个高并发的秒杀架构？](https://mp.weixin.qq.com/s/fLLd-ml-gdo3-700iJso_A)\\n- [原理探究：亿级流量网关设计思路](https://mp.weixin.qq.com/s/J0aSVry1-Ss1OTA-jQAX3w)\\n- [原理探究：分布式架构的几个常见的坑](https://mp.weixin.qq.com/s/pg6lyAkgAaqSAZjiPgQTWA)\\n- [原理探究：什么是异地多活架构](https://mp.weixin.qq.com/s/Uv9pAOocep2rUW5qgGFSSw)\\n- [实践应用：RPC框架实践之：Apache Thrift](https://mp.weixin.qq.com/s/iCw-CHa5ITz6zoQI78Wb3w)\\n- [实践应用：RPC框架实践之：Google gRPC](https://mp.weixin.qq.com/s/LdzkBUzvyjMVW7pgzkA23w)\\n- [实践应用：Spring Cloud Feign的两种使用姿势](https://mp.weixin.qq.com/s/U4eustBBu9N-6B1SRsYc7w)\\n- [实践应用：Spring Cloud Eureka Server高可用之：在线扩容](https://mp.weixin.qq.com/s/oMsZquaphqEJqoGt1dt9WA)\\n- [实践应用：Eureka Server 开启Spring Security Basic认证](https://mp.weixin.qq.com/s/tRRwG1jnWi5r1XlbeBlv8g)\\n- [实践应用：Eureka Server启用 https服务指北](https://mp.weixin.qq.com/s/EAi7F3lBQ7ZrjSjNnFkj4g)\\n- [实践应用：微服务调用链追踪中心搭建](https://mp.weixin.qq.com/s/c55ejzWEU6SQBdcmTTRC1g)\\n- [实践应用：利用Zipkin追踪Mysql数据库调用链](https://mp.weixin.qq.com/s/wQRBxBBXCnP0YKPvtIPRcA)\\n- [实践应用：一个小团队的微服务架构改造之路](https://mp.weixin.qq.com/s/VjBiUmQNQPpSHeSVjK1C2A)\\n- 内容持续更新中...\\n\\n\\n<!-- div:left-panel -->\\n\\n## 容器/集群\\n\\n- [知识总结：常用虚拟化技术（VMware/KVM/Docker）对比](https://mp.weixin.qq.com/s/hVNMfh9nWdilXHSqvyS9ng)\\n- [知识总结：Docker从入门到干活，看这一篇入门](https://mp.weixin.qq.com/s/YlcvlUQ-xkz25PuYkeEQqw)\\n- [知识总结：Docker Swarm的前世今生](https://mp.weixin.qq.com/s/jf4qWaEYfn0CH5A6fG6MKw)\\n- [知识总结：编写高效Dockerfile的几条准则](https://mp.weixin.qq.com/s/MDGvWKkk4npWtqo2k4tsfg)\\n- [实践应用：Docker Swarm集群初探](https://my.oschina.net/hansonwang99/blog/1603378)\\n- [实践应用：利用ELK搭建Docker容器化应用日志中心](https://mp.weixin.qq.com/s/sO9_TixS0XrKoCKIS9oETw)\\n- [实践应用：Docker容器可视化监控中心搭建](https://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247483763&idx=1&sn=6ceb9e73540b5016dadfb212636b3855&scene=21#wechat_redirect)\\n- [实践应用：Docker容器跨主机通信之直接路由方式](https://mp.weixin.qq.com/s/evxiE6nhK6_y6zLMFWHTKQ)\\n- [实践应用：利用TICK搭建Docker容器可视化监控中心](https://mp.weixin.qq.com/s/-54IZbsX2nQIHaMZ1y6fTQ)\\n- [实践应用：利用Kubeadm部署Kubernetes 1.13.1集群实践录](https://mp.weixin.qq.com/s/wx68Chw1XaKQ1cb57jTiOw)\\n- [实践应用：利用K8S技术栈打造个人私有云（连载之：初章）](http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247483699&idx=1&sn=57b84f4ec72c8a578934cdb4225e6fe7&chksm=fdded7f7caa95ee198652c295b48b74565fd244afc4dccc0551b036c8216caab0397a1342d99&scene=21#wechat_redirect)\\n- [实践应用：利用K8S技术栈打造个人私有云（连载之：K8S集群搭建）](http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247483755&idx=1&sn=92a547c579aeacf1db9a8f0e56601b52&chksm=fdded7afcaa95eb9d6aa6cf323bff1df46692fc6a6672e0a483105f091ddf9670fb06d034e2a&scene=21#wechat_redirect)\\n- [实践应用：利用K8S技术栈打造个人私有云（连载之：K8S环境理解和练手）](http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247483758&idx=1&sn=629b6219a06374b2050703b9549037fa&chksm=fdded7aacaa95ebc9a3e88e839515b13109752c26c586032ae60219d2c3b24e13385e1bcd37c&scene=21#wechat_redirect)\\n- [实践应用：利用K8S技术栈打造个人私有云（连载之：基础镜像制作与实验）](http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247483759&idx=1&sn=8403d42fe1769a252f9ee2997fc2f561&chksm=fdded7abcaa95ebd8cdae86f4d692f1f6e92daab74dbbd8c56c6db8fe6aa2a3616ccce1eebb1&scene=21#wechat_redirect)\\n- [实践应用：利用K8S技术栈打造个人私有云（连载之：K8S资源控制）](http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247483760&idx=1&sn=d44f2c744ccdc965fb6c7e4d9efe9f92&chksm=fdded7b4caa95ea278d7363b4b4788d84914b915422a9cc98e7936c3bce0c7ce1197abfac13f&scene=21#wechat_redirect)\\n- 内容持续更新中...\\n\\n<!-- div:right-panel -->\\n\\n## 缓存/MQ/中间件/服务器\\n\\n- [缓存：Redis字符串类型内部编码剖析](https://mp.weixin.qq.com/s/tL2HVoeEH9hnalb9-tuoXg)\\n- [缓存：Redis哈希结构内存模型剖析](https://mp.weixin.qq.com/s/TdPcIMnv4iKIx3dRjei95A)\\n- [缓存：15张图解：为什么Redis这么快](https://mp.weixin.qq.com/s/0R0Evh1QX5BPOQt9233vpQ)\\n- [缓存：Redis面试全攻略、面试题大集合](https://mp.weixin.qq.com/s/6NobACeeKCcUy98Ikanryg)\\n- [缓存：把Redis当作队列来用，真的合适吗？](https://mp.weixin.qq.com/s/aNdWL3xKtjOd_briXL6Bjg)\\n- [缓存：缓存和数据库一致性问题，看这个就够了](https://mp.weixin.qq.com/s/RDOKLnG7P1j5Ehu3EyrsCQ)\\n- [缓存：面试官爱问的Redis高频面试题大集合](https://mp.weixin.qq.com/s/lxMP4-Z3DzQg5fRqLs9XNA)\\n- [缓存：1分钟科普：什么是缓存穿透、缓存雪崩、缓存击穿？](https://mp.weixin.qq.com/s/m9trzqE3Zd0KHC1cA3PlZQ)\\n- [缓存：如何构建一个稳定的高性能Redis集群？](https://mp.weixin.qq.com/s/x1AobPWpMufNWqrBnc5sZg)\\n- [缓存：轻量级memcached缓存代理twemproxy初探实践](https://mp.weixin.qq.com/s/Fgg2bNhdOTRfHIzGX86X3Q)\\n- [缓存：先更新数据库还是先更新缓存](https://mp.weixin.qq.com/s/SPgtpfgv6bz2AfPa1CYYeQ)\\n- [MQ：消息队列RabbitMQ快速入门上手](https://mp.weixin.qq.com/s/WMriUm27CZkiSWEt1f4lig)\\n- [MQ：Kafka快速入门上手](https://mp.weixin.qq.com/s/bUNAD2fkGTD73jVLw8rDHg)\\n- [MQ：从面试角度一文学完Kafka](https://mp.weixin.qq.com/s/o-rqnOH4FHeHaz0VqoHnFg)\\n- [MQ：为什么Kafka用得这么多？](https://mp.weixin.qq.com/s/vC0YbMJxHqs0JfcdAxjhHg)\\n- [MQ：刨根问底之Kafka到底会不会丢消息](https://mp.weixin.qq.com/s/PDvG5vSuA_NCkJ3mMUua5w)\\n- [MQ：大厂面试必备之消息队列连环问](https://mp.weixin.qq.com/s/u6_WH-r1bRc4m7CUm21Tew)\\n- [MQ：后端岗面试必备之Dubbo九连问](https://mp.weixin.qq.com/s/wM0Vj_YMh7881NwK-AwKSw)\\n- [服务器：Nginx服务器开箱体验](https://mp.weixin.qq.com/s/mif0NmY1Ij6lapHppb6LFg)\\n- [服务器：从一份配置清单详解Nginx服务器配置](https://mp.weixin.qq.com/s/099PJZE89JVNnaF0kwePDQ)\\n- [服务器：为什么Nginx能轻松撑起几万并发](https://mp.weixin.qq.com/s/VR1jEhJVXCfja3Pmo_kKkw)\\n- [搜索引擎：CentOS7上搭建多节点Elasticsearch集群](https://mp.weixin.qq.com/s/pdQNDMQQnXpoVKIA8JpyQQ)\\n- [搜索引擎：一文上手Elasticsearch常用可视化管理工具](https://mp.weixin.qq.com/s/BE8LrpviJNXGV41bhzGFTw)\\n- [搜索引擎：从一份定义文件详解ELK中Logstash插件结构](https://mp.weixin.qq.com/s/d2maG61HB2_rU56DYD2A9w)\\n- [搜索引擎：Elasticsearch索引的映射配置详解](https://mp.weixin.qq.com/s/C8JTxdjeSCR22xeAiLHHGg)\\n- [其他中间件：ZooKeeper面试常见十二问](https://mp.weixin.qq.com/s/ir0uurwo95hB3g__vTceJQ)\\n- [其他中间件：基于代理的数据库分库分表框架Mycat实践](https://mp.weixin.qq.com/s/3L5PcA0dGlrqJ2FjM_C77Q)\\n- 内容持续更新中...\\n\\n<!-- div:left-panel -->\\n\\n\\n<!-- panels:end -->\\n\\n---\\n\\n---\\n\\n# **书籍/资料推荐**\\n\\n---\\n\\n<p align=\\\"left\\\">\\n    <a href=\\\"https://mp.weixin.qq.com/s/ePhaYezFblgt0NgbvtWqww\\\" target=\\\"_blank\\\">\\n        <img src=\\\"https://cdn.jsdelivr.net/gh/justacoder99/r2coding@master/img/bookref.32p5e3kiqri0.jpg\\\" width=\\\"\\\"/>\\n    </a>\\n</p>\\n\\n\\n---\\n\\n毫无疑问的是，对于上文提到的 **「编程基础」** 部分，有大量经典的书籍值得阅读，每一本都是大师们若干年经验的汇聚，所以学好编程基础，对于我们普通人来说，看书是一个非常直接有效的方式。\\n\\n很多经典书看一遍可能远远不够，正所谓 **「初看懵、再看迷、三看发现有点小意思」** 讲的就是这个道理，这事急不得，而且有些东西的确需要一个反反复复的过程，有些甚至是在工作后的实践中才会遇到，所以珍惜每一次回炉重造的过程吧。\\n\\n---\\n\\n书籍资料推荐：\\n\\n- [Java开发：我的Java后端开发小书架](https://mp.weixin.qq.com/s/voNG467kSVfR-yjwelQhow)\\n- [Java开发：一份Java程序员的珍藏书单](https://mp.weixin.qq.com/s/OislKcvk-YSFstIl2PcrbA)\\n- [C/C++开发：自学C/C++书籍整理](https://www.bilibili.com/video/BV1ob411m76i)\\n- [前端开发：前端开发学习资料+书籍盘点](https://mp.weixin.qq.com/s/JFmj5cMhpJ2BKFq2p4IQGw)\\n- [嵌入式开发：嵌入式开发学习资料+书籍推荐](https://mp.weixin.qq.com/s/nkBsUgbuMK3ArHfFc2417w)\\n- [视频：我的计算机编程书单](https://www.bilibili.com/video/BV1kJ411W7pi)\\n\\n互联网开源教程推荐：\\n\\n- [羊哥当时自学数据结构和算法的9大工具](https://mp.weixin.qq.com/s/f9dfQQbpKjMopH6m2Gjiiw)\\n- [拜访了这位小哥的GitHub后，我失眠了](https://mp.weixin.qq.com/s/-Xp84QH5zQvvHaGWTJF9MA)\\n- [GitHub上这份计算机自学指南火了~](https://mp.weixin.qq.com/s/C48HcLYlLbYx1O82U0mpyg)\\n- [GitHub 40000星！收下这份宇宙最强「程序员生存指南」](https://mp.weixin.qq.com/s/V_Dfs44C3wtzlMGdUgY7qg)\\n\\n\\n**编程资源汇总和下载** → [点击查看](#资源下载)\\n\\n编程视频教程推荐 →  [点击查看](#视频教程)\\n\\n---\\n\\n# **项目经验获得**\\n\\n## 自学党如何获得项目经验？\\n\\n[---> 点击查看](https://www.bilibili.com/video/BV1Ai4y1V7PX)\\n\\n<!-- panels:start -->\\n\\n<!-- div:left-panel -->\\n\\n## 个人博客/网站搭建\\n\\n- [手把手教你从0开始搭建自己的个人博客之：Hexo版](https://www.bilibili.com/video/BV1Yb411a7ty)\\n- [手把手教你从0开始搭建自己的个人博客之：Hugo版](https://www.bilibili.com/video/BV1q4411i7gL)\\n- [手把手教你从0开始搭建自己的个人博客之：Wordpress+Docker版](https://www.bilibili.com/video/BV12E41127Uj)\\n- [建站神器：Hexo+Kaze+Gitee！](https://mp.weixin.qq.com/s/DrEc8FqycC15hp2X010wxQ)\\n- [Win10下Hexo博客搭建教程及阿里云服务器部署实战](https://mp.weixin.qq.com/s/JTTUYJTvtdT6X2fvLUBFZg)\\n\\n## 开源项目\\n\\n- [开源协议：开源软件的许可协议，先了解一下](https://mp.weixin.qq.com/s/ojGRSWSaJutAsBC0i5_6jA)\\n- [Java开源项目：看完这篇，别人的Java开源项目结构应该能看懂](https://mp.weixin.qq.com/s/5Ar5B9Ah2BdO8i9YjMQ7Qg)\\n- [Java开源项目：Java领域学习和练手的开源项目分享：第一弹](https://mp.weixin.qq.com/s/PmxVlkI9LUmnqqSk0Frqeg)\\n- [Java开源项目：Java领域学习和练手的开源项目分享：第二弹](https://mp.weixin.qq.com/s/y59hmDbQj1QglVj90viZqw)\\n- [Java开源项目：Java领域学习和练手的开源项目分享：第三弹](https://mp.weixin.qq.com/s/jjugnXIr3G0u7i9krbmmqg)\\n- [C/C++开源项目：几款适合初学者学习和练手的C/C++开源项目](https://mp.weixin.qq.com/s/bRNiqhZZXaoRwPEt8GIpLg)\\n- [C/C++开源项目：几款适合进阶学习和练手的C/C++开源项目](https://mp.weixin.qq.com/s/fNgOqKlITKa4yTbULO2Atw)\\n- [人工智能开源项目：AI领域几款标杆开源项目大巡礼](https://mp.weixin.qq.com/s/I9lr_SEg70OO_v-GOIUgjQ)\\n- [Python开源项目：几个炫酷的Python开源项目](https://mp.weixin.qq.com/s/Fu4OMojTJK0MrZohsLOx4w)\\n- [B站开源了哪些优秀的开源项目](https://mp.weixin.qq.com/s/Uq_Pf_mn6clC9XrgKclMDw)\\n- [读源码的7大心得总结](https://mp.weixin.qq.com/s/eWN7I8eHGE2exrdF3xziIA)\\n\\n<!-- div:right-panel -->\\n\\n## 实际项目需求和问题例析\\n\\n- [实践案例：实际项目业务接口的幂等性问题](https://mp.weixin.qq.com/s/gqvgysyGcP3yr0of_GwaTw)\\n- [实践案例：URL短链接服务如何设计](https://mp.weixin.qq.com/s/KPUuCU-q1SqnHzeyQeQzhw)\\n- [实践案例：亿行数据超大文件如何高效导入生产数据库](https://mp.weixin.qq.com/s/A-ZwcxlkB7Groe4k4Vq1Ew)\\n- [实践案例：订单系统一般怎么设计](https://mp.weixin.qq.com/s/-3g1ljoIrYWhhTHTF2RmLw)\\n- [实践案例：百亿级数据分表后如何分页查](https://mp.weixin.qq.com/s/EplL3kBx5vOXGDhDOP8NjQ)\\n- [实践案例：线上服务的YGC问题排查例析](https://mp.weixin.qq.com/s/-8xYoAkBUoavcSl69I0XJw)\\n- [实践案例：线上服务的FGC问题排查例析](https://mp.weixin.qq.com/s/Sjh9qFPKF250vLQGZig6nw)\\n- [实践案例：一个小团队的微服务架构改造之路](https://mp.weixin.qq.com/s/VjBiUmQNQPpSHeSVjK1C2A)\\n- [实践案例：一个遗留项目的SQL优化实战录](https://mp.weixin.qq.com/s/MA7FVeJDMg8WDJABiBWpBA)\\n- [实践案例：分布式锁使用不当导致的业务损失例析](https://mp.weixin.qq.com/s/OhkdQJ10biLOIezXc_vhkA)\\n- [实践案例：定时任务的几种简单方案](https://mp.weixin.qq.com/s/0p44f213fYdtr5LPJlrfLQ)\\n- [实践案例：项目常用的6种URL去重方案汇总](https://mp.weixin.qq.com/s/3zXdH2MALmWj57MWt0dImw)\\n- [实践案例：分布式系统架构的几个常见的坑](https://mp.weixin.qq.com/s/pg6lyAkgAaqSAZjiPgQTWA)\\n- [项目架构科普：企业里常用的软件架构剖析](https://mp.weixin.qq.com/s/NJFJ5UrzGk0cMGL1oZe0Bg)\\n- [项目架构科普：单体→分布式→微服务，这些年的软件架构是如何发育的](https://mp.weixin.qq.com/s/kfhCEDSUGwnNUbtGDL_rvQ)\\n- [项目架构科普：微服务架构的全局图景分析](https://mp.weixin.qq.com/s/Iy1dguNFkU73r1FxYIvlIQ)\\n- [原理解析：如何设计一个高并发的秒杀架构？](https://mp.weixin.qq.com/s/fLLd-ml-gdo3-700iJso_A)\\n- [原理解析：高并发系统设计的常见问题小结](https://mp.weixin.qq.com/s/ZzxmDbs08waUCtO7PeUhqw)\\n- [原理解析：亿级流量网关设计思路](https://mp.weixin.qq.com/s/J0aSVry1-Ss1OTA-jQAX3w)\\n- [原理解析：实际网站用户密码是如何存储的](https://mp.weixin.qq.com/s/Fd3cUDrqr0CsCl7FvZgd7Q)\\n- [原理解析：死磕搜索引擎背后的故事](https://mp.weixin.qq.com/s/Q1rZYvgklC_mBqfmIEC0Dw)\\n- [原理解析：用微信扫码登录的背后发生了什么](https://mp.weixin.qq.com/s/1lG-aAyVycO4zTbOqdy6BA)\\n- [原理解析：扫码付款背后的原理解析](https://mp.weixin.qq.com/s/RjVLsAhiMIYzsMhXJiReNg)\\n- [原理解析：收款码背后的原理剖析](https://mp.weixin.qq.com/s/1b9jBfwM9_RLkMPquqAuMw)\\n- [原理解析：支付掉单背后的几个问题](https://mp.weixin.qq.com/s/Kske9ahRcIUM5XEs2ZIN3A)\\n- [原理解析：手机没网却能支付成功的背后原理](https://mp.weixin.qq.com/s/VROp_0M3mz5Zhhnz0ZSmKQ)\\n- [原理解析：高并发场景下，先更新缓存还是先更新数据库？](https://mp.weixin.qq.com/s/1FDb63R_OMbSJo9VOWSr3Q)\\n- [原理解析：如何保证缓存和数据库的一致性问题？](https://mp.weixin.qq.com/s/RDOKLnG7P1j5Ehu3EyrsCQ)\\n- [原理解析：什么是分布式事务？](https://mp.weixin.qq.com/s/_56jq_p_nDUiBwaI2MTlmA)\\n- [原理解析：Redis分布式锁实践分析](https://mp.weixin.qq.com/s/RViDM1WHE61SDLNKzUmTAg)\\n- [原理解析：高并发下如何保证接口的幂等性？](https://mp.weixin.qq.com/s/QgliAGeUAISQVR4VNWqdgA)\\n- [原理解析：如何实现丝滑的数据库扩容](https://mp.weixin.qq.com/s/1VCC3i6ZCk7sb9kVRZ1czQ)\\n- [原理解析：如何构建一个稳定的高性能Redis集群？](https://mp.weixin.qq.com/s/x1AobPWpMufNWqrBnc5sZg)\\n- 内容持续更新中...\\n\\n\\n<!-- panels:end -->\\n\\n---\\n\\n# **面试准备和求职**\\n\\n---\\n\\n该板块会持续更新各技术方向的求职面试题集合、面经、以及一些小伙伴的求职心得与经历感悟。\\n\\n## 简历相关\\n\\n- [资源下载 → 简历模板下载（word版）](https://mp.weixin.qq.com/s/-qlU2-a-vvXWOHXzKHRm6A)\\n- [程序员写简历时必须注意的技术词汇拼写](https://mp.weixin.qq.com/s/q5gPSIiJqVvbI6Xa4dMXwA)\\n- [国内程序员最容易发音错误的单词集合](https://mp.weixin.qq.com/s/VJsp5SzGuOCGl-mWdbtCxQ)\\n\\n## 工作岗位科普\\n\\n- [科普：学C++的以后能从事哪些岗位](https://mp.weixin.qq.com/s/LEWBkJ5wkAIIcuv98g1Yhg)\\n- [科普：物联网行业的岗位、技能](https://mp.weixin.qq.com/s/AtSMfjq0GXQdVxo2o6s3-g)\\n- [科普：学Linux的以后能做什么](https://mp.weixin.qq.com/s/EA_iYwpSIMQGgpCrvvVOzA)\\n- 持续更新中 ...\\n\\n## 面试题集合\\n\\n<!-- panels:start -->\\n\\n<!-- div:left-panel -->\\n\\n- [C/C++：C语言/C++基础面试知识大集合](https://mp.weixin.qq.com/s/7mx58Idw1pL0MjPIFBUB1Q)\\n- [C/C++：68道C语言/C++常见面试题集合](https://mp.weixin.qq.com/s/BRQ-3uvstdZPO-cnLGCVzA)\\n- [Java：Java面试题硬核全梳理 ~](https://mp.weixin.qq.com/s/p1zxnGVeTDJiyjgowRIoBA)\\n- [Java：10道精选Java基础面试题集合](https://mp.weixin.qq.com/s/oBDrFnuk1lbfuNHkrhAC5w)\\n- [Java：Java基础知识面试题大集合](https://mp.weixin.qq.com/s/f-qIQGbzwHcW5Ur51rCqgg)\\n- [Java：Java集合硬核面试50问（附答案）](https://mp.weixin.qq.com/s/si_V6J_6ZZn4Akc12mMk2g)\\n- [Java：面试必问的JVM GC机制精讲](https://mp.weixin.qq.com/s/bHkgpznnqixDNyDKwdAbOg)\\n- [Java：JVM虚拟机面试题大集合](https://mp.weixin.qq.com/s/T2DqgJ9-0QiRZQYUeR3c8w)\\n- [Java：JVM垃圾回收硬核18问](https://mp.weixin.qq.com/s/XsZUF2nBUSEJoGIA8RimJw)\\n- [Java：面试官常问的一些JVM面试题](https://mp.weixin.qq.com/s/ZYoeC8yyfReEJDFSqiW8hw)\\n- [Java：Java并发和多线程基础面试题大集合](https://mp.weixin.qq.com/s/pIVf97W4DuAPNxq6zgRvsQ)\\n- [Java：面试常问的ThreadLocal源码剖析](https://mp.weixin.qq.com/s/ND-nUCGvXTHkEClKqN1qrQ)\\n- [Java：面试常问的线程池例析](https://mp.weixin.qq.com/s/TF04dB-i0q0-dOTqlprmYA)\\n- [Java：面试常问的volatile剖析](https://mp.weixin.qq.com/s/kQ498ifh4OUEDd829JIhnQ)\\n- [Java：面试必问的ConcurrentHashMap精讲](https://mp.weixin.qq.com/s/cnpfLL4TeL2oyEcHia6Bmg)\\n- [Java：说说什么是Java内存模型](https://mp.weixin.qq.com/s/lEgHPertXyguZIkv61LlKQ)\\n- [Java：浮点数精度问题面试例析](https://mp.weixin.qq.com/s/VXRRMabz_fvwnZeLWT-ybg)\\n- [计网：2w+字的计算机网络常见面试题整理](https://mp.weixin.qq.com/s/C82YpO0gwC8LHcJSHbR81A)\\n- [计网：面试最爱问的三次握手和四次挥手问题](https://mp.weixin.qq.com/s/lFnyBaaP3f0eNcKGW5RtCg)\\n- [计网：计算机网络高频12问](https://mp.weixin.qq.com/s/PIGfhMaAx9R5C4x5eJQnIw)\\n- [计网：GET和POST到底有什么区别](https://mp.weixin.qq.com/s/H4gbg7bfnw61jZQcapTnMw)\\n- [计网：TCP/UDP 部分高频面试题大集合](https://mp.weixin.qq.com/s/doxVJZ1G6187B4AOXb0JlA)\\n- [计网：HTTP常见面试题集合](https://mp.weixin.qq.com/s/FJGKObVnU61ve_ioejLrtw)\\n- [计网：浏览器输入网址并回车，后面到底发生了什么](https://mp.weixin.qq.com/s/t2Csrl7idUXISKW54cpV1g)\\n- [计网：都说HTTP协议是无状态的，这里的「状态」到底指什么？](https://mp.weixin.qq.com/s/EZwOUGMrGKEF_POisJKmuw)\\n- [操作系统：操作系统面试题集合](https://mp.weixin.qq.com/s/lR_A3jbfRiRjchz_lyyKxw)\\n- [操作系统：内存管理部分8个常见面试题汇总](https://mp.weixin.qq.com/s/5f3ku77xSO8UlaOsTkOnHQ)\\n- [操作系统：操作系统面试题大分享](https://mp.weixin.qq.com/s/oTEMOQY1xcG8uVceW-kLDA)\\n- [操作系统：面试常问的20个Linux命令](https://mp.weixin.qq.com/s/3NI4FWuOfYMJBiKqqnpqMA)\\n- [应用框架：Spring夺命连环10连问](https://mp.weixin.qq.com/s/euzbHPpQG2BSKl93N5L1Hg)\\n- [应用框架：Spring 经典面试题大集合](https://mp.weixin.qq.com/s/q4CajkpSUC8TCgv55VK5aQ)\\n- [应用框架：Spring Boot基础面试题大集合](https://mp.weixin.qq.com/s/cLh9xCDkVG0KV-uaX8PkNw)\\n- [应用框架：Spring Cloud基础面试题大集合](https://mp.weixin.qq.com/s/g0br3PfTmm8C_nkKbzE_ig)\\n\\n<!-- div:right-panel -->\\n\\n- [数据库：MySQL面试硬核25问（附答案）](https://mp.weixin.qq.com/s/vdOOVQtZhrJXsvRUjq0HqQ)\\n- [数据库：先更新数据库还是先更新缓存？](https://mp.weixin.qq.com/s/SPgtpfgv6bz2AfPa1CYYeQ)\\n- [数据库：如何保证缓存和数据库的一致性问题？](https://mp.weixin.qq.com/s/RDOKLnG7P1j5Ehu3EyrsCQ)\\n- [数据库：面试官最爱的MySQL连环问](https://mp.weixin.qq.com/s/8ddEzG-NzzFD35ehvbER7A)\\n- [数据库：如何实现丝滑的数据库扩容](https://mp.weixin.qq.com/s/1VCC3i6ZCk7sb9kVRZ1czQ)\\n- [数据库：数据库索引到底是什么](https://mp.weixin.qq.com/s/WMuxdG3ymNMWWDk1XhLwZQ)\\n- [数据库：为什么MySQL索引要用B+ tree](https://mp.weixin.qq.com/s/d7Zfat2fP6IX5DMKKtEIjQ)\\n- [数据库：为什么用了索引，SQL查询还是慢](https://mp.weixin.qq.com/s/-mOOchaXx_pKI6qWhohEnA)\\n- [数据库：慢SQL背后的原理是什么](https://mp.weixin.qq.com/s/iBnav_WPrX5vjR-NbdNeQg)\\n- [数据库：30道保底的MySQL数据库面试题汇总](https://mp.weixin.qq.com/s/aBboeqEphejICklAKLqS2Q)\\n- [数据库：用心整理的9道MySQL面试题](https://mp.weixin.qq.com/s/JQCtqM6aep3jtgiRL_9J5g)\\n- [中间件：面试官爱问的Redis高频面试题集合](https://mp.weixin.qq.com/s/lxMP4-Z3DzQg5fRqLs9XNA)\\n- [中间件：Redis面试全攻略、面试题大集合](https://mp.weixin.qq.com/s/6NobACeeKCcUy98Ikanryg)\\n- [中间件：什么是缓存穿透、缓存雪崩、缓存击穿？](https://mp.weixin.qq.com/s/m9trzqE3Zd0KHC1cA3PlZQ)\\n- [中间件：说说为什么Redis能这么快？](https://mp.weixin.qq.com/s/0R0Evh1QX5BPOQt9233vpQ)\\n- [中间件：如何构建一个稳定的高性能Redis集群？](https://mp.weixin.qq.com/s/x1AobPWpMufNWqrBnc5sZg)\\n- [中间件：把Redis当作队列来用，真的合适吗？](https://mp.weixin.qq.com/s/aNdWL3xKtjOd_briXL6Bjg)\\n- [中间件：Redis分布式锁的详细分析](https://mp.weixin.qq.com/s/RViDM1WHE61SDLNKzUmTAg)\\n- [中间件：ZooKeeper面试十二连问](https://mp.weixin.qq.com/s/ir0uurwo95hB3g__vTceJQ)\\n- [中间件：消息队列面试连环问总结](https://mp.weixin.qq.com/s/xpSel2nsLkf3yck5edNMJQ)\\n- [中间件：Kafka面试要点梳理](https://mp.weixin.qq.com/s/o-rqnOH4FHeHaz0VqoHnFg)\\n- [中间件：说说你对RPC技术是怎么理解的？](https://mp.weixin.qq.com/s/iTnKumgre3SzrBuWf8KB6g)\\n- [中间件：后端岗面试必备之Dubbo九连问](https://mp.weixin.qq.com/s/wM0Vj_YMh7881NwK-AwKSw)\\n- [中间件：为什么Nginx能轻松撑起几万并发？](https://mp.weixin.qq.com/s/VR1jEhJVXCfja3Pmo_kKkw)\\n- [系统架构：企业里常用的软件架构科普](https://mp.weixin.qq.com/s/NJFJ5UrzGk0cMGL1oZe0Bg)\\n- [系统架构：单体→分布式→微服务，这些年的软件架构是怎么发展的](https://mp.weixin.qq.com/s/kfhCEDSUGwnNUbtGDL_rvQ)\\n- [系统架构：如何设计一个高并发的秒杀架构？](https://mp.weixin.qq.com/s/fLLd-ml-gdo3-700iJso_A)\\n- [系统架构：分布式架构的几个常见的坑](https://mp.weixin.qq.com/s/pg6lyAkgAaqSAZjiPgQTWA)\\n- [系统架构：说说分布式架构负载均衡的几种方式](https://mp.weixin.qq.com/s/8CvoGCtGDvMHR91Lx89pxQ)\\n- [系统架构：说说什么是分布式事务？](https://mp.weixin.qq.com/s/_56jq_p_nDUiBwaI2MTlmA)\\n- [系统架构：亿级流量网关的设计思路](https://mp.weixin.qq.com/s/J0aSVry1-Ss1OTA-jQAX3w)\\n- [设计模式：说说Spring用到了哪些设计模式？](https://mp.weixin.qq.com/s/ZcKqGT2Sn4wVScExSF9Alg)\\n\\n<!-- panels:end -->\\n\\n## 求职经历分享\\n\\n- [小伙伴经历分享：Linux后台开发该如何准备](https://mp.weixin.qq.com/s/joFBDntI9PmyVRiKPHwpRg)\\n- [二本无实习上岸滴滴京东58复盘(一)](https://mp.weixin.qq.com/s/V0nRwXQlkNBnBneERZQURQ)\\n- [二本无实习上岸滴滴京东58复盘(二)](https://mp.weixin.qq.com/s/BnbBQGL-S2sGdRtNh7DN1A)\\n- [小伙伴面经分享(一)：深信服(含答案)](https://mp.weixin.qq.com/s/3YfKHo2lW-NC1tEA_u-mlQ)\\n- [小伙伴面经分享(二)：京东(含答案)](https://mp.weixin.qq.com/s/sc-7rc6obYZNFcc1mjNPAg)\\n- [一位程序媛的秋招软件开发岗面试经历](https://mp.weixin.qq.com/s/jAPYcMULqQl6AE_Vv7BZhQ)\\n- [写简历→面试→谈薪：一绿向北](https://mp.weixin.qq.com/s/0RoFVAezxW8cl3bjlAHbQg)\\n- [小红书后台开发岗面试经历复盘~](https://mp.weixin.qq.com/s/4L3J45Wj81yjoZIQ3ZVSog)\\n- [国企和银行：面试都问些啥？如何准备？](https://mp.weixin.qq.com/s/34SdkDyMvpVmoCFEB4UF-g)\\n- [招银网络（银行科技岗）面试都问了些啥？](https://mp.weixin.qq.com/s/4hP8s7TzsOv_tdQtOdCdig)\\n- [准备提前批？还是去实习？还是准备秋招？](https://mp.weixin.qq.com/s/jy0g3ohLzbtD-6JeCeMVvw)\\n- [7面Google，面经分享](https://mp.weixin.qq.com/s/9Fb8w2XwkXQpj8agBtdmFg)\\n- [化学专业大二转码的抉择之路](https://mp.weixin.qq.com/s/j6poLkiomb80jTE7EaFVJA)\\n- [拿到腾讯实习Offer的经历分享](https://mp.weixin.qq.com/s/-27fvvzBpmwwuAFANRoeIA)\\n- [怎么准备国企和银行？](https://mp.weixin.qq.com/s/YP4qafQ8gPbB7W0CkfACug)\\n- [去银行当程序员是一种什么体验](https://mp.weixin.qq.com/s/u_jIpGfmH4BHYS7hIlQk9w)\\n\\n\\n## 城市/公司选择\\n\\n- [一二线城市知名IT互联网公司总名单](https://mp.weixin.qq.com/s/VFocc914mGTrDzodI-MF1A)\\n- [常见互联网公司职级和薪资一览](https://mp.weixin.qq.com/s/5gtu7B05EKbPDXvhha5uNQ)\\n- [常见互联网公司时薪排行榜](https://mp.weixin.qq.com/s/wvdzBTcLLaeEtCqZI6T_Qg)\\n\\n---\\n\\n- [北京有哪些知名的IT/互联网公司？](https://mp.weixin.qq.com/s/f8J0pW8Sdj9_PKO2kV3mqw)\\n- [成都有哪些知名的IT/互联网公司？](https://mp.weixin.qq.com/s/UDWHt3QwsZBfZ25-pddwhQ)\\n- [武汉有哪些知名的IT/互联网公司？](https://mp.weixin.qq.com/s/bjHmAtPrSKQCDjfr9Mu0_Q)\\n- [南京有哪些知名的IT/互联网公司？](https://mp.weixin.qq.com/s/kskE2wJx_QtT6vCgsrUgIA)\\n- [合肥有哪些知名的IT/互联网公司？](https://mp.weixin.qq.com/s/tBNWFJbkjkV0bEPh4t9VQg)\\n- [深圳有哪些知名的IT/互联网公司？](https://mp.weixin.qq.com/s/dtJBi4QXXTrGkKTPM0y7VA)\\n- [成都有哪些知名的IT/互联网公司？](https://mp.weixin.qq.com/s/t4L45znsZRmWQ7MIQQtvhg)\\n- [西安有哪些知名的IT/互联网公司？](https://mp.weixin.qq.com/s/eD3tjUC4qASHH0WSWhz57Q)\\n- [长沙有哪些知名的IT/互联网公司？](https://mp.weixin.qq.com/s/UQHJ-iZDvQb3RLwQsELbUQ)\\n- [武汉有哪些知名的IT/互联网公司？](https://mp.weixin.qq.com/s/6dh1jbmuDqnHBoM7beTQbg)\\n- [天津有哪些知名的IT/互联网公司？](https://mp.weixin.qq.com/s/Ks9XLLUh099wSHWG0OBf1g)\\n- [郑州有哪些知名的IT/互联网公司？](https://mp.weixin.qq.com/s/8-uZUrG8_ziR5tKl1K8YNw)\\n- [杭州有哪些知名的IT/互联网公司？](https://mp.weixin.qq.com/s/Bwu0MDQhZiaY0vj3HsEsLg)\\n- [广州有哪些知名的IT/互联网公司？](https://mp.weixin.qq.com/s/s5UhdFyj9-8bqwQyZUMvVA)\\n- [青岛有哪些知名的IT/互联网公司？](https://mp.weixin.qq.com/s/Miu3eC6hqJlK8fi8Qr-DtQ)\\n- [上海有哪些知名的IT/互联网公司？](https://mp.weixin.qq.com/s/zYI8qW3Zfu2ySeO-PDqwZA)\\n- [大连有哪些知名的IT/互联网公司？](https://mp.weixin.qq.com/s/12inr2oRTULf7NhYOBGMYw)\\n- [苏州有哪些知名的IT/互联网公司？](https://mp.weixin.qq.com/s/529Zv24uToDW4xxEOFdiqw)\\n\\n## 其他求职相关问题\\n\\n- [为什么有些大公司技术却弱爆了？](https://mp.weixin.qq.com/s/QUJzl1ZG77DDnQNK0OAsHg)\\n- [嵌入式行业到底有没有搞头？](https://mp.weixin.qq.com/s/iV7DMApxhEw5YL-upIowVA)\\n- [找工作时，公司所说的「给期权」到底是什么东西？](https://mp.weixin.qq.com/s/9XMAvP_t0B1Ev57-ZC42yw)\\n- [入职一家公司，应该选择新业务还是老业务？](https://mp.weixin.qq.com/s/cu7mDeU2q2uEG8Q0CPzDEA)\\n- [采访了一位技术总监：聊了聊跳槽的心态问题](https://mp.weixin.qq.com/s/NGJc71cW2TKEONe6jhIUSg)\\n- [程序员从技术→管理，要走哪些路？](https://mp.weixin.qq.com/s/4_MB3L511h7qoXNxPRdOvQ)\\n\\n\\n---\\n\\n<a name=\\\"视频教程\\\"></a>\\n\\n# **视频教程推荐**\\n\\n---\\n\\n对于学习编程的小伙伴来说，网上有海量现成的宝贵视频学习资源可供食用。\\n\\n所以该板块会持续甄选和更新互联网上那些优秀的、值得反复观看的技术视频教程。\\n\\n---\\n\\n- [数据结构和算法：《郝斌 数据结构入门》](https://www.bilibili.com/video/BV11s41167h6)\\n- [数据结构和算法：《数据结构-浙江大学》](https://www.bilibili.com/video/BV1JW411i731)\\n- [数据结构和算法：《数据结构与算法基础（青岛大学-王卓）》](https://www.bilibili.com/video/BV1nJ411V7bd)\\n- [数据结构和算法：《尚硅谷 Java数据结构与算法）》](https://www.bilibili.com/video/BV1E4411H73v)\\n- [计算机网络：《计算机网络微课堂》](https://www.bilibili.com/video/BV1c4411d7jb)\\n- [计算机网络：《2019 王道考研 计算机网络》](https://www.bilibili.com/video/BV19E411D78Q)\\n- [计算机网络：《韩立刚 计算机网络》](https://www.bilibili.com/video/BV1gV411h7r7)\\n- [计算机网络：《计算机网络（谢希仁第七版）》](https://www.bilibili.com/video/BV1H3411y7q6)\\n- [操作系统：《2020 南京大学  操作系统：设计与实现 (蒋炎岩) 》](https://www.bilibili.com/video/BV1N741177F5)\\n- [操作系统：《操作系统（哈工大李治军老师）》](https://www.bilibili.com/video/BV1d4411v7u7)\\n- [计算机组成原理：《计算机组成原理（哈工大刘宏伟）》](https://www.bilibili.com/video/BV1t4411e7LH)\\n- [编译原理：《编译原理（哈工大）》](https://www.bilibili.com/video/BV1zW411t7YE)\\n- 更多的视频教程资源会持续更新，敬请期待…\\n\\n\\n---\\n\\n<a name=\\\"资源下载\\\"></a>\\n\\n# **资源汇总和下载**\\n\\n---\\n\\n该版块会持续更新那些优秀的编程资源，**包括但不限于：** 各种硬核的PDF笔记、软件包、技术手册、自制文档、题解解析、简历模板、面试题文档 等等。\\n\\n---\\n\\n## 编程学习资源大整理\\n\\n前段时间我花了大把力气，把自用的编程学习资源做了个大整理。\\n\\n都是纯肝货，目录如下，有需要的可以自取。\\n\\n![](https://cdn.jsdelivr.net/gh/justacoder99/r2coding@master/img/rescollection.2twl61h5k0s0.jpeg)\\n\\n- 下载链接：https://pan.baidu.com/s/1jEjcF96iVAXEXaadE1V6RQ\\n- 提取码：f23d\\n\\n## PDF干货笔记下载\\n\\n- [下载 → LeetCode算法刷题Golang版答案PDF文档](https://mp.weixin.qq.com/s/EaDLaLy3YjrNiSoNofwMMA)\\n- [下载 → LeetCode算法刷题C++版答案PDF文档](https://mp.weixin.qq.com/s/qR6KTfldk41lsOj1Ghp6Og)\\n- [下载 → LeetCode算法刷题Java版答案PDF文档](https://mp.weixin.qq.com/s/kWTJ9640mPegr5wqVE0GMg)\\n- [下载 → 谷歌学长的数据结构+算法题代码笔记手册](https://mp.weixin.qq.com/s/gXH98f1p5cCYVETCn9w9kA)\\n- [下载 → 再肝两夜，写了个「服务器项目部署」实战PDF手册](https://mp.weixin.qq.com/s/JUJ6qu_ec3s1JmTxQt_V3g)\\n- [下载 → 熬10天夜，肝出了这个PDF版「软件安装手册」](https://mp.weixin.qq.com/s/YNOZSQ5smo1uGE5ZttUZ_w)\\n- [下载 → 熬了7天夜，羊哥肝了个Linux速查备忘手册！](https://mp.weixin.qq.com/s/GJYVt376C_g4406ux5uw0Q)\\n- [下载 → Java后端开发学习路线+知识点梳理总结](https://mp.weixin.qq.com/s/x9E7ogAxFNpODXkAXCZZ3w)\\n- [下载 → 前端开发学习路线+知识点梳理总结](https://mp.weixin.qq.com/s/xUKlD-Ro4x55NfANAwxJUw)\\n- [下载 → 大数据开发学习路线+知识点梳理总结](https://mp.weixin.qq.com/s/vBCwU-BCsGVNpjJM__LheQ)\\n- [下载 → 嵌入式开发学习路线+知识点梳理总结](https://mp.weixin.qq.com/s/nkBsUgbuMK3ArHfFc2417w)\\n- [下载 → C/C++后台开发学习路线+知识点梳理总结](https://mp.weixin.qq.com/s/ac8vgjob8nDqM1Q7FGLRiA)\\n- [下载 → 找工作简历模板集(word格式) ](https://mp.weixin.qq.com/s/EKBRCNr_3n0y8CCSUNPdPg)\\n- [下载 → 程序员写简历时的技术词汇拼写规范PDF手册](https://mp.weixin.qq.com/s/q5gPSIiJqVvbI6Xa4dMXwA)\\n- [下载 → Java基础核心知识大总结PDF文档](https://mp.weixin.qq.com/s/jn7oraFlhRkOmiv3rh74WA)\\n- [下载 → C/C++常见面试题（含答案）PDF文档](https://mp.weixin.qq.com/s/BRQ-3uvstdZPO-cnLGCVzA)\\n- [下载 → 设计模式学习笔记PDF文档](https://mp.weixin.qq.com/s/miV4SH1Eb_FMogQ2XYvPuA)\\n- [下载 → Java多线程+并发编程知识点详细总结PDF](https://mp.weixin.qq.com/s/EGQAuvITVJT3fZUdQG84sw)\\n- [下载 → 阿里Java开发手册PDF全套](https://mp.weixin.qq.com/s/J-vlX5tIuXWdglXWewK0FQ)\\n\\n\\n## 其他资源下载\\n\\n- [下载 → 我的浏览器收藏夹大公开（附浏览器收藏夹书签下载）](https://mp.weixin.qq.com/s/XUHnLCbq7mDWhOc9imTVzg)\\n- [下载 → 豆瓣9.1分的Pro Git学习手册YYDS！](https://mp.weixin.qq.com/s/xDYSG4uDz9rgNCuk0RxLjg)\\n- [下载 → 《Linux命令行大全》.pdf手册](https://mp.weixin.qq.com/s/3rV556_0piRNsSpDYwuZ8g)\\n\\n---\\n\\n# **编码之外**\\n\\n---\\n\\n诚然，程序员应该重视代码，但眼里也不应该只有代码，很多代码之外的东西也很精彩。工作也是为了更好的生活，多看看身边的事，多关心身边的人，终究我们还是要回归到平凡的生活中\\n\\n**我们所热爱的，就是自己的生活！**\\n\\n---\\n\\n## 码农生活\\n\\n- [办公室划水？嘿嘿，这事我擅长...](https://mp.weixin.qq.com/s/zRU-n-5VOgrMqG09477RyQ)\\n- [戴着耳机敲代码，我都听些啥？](https://mp.weixin.qq.com/s/7_2ibVNVMZLEYl89zT7sGQ)\\n- [程序员猪队友行为大赏，你遇到过哪些？](https://mp.weixin.qq.com/s/1dJO8VJ6GaZykv33IUslkw)\\n- [写给程序员看的买房+考公务员攻略](https://mp.weixin.qq.com/s/f8KtgdRx6ATbR-4RY_I_aA)\\n- [毕业租房避坑攻略（含购物清单）](https://mp.weixin.qq.com/s/9fyrQPqfXx2bhbXjyYdnaw)\\n- [加班严重时该如何自我提升？](https://mp.weixin.qq.com/s/oCQWlUkQ7ezgtYdono3BzA)\\n- [在腾讯待了9年还离了职](https://mp.weixin.qq.com/s/SclEMeRJTqSVq-HsXaLNTQ)\\n- [聊一聊自学计算机的辛酸史](https://mp.weixin.qq.com/s/AFnB33Rs7ahbjiX1CqfccQ)\\n- [一个算法工程师的日常](https://mp.weixin.qq.com/s/-vBrii3kn5lNn0Bj4rzAdg)\\n- [测试岗与开发岗的那些爱恨情仇](https://mp.weixin.qq.com/s/3Vf49cYXfwp6znt_SJhgsg)\\n- [采访了一位技术总监：聊了聊跳槽的心态问题](https://mp.weixin.qq.com/s/NGJc71cW2TKEONe6jhIUSg)\\n- [这就是架构师一天的生活，还羡慕不？](https://mp.weixin.qq.com/s/rMqSG84kNtLJ5Oiwk-S7Qw)\\n- [程序员是如何玩浪漫的？](https://mp.weixin.qq.com/s/vI7EGqo7YbljRdZn2nUSMQ)\\n- [假如曹操是一名程序员，你猜怎么着？](https://mp.weixin.qq.com/s/AE8dGz9asZ1de2-kvCiZwQ)\\n- [周末无聊，我都逛哪些资讯类网站充电呢？](https://mp.weixin.qq.com/s/yE_fShdcgE1e1bnpHiLWyA)\\n- [亲历分享：一行代码，百万人民币打水漂](https://mp.weixin.qq.com/s/dj3Z8-kgpCzzc-bQQgg__g)\\n- [程序员从技术→管理，要走哪些路？](https://mp.weixin.qq.com/s/4_MB3L511h7qoXNxPRdOvQ)\\n- [IT领域的2/8法则，扎心了](https://mp.weixin.qq.com/s/wd9QkLsrygO8ADW6heJg8w)\\n- [周一划水必备：程序员专属GIF动图批发](https://mp.weixin.qq.com/s/Gy-Qs80rHKDJwapCmYGGEg)\\n- [521坦白帖：当年念书时是怎么写情书的？](https://mp.weixin.qq.com/s/9DxslnAKgBHG85iZ8m6yYQ)\\n- [一位半路转行计算机的女生](https://mp.weixin.qq.com/s/xfKoK3cQvcz-WGh50LiSBg)\\n- [程序员界的孔乙己](https://mp.weixin.qq.com/s/dW81quoXMRA2ObwTzIv74g)\\n- [我的大学四年收获及工作感悟](https://mp.weixin.qq.com/s/x9EEDlGNIOPOL3v_qZiiAQ)\\n- [离职后，华为的哪些东西是自己最留恋的？](https://mp.weixin.qq.com/s/g5nb-yti5bv9_OCRqIjFCQ)\\n- [华为最美小姐姐，被外派到墨西哥后...](https://mp.weixin.qq.com/s/Dk-9se1eFl44NdmWB_sFOQ)\\n- [我在南大的七年](https://mp.weixin.qq.com/s/HrSitzmxTxWw4atXQHCa_A)\\n- [垃圾领导把我的功劳全抢走了！](https://mp.weixin.qq.com/s/gknm-6k1zLY-1Cey12whSw)\\n- [用随机梯度下降法来优化自己的人生！！](https://mp.weixin.qq.com/s/Rc2_rR9rJ7tx_LO_q80zuQ)\\n- [美团大佬分享：写给工程师的几条精进建议](https://mp.weixin.qq.com/s/gJby-f46_hv5Wjk3Eu5iaw)\\n- [我，生物专业出身，自学转到了互联网](https://mp.weixin.qq.com/s/yhY1VfuCEB0DSWYtBzMKDA)\\n- [坦白贴：十一在家我都逛哪些技术网站？](https://mp.weixin.qq.com/s/jboZwMaxfs1mOdf5mxPbeA)\\n- [在国外当程序员是一种什么样的体验](https://mp.weixin.qq.com/s/Qd3zNLGDYbifACJn82p1PA)\\n- [很佩服的一个Google大佬，离职了](https://mp.weixin.qq.com/s/LdTDhE8sUjLZf0My1AXK2g)\\n- [雷军：我的程序人生路](https://mp.weixin.qq.com/s/wxpJKTbivM63izuyHsneUw)\\n\\n## 读研深造\\n\\n- [整整5年了！老羊斗胆聊一聊和自己导师的相处](https://mp.weixin.qq.com/s/6h8GIqCdqs0pkNuwR-M7Yg)\\n- [学弟跨考浙大计算机的掏心窝子分享！](https://mp.weixin.qq.com/s/cgtbhh7lrhsHXquFz7d1Ow)\\n- [既然硕士毕业也去搞开发，那我还读个喵的研？](https://mp.weixin.qq.com/s/_Kt9OmaBVDDj6S7rsdC-Aw)\\n- [一篇所有研究生都该读的好文：阳光温热，科研静好！](https://mp.weixin.qq.com/s/kbRlOB9hdU4j54VGF1s8oQ)\\n- [如何优雅地向老师表达我这周任务没啥进展？](https://mp.weixin.qq.com/s/gbIGNXIkOpw8tQ5aIoJMtw)\\n- [好不容易读个研，遇到放羊的导师怎么办？](https://mp.weixin.qq.com/s/OkxMe3Eaywx-KF9tBmjf-Q)\\n- [研究生/专升本都扩招，我们没有理由放弃](https://mp.weixin.qq.com/s/MvZFLDHItPR7InzrtYRL5w)\\n- [本科、硕士、博士，究竟有何区别？](https://mp.weixin.qq.com/s/Oa-1F1h6FmgodjG__2AZ_Q)\\n- [一位博士的自白：毕业时想大哭一场](https://mp.weixin.qq.com/s/h6o5XpA8-M97MWILhdrO5A)\\n- [一个农村博士的独白：全家为什么只有我读到了博士](https://mp.weixin.qq.com/s/EhWWnpLuhLM3_lX8Ja3qMQ)\\n- [考研上岸哈工大的经历分享](https://mp.weixin.qq.com/s/hDR4FKDA4Hkc_yvXgyvI8A)\\n\\n## 闲聊唠嗑\\n\\n- [深夜闲聊：还敢无脑梭哈计算机么？](https://mp.weixin.qq.com/s/AAMmLDeZSLPkKzzGrkHd9g)\\n- [那些学计算机的女生后来都怎么样了？](https://mp.weixin.qq.com/s/xweKJoGKG5NUssZioROQZw)\\n- [程序员缺乏经验的7种表现](https://mp.weixin.qq.com/s/UT1muuGblZ6hFvLViti6OQ)\\n- [程序员的酒后真言，都不容易](https://mp.weixin.qq.com/s/oKFHpaItmlB57gCE0sbzig)\\n- [自学技术时，看书还是看视频？](https://mp.weixin.qq.com/s/1AabNVmQTyhlEnaghoyGOg)\\n- [学校出身一般，该怎么办](https://mp.weixin.qq.com/s/7oOoThASit_ipIgyYzuMfA)\\n- [如何写出让同事无法维护的代码？](https://mp.weixin.qq.com/s/8zP5DX79-aEuFF17MYnHtg)\\n- [六成大学生认为自己毕业10年内会年入百万？](https://mp.weixin.qq.com/s/bj6LG7bq1Og8-fplcLjROA)\\n- [拼多多和电网offer，要你会选哪个？](https://mp.weixin.qq.com/s/bWcoi4oEIq6_F_NSkO7lOA)\\n- [C语言，50岁了！永远滴神！](https://mp.weixin.qq.com/s/Bhj0hj43jW7Ua78QENeC1g)\\n- [围观Linus大佬吐槽桌面版Linux](https://mp.weixin.qq.com/s/9GoTYs9IQZ3q9saz8p8VbQ)\\n\\n\\n## 读书写作\\n\\n- [羊哥今年的闲读书单！](https://mp.weixin.qq.com/s/rk0eOgioOj7yw3EjfTt5zQ)\\n- [大公开：我技术文章里的动图是怎么做的？](https://mp.weixin.qq.com/s/40nmWT6DtPqcqblQuwv9Tw)\\n- [坚持写博客三年了，分享几个私藏小工具](https://mp.weixin.qq.com/s/T-b7GfBoMGRuOqtp3T_HaA)\\n- [白瞟七牛云作为个人博客免费图床](https://mp.weixin.qq.com/s/UU4Ha5bym4VhEDAlMZwVFQ)\\n\\n---\\n\\n- [在线画图工具ProcessOn](https://www.processon.com/)\\n- [在线画图工具Draw.io](https://app.diagrams.net/)\\n- [在线思维导图工具MindLine](http://www.mindline.cn/webapp)\\n- [在线字数统计工具](https://www.eteste.com/)\\n- [mdnice markdown排版工具](https://mdnice.com/)\\n- [md2all markdown排版工具](http://md.aclickall.com/)\\n- [在线代码截图工具](https://carbon.now.sh/)\\n\\n\\n## 摸鱼时间\\n\\n咳咳。。。\\n\\n  - [0x00000001](https://www.bilibili.com/)\\n  - [0x00000002](https://mo.fish/)\\n  - [0x00000003](http://www.mazegenerator.net/)\\n  - [0x00000004](https://duomoyu.com/)\\n  - [0x00000005](http://slither.io/)\\n  - [0x00000006](https://www.anyknew.com/#/)\\n  - [0x00000007](http://gogoame.sumbioun.com/)\\n  - [0x00000008](https://flipanim.com/)\\n  - [0x00000009](https://zty.pe/)\\n  - [0x0000000a](https://aidn.jp/mikutap/)\\n  - [0x0000000b](http://zoomquilt.org/)\\n  - [0x0000000c](https://lab.bangbang93.com/wsyw)\\n  - [0x0000000d](https://lmbtfy.cn/)\\n  - [0x0000000e](https://suulnnka.github.io/BullshitGenerator/index.html)\\n  - [0x0000000f](https://zzkia.noddl.me/)\\n  - [0x00000010](https://www.dgtle.com/)\\n  - [0x00000011](https://sspai.com/)\\n\\n---\\n\\n# **联系作者**\\n\\n---\\n\\n## 关于作者\\n\\n- 普通开发者，热情的学习者，狂热的数码迷\\n- 90后，硕士毕业于华中科技大学电信专业，现从事IT类工作\\n- 目前在南京栖息，天天被业务折腾得死去活来的同时依然保有对各项技术热忱的追求\\n- 参加工作以后越来越理解交流与分享的重要性，我在不停地汲取大家宝贵经验的同时，也想回馈自己的所学所感给读者\\n- 本仓库是作者自学编程以来所用资源和分享内容的聚合，旨在为编程自学者提供一系列清晰的学习路线/靠谱的资源/高效的工具/务实的技术文章，方便自己也方便他人。网站内容会保持持续更新，欢迎收藏品鉴\\n\\n---\\n\\n## 心路历程\\n\\n- [2021-12-23：我的小网站被打挂了。](https://mp.weixin.qq.com/s/VtgMAMRoox97p6e8hyONng)\\n- [2021-12-01：最近状态一般，聊聊正在做的一件小事](https://mp.weixin.qq.com/s/-yC_t4onUsopuIQdiFNq3w)\\n- [2021-10-14：我坚持两年了！](https://mp.weixin.qq.com/s/GPVeZtMokBI_LwmcM5XEtA)\\n- [2021-09-12：羊哥今年的书单！](https://mp.weixin.qq.com/s/rk0eOgioOj7yw3EjfTt5zQ)\\n- [2021-08-29：读了7年通信最后还是转了码，羊哥你后悔吗？](https://mp.weixin.qq.com/s/gU5jhu9wcZHTgGuawpKE8g)\\n- [2021-08-05：羊哥竟然翻出了当年的大学成绩单。。](https://mp.weixin.qq.com/s/yhOep3tFNpJ5-4YkDigVxw)\\n- [2021-07-16：羊嫂偷偷抹了两个小时眼泪](https://mp.weixin.qq.com/s/OQ5dNnxFKXVt7rgRxxygyw)\\n- [2021-06-23：还敢无脑梭哈计算机么？](https://mp.weixin.qq.com/s/AAMmLDeZSLPkKzzGrkHd9g)\\n- [2021-06-17：羊家坝村首席高考志愿填报推荐官](https://mp.weixin.qq.com/s/oqopuK0mMP-FAxiDvPUeCg)\\n- [2021-06-13：羊哥接到了百万大V的邀请！起飞了~](https://mp.weixin.qq.com/s/8CxIPP2Amb3HXPY7hKUWGA)\\n- [2021-06-06：整整5年了！老羊斗胆聊一聊和自己导师的相处](https://mp.weixin.qq.com/s/6h8GIqCdqs0pkNuwR-M7Yg)\\n- [2021-05-27：拜访了这位小哥的GitHub后，羊哥失眠了](https://mp.weixin.qq.com/s/-Xp84QH5zQvvHaGWTJF9MA)\\n- [2021-05-21：521坦白帖：当年念书时是怎么写情书的？](https://mp.weixin.qq.com/s/9DxslnAKgBHG85iZ8m6yYQ)\\n- [2021-05-09：卧槽，人品爆了 ...](https://mp.weixin.qq.com/s/q-fHPCz9YQzVDC4wC9P4YA)\\n- [2021-05-05：生产队的驴都不敢这么过五一](https://mp.weixin.qq.com/s/sYPGrLBhojhqIkVAKXLZNg)\\n- [2021-04-24：日子浑浑噩噩地过，这可能是我最开心的一周了](https://mp.weixin.qq.com/s/EfYQgGxOYUb6mLs4EBuCCw)\\n- [2021-03-28：痴声痴色痴梦痴情几辈痴人](https://mp.weixin.qq.com/s/VqVFhueNtm9jN1GrW4Ebsg)\\n- [2021-03-21：我和羊嫂的3平米小书房](https://mp.weixin.qq.com/s/KTD15ZQ4xdTJXt-MVWa7zg)\\n- [2021-02-28：哎，我也想有一个这样的老婆啊](https://mp.weixin.qq.com/s/-Odh3JZNzJzGLGLiCf_uzw)\\n- [2021-01-14：熬夜多疯狂，体检报告就有多刺激！我怂了](https://mp.weixin.qq.com/s/B9iPfm4DVAwHR1e-wWNPOg)\\n- [2021-01-10：去芜湖、看房子、拿体检报告，魔幻的2021开端~](https://mp.weixin.qq.com/s/v1TiNA7XJeMp92u-YLLxjg)\\n- [2020-12-13：今天的南京，很冷很冷](https://mp.weixin.qq.com/s/lfm_y0WskLrQJc55JYdu2Q)\\n- [2020-10-22：和字节跳动面试官学长聊了聊人生~](https://mp.weixin.qq.com/s/WDatlUIMnADEASTzBTQZQw)\\n- [2020-10-15：愿那只在天堂的猫，能够被温柔相待](https://mp.weixin.qq.com/s/ukyCJTXeD9ZoSaNK-WV0Ig)\\n- [2020-10-06：老家被拆了，我的少年记忆也无处安放了](https://mp.weixin.qq.com/s/9hw1FTUGZANgcecCFUDovQ)\\n- [2020-09-06：没有什么事是一顿撸串解决不了的~](https://mp.weixin.qq.com/s/QHvFgYQLvTrwAsxdWe_eAQ)\\n- [2020-08-08：实不相瞒，我就是鹤岗的女婿~](https://mp.weixin.qq.com/s/kXjD-lIZpVjSroKkGHA7SQ)\\n- [2020-07-18：最近厚着脸皮联系了不少同学](https://mp.weixin.qq.com/s/FlnZuzmZ9eNK1ahkvC98CA)\\n- [2020-07-03：自学党/野生猿，项目经验上哪搞？](https://mp.weixin.qq.com/s/-mFZnE8-DNG6XVM-t589-Q)\\n- [2020-06-21：既然硕士毕业也去搞开发，那我还读个喵的研？](https://mp.weixin.qq.com/s/_Kt9OmaBVDDj6S7rsdC-Aw)\\n- [2020-06-14：我的毕业季，没有一点点仪式感](https://mp.weixin.qq.com/s/0iSzqJBj7YHkijGxbFUqCQ)\\n- [2020-05-08：最近状态不咋好...](https://mp.weixin.qq.com/s/C9HuUYis2zu6ThJAjXRqpA)\\n- [2020-05-01：二线城市的程序员活得好吗？](https://mp.weixin.qq.com/s/gOo8ztVLdXp3m_rvBozQpQ)\\n- [2020-04-21：自学编程的八大误区！克服它！](https://mp.weixin.qq.com/s/r_vm7lA2Ul_ZFhkx60wplg)\\n- [2020-04-08：我的本科回忆录：从迷茫自卑到保送华科](https://mp.weixin.qq.com/s/t9F6Z-DrybWLUxVrPTRPJw)\\n- [2020-03-15：到底要不要考研？](https://mp.weixin.qq.com/s/pwInIR-h1gkPXGuu4u1aWw)\\n- [2020-02-23：实不相瞒，在家远程办公15天，我有点自闭](https://mp.weixin.qq.com/s/gJBlu5gXL5vqYWG6ggisRw)\\n- [2020-02-16：昨夜，我梦回武汉 . . .](https://mp.weixin.qq.com/s/lfGqTBuyRSiA9NL-8Na-xg)\\n- [2020-02-02：转行的路，走起来其实有点累...](https://mp.weixin.qq.com/s/FPreCde-JHl2D6HZDGK7qg)\\n- [2020-01-23：来B站一年，我活成了人的模样！](https://mp.weixin.qq.com/s/-RWgqMi2iKFUQGWbgyyo3w)\\n- [2019-10-28：快30岁的我，终于赚到人生第一个10W！](https://mp.weixin.qq.com/s/i-EFuFb7yPpoOidme18EWA)\\n- [2019-09-08：华科研究生学长想对导师们说的话！](https://mp.weixin.qq.com/s/TO9-kBWKFs2sV1z0Hw3qWw)\\n\\n---\\n\\n## 微信联系\\n\\n<a name=\\\"微信\\\"></a>  <a name=\\\"公众号\\\"></a>\\n\\n<p align=\\\"left\\\">\\n    <a href=\\\"https://mp.weixin.qq.com/s/ePhaYezFblgt0NgbvtWqww\\\" target=\\\"_blank\\\">\\n        <img src=\\\"https://cdn.jsdelivr.net/gh/justacoder99/r2coding@master/img/qrcode_for_gh_1537917051d0_258.nd3fymuhyts.jpeg\\\" width=\\\"\\\"/>\\n    </a>\\n</p>\\n\\n\\n\\n---\\n\\n# 持续更新中...\\n\\n[本仓库内容会持续保持更新 → 欢迎收藏品鉴！](https://mp.weixin.qq.com/s/ePhaYezFblgt0NgbvtWqww)\",\"articleCover\":\"https://upload.haoxx.site/article/2ec42f646cb85e6554ab21b4e9bc6c19.jpg\",\"articleTitle\":\"C++参考资料\",\"articleType\":1,\"categoryName\":\"编程语言基础\",\"id\":80,\"isRecommend\":0,\"isTop\":0,\"status\":1,\"tagNameList\":[]}]','PUT','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',37,'2023-06-07 20:02:04');
INSERT INTO `t_operation_log` VALUES (1408,'文章模块','上传','/admin/article/upload','com.ican.controller.ArticleController.saveArticleImages','上传文章图片','image_71.jpg','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/article/ef2a97cea70aa44f3e7e7e4ac7c0a1ce.jpg\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',24,'2023-06-07 20:02:14');
INSERT INTO `t_operation_log` VALUES (1409,'文章模块','修改','/admin/article/update','com.ican.controller.ArticleController.updateArticle','修改文章','[{\"articleContent\":\"---\\ntitle: C/C++字符串处理函数大汇总\\ndate: 2023-04-01\\ncategory:\\n - 1编程语言基础\\n\\nfooter: <a href=\\\"https://beian.miit.gov.cn/#/Integrated/index\\\">渝ICP备2023001651号</a>\\n\\n---\\n\\n:::tip\\nC/C++字符串处理函数大汇总\\n:::\\n\\n<!-- more -->\\n\\n\\n\\n参考资料：[cnblogs](https://www.cnblogs.com/kongweisi/p/14676259.html)\\n1、strlen(str*)  计算字符串长度（不含\'\\\\0\'） sizeof是计算所占内存大小，包含‘\\\\0’ \\n\\n2、strcpy(目标字符串，源字符串）或strncpy(目的字符串，源字符串，长度) 不会复制\\\\0\\n注意：内存复制：，emcpy(目的地址，源地址，sizeof()长度) 恢复至\\\\0，注意目的地址要分配足够的空间，不然会段错误\\n\\n3、字符串追加函数strcat(目标字符串，源字符串) 或strncat(目的字符串。源字符串，长度)\\n\\n4、比较字符串strcmp(s1,s2)  strncmp(s1,s2,strlen()长度)\\n\\n5、字符串格式转换函数sprintf()  sscanf()\\nsprintf使用的较多，使用场景比如，1.获取时间戳，格式化时间格式；2.日志文件系统写入格式化；\\n\\n6、strstr字符串中查找指定字符串     **推荐使用cpp的string的find函数**\\n`char* strstr(源字符串s1，\\\"匹配字符串s2\\\")`。\\n\\n7、strchr字符串中查找指定字符      **推荐使用cpp的string的find函数**\\n`char* strchar(源字符串s1，\'字符c\')`。参数1是字符串，参数2是字符。查找该字符在字符串中最后一次出现的位置。换个思路向：或者，是从右侧开始找，寻找字符在字符串中最后一次出现的位置。这个函数可以用来处理路径字符串，来获取文件名。对于s1=\\\"a/b/c/d.jpg\\\"，字符c=\'/\'，对于函数`char* p=strchr(s1,\'/\')`,函数返回值p=“/d.jpg\\\"。一般使用时是p+1，即”d.jpg\\\"。\\n\\n8、字符串分割函数strtok()      **推荐使用cpp封装的split方法，其中要用到cpp的流和getline函数**\\n参考博客：[参考博客](http://c.biancheng.net/view/1345.html)\\n格式：strtok（目标字符串，“目标字符串中所包含的字符”）\\n\\n9、atoi()转整形/atof()转双精度/atol()转long整型\\n注意：①跳过前面的空格字符，直到遇到数字或正负号才开始做转换，而遇到非数字或字符串结束符(\'\\\\0\')才结束转换\\n\\n10、strpbrk\\n`char* strpbrk(s1,s2)`，s1中寻找第一次出现s2中任意字符是的字符串指针。比如，s1=\\\"Hi,Linux\\\" ,s2=\\\"Linux\\\"，那么函数返回字符串指针所指向的字符串内容为i,Linux\\n\\n11、strcasecmp\\n忽略大小写，比较字符串大小。第一个参数为s1，第二个参数为s2，s1小时返回负数。\\n\\n12、strspn\\n`char* strspn(字符串s1，字符串s2)`，strspn()返回的数值为n，则代表字符串s 开头连续有n 个字符都是属于字符串accept内的字符。\",\"articleCover\":\"https://upload.haoxx.site/article/ef2a97cea70aa44f3e7e7e4ac7c0a1ce.jpg\",\"articleTitle\":\"C/C++字符串处理函数大汇总\",\"articleType\":1,\"categoryName\":\"编程语言基础\",\"id\":78,\"isRecommend\":0,\"isTop\":0,\"status\":1,\"tagNameList\":[]}]','PUT','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',25,'2023-06-07 20:02:16');
INSERT INTO `t_operation_log` VALUES (1410,'文章模块','上传','/admin/article/upload','com.ican.controller.ArticleController.saveArticleImages','上传文章图片','image_79.jpg','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/article/015acc505d3ef69b0d459b85d2b4f990.jpg\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',16,'2023-06-07 20:02:35');
INSERT INTO `t_operation_log` VALUES (1411,'文章模块','修改','/admin/article/update','com.ican.controller.ArticleController.updateArticle','修改文章','[{\"articleContent\":\"---\\ntitle: C/C++学习思路\\ndate: 2022-10-30\\ncategory:\\n - 1编程语言基础\\n\\nfooter: <a href=\\\"https://beian.miit.gov.cn/#/Integrated/index\\\">渝ICP备2023001651号</a>\\n\\n---\\n\\n:::tip\\nC/C++学习思路\\n:::\\n\\n<!-- more -->\\n\\n\\n学完编程语言是基础，但仅仅掌握基础还不顾，离上手干活还有很大的鸿沟。鸿沟在于**编程基础四大件和应用实践编程**\\n\\n编程四大件：数据结构和算法、计算机网络、操作系统和设计模式\\n\\n应用编程实践：这部分会涉及到一些工具、编程环境、和具体编程实践，应该说这一部分学完，自己应该能做点东西出来、或者说能看懂一些实际项目的代码。包括但不限于：Linux操作系统的学习和使用（包含常用系统配置和shell脚本的使用）、编译/调试工具的使用、Linux环境编程（Linux系统编程、多线程编程和网络编程）\\n\\n-----------------------------------------\\n\\nC/cpp与Java的比较\\n\\nC/cpp与Java还是有很大的区别的。C是一种面向过程的更偏向于底层的编程语言，cpp是一种面向对象的编程语言。C和cpp，尤其是cpp，语言粒度细、机制多，性能虽然高，但语言本身的包袱也确实重，我们更愿意称它为“造轮子”的语言！也正因为C和cpp性能好，粒度细，所以什么都能做。而Java本身就是一种服务于互联网软件开发（后端开发+客户端开发）的语言，它是一个明显的“生态圈”的概念，所以应用领域非常清晰。更一般地来说，Java是纯应用层的，而C/cpp程序员既需要对底层知识有所了解，也需要知道应用层的知识。\\n\\n------------------------------------------\\n\\n岗位分析\\n\\n一般来说，C/cpp更适合做后台开发。包括：通信公司的后台开发、互联网公司的后台开发、游戏公司的后台开发。。。\\n\\n后台开发的职责细分，有：有做数据处理和分析的、有做基础协议和通信的、有做基础协议和通信的、甚至有做后台系统驱动和内核的。。。\\n\\n-------------------------------------------\\n\\n编程语言本身的学习\\n\\n**C语言**：\\n\\n+ 除了最基本的变量、条件、循环、字符串、数组、函数、结构体外\\n+ C语言最最最重要的就是<font color=\\\"red\\\">指针</font>和<font color=\\\"red\\\">内存管理</font>。以后在工作中多半靠这两个东西吃饭，而且也是检验C语言掌握情况的两大标准\\n\\n> **推荐书籍**：《C Primer Plus》、《C和指针》、《C专家编程》\\n\\n**cpp**：\\n\\n+ cpp和C语言确实是不同的语言，但是cpp确实是对C语言的延伸，可以理解为在C语言里加入了面向对象的特性。因为只有面向对象特性的加持，代码才能更好的**复用**、**扩展**和**工程化**，这是大型项目的必备要素\\n+ 除了C语言所有的底子之外，还需要学习cpp的面向对象（封装、继承与多态）特性、**泛型**、**模板**、**STL**等等\\n\\n> 推荐书籍（有先后顺序）：《cpp Primer》、《Effective cpp》、《cpp 标准程序库》、《STL源码剖析》《深度探索cpp对象模型》\\n\\n**最后一个小建议是**：语言部分的学习建议不要拖太久，一定要规划好时间，一鼓作气，高强度给它压下来，否则容易把自己拖泄气。\\n\\n-----------------------------------------\\n\\n编程基础“四大件”\\n\\n四大件是指：数据结构和算法、计算机网络、操作系统、设计模式\\n\\n1、数据结构和算法\\n\\n可以说这个直接决定了面试的成败！几种基础数据结构类型得烂熟于心，比如：<font color=\\\"red\\\">字符串、链表、二叉树、堆、栈、队列、哈希</font>等；基本的几大算法也要了如指掌，比如<font color=\\\"red\\\">查找、排序、动态规划、分治</font>等等。\\n\\n> 参考资料： 《大话数据结构》、《算法》、《剑指offer》《LeetCode刷题》 ，建议多在LeetCode上刷题\\n\\n2、计算机网络\\n\\n此处的计算机网络指的就是TCP/IP协议栈，可以说它是当下互联网通信的基石，无论如何一定要对TCP/IP的协议栈了如指掌，主要就是学习和掌握原理，包括：**ARP协议、IP协议、ICMP协议、TCP和UDP协议、DNS协议、HTTP协议、HTTPS协议**。\\n\\n> 推荐书籍： 《TCP/IP详解》\\n\\n3、操作系统\\n\\n该部分重点包括：进程和线程的相关原理（原子性、并发、锁）、内存相关原理（内存分布、内存调度）\\n\\n> 推荐书籍：《深入理解计算机系统》\\n\\n4、设计模式\\n\\n倒不需要23种设计模式全部记住，常见的几个如：**单例模式、工厂模式、代理模式、策略模式、模板方法模式**建议熟练于心。\\n\\n> 推荐书籍：《大话设计模式》、《设计模式之禅》\\n\\n------------------------------------------\\n\\n应用编程实践\\n\\n这部分会涉及到一些工具、编程环境、和具体编程实践，应该说这一部分学完，自己应该能做点东西出来、或者说能看懂一些实际项目的代码。\\n\\n1、Linux操作系统的使用\\n\\n包括：常见的Linux系统命令和基本的Shell编程\\n\\n> 推荐书籍：《鸟哥的私房菜》\\n\\n2、编译/调试工具\\n\\n我想大家最熟悉的一定是GCC了，与该命令配套的还有make/makefile脚本也必须掌握。作为make升级版的扩平台编译脚本Cmake和CmakeLists.txt也需要掌握。在gcc编译时，进场要指定头文件和库文件路径，这时常用的pkg-config命令就配上用场了。\\n\\n进阶一点的，除了GCC还有其他的编译工具，比如Clang。还有其他的跨平台的交叉编译工具链等等也需要学习。\\n\\n在程序调试中，GDB也需要掌握。\\n\\n3、Linux环境编程\\n\\n（1）Linux系统编程\\n\\n调用Linux系统的API来进行程序编写和功能实现。\\n\\n（2）多线程编写\\n\\n这一点与编程四大件之一的《操作系统》有很大的联系，进行多进程、多线程的程序编写，还有考虑进程间/线程间的通信：共享内存，还有考虑多进程间/多线程间的变量读写问题：互斥量、信号量、互斥锁、读写锁。一般在这部分，还会涉及到内存的开辟和释放问题。\\n\\n此处指的是多线程编程实践相关的东西，一般包括：线程、资源、信号、同步、互斥、锁等等一些具体的编程方法。\\n\\n（3）网络编程\\n\\n此处的网络编程主要指的是具体Linux系统上的网络编程 API和 IO函数的编程实践。一般是TCP和UDP相关的程序，涉及到点对点通信、广播通信、客户端-服务器-客户端通信等等。\",\"articleCover\":\"https://upload.haoxx.site/article/015acc505d3ef69b0d459b85d2b4f990.jpg\",\"articleTitle\":\"C/C++学习思路\",\"articleType\":1,\"categoryName\":\"编程语言基础\",\"id\":77,\"isRecommend\":0,\"isTop\":0,\"status\":1,\"tagNameList\":[]}]','PUT','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',17,'2023-06-07 20:02:36');
INSERT INTO `t_operation_log` VALUES (1412,'文章模块','上传','/admin/article/upload','com.ican.controller.ArticleController.saveArticleImages','上传文章图片','image_29.jpg','POST','{\"code\":200,\"data\":\"https://upload.haoxx.site/article/79db75241acafdd2e58deb66960c3e25.jpg\",\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',14,'2023-06-07 20:02:58');
INSERT INTO `t_operation_log` VALUES (1413,'文章模块','修改','/admin/article/update','com.ican.controller.ArticleController.updateArticle','修改文章','[{\"articleContent\":\"---\\ntitle: Python学习思路\\ndate: 2022-10-30\\ncategory:\\n - 1编程语言基础\\n\\nfooter: <a href=\\\"https://beian.miit.gov.cn/#/Integrated/index\\\">渝ICP备2023001651号</a>\\n\\n---\\n\\n:::tip\\nPython学习思路\\n:::\\n\\n<!-- more -->\\n\\n\\n## 第一部分 入门：字面量/注释/数据类型/标识符和运算符\\n\\n### 1、字面量\\n\\n字面量是指“代码中，被卸下来的固定的值，被称之为字面量”，常见的有数字（整数、浮点数、布尔）、字符串、列表、元组、集合和字典。\\n\\nPython中定义变量不需要写上变量类型名，直接用“变量名=值”的方式定义和初始化变量。布尔变量的取值只能是True和Flase。字符串可由任意数量的字符组成。\\n\\n列表List，是有序的可变序列。它是python中使用最频繁的数据类型，可有序记录一堆数据。\\n\\n元组Tuple，有序的不可变序列。可以有序记录一堆不可变的python数据集合。\\n\\n集合Set，无需不重复集合，可无序记录一堆不重复的python数据集合。\\n\\n字典Dictionary，无序的键值对，可无序记录一堆键值对的python数据集合。\\n\\n### 2、注释\\n\\n注释有单行：#  ;多行： \\\"\\\"\\\"\\n\\n### 3、print格式化打印\\n\\n基础：print(内容1，内容2，内容3，。。。)，示例：`print(\\\"变量a的结果是：\\\",a,\\\"\\\\n\\\")`\\n进阶版：使用%来进行格式化打印。\\n①整数输出\\n\\n```python\\n%o   ----   oct八进制\\n%d   ----   dec十进制\\n%x   ----   hex十六进制\\n示例：\\n>>> print(\'%o\' % 20)    ,输出 24\\n>>> print(\'%d\' % 20)    ,输出 20\\n>>> print(\'%x\' % 20)    ,输出 14\\n```\\n\\n②浮点数输出\\n\\n```python\\n%.nf   ----   保留小数点后n位小数\\n%.ne   ----   保留小数点后n为小数，以指数形式输出打印\\n%.ng   ----   保留n位有效数字\\n示例：（注意：计算有效位时，小数点也算一个）\\n>>> print(\'%f\' % 1.11)    ,输出 1.110000\\n>>> print(\'%.1f\' % 1.11)    ,输出 1.1\\n>>> print(\'%e\' % 1.11)    ,输出 1.110000e+00\\n>>> print(\'%e\' % 1.11)    ,输出 1.110000e+00\\n>>> print(\'%.1e\' % 1.11)    ,输出 1.1e+00\\n>>> print(\'%g\' % 221.1111)    ,输出 221.111  ，默认g是6位有效数字\\n>>> print(\'%.2g\' % 221.1111)    ,输出 2.2e+03 ，自动转换为科学计数法\\n```\\n\\n③整数输出\\n\\n```python\\n%0nd   ----   输出指定位数的十进制，如有效数字位数不够，前方补零\\n>>> print(\'%05n\' % 123)   ,输出00123\\n```\\n\\n④字符串输出\\n\\n```python\\n%ns   ----   右对齐，占位符10位\\n%-ns   ----  左对齐，占位符10位\\n%.ns   ----  左对齐，占位符10位\\n%n.ms   ---- n位占位符，截取m位字符串\\n示例：\\n>>> print(\'%s\' % \'hello world\')      ,输出 hello world\\n>>> print(\'%20s\' % \'hello world\')    ,输出           hello word (右对齐，字符串为10，所以前面要补10个空格)\\n>>> print(\'%-20s\' % \'hello world\')    ,输出 hello world         (左对齐，后面补10个空格)\\n>>> print(\'%.2s\' % \'hello world\')    ,输出 he\\n>>> print(\'%10.2s\' % \'hello world\')    ,输出         he (默认右对齐，总长度为10，取两个字符，所以前面有8个空格)\\n>>> print(\'%-10.2\' % \'hello world\')    ,输出 he        (左对齐，输出一个he加上8个空格)\\n```\\n\\n```python\\n# 用print打印字符串输出\\n方法1：\\nprint(\\\"the a is %d\\\" % a)\\n方法2：\\nprint(f\\\"the a is {a}\\\")\\n方法3：\\nprint(\\\"current path length: {}, It costs {} s\\\".format(pathLen, time.time() - start_time))\\n方法1的例子2：\\nprint(\\\"current path length: %f, It costs %f s\\\" % (pathLen, time.time() - start_time))\\n```\\n\\n### 4、数据类型与数据类型的转换\\n\\n使用print和type来获取变量的<font color=\'red\'>数据</font>类型。 `type(被查看类型的数据)`\\n注意，变量没有类型，有类型的是数据。\\n\\n数据类型转换： int()   str()    float()\\n\\n### 5、标识符\\n\\n了解并掌握常用的关键字（区分大小写）：False True  None ,其余关键字均为小写\\n\\n标识符：变量、函数的命名(只允许字母、数字和下划线，甚至包含中文做变量名)。但是中文做变量名支持不完善，不建议用。\\n\\n标识符命名规则：\\n\\n+ 内容限定\\n+ 大小写敏感\\n+ 不可使用关键字\\n\\n### 6、基本运算符、以及布尔类型与比较运算符\\n\\n常见的有：加减乘除，还有<font color=\'blue\'>取整除符号</font>： `//`，比如：`5//2==2`，还有<font color=\'blue\'>取余符号</font>，比如：`5%2==1`，还有<font color=\'blue\'>指数符号</font>，`5**2==25`。\\n\\n另外，上述符号还可以与等号相结合，构成符合运算符。\\n\\n比较运算符：\\n大于，小于，大于等于，小于等于，等于，不等于\\n\\n### 7、字符串的三种定义方式与字符串的拼接、格式化\\n\\n单引号、双引号、三引号。python中的字符串不区分单字符和字符串，所以单引号和双引号功能是一样的。三引号中的字符串可以跨行。\\n\\n使用+号对多个字符串进行拼接。\\n\\n方式①：使用三类常见的占位符与%相结合来进行字符串的格式化输出：\\n常见的占位符：\\n\\n+ 字符串  %s\\n+ 整数     %d\\n+ 浮点数  %f\\n\\n```python\\nname=\\\"测试姓名\\\"\\nyear_num=1999\\nstock_price=19.9\\nmessage=\\\"我是：%s,我成立于：%d，我今天的估价是：%f\\\" % (name,year_num,stock_price)\\nprint(message)\\n```\\n\\n方式②：格式化的精度控制\\n使用辅助符号m.n来进行精度控制：\\n\\n+ m，控制宽度，要求是数字（<font color=\'red\'>很少使用，设置的宽度小于数字自身，不生效</font>）\\n+ .n，控制小数点精度，要求是数字，<font color=\'red\'>会进行小数位的四舍五入</font>。\\n+ 一半在m前面没有任何东西，默认表示右对齐，当m大于数字的最大有效位时，在前面补空格。如果m前面有个`-`号，表示左对齐，当m大于数字的有效位数时，不需要在前面不空格，在数字的后面补空格。\\n  方式③：掌握快速进行字符串格式化的方式：\\n  通过语法：`f\\\"内容{变量}\\\"`的格式来进行快速格式化。例如：\\n\\n```python\\nname=\\\"测试姓名\\\"，stock=19.9,year=1999\\nprint(f\\\"我是：{name},我成立于：{year}，我今天的估价是：{stock}\\\")\\n```\\n\\n这样做的特点是：\\n\\n+ 这种写法不做精度控制\\n+ 也不理会类型\\n+ 适用于快速格式化字符串\\n\\n方式④：技巧：对表达式的格式化\\n上述三种方法，都是对变量进行格式化处理，那如果不需要使用变量存储，可不可以直接对表达式进行格式化处理呢？\\n\\n表达式：是一个具有明确执行结果的代码语句，比如：1+1, 2\\\\*4，他们就是表达式，因为他们有明确的结果，就是一个数值。又比如，常见的变量定义：`name=\\\"张三\\\"`也是一种表达式，因为他也有结果，就是把一个字符串常量付给了一个变量存储。\\n\\n下面。使用上述三种对变量的格式化方法，来处理表达式：\\n\\n```python\\nprint(\\\"1 * 1 的结果是： %d\\\" % (1*1))\\nprint(f\\\"1 * 1 的结果是：{1 * 1}\\\")\\nprint(\\\"字符串在python中的类型是…%s\\\" % type(\'字符串\'))\\n```\\n\\n### 8、数据的输入：input\\n\\n1、基础版：\\n\\n```python\\nname=input()\\nprint(\\\"your name is %s\\\" % name)\\n```\\n\\n2、进阶版\\n\\n```python\\nname=input(\\\"请输入你的名字：\\\")\\nprint(\\\"your name is %s\\\" % name)\\n```\\n\\n需要注意，input()接收并存入变量里的数据，均是字符串类型。就算你输入的是整数，也是转换成了字符串类型在存储的。用int()来得到整型值。10.16.63.184\\n\\n## 第二部分 代码结构：逻辑结构与函数\\n\\n### 9、if-else的条件语句、while/for循环语句、switch/case条件分支以及continue/break\\n\\n①if-elif-else代码块示例：\\n代码示例：\\n\\n```python\\nif 条件1：\\n\\t满足条件1后该做的动作\\nelif 条件2:\\n\\t满足条件2后该做的动作\\nelse:\\n\\t所有条件都不满足后的动作\\n```\\n\\nif-else的多层嵌套：秘诀：空格缩进，python根据缩进来判断代码块的归属和层次关系。\\n\\n②while代码块示例：\\n\\n```python\\nwhile 条件：\\n\\t满足条件后的动作\\n```\\n\\n③for循环代码块示例：\\n\\n```python\\nfor 临时变量 in 待处理的数据集\\n\\t临时变量满足条件时，执行的语句\\n#例如：\\nname=\\\"test\\\"\\nfor x in name\\n\\tprint(x)  # 输出t e s t\\n```\\n\\n上述待处理的数据集，严格来讲，称之为：<font color=\'red\'>可迭代类型</font>。可迭代类型是指，其内容可以一个个一次取出的一种类型，包括：\\n\\n+ 字符串\\n+ 列表     如：name_list=[\'Lisa\',\\\"Micheal\\\",\'LiHua\']\\n+ 元组\\n+ etc等等\\n\\n通过学习range语句，获得一个简单的数学序列（可迭代类型的一种）：\\n语法1：`range(num)`，获取一个从0开始，到num结束的数字序列（不含num本身）。如range(5)就是获得一个从0 ~ ~ 4的序列：[0,1,2,3,4]。\\n语法2：`range(num1,num2)`,获取一个从num1开始到num2结束的数字序列（包含num1但是不包含num2）。如range(1,5)就是输出序列[1,2,3,4]。\\n语法3：`range(num1,num2,step)`,获取一个从num1开始到num2结束，包含num1但是不包含num2的数字序列，并且步长为step。如range(1,8,2)就是输出序列：[1,3,5,7]。\\n\\n### 10、函数\\n\\n#### 10.1 函数基础\\n\\n注意：函数体内为局部变量，函数体外为全局变量。但是，可以在函数体内，使用关键字`global`来将函数内部的变量声明为全局变量，如：\\n\\n```python\\ndef testA()：\\n\\tglobal num\\n\\tnum = 20\\n\\tprint(\\\"testA中的num为：\\\",num)\\n\\ndef testB()：\\n\\tprint(\\\"testB中的num为：\\\"，num)\\n\\t\\ntestA()\\ntestB()\\nprint(f\\\"全局变量num为{num}\\\")\\n```\\n\\n#### 10.2 函数进阶\\n\\n##### 1、函数的多个返回值\\n\\n```python\\ndef  xxx()：\\n\\treturn 1,2    //return语句后接多个变量，每个变量用逗号隔开\\n//并且。return支持多种不同数据类型的数据return\\n```\\n\\n##### 2、函数传参\\n\\n2.1 位置参数\\n<font color=\'red\'>位置参数</font>：调用函数时根据函数定义的参数位置来传递参数\\n<font color=\'blue\'>注意</font>：传递的参数和定义的参数的顺序及个数必须一致\\n\\n```python\\ndef user_info(name,hei,gner)：\\n\\tprint(f\\\"{name}的{hei}是{gner}\\\\n\\\")\\n\\t\\n#函数调用\\nuser(\\\"李华\\\",\\\"身高\\\",175)\\n```\\n\\n2.2 关键字参数\\n<font color=\'red\'>关键字参数</font>：函数调用时通过“键=值”形式传递参数.\\n<font color=\'red\'>作用</font>: 可以让函数更加清晰、容易使用，同时也清除了参数的顺序需求.\\n<font color=\'blue\'>注意</font>：函数调用时，如果有位置参数时，位置参数必须在关键字参数的前面，但关键字参数之间不存在先后顺序\\n\\n```python\\ndef user_info(name,hei,gner)：\\n\\tprint(f\\\"{name}的{hei}是{gner}\\\\n\\\")\\n\\t\\n#函数调用\\nuser(hei=\\\"身高\\\",name=\\\"李华\\\",gner=175)\\n//或者：位置参数和关键字参数混用：注意位置参数必须放在最前面\\nuser(175,hei=\\\"身高\\\",name=\\\"李华\\\")\\n```\\n\\n2.3 缺省参数\\n<font color=\'red\'>缺省参数</font>：缺省参数也叫默认参数，用于定义函数，为参数提供默认值，调用函数时可不传该默认参数的值（注意：所有位置参数必须出现在默认参数前，包括函数定义和调用）.\\n<font color=\'red\'>作用</font>: 当调用函数时没有传递参数, 就会使用默认是用缺省参数对应的值\\n<font color=\'blue\'>注意</font>：函数调用时，如果为缺省参数传值则修改默认参数值, 否则使用这个默认值\\n\\n```python\\ndef user_info(name,hei,gner=175)：\\n\\tprint(f\\\"{name}的{hei}是{gner}\\\\n\\\")\\n\\t\\n#函数调用\\nuser(hei=\\\"身高\\\",name=\\\"李华\\\")\\n//或者：位置参数和关键字参数混用：注意位置参数必须放在最前面\\nuser(180,hei=\\\"身高\\\",name=\\\"李华\\\")\\n```\\n\\n2.4 不定长参数\\n<font color=\'red\'>不定长参数</font>：不定长参数也叫可变参数. 用于不确定调用的时候会传递多少个参数(不传参也可以)的场景.\\n<font color=\'red\'>作用</font>: 当调用函数时不确定参数个数时, 可以使用不定长参数\\n不定长参数的类型：\\n\\n+ 1、位置传递\\n+ 2、关键字传递\\n\\n1、位置传递：\\n\\n传进的<font color=\'red\'>所有参数</font>都会被<font color=\'red\'>args变量收集</font>，它会根据传进参数的位置合并为一个元组(tuple)，<font color=\'red\'>args是元组类型</font>，这就是<font color=\'red\'>位置传递</font>\\n\\n```python\\ndef user_info(*args)：\\n\\tprint(args)\\n\\t\\n#函数调用\\nuser_info(\'TOM\')\\nuser_info(\'TOM\',18)\\n```\\n\\n2、关键字传递\\n\\n参数是<font color=\'red\'>“键=值”</font>形式的形式的情况下, 所有的“键=值”都会被<font color=\'red\'>kwargs接受</font>, 同时会根据“键=值”组成<font color=\'red\'>字典</font>。\\n\\n```python\\ndef user_info(**kwargs)：\\n\\tprint(kwargs)\\n\\t\\n#函数调用\\nuser_info(name=\'TOM\',age=18)\\n```\\n\\n\\n位置不定长传递以\\\\*号标记一个形式参数，以元组的形式接受参数，形式参数一般命名为args\\n\\n关键字不定长传递以\\\\*\\\\*号标记一个形式参数，以字典的形式接受参数，形式参数一般命名为kwargs\\n\\n##### 3、匿名函数\\n\\n1、函数作为参数传递\\n\\n函数本身是可以作为参数，传入另一个函数中进行使用的。\\n\\n将函数传入的作用在于：传入计算逻辑，而非传入数据。示例如下：\\n\\n```python\\ndef test_func(a,b,func)：\\n\\tresult=func(a,b)\\n\\tprint(result)\\n\\ndef func1(x,y)：\\n\\treturn x+y\\ndef func2(x,y)：\\n\\treturn x*y\\n\\t\\n# 函数调用测试\\ntest_func(1,2,func1) # 打印结果为3\\ntest_func(1,2,func2) # 打印结果为2\\n```\\n\\n2、lambda匿名函数\\n\\ndef定义的函数都是有名称的，并且可以基于名称多次使用该函数。而lambda函数可以定义没有函数名的<font color=\'red\'>匿名</font>函数，且匿名函数仅能使用一次。\\n\\n注意：\\n\\n+ 匿名函数用于临时构建一个函数，只用一次的场景\\n+ 匿名函数的定义中，函数体只能写一行代码，如果函数体要写多行代码，不可使用匿名函数。\\n\\n匿名函数定义的语法：\\n`lambda 传入参数：函数体`  # 注意：函数体仅允许只有一行代码\\n\\n+ lambda 是关键字，表示定义匿名函数\\n+ 传入参数表示匿名函数的形式参数，如：x, y 表示接收2个形式参数\\n+ 函数体，就是函数的执行逻辑，要注意：只能写一行，无法写多行代码\\n  示例：\\n\\n```python\\ndef test_func(a,b,func)：\\n\\tresult=func(a,b)\\n\\tprint(result)\\n\\n# 函数调用\\ntest_func(1,2,lambda x,y: x+y)  # 打印输出3\\n```\\n\\n\\n\\n\\n\\n## 第三部分 数据容器\\n\\n### 11.1、五类数据容器入门\\n\\n数据容器根据特点的不同，如：\\n\\n+ 是否支持重复元素\\n+ 是否可以修改\\n+ 是否有序\\n\\n列表(List)、元组(tuple)、字符串(str)、集合(set)、字典(dict)\\n\\n>列表List，是有序的可变序列。它是python中使用最频繁的数据类型，可有序记录一堆数据。\\n>\\n>元组Tuple，有序的不可变序列。可以有序记录一堆不可变的python数据集合。\\n>\\n>字符串String\\n>\\n>集合Set，无需不重复集合，可无序记录一堆不重复的python数据集合。\\n>\\n>字典Dictionary，无序的键值对，可无序记录一堆键值对的python数据集合。\\n\\n序列：序列是指内容连续、有序，可使用下标索引的一类数据容器。<font color=\'red\'>列表、元组和字符串</font>，均可以视为序列。序列不是一种新的数据容器，而是多种数据容器的一种共通属性。\\n\\n**序列的切片**：\\n\\n格式为：<font color=\'red\'>[起始下标:结束下标:步长]</font>\\n\\n注意：\\n\\n+ 1、步长为负数，表示反向取（注意，起始下标和结束下标也要反向标记）\\n+ 2、注意，此操作<font color=\'blue\'>不会影响序列本身，而是会得到一个新的序列（列表、元组、字符串）</font>\\n\\n正向切片：\\n![](https://s3.bmp.ovh/imgs/2022/10/14/e76148b450adaad2.png)\\n\\n反向切片：\\n![](https://s3.bmp.ovh/imgs/2022/10/14/eed814e7ce28fd0e.png)\\n举例如下：\\n\\n```python\\n说明：列表方括号，元组圆括号，字符串使用双引号，集合大括号，字典也是大括号\\n---------------------\\n一、列表\\n列表：name_list=[\'王力宏\',\'周杰伦\',\'林俊杰\',\'白洁\']\\n列表2：name_list=[\'王力宏\',\'周杰伦\',24，True,12.31]\\n---------------------\\n二、元组\\n元组：t1=(1,\'王力宏\',True,11.44)    # 元组内的元素在定义后就不可以更改了\\n元组2：t2=(\'hello\',)        # 元组内只有一个元素的话，这个数据后要添加逗号\\n---------------------\\n三、字符串\\n字符串：str1=\\\"iccaa\\\"\\n---------------------\\n四、集合\\nnames={\'王力宏\',\'周杰伦\',\'林俊杰\',12,\'王力宏\'}  # 集合去重且无序，因为无序，所以不支持下标访问\\nprint(names)     # 输出为 \'王力宏\',\'周杰伦\',\'林俊杰\',12\\n---------------------\\n五、字典\\n字典：my_dict={\'网络\':99,\'所示\':23,\'啊啊\':82} # 1、字典的key和value可以是任意类型的数据，但key不可为字典。2、key不可重复，重复会对原有数据覆盖。和集合一样，无序，不可使用下标访问。3、value可以为字典，从而构成嵌套字典\\n字典2：stu_score={\\n\\t\\\"王力宏\\\"：{\\\"语文\\\":42,\\\"数学\\\":42,\\\"英语\\\":32}\\n\\t\\\"周杰伦\\\": {\\\"语文\\\":31,\\\"数学\\\":92,\\\"英语\\\":25}\\n\\t\\\"李 白\\\": {\\\"语文\\\":13,\\\"数学\\\":62,\\\"英语\\\":52}\\n}\\n嵌套字典的使用：\\nprint(stu_score[\\\"王力宏\\\"])   # 输出为 {\\\"语文\\\":42,\\\"数学\\\":42,\\\"英语\\\":32}\\nprint(stu_score[\\\"王力宏\\\"][\\\"语文\\\"]) # 输出为 42\\n```\\n\\n<font color=\'red\'>列表</font>的特点：\\n\\n+ 可以容纳多个数据，上限为2^63^-1=9,223,372,036,854,775,807个\\n+ 可以容纳不同类型的数据（混装）\\n+ 数据是有序存储的（有下标序号）\\n+ 允许重复数据存在\\n+ 可以修改（增加或删除元素等）\\n\\n<font color=\'red\'>元组</font>的特点：      多数特性与列表一致，最大的不同在于不可修改性\\n\\n+ 可以容纳多个数据\\n+ 可以容纳不同类型的数据（混装）\\n+ 数据是有序存储的（下标索引）\\n+ 允许重复数据存在\\n+ <font color=\'blue\'>不可以修改</font>（增加或删除元素等）\\n+ 支持for循环\\n\\n<font color=\'red\'>字符串</font>的特点：\\n\\n+ <font color=\'blue\'>只可以存储字符串</font>\\n+ 长度任意（取决于内存大小）\\n+ 支持下标索引\\n+ 允许重复字符串存在\\n+ <font color=\'blue\'>不可以修改</font>（增加或删除元素等）\\n+ 支持for循环\\n\\n字符串的特点基本有列表、元组相同。与列表、元组不同的在于：字符串容器要求可以容纳的类型式单一的，只能是字符串类型。与列表不同与元组相同的在于：字符串不可更改。\\n\\n<font color=\'red\'>集合</font>的特点：\\n\\n+ 可以容纳多个数据\\n+ 可以容纳不同类型的数据（混装）\\n+ <font color=\'blue\'>数据是无序存储的</font>（不支持下标索引）\\n+ <font color=\'blue\'>不允许重复数据存在</font>\\n+ 可以修改（增加或删除元素等）\\n+ 支持for循环\\n\\n<font color=\'red\'>字典</font>的特点：\\n\\n+ 可以容纳多个数据\\n+ 可以容纳不同类型的数据（混装）\\n+ <font color=\'blue\'>每一份数据是KeyValue键值对</font>（不支持下标索引）\\n+ <font color=\'blue\'>可以通过Key获取到Value，Key不可重复(重复会覆盖)</font>\\n+ 不支持下标索引\\n+ 可以修改（增加或删除元素等）\\n+ 支持for循环，不支持wehile循环\\n\\n### 11.2 列表\\n\\n#### 11.2.1 列表的定义方式\\n\\n```python\\n变量名称 = [元素1,元素2,元素3,...]\\n定义空列表：变量名=list() 或 变量名=[]\\n支持嵌套：my_list=[[1,2,3],[4,5,6]]\\n```\\n\\n#### 11.2.2 列表的下标索引\\n\\n正向索引：下标从0开始，0,1,2,3...\\n反向索引：下标从-1开始，-1，-2，-3...\\n嵌套列表也是支持下标索引的。\\n\\n#### 11.2.3 列表的常用操作（方法）\\n\\n如果将函数定义为类中成员，那么他就称为方法。函数与方法定义是一致的，只是使用格式不同。\\n\\n下面将介绍列表的常用操作：增删改查和统计/清空操作。其实这些都是数据容器的基本操作，不过对于元组和字符串来将，增删改+清空操作是不存在的。\\n\\n```python\\nmy_list= [\'ass\',\'ss\',\'wwas\']\\n-----------------------------\\n1、查询1、根据下标，查询元素值：\\nprint(my_list[2])\\n查询2、根据元素值查询对应的坐标：\\nprint(my_list.index(\\\"ss\\\"))\\n----------------------------\\n2、插入\\n2.1 在指定位置插入：insert\\nmy_list.insert(1,\\\"haha\\\")\\nprint(my_list)  # 输出为： \'ass\',\\\"haha\\\"，\'ss\',\'wwas\'\\n2.2 在结尾追加append\\nmy_list.append(\\\"yuhao\\\")\\nprint(my_list)  # 输出为： \'ass\'，\'ss\',\'wwas\',\\\"yuhao\\\"\\n2.3 先从其他容器中取出数据，在依次追加到列表尾部\\nmy_list.extend([4,1,6])\\nprint(my_list)  # 输出为： \'ass\'，\'ss\',\'wwas\',4,1,6\\n------------------------------\\n3、删除\\n3.1 用del关键字删除\\ndel my_list[0] # 删除单个  或者  del my_list # 删除全部\\ndel my_list[1:3]  # 删除链表的下标为1到下标为2的元素，用冒号来指定子区间，包含前者而不包含后者\\n3.2 使用列表方法pop删除\\nmy_list.pop([index=-1])  # 默认是出栈最后一个元素\\nmy_list.pop()  # 出栈最后一个元素\\nmy_list.pop(2)  # 出栈下标为2的元素，注意下标号从0开始\\n3.3 使用列表方法clear来清空列表\\nmy_list.clear()  \\n3.4 根据元素值而非下标位置来删除元素\\n#使用remove删除与元素值相匹配的第一个元素\\nmy_list.remove(\'ass\')\\n## 注意，del和pop都可以按照坐标来删除元素，但是del是关键字，pop是方法。del可以删除区间，del可以删除全部，而pop不能。还有del删除后不会将删除元素返回，但是pop会将删除的元素返回。\\n-------------------------------\\n4、更改\\n# 直接用下标来对元素值进行更改\\nmy_list[1]=\'hehhe\'\\n--------------------------------\\n5、查找\\n通过下标号获取元素值；或者通过元素值反向查找下标号.index(\'ass\')\\n查找列表最小值的方法1：.sort()，然后list[0];方法2;min(list)\\n---------------------------------\\n6、统计\\n6.1 通过某元素在列表中的个数\\nmy_list.count(\\\"ass\\\")\\n6.2 统计列表的长度\\nlen(my_list)\\n```\\n\\n![](https://s3.bmp.ovh/imgs/2022/10/14/1134525ff952347e.png)\\n\\n#### 11.2.4 列表的遍历\\n\\n1、使用while遍历\\n\\n```python\\nindex = 0\\nwhile index < len(列表)：\\n\\t元素=列表[index]\\n\\tindex++\\n```\\n\\n2、使用for循环遍历\\n\\n```python\\nfor i in my_list\\n\\tprint(i)\\n```\\n\\n3、while和for循环的区别与联系\\n\\n+ 在循环控制上：\\n+ + while循环<font color=\'blue\'>可以自定循环条件</font>，并自行控制\\n+ + for循环<font color=\'blue\'>不可以自定循环条件</font>，只可以一个个从容器内取出数据\\n+ 在无限循环上：\\n+ + while循环<font color=\'blue\'>可以</font>通过条件控制做到无限循环\\n+ + for循环理论上<font color=\'blue\'>不可以</font>，因为被遍历的容器容量不是无限的\\n+ 在使用场景上：\\n+ + while循环适用于任何想要循环的场景\\n+ + for循环适用于，遍历数据容器的场景或简单的<font color=\'blue\'>固定次数</font>的循环场景\\n\\n### 11.3 元组tuple\\n\\n#### 11.3.1 元组的定义方式\\n\\nmy_tuple=(\'as\',\'sas\',\'asa\')\\n定义空元组：my_tupe=tuple() 或my_tuple=()\\n定义嵌套元组：my_tuple=((1,2,1),(2,1,6),(2,1))\\n定义单个元素的元组：mt_tuple=(1,)  或(\'hello\',)\\n\\n#### 11.3.2 元组的常用操作（方法）\\n\\n```python\\nmy_tuple=(\'wqw\',\'dsd\',\'sd\')\\n1、查找\\n1.1 根据下标查找\\ntest=my_tuple[2]\\n1.2 根据元素值查找下标值\\nnum=my_tuple.index(\'wqw\')\\n2、统计\\n2.1 统计某元素在元组中出现的次数\\nprint(my_tuple.count(\'wqw\'))\\n2.2 统计元组长度\\nprint(len(my_tuple))\\n```\\n\\n#### 11.3.1 元组的遍历\\n\\n1、while遍历\\n\\n```python\\nindex=0\\nwhile index < len(my_tuple):\\n\\tprint(my_tuple[index])\\n\\tindex++\\n```\\n\\n2、for循环遍历\\n\\n```python\\nfor i in my_puple\\n\\tprint(i)\\n```\\n\\n### 11.4 字符串\\n\\n#### 11.4.1 字符串的索引\\n\\n下标索引，正向从0开始，反向从-1开始\\n\\n#### 11.4.2 字符串的操作（方法）\\n\\n字符串与元组类似，内部元素不允许改动。所以，可使用的操作很少。\\n\\n```python\\n1、查找\\n通过下标或者index方法\\n---------------------------------\\n2、替换replace  # 注意，不是替换字符串本身，而是新生成了一个字符串\\nname=\\\"iteima itcast\\\"\\nnew_name = name.replace(\\\"it\\\",\\\"黑马\\\")\\nprint(new_name)       # 输出为 黑马eima 黑马cast\\n---------------------------------\\n3、字符串分割 （是重新得到一个对象）\\n将源字符串按照指定的分割方式，分割成几个子字符串，并存入列表\\nname=\\\"传智播客  传智教育  差遵化  送达\\\"\\nnew_name = name.split(\\\" \\\")\\nprint(type(new_name))   # 输出为 <class \'list\'>\\nprint(new_name) # 输出为 [\'传智播客\',\'传智教育\',\'差遵化\',\'送达\']\\n---------------------------------\\n4、字符串规整\\n4.1 去掉前后空格\\nmy_str=\\\"  itrima and itcast  \\\"\\nprint(my_str.strip()) #输出为 \\\"itrima and itcast\\\"\\n4.2 去前后指定字符串\\nmy_str=\\\"12itrima and itcast21\\\"\\nprint(my_str.strip(\\\"12\\\")) #输出为 \\\"itrima and itcast\\\"\\n#注意，传入的是\\\"12\\\"，其实是按照单个字符来的，\\\"1\\\"和\\\"2\\\"都会被移除\\n---------------------------------\\n5、统计\\n统计某字符串的出现次数：print(my_str.count(\\\"it\\\"))\\n统计字符串长度：print(len(my_str))\\n---------------------------------\\n6、检查字符串的子串\\n# find()函数的作用是检查一个字符串是否是另一个字符串的子串，并返回子串所在的起始位置索引\\n语法：string_object.find(sub, start, end)\\n参数含义：\\nsub：必选参数。指定要检索的字符串，可以直接使用字符串具体的值或字符串变量；\\nstart：可选参数。检查搜索开始的索引，默认为0；\\nend：可选参数。检查搜索停止的索引，默认为字符串string_object的长度。\\n注意，find()函数在执行检查搜索时，start处的字符将会被检查，而end是停止检索的索引，所以end索引处的字符不会参与检查搜索。\\n方法返回值：\\n如果字符串string_object中包含sub，则返回sub在string_object中起始的位置索引，否则返回-1。\\n示例：\\nstr1 = \\\"该网站的名称是：翔宇亭IT乐园\\\"\\nstr2 = \\\"翔宇亭\\\"\\nprint(str1.find(str2)) #结果为：8\\n# 在字符串中，一个中文算一个字符。\\n```\\n\\n![](https://s3.bmp.ovh/imgs/2022/10/14/d034ba3b4152f0e2.png)\\n\\n#### 11.4.3 字符串的遍历\\n\\n1、while遍历\\n\\n```python\\nindex=0\\nwhile index < len(my_str):\\n\\tprint(my_str[index])\\n\\tindex++\\n```\\n\\n2、for循环遍历\\n\\n```python\\nfor i in my_str\\n\\tprint(i)\\n```\\n\\n\\n\\n\\n接下来将学习“集合”和“字典”，这两种方式都是无序的，所以不可以使用下标访问。集合会组合相同项，字典可以使用键名来获取键值。\\n\\n### 11.5 集合\\n\\n#### 11.5.1 集合简介及集合的常见操作（方法）\\n\\n集合，最重要的一个特点就是可以去重。使用一个大括号来定义一个集合。\\nmt_set={\\\"11a\\\",\\\"as\\\",\\\"das\\\"}\\n定义空集合： my_set=set()\\n提醒：my_dict={}是定义了一个空字典，而不是空集合\\n\\n集合的常见操作（方法）\\n\\n```python\\n--------------------\\n   操作集合时，一定要在心中谨记，集合内部是无序的，你看到在代码中集合的第一个元素是\\\"hello\\\"，但其实在内存中第一个元素有可能不是\\\"hello\\\"。因为集合需要对元素进行判断和删除重复元素的操作，就有可能会打乱内部元素的排序。\\n--------------------\\n1、添加新元素add   (其他几种数据容器的添加方法是insert或append)\\nmy_set={\\\"hello\\\",\\\"world\\\"}\\nmy_set.add(\\\"inte\\\")\\nprint(my_set)   # 输出为 {\\\"hello\\\",\\\"world\\\",\\\"inte\\\"}\\n2、移除元素remove\\nmy_set={\\\"hello\\\",\\\"sdsdsd\\\",\\\"sdaa\\\",\\\"world\\\"}\\nmy_set.remove(\\\"asaa\\\")\\nprint(my_set)   # 输出为 {\\\"hello\\\",\\\"sdsdsd\\\",\\\"world\\\"}\\n3、从集合中随即取出一个元素\\nelement=my_set.pop()\\n4、清空集合\\nmy_set.clear()\\n---------------------\\n5、集合之间的操作\\n5.1 取出了两个子集的差集\\n6.功能：判断两个集合的差集，取出1中有的而2中没有的，并存入新的集合\\nset1={1,2,3}\\nset2={2,3,4}\\nset_dif=set1.different(set2)\\nprint(set_dif)  # 输出结果为 {1}，且集合1和集合2不变\\n5.2 消除两个子集的差集\\n功能：对比集合1和集合2，在集合1中，删除和集合2中相同的元素\\n结果：集合1被改变，集合2不变化\\nset1={1,2,3}\\nset2={2,3,4}\\nset1.different_update(set2)\\nprint(set1)  # 输出{1}\\n5.3 两集合合并\\n功能：将集合1和集合2合并为一个集合\\n结果：出现一个新集合，且集合1和集合2都不改变\\nset3=set1.union(set2)\\nprint(set3)  # 输出为 {1,2,3,4}\\n\\n---------------------\\n6、统计集合中元素的数量\\nprint(len(my_set))\\n集合没有count方法，因为所有元素均唯一。\\n```\\n\\n![](https://s3.bmp.ovh/imgs/2022/10/14/daa03b0bad2855b3.png)\\n\\n#### 11.5.2 集合的遍历\\n\\n因为集合内部无序，所以不能使用下标访问。因此，不能使用while循环，但是for循环不受影响。\\n\\n```python\\nset={1,2,3}\\nfor i in set\\n\\tprint(i)\\n```\\n\\n字典也是同样的道理\\n\\n\\n### 11.6 字典\\n\\n#### 11.6.1 字典的常见操作（方法）\\n\\n```python\\n1、新增元素\\nstu_score={\\n\\t\\\"网\\\"=11\\n\\t\\\"里\\\"=22\\n\\t\\\"bai1\\\"=33\\n}\\nstu_score[\\\"张\\\"]=89\\n2、更新元素值\\n注意，字典的键名不可以重复，对已存在的键名进行操作就是在更新键值。\\nstu_score[\\\"张\\\"]=21\\n3、删除元素\\n语法：字典.pop(键名)  # 获取指定键名的键值，并从字典中删除该元素\\n4、清空元素\\n语法：字典.clear()\\n5、获取全部的key键名\\nget_all_keys=stu_score.keys()\\nprint(get_all_keys)  # 输出为 dict_keys([\'网\',\'里\',\'bail\'])，类型为<class \'dict_keys\'>\\n5.2 获取全部的键值\\nprint(stu_score.values())\\n6、遍历字典（只能使用for）\\nfor i in my_dict:\\n\\tprint(f\\\"字典中，键名为{i}的键值为{my_dict[i]}\\\")\\n或：\\nfor i in my_dict.keys():\\n    print(f\\\"字典中，键名为{i}的键值为{my_dict[i]}\\\")\\n7、获取字典中所有键值对的数量\\nprint(len(my_dict))\\n8、根据指定的键名获取键值\\nprint(my_dict.get(\'网\'))  或  print(my_dict.get(\'网\',\'里\')) \\n9、通过gets方法，根据键名获取键值\\n# 语法： get(key, \\\"输出的信息\\\")\\n# get方法根据第一个参数在键名中查找，找到了对应的键，打印其键值；没找到对应的键，就输出第二个参数对应的内容。如果第二个参数为空，就输出None。\\n10、items方法，查找字典中所有的键值对，并返回一个可迭代对象，且对象是元组类型的。\\ndict1 = {\'name\': \'Rose\', \'age\': 30, \'sex\': \'女\'}\\nprint(dict1.items())\\n#输出结果为：dict_items([(\'name\', \'Rose\'), (\'age\', 30), (\'sex\', \'女\')])\\n# 输出结果的类型是：<class \'dict_items\'>\\n```\\n\\n![](https://s3.bmp.ovh/imgs/2022/10/14/434f88294d37e333.png)\\n\\n### 11.7 几种数据容器的总结\\n\\n1、数据容器的分类\\n\\n+ 是否支持下标索引\\n+ + 支持：列表、元组、字符串 - 序列类型\\n+ + 不支持：集合、字典 - 非序列类型\\n+ 是否支持重复元素\\n+ + 支持：列表、元组、字符串 - 序列类型\\n+ + 不支持：集合、字典 - 非序列类型\\n+ 是否可以修改\\n+ + 支持：列表、集合、字典\\n+ + 不支持：元组、字符串\\n\\n![](https://s3.bmp.ovh/imgs/2022/10/14/75c25d928730e470.png)\\n\\n![](https://s3.bmp.ovh/imgs/2022/10/14/1bb99fb466c009c1.png)\\n\\n### 11.8 数据容器的通用操作\\n\\n1、都支持for循环遍历。但是，只有能读取下标的数据容器才支持while循环。即只有列表、元组和字符串才支持while循环，集合和字典仅支持for循环。\\n\\n2、通用的\\\"统计\\\"方法：\\n列表、元组和字符串都支持以下三种方法：求长度、求最大元素和求最小元素：\\n![](https://s3.bmp.ovh/imgs/2022/10/15/3b575f44ccd40b62.png)\\n\\n3、通用的转换功能（除了不能转成字典）\\n![](https://s3.bmp.ovh/imgs/2022/10/15/bc6b7d83e5de3542.png)\\n\\n4、通用的排序功能\\n\\nsorted的参数reverse=True代表降序排序\\n![](https://s3.bmp.ovh/imgs/2022/10/15/2055118e74bd42c4.png)\\n\\n\\n\\n## 第四部分 文件IO\\n\\n### 12、文件IO\\n\\n文件编/解码：就是将内容翻译成二进制的一种方式，常用的有UTF-8、GBK、big5等。\\n\\n文件的操作，常见的主要有文件的的打开、关闭、读、写等操作。文件打开用open函数，写用write函数，读用read、readline()或readlines函数，文件关闭用close函数。一般文件写write还伴随有flush缓存刷新。\\n\\n1、文件打开的操作：\\n语法格式为：`open(name,mode,encoding)`\\nname：是要打开的目标文件名的字符串(可以包含文件所在的具体路径)。\\nmode：设置打开文件的模式(访问模式)：只读、写入、追加等。\\nencoding:编码格式（推荐使用UTF-8）\\n\\n|    mode    |                             描述                             |\\n| :--------: | :----------------------------------------------------------: |\\n|     r      | 以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。 |\\n|     w      | 打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，<font color=\'red\'>原有内容会被删除</font>。如果该文件<font color=\'red\'>不存在，创建新文件</font>。 |\\n|     a      | 打开一个文件用于追加。如果该文件已存在，<font color=\'red\'>新的内容将会被写入到已有内容之后</font>。如果该文件<font color=\'red\'>不存在，创建新文件进行写入</font>。 |\\n| 示例代码： |                                                              |\\n\\n```python\\nf=open(\\\"python.txt\\\",\'r\',encoding=UTF-8)\\n# 注意：此时的`f`是`open`函数的文件对象，对象是Python中一种特殊的数据类型，拥有属性和方法，可以使用对象.属性或对象.方法对其进行访问，后续面向对象课程会给大家进行详细的介绍。\\n\\n```\\n\\n2、读操作\\n\\n**read()方法**：\\n\\n`文件对象.read(num)`\\nnum表示要从文件中读取的数据长度（单位为字节）。如果不设置num，默认为读取文件中所有数据。\\n\\n**readline()和readlines()方法**：\\nreadline()方法是只读取一行内容，\\nreadlines可以按照行的方式把整个文件中的内容进行一次性读取，并且返回的是一个<font color=\'blue\'>列表</font>，其中每一行的数据为一个元素。\\n\\n这个readlines方法经常与for循环搭配使用。\\n\\n```python\\nfor line in open(\\\"python.txt\\\",\\\"r\\\"):\\n\\tprint(line)\\n```\\n\\n3、文件的关闭\\n\\n```python\\nf=open(\\\"python.txt\\\",\\\"r\\\")\\nf.close()\\n```\\n\\n4、with open语法\\n\\n```python\\nwith open(\\\"python.txt\\\",\\\"r\\\") as f:\\n\\tf.readlines()\\n\\n# 通过在with open的语句块中对文件进行操作,\\n# 可以在操作完成后自动关闭close文件，避免遗忘掉close方法\\n```\\n\\n5、文件的写入、文件的追加写入\\n\\n```python\\n#（1）普通写入：文件不存在会创建，文件存在会先清空在写入\\nf=open(\'python.txt\',\'w\')\\nf.write(\\\"hello,world\\\")\\nf.flush()\\n#（2）追加写入，在原内容上追加写入内容\\nf=open(\'python.txt\',\'a\')\\nf.write(\\\"hello,world\\\")\\nf.flush()\\n```\\n\\n注意：\\n\\n> 直接调用write，内容并未真正写入文件，而是会积攒在程序的内存中，称之为缓冲区\\n>\\n> 当调用flush的时候，内容会真正写入文件\\n>\\n> 这样做是避免频繁的操作硬盘，导致效率下降（攒一堆，一次性写磁盘）\\n\\n\\n## 第五部分  扩展\\n\\n### 13、异常\\n\\n代码示例：\\n\\n```python\\ntry:\\n\\tf=open(\'test.txt\',\'r\')\\nexcept Exception as e:\\n\\tf=open(\'test.txt\',\'w\')\\nelse:\\n\\tprint(\\\"没有异常，真开心\\\")\\nfinally:\\n\\tf.close()\\n\\t# 一般try下方只放一行尝试执行的代码\\n```\\n\\n1、try后跟的可能会出现BUG的代码，如果该代码出现了错误，就跳转到except后的语句进行执行。如果没有出错，就跳转到else后的语句进行执行。不论try后的代码是否出现错误，最终都会执行finally后的代码。\\n\\n2、当捕获多个异常时，可以把要捕获的异常类型的名字，放到except 后，并使用元组的方式进行书写：`xcept(NameError,ZeroDivisionError)`\\n\\n3、捕获异常并输出信息：\\n\\n```python\\nNameError, ZeroDivisionError) as e:\\n    print(e)\\n```\\n\\n4、使用`except`或`except Exception`来捕获所有类型的异常。\\n![](https://s3.bmp.ovh/imgs/2022/10/15/25f7c38edf8d70a9.png)\\n\\n5、异常的传递性\\n\\n假设main函数调用func1()，func1()调用func2()。如果func2()出现了异常，并且没处理，异常会传递到func1()；如果fun1()也没处理，异常会传递到main()；如果main()也没处理，程序就会报错。这就是异常的传递性。基于此原理，我们可以在main函数中设置异常处理函数，这样就能确保所有异常都能被捕捉到。\\n\\n注意：当所有函数都没有处理异常时，程序就会报错。\\n![](https://s3.bmp.ovh/imgs/2022/10/15/5c506fda7a3a2468.png)\\n\\n### 14、模块的导入、包的导入\\n\\npython模块Module：是一个python文件，以.py结尾。模块能定义函数、类和变量，模块中也能饱含可执行的代码。（类似于c语言的.h和配套的.c文件糅合在一起的那种）\\n\\n模块的作用:  python中有很多各种不同的模块, 每一个模块都可以帮助我们快速的实现一些<font color=\'red\'>功能</font>, 比如实现和时间相关的功能就可以使用time模块我们可以认为<font color=\'red\'>一个模块</font>就是<font color=\'red\'>一个工具包</font>, 每一个工具包中都有各种不同的工具供我们使用进而实现各种不同的功能。\\n\\n什么是Python包？包就像个文件夹，里面装了若干个模块。\\n\\n> <font color=\'red\'>从物理上看</font>，包就是一个文件夹，在该文件夹下包含了一个 <font color=\'red\'>__init__.py 文件</font>，该文件夹可用于包含多个<font color=\'red\'>模块文件</font>\\n>\\n> <font color=\'red\'>从逻辑上看</font>，包的本质依然是模块\\n\\n#### 14.1 模块的导入\\n\\n包的作用：当我们的模块文件越来越多时,包可以帮助我们管理这些模块, 包的作用就是包含多个模块，但包的本质依然是模块\\n\\n刚刚说过，模块类似于c语言中的.h和.c文件，那么一定有类似于#include的操作咯，示例如下：\\n\\n```python\\n语法：[from 模块名] import [模块 | 类 | 变量 | 函数 | * ][as 别名]\\n常见用法示例：\\nimport 模块名\\nimport 模块名1,,模块名2\\nfrom 模块名 import 类、变量、方法等\\nfrom 模块名 import *\\nimport 模块名 as 别名\\nfrom 模块名 import 功能名 as 别名\\n```\\n\\n注意：只使用import时，需要用`模块名.方法()`的方式调用对应的方法；如果是使用import的话，直接用方法：`方法()`。而as只是起一个别名，当模块名比较长或者不好记时，用别名也是一种不错的方法。\\n\\n#### 14.2 自定义模块\\n\\n其实就是新建一个python文件，里面写上对应的类或函数。然后和你的主程序放在一个目录下，用`import 文件名`的方式来引用。模块的名字就是文件的名字（不要带.py）。也就是说自定义模块名必须要符合标识符命名规则\\n\\n1、模块的测试\\n\\n当模块写好后，开发人员可以在模块后写上测试代码，来验证模块函数的可行性。可是，这样的话，不论是模块还是调用模块的代码中都会执行这部分测试代码，这显然不是我们想要的。使用`if __name__==\'__main__\'`来解决这个问题：\\n\\n```python\\ndef test(a,b)\\n\\tprint(a+b)\\n\\n# 只在当前文件中调用该函数，其他导入的文件内不符合该条件，则不执行test函数调用\\nif __name__==\'__main\':\\n\\ttest(1,2)\\n```\\n\\n2、注意事项\\n\\n```python\\n#模块1代码module1.py\\ndef my_test(a,b)\\n\\tprint(a+b)\\n#模块2代码module2.py\\ndef my_test(a,b)\\n\\tprint(a*b)\\n# 导入模块和调用功能代码\\nimport module1  # 或 from module1 import my_test\\nimport module2  # 或 from module2 import my_test\\n#方法测试\\nmy_test(1,2)  # 输出结果为2,同名方法就调用最新的那个\\n\\n## 可行的解决办法之一\\nfrom module1 import my_test as my_test1\\nfrom module2 import my_test as my_test2\\n```\\n\\n3、`__all__`可以控制模块内的那些方法可以被导入\\n\\n```python\\n# 模块文件module.py\\n__all__ = [test_A]\\n\\ndef test_A():\\n\\tprint(\'testA\')\\ndel test_B():\\n\\tprint(\'testB\')\\n\\n# 测试文件test.py\\nfrom module import *\\ntest_A()  //运行正常\\ntest_B()  //运行出错，显示没定义\\n```\\n\\n#### 14.3 自创建包、导入包和通过pip安装第三方包\\n\\n1、自创建包\\n\\n> ①新建包“my_package”\\n>\\n> ②新建包内模块：\\\"my_module1.py\\\"和\\\"my_module2.py\\\"，然后在模块内写对应的类和方法\\n>\\n> ③新建包后，包内会自动创建init.py来管理和控制包的导入行为。\\n\\n**Pycharm中的步骤**：[New]      [Python Package]    输入包名    [OK]     新建功能模块(有联系的模块)\\n\\n2、包的导入\\n方式一：\\n\\n```python\\nimport 包名.模块名\\n#使用\\n包名.模块名.方法名\\n```\\n\\n方法二：（前提：必须在init.py文件中添加`__all__=[]`，来控制允许导入的模块列表\\n\\n```python\\nfrom 包名 import *\\n# 注意：__all__这种方法针对的是from XXX import * ,对import XXX这种方式无效\\n```\\n\\n3、第三方包的导入\\n我们知道，包可以包含一堆的Python模块，而每个模块又内含许多的功能。\\n\\n所以，我们可以认为：一个包，就是一堆同类型功能的集合体。\\n\\n在Python程序的生态中，有许多非常多的第三方包（非Python官方），可以极大的帮助我们提高开发效率，如：\\n\\n+ 科学计算中常用的：numpy包\\n+ 数据分析中常用的：pandas包\\n+ 大数据计算中常用的：pyspark、apache-flink包\\n+ 图形可视化常用的：matplotlib、pyecharts\\n+ 人工智能常用的：tensorflow\\n\\n**安装方法**：\\n1、直接：pip install 包名\\n2、用国内源下载和安装：`pip install -i https://pypi.tuna.tsinghua.edu.cn/simple` 包名\\n\\n### 15、数据的可视化分析\\n\\n#### 15.1 折线图\\n\\n1、json数据格式\\n\\n```python\\nimport json\\ndata_dict={\\\"name\\\":\\\"老王\\\",\\\"sex\\\":\\\"famle\\\",\\\"age\\\":20}\\n# 将python字典转换成json数据\\ndata_json=json.dumps(data_dict)\\n## 如果有中文，可以带上ensure_ascii=False来确保中文正常转换\\ndata_json=json.dumps(data_dict,ensure_ascii=False)\\n# 将json数据转换成python字典\\ndata_dumps=json.loads(data_json)\\n```\\n\\n关机json数据格式测试案例：\\n![](https://s3.bmp.ovh/imgs/2022/10/16/321d1c102158afa7.png)\\n![](https://s3.bmp.ovh/imgs/2022/10/16/3429e2e7a286ce02.png)\\n\\n2、pyecharts模块介绍和快速入门\\n\\nEcharts 是个由百度开源的数据可视化，凭借着良好的交互性，精巧的图表设计，得到了众多开发者的认可。而 Python 是门富有表达力的语言，很适合用于数据处理。\\n\\n开发可视化图表，需要用到这个包。[官方示例文档](https://gallery.pyecharts.org/#/README)\\n\\n2.1 画一个基础折线图：\\n\\n```python\\n# 导包，导入Line功能来构建折线图\\nfrom pyecharts.charts import Line\\n\\n# 得到折线图对象\\nline=Line()\\n# 添加x/y轴数据   axis的意思是轴\\nline.add_xaxis([\\\"中国\\\",\\\"美国\\\",\\\"英国\\\"])\\nline.add_yaxis(\\\"GDP\\\",[30,20,10])\\n# 生成图表  render使成为，使表现\\nline.render()\\n```\\n\\n2.2 pyecharts的全局配置和系列配置选项\\n\\n全局配置项可以做很多工作：\\n\\n> 配置图表的标题\\n>\\n> 配置图例\\n>\\n> 配置鼠标移动效果\\n>\\n> 配置工具栏\\n>\\n> 等整体配置项\\n\\n代码示例：\\n\\n```python\\nline.set_global_opts(\\n\\ttitle_opts=TitleOpts(\\\"测试\\\"，pos_left=\\\"center\\\",pos_bottom=\\\"1%\\\"),\\n\\tlegend_opts=LegenfOpts(is_show=True),\\n\\tvisualmap_opts=VisualMapOpts(is_show=True),\\n\\ttoolbox_opts=ToolboxOpts(is_show=True),\\n\\ttooltip_opts=TooltipOpts(is_show=True),\\n)\\n```\\n\\n系列配置：\\n先导入包：\\n\\n```python\\nfrom pyecharts.charts import Line\\nimport pyecharts.options as opts\\n```\\n\\n然后，折线图的相关配置选项\\n![](https://s3.bmp.ovh/imgs/2022/10/16/1e3610da99f33f5b.png)\\n然后，y轴坐标的配置选项\\n![](https://s3.bmp.ovh/imgs/2022/10/16/fd22b3bc8c11fd9a.png)\\n然后，全局配置选项\\n![](https://s3.bmp.ovh/imgs/2022/10/16/fb1a846ba437877c.png)\\n代码示例：\\n\\n```python\\nfrom pyecharts.charts import Line\\nimport pyecharts.options as opts\\n\\nl=(\\n\\tLine(init_opts=opts.InitIpts(width=\\\"1600px\\\",height=\\\"800px\\\"))\\n\\t.add_xaxis(xaxis_data=x1_data[0,-1,2])\\n\\t.add_yaxix(\\n\\t\\tseriwa_name=\\\"美国确诊人数\\\"，\\n\\t\\ty_axix=y1_data[0；-1]，\\n\\t\\tsymbol_size=10,\\n\\t\\tlabel_opts=opts.LabelOpts(is_show=False),\\n\\t\\tlinestyle_opts=opts.LineStyleOpts(width=2)\\n\\t\\t)\\n\\t.set_global_opts(\\n        title_opts=opts.TitleOpts(title=\\\"测试\\\"，\\tpos_left=\\\"center\\\",pos_bottom=\\\"1%\\\"),\\n       xaxis_opts=opts.AxisOpts(name=\\\"时间\\\")，\\n       yaxis_opts=opts.AxisOpts(name=\\\"累计确诊人数\\\")，\\n       legend_opts=opts.LegendOpts(pos_left=\\\"70%\\\"),\\n\\t\\t)\\n\\t)\\n```\\n\\n#### 15.2 地图\\n\\n从pyecharts导入模块Map和VisualMapOpts\\n\\n```python\\nfrom pyecharts.charts import Map\\nfrom pyecharts.options import VisualMapOpts\\n```\\n\\n然后就是导入数据，设置格式，显示图片，略。\\n\\n\\n\\n#### 15.3 动态展示柱状图\\n\\n从pyecharts导入模块Bar\\n1、基础柱状图\\n\\n```python\\nfrom pyecharts.charts import Bar  # 基础柱状图\\nbar=Bar()\\nbar.add_xaxis([\\\"中国\\\",\\\"因果\\\",\\\"美国\\\"])\\nbar.add_yaxis(\\\"GDP\\\",[10,20,30])\\nbar.render(\\\"基础柱状图.html\\\")\\n```\\n\\n反转x、y轴：`bar.reversal_axis()`\\n设置数值标签在右侧：`bar.add_yaxis(\\\"GDP\\\",[10,20,30],label_opts=LabelOpts(position=\\\"right\\\"))`\\n\\n2、基础时间线柱状图\\n\\n> 掌握基础的时间线配置动态图表\\n>\\n> 掌握设置主题更改颜色样式\\n\\n柱状图描述的是分类数据，回答的是每一个分类中『有多少？』这个问题. 这是柱状图的主要特点,同时柱状图很难动态的描述一个趋势性的数据. 这里pyecharts为我们提供了一种解决方案-<font color=\'red\'>时间线</font>\\n\\n如果说一个Bar、Line对象是一张图表的话，时间线就是创建一个一维的x轴，轴上每一个点就是一个图表对象。要导入TimeLine模块：`from pyecharts.charts import Bar,TimeLine`。代码示例如下：\\n\\n```python\\nfrom pyecharts.chrts import Bar,TimeLine\\nfrom pyecharts.options import *\\n\\nbar1=Bar()\\nbar1.add_xaxis([\\\"中国\\\",\\\"因果\\\",\\\"美国\\\"])\\nbar1.add_yaxis(\\\"GDP\\\",[10,20,30],label_opts=LabelOpts(position=\\\"right\\\"))\\nbar1.reversal_axis()\\n\\nbar2=Bar()\\nbar2.add_xaxis([\\\"中国\\\",\\\"因果\\\",\\\"美国\\\"])\\nbar2.add_yaxis(\\\"GDP\\\",[30,50,20],label_opts=LabelOpts(position=\\\"right\\\"))\\nbar2.reversal_axis()\\n\\n# 创建时间线对象\\ntimeline=TimeLine()\\n# 将柱状图添加到时间线对象中\\ntimeline.add(baar1,\\\"2021年GDP\\\")\\ntimeline.add(bar2,\\\"2022年GDP\\\")\\n# 通过时间线绘图\\ntimeline.render(\\\"基础柱状图-时间线.html\\\")\\n\\n## 设置自动播放\\ntimeline.add_schema(\\n\\tplay_interval=1000,     # 自动播放的时间间隔，单位毫秒\\n\\tis_timeline_show=True,  # 是否在自动播放时，显示时间线\\n\\tis_auto_play=True,      # 是否自动播放\\n\\tis_loop_play=True,      # 是否循环自动播放\\n)\\n```\\n\\n时间线设置主题：\\n\\n```python\\nfrom pyecharts.global import ThemeType\\n# 创建时间线对象\\ntimeline=TimeLine(\\n\\t{\\\"theme\\\":ThemeType.LIGHT}\\n)\\n```\\n\\n主题的其他配置选项见下图：\\n![](https://s3.bmp.ovh/imgs/2022/10/16/ee45d67c9af77da8.png)\\n\\n3、动态柱状图绘制\\n\\n> 1. 掌握列表的sort方法并配合lambda匿名函数完成列表排序\\n>\\n> 2. 完成图表所需的数据处理\\n>\\n> 3. 完成GDP动态图表绘制\\n\\n3.1 需求分析\\n\\n简单分析后，发现最终效果图中需要：\\n\\n1. GDP数据处理为亿级\\n2. 有时间轴，按照年份为时间轴的点\\n3. x轴和y轴反转，同时每一年的数据只要前8名国家\\n4. 有标题，标题的年份会动态更改\\n5. 设置了主题为LIGHT\\n\\n最终效果图：\\n![](https://s3.bmp.ovh/imgs/2022/10/16/7c6087271250c484.png)\\n\\n代码示例：\\n\\n1、处理数据\\n![](https://s3.bmp.ovh/imgs/2022/10/16/0b6ffdafd38e7a38.png)\\n![](https://s3.bmp.ovh/imgs/2022/10/16/199b4d8405330400.png)\\n\\n2、准备时间线\\n![](https://s3.bmp.ovh/imgs/2022/10/16/5d1c21a705f36697.png)\\n\\n3、自动播放和绘图\\n![](https://s3.bmp.ovh/imgs/2022/10/16/379d6908a207ba41.png)\\n\\n\\n\\n\\n### 16、python中的类与对象（封装、继承与多态）\\n\\n#### 16.1、类的封装与定义（方法、属性）\\n\\n1、关键点：掌握类的定义和使用，掌握成员方法的使用，掌握self关键字的作用（self是不是与c++的this指针很像？）\\n\\n```python\\nclass Student:\\n\\tname=None\\n\\tage=None\\n\\tdef say_hi(self):\\n\\t\\tprintf(f\\\"Hi,{self.name}!\\\")\\n\\n# 调用\\nstu=Student()\\nstu.name=HaoY\\nstu.say_hi()\\n```\\n\\n从上述实例可以看出类中有属性（成员变量），有方法（成员方法）。可以看到，类中定义的方法和外面定义的函数时非常类似的，仍需注意一点的是，类中方法的第一个形参必须是self，方法中调用类内属性时，必须使用self指针；类外调用方法时，不用填充第一个形参self。\\n使用构造方法，通过传参的方式初始化类的对象（是不是与c++的构造函数很相似）\\n\\n2、self的作用\\n\\n+ 表示类对象本身的意思\\n+ 只有通过self，成员方法才能访问类的成员变量\\n+ self出现在形参列表中，但不占用参数位置，无需理会\\n\\n3、类的构造方法：使用`__init__`来实现类对象的初始化：\\n\\n```python\\n# 该方法在构建类对象时，会自动运行：stu=Student(\\\"HaoY\\\",23,1100992)\\ndef __init__(self,name,age,tel)\\n\\tself.name=name\\n\\tself.age=age\\n\\tself.tel=tel\\n```\\n\\n4、掌握python的其他内置方法  （类中的内置方法）\\n上文学习的`__init__` 构造方法，是Python类内置的方法之一。这些内置的类方法，各自有各自特殊的功能，这些内置方法我们称之为：魔术方法。（以下部分内置方法为常用的）\\n\\n> `__init__`：类的构造方法\\n>\\n> `__str__`：字符串方法\\n>\\n> `__lt__` 和 `__gt__`：小于、大于符号比较\\n>\\n> `__le__`  和  `__ge__` ：小于等于、大于等于符号比较\\n>\\n> `__eq__`：等于符号比较\\n\\n4.1 `__str__`方法\\n\\n直接print(对象)，输出的结果是对象的内存地址。这个地址在python中没啥用。我们可以在类中新增`__str__`方法，这样当使用print(对象)时，输出的就是我们指定的字符串了。示例如下：\\n\\n```python\\nclass Student:\\n\\tdef __init__(self,name,age):\\n\\t\\tself.name=name\\n\\t\\tself.age=age\\n\\n# 测试  （不使用__str__方法）\\nstu=Student(\\\"HaoY\\\",23)\\nprint(stu)   # 输出： <__main.Student object at 0x000002200CFD6040>\\nprint(str(stu)) # 输出： <__main.Student object at 0x000002200CFD6040>\\n--------------------------------------------------------------\\nclass Student:\\n\\tdef __init__(self,name,age):\\n\\t\\tself.name=name\\n\\t\\tself.age=age\\n\\tdef __str__(self):\\n\\t\\treturn f\\\"哈哈，你看到我了吗？\\\"\\n\\n# 测试   （使用__str__方法）\\nstu=Student(\\\"HaoY\\\",23)\\nprint(stu)   # 输出： 哈哈，你看到我了吗？\\nprint(str(stu)) # 输出： 哈哈，你看到我了吗？\\n```\\n\\n4.2 `__lt__`  /  `__gt__`小于/大于符号比较方法\\n\\n注意，直接用小于/大于福来来比较两个类对象，是错误的用法。但是在类中添加了`__lt__`内置方法后，就可以实现直接用大于小于符号来比较两个类对象的操作了。（有点像c++的重载大于小于操作符的方法）\\n\\n```python\\nclass Student:\\n\\tdef __init(self,name,age):\\n\\t\\tself.name=name\\n\\t\\tself.age=age\\n\\n\\tdef __lt__(self,other):\\n\\t\\treturn self.age < other.age\\n# 测试\\nstu1=Student(\\\"HaoY\\\",23)\\nstu2=Student(\\\"WuMan\\\",22)\\nprint(stu1<stu2)  # 结果： False\\nprint(stu1>stu2)  # 结果： True  注意，实现大于符号需要写`def __gt__`，上面的类未实现\\n```\\n\\n4.3 `__le__`  /  `__ge__`小于等于 / 大于等于符号比较方法\\n\\n与4.2内容相似。还有`__eq__`也是类似的用法。\\n\\n5、类的封装：私有成员变量/方法的设置（注意与c++的不同）\\n\\n如何定义私有变量和私有方法？\\n\\n答：在变量名和方法名前，加上两个下划线即可。`__name`和`def __keep_score(self)`\\n\\n私有变量只能在类内使用，不能被对象调用。不能被对象赋值，不能被对象读值。在类内的方法中，通过self来调用私有变量。\\n\\n```python\\npthon.__name=\\\"HaoY\\\"   # 不报错，但无效\\nprint(pthon.__name)   # 报错，无法使用\\n```\\n\\n#### 16.2、类的继承\\n\\n单继承：\\n\\n```python\\n# 父类\\nclass Phone:\\n\\tIMEI=None\\n\\tproducer=None\\n\\n# 子类  继承表示：将从父类那里继承（复制）来成员变量和成员方法（不含私有）\\nclass Xiao(Phone)\\n\\tface_id=True\\n\\n```\\n\\n多继承（多父类的同名函数问题，继承顺序问题）还有pass关键字\\n\\n```python\\nclass Phone:\\n\\tIMEI=None\\n\\tproducer=None\\n\\nclass Ss:\\n\\tface_id=True\\n\\nclass Bb:\\n\\tface_chec=True\\n\\tproducer=\\\"HM\\\"\\n\\t\\nclass MyPhone(Phone,Ss,Bb)\\n\\tpass\\n\\n## 温馨提示：关于多继承的优先级问题\\n如上所示，子类MyPhone继承了三个类，而父类Phone和父类Ss都有成员属性producer，并且这个属性是公共属性并非私有属性。那么，在子类中使用该变量时（假设子类未重新定义该变量），子类实际调用的哪个父类的属性呢？\\n\\n答案：继承优先级从左到右，优先级从高到底。所以，子类调用producer属性时，输出None而不是HM。\\n```\\n\\n复写：（与C++的虚函数类似）在子类中 重新定义同名的属性或方法即可\\n\\n一般在子类复写了父类方法后，在子类调用该方法就是调用子类中的方法。那有什么方式可以再子类中调用父类方法吗？\\n\\n```python\\n## 前提：只能在子类内调用父类的同名成员。子类的类对象直接调用会调用子类复写的成员\\n# 方式一：\\n使用子类中的父类变量/方法来调用\\n调用变量：父类成员.变量\\n调用方法：父类成员.成员方法(self)\\n# 方法二：\\n使用super()调用父类变量/方法\\n调用变量：super().变量\\n调用方法：super().方法\\n```\\n\\n#### 16.3、类的多态\\n\\n在C++中的多态有两种，一是函数多态，根据形参数据类数量和位置的不同，产生多态行为；而是类中函数为纯虚函数，此时类为抽象类，子类继承该父类并重新父类方法是另一种多台。\\n\\npython中没有函数多态，只有类的抽象继承。\\n父类定义方法，但不实现，子类重新定义方法并实现。这样就实现了父类一个方法有多种输出结果的多态。示例;\\n\\n```python\\nclass father:\\n\\tdef speak():\\n\\t\\tpass\\nclass son1:\\n\\tdef speak()\\n\\t\\tprint(\\\"哇哇哇\\\")\\nclass son2:\\n\\tdef speak()\\n\\t\\tprint(\\\"哈哈哈\\\")\\n```\\n\\n>抽象类：含有抽象方法的类称之为抽象类\\n>\\n>抽象方法：方法体是空实现的（pass）称之为抽象方法\\n\\n\\n\\n#### 16.4、类型注解问题（ctrl+p弹出函数传参提示）\\n\\nPython3.5引入了类型注解，它的功能是方便静态类型检查工具、IDE等第三方工具，来为编程提供便利和提前排错。\\n\\n主要功能：\\n\\n+ 帮助第三方IDE工具（如PyCharm）对代码进行类型推断，协助做代码提示\\n+ \\n+ 帮助开发者自身对变量进行类型注释（备注）\\n\\n类型注解分为变量注解、函数（方法）形参列表和返回值注解和Union类型注解。注解只是提示性的，不是决定性的，不会真正的对类型做验证和判断。\\n\\n##### 16.4.1 变量的注解\\n\\n```python\\n# 基本语法： 变量：类型\\n# 1、基础数据类型注解\\nvar_1： int = 10\\nvar_2: float=3.12\\nvar_3: bool=True\\nvar_4: str=\\\"itheima\\\"\\n#2、类对象的类型注解\\nclass Student:\\n\\tpass\\nstu:student=Sthdent()\\n#3、基础容器注解\\nmy_list:list=[1,2,3]\\nmy_tuple:tuple=(1,2,3)\\nmy_set:set={1,2,3}\\nmy_dict:dict={\\\"Aa\\\":1,\\\"Bb\\\":2}\\nmy_str:str=\\\"itheima\\\"\\n#4、容器类型详细注解\\n## 注意：\\n### + 元组类型设置类型详细注解，需要将每一个元素都标记出来。注意哦，元组很特殊，需要把每一个元素类型都标列出来\\n### + 字典类型设置类型详细注解，需要2个类型，第一个是key第二个是value\\nmy_list:list[int]=[1,2,3]\\nmy_tuple:tuple[int]=(1,2,3)\\nmy_set:set[int]={1,2,3}\\nmy_dict:dict[str,int]={\\\"Aa\\\":1,\\\"Bb\\\":2}\\n\\n# 注意，警告！下面这种复合数据类型的写法，只在python3.9后才支持的。在python3.5~python3.9之间，对于复合型的数据类型，请使用Union类型\\nmy_list:list[int,str,float]=[1,\\\"2\\\",3.12]\\nmy_tuple:tuple[int,str,float]=(1,\\\"2\\\",3.12)\\nmy_set:set[int,str,float,bool]={1,\\\"2\\\",3.12,True}\\n```\\n\\n除了使用`变量：类型`的方式注解外，也可以在注释中进行类型注解\\n语法：`#type:类型`\\n\\n```python\\nvar_1=random.randint(1,10)  #type:int\\nvar_2=json,loads(data)      #type:dict[str,int]\\nvar_3=func()                #type:Student\\n```\\n\\n一般直接定义的普通变量无需注解，一般能看出它的类型，但是存储函数返回值、类对象的返回值的变量，可能很难直接看出它的数据类型，所以需要注解：\\n\\n```python\\n#小总结，第一种注解方式：\\nvar_1:int=random.randint(1,10) \\nvar_2:dict=json,loads(data)    \\nvar_3:Student=func()\\n# 第二种注解方式  在注释中：\\nvar_1=random.randint(1,10)  #type:int\\nvar_2=json,loads(data)      #type:dict[str,int]\\nvar_3=func()                #type:Student\\n```\\n\\n##### 16.4.2 函数（方法）的类型注解\\n\\n1、形参注解\\n语法形式：\\n\\n```python\\ndef 函数方法名(形参名1：类型1，形参名2：类型2，...):\\n\\tpass\\n```\\n\\n2、返回值注解\\n语法形式：\\n\\n```python\\ndef 函数方法名(形参名1：类型1，形参名2：类型2，...) -> 返回值类型：\\n\\tpass\\n```\\n\\n综合示例：\\n\\n```python\\ndef add(x:int,y:int) -> int:\\n\\treturn x+y\\ndef func(data:list[int]) -> list[int]\\n\\tpass\\n```\\n\\n##### 16.4.3 Union类型的注解\\n\\n在含有多种数据类型的数据容器中进行类型注释，就需要一点技巧了。Union类型就是解决这一问题的方法之一。\\n\\n先导包：`from typing import Union`\\n对于单一数据类型的容器或函数形参/返回值注解，可以直接使用：\\n\\n```python\\nmy_list:list[int]=[1,2,3]\\nmy_dict:dict[str,int]={\\\"HM\\\":11,\\\"ds\\\":22}\\n```\\n\\n对于含有多种数据类型的容器或函数形参、返回值，就需要Union类型的帮助了。\\n\\n```python\\n# 也可以将复合的这几种数据类型拆开，不过这种写法只在python3.9后才支持\\n# my_list:list[int,str]=[1,2,\\\"HM\\\",\\\"lalala\\\"]\\n\\nfrom typing import Union\\nmy_list:list[Union[str,int]]=[1,2,\\\"HM\\\",\\\"lalala\\\"]\\nmy_dict:dict[str,Union[str,int]]={\\\"HM\\\":11,\\\"sanaj\\\":\\\"heihie\\\"}\\n# 使用Union[类型,类型,...]，\\n# 可以实现联合类型注解  在函数形参和返回值上，也是可以用的：\\ndef func(data:Union[int,str]) -> Union[int,str]:\\n\\tpass\\n```\",\"articleCover\":\"https://upload.haoxx.site/article/79db75241acafdd2e58deb66960c3e25.jpg\",\"articleTitle\":\"Python学习思路\",\"articleType\":1,\"categoryName\":\"编程语言基础\",\"id\":79,\"isRecommend\":0,\"isTop\":0,\"status\":1,\"tagNameList\":[]}]','PUT','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',27,'2023-06-07 20:02:59');
INSERT INTO `t_operation_log` VALUES (1414,'照片模块','删除','/admin/photo/delete','com.ican.controller.PhotoController.deletePhoto','删除照片','[[37,38]]','DELETE','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',15,'2023-06-07 20:04:04');
INSERT INTO `t_operation_log` VALUES (1415,'说说模块','添加','/admin/talk/add','com.ican.controller.TalkController.addTalk','添加说说','[{\"images\":\"\",\"isTop\":0,\"status\":1,\"talkContent\":\"账户登录问题还没弄好<img src=\\\"https://static.ttkwsd.top/emoji/daku.png\\\" width=\\\"24\\\" height=\\\"24\\\" alt=\\\"[大哭]\\\" style=\\\"margin: 0 1px;vertical-align: text-bottom\\\">\"}]','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',23,'2023-06-07 20:04:46');
INSERT INTO `t_operation_log` VALUES (1416,'文件模块','上传','/admin/file/upload','com.ican.controller.BlogFileController.uploadFile','上传文件','0639b8855aab4dcbb827a9884e8ec57d.jpg','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',19,'2023-06-07 20:09:35');
INSERT INTO `t_operation_log` VALUES (1417,'文件模块','上传','/admin/file/upload','com.ican.controller.BlogFileController.uploadFile','上传文件','c8049b9b880411ebb6edd017c2d2eca2.jpg','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',18,'2023-06-07 20:11:52');
INSERT INTO `t_operation_log` VALUES (1418,'文件模块','上传','/admin/file/upload','com.ican.controller.BlogFileController.uploadFile','上传文件','e3408389cb0d4ea1b5f651873dab2a19.jpg','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',20,'2023-06-07 20:13:01');
INSERT INTO `t_operation_log` VALUES (1419,'文件模块','添加','/admin/file/createFolder','com.ican.controller.BlogFileController.createFolder','创建目录','[{\"fileName\":\"首页背景轮播图\",\"filePath\":\"/config\"}]','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',22,'2023-06-07 20:13:40');
INSERT INTO `t_operation_log` VALUES (1420,'文件模块','上传','/admin/file/upload','com.ican.controller.BlogFileController.uploadFile','上传文件','510b81cfad5336fcb71305295a92a7bcace8c19c.jpg','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',19,'2023-06-07 20:17:12');
INSERT INTO `t_operation_log` VALUES (1421,'文件模块','上传','/admin/file/upload','com.ican.controller.BlogFileController.uploadFile','上传文件','fa1bd88bd08ed77ec2d960fe7733aa23b30ba702.jpg','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',14,'2023-06-07 20:17:12');
INSERT INTO `t_operation_log` VALUES (1422,'文件模块','上传','/admin/file/upload','com.ican.controller.BlogFileController.uploadFile','上传文件','e0b14abb7a628a3706007c2f7f252f43ef747778.jpg','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',18,'2023-06-07 20:17:13');
INSERT INTO `t_operation_log` VALUES (1423,'文件模块','上传','/admin/file/upload','com.ican.controller.BlogFileController.uploadFile','上传文件','c522d219de91d5a14e6468d950ab39b32e2a9443.jpg','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',12,'2023-06-07 20:17:13');
INSERT INTO `t_operation_log` VALUES (1424,'文件模块','删除','/admin/file/delete','com.ican.controller.BlogFileController.deleteFile','删除文件','[[218,219,220,221]]','DELETE','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',15,'2023-06-07 20:17:47');
INSERT INTO `t_operation_log` VALUES (1425,'文件模块','删除','/admin/file/delete','com.ican.controller.BlogFileController.deleteFile','删除文件','[[217]]','DELETE','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',35,'2023-06-07 20:17:52');
INSERT INTO `t_operation_log` VALUES (1426,'文件模块','添加','/admin/file/createFolder','com.ican.controller.BlogFileController.createFolder','创建目录','[{\"fileName\":\"indexlist\",\"filePath\":\"/config\"}]','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',14,'2023-06-07 20:18:13');
INSERT INTO `t_operation_log` VALUES (1427,'文件模块','上传','/admin/file/upload','com.ican.controller.BlogFileController.uploadFile','上传文件','510b81cfad5336fcb71305295a92a7bcace8c19c.jpg','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',13,'2023-06-07 20:18:20');
INSERT INTO `t_operation_log` VALUES (1428,'文件模块','上传','/admin/file/upload','com.ican.controller.BlogFileController.uploadFile','上传文件','c522d219de91d5a14e6468d950ab39b32e2a9443.jpg','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',16,'2023-06-07 20:18:20');
INSERT INTO `t_operation_log` VALUES (1429,'文件模块','上传','/admin/file/upload','com.ican.controller.BlogFileController.uploadFile','上传文件','fa1bd88bd08ed77ec2d960fe7733aa23b30ba702.jpg','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',14,'2023-06-07 20:18:21');
INSERT INTO `t_operation_log` VALUES (1430,'文件模块','上传','/admin/file/upload','com.ican.controller.BlogFileController.uploadFile','上传文件','e0b14abb7a628a3706007c2f7f252f43ef747778.jpg','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',14,'2023-06-07 20:18:21');
INSERT INTO `t_operation_log` VALUES (1431,'文件模块','上传','/admin/file/upload','com.ican.controller.BlogFileController.uploadFile','上传文件','379ce4b2ddf4b087441c196fbffa2f3b.jpg','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',17,'2023-06-07 20:19:55');
INSERT INTO `t_operation_log` VALUES (1432,'文件模块','上传','/admin/file/upload','com.ican.controller.BlogFileController.uploadFile','上传文件','0d7d8d691e644989b72ddda5f695aca2.jpg','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',18,'2023-06-07 20:29:23');
INSERT INTO `t_operation_log` VALUES (1433,'网站配置模块','修改','/admin/site/update','com.ican.controller.SiteConfigController.updateSiteConfig','更新网站配置','[{\"aboutMe\":\"🍀个人简介\\n\\n普通人\",\"aliCode\":\"https://upload.haoxx.site/cloud/images/image_2.jpg\",\"articleCover\":\"https://upload.haoxx.site/config/27c7f38a329c07159a80315712680ea5.jpg\",\"authorAvatar\":\"https://upload.haoxx.site/config/5bbb6dc8be42f3e96dbcc7d7529dc402.gif\",\"bilibili\":\"https://space.bilibili.com/505715511\",\"commentCheck\":0,\"createSiteTime\":\"2023-06-06\",\"emailNotice\":1,\"gitee\":\"https://gitee.com/wu_shengdong\",\"github\":\"https://github.com/XiaoYuer2022\",\"id\":1,\"isMusic\":1,\"isReward\":0,\"loginList\":\",gitee,qq\",\"messageCheck\":0,\"musicId\":\"7611185981\",\"qq\":\"508506630\",\"recordNumber\":\"渝ICP备2023001651号-2\",\"siteAddress\":\"https://www.haoxx.site\",\"siteAuthor\":\"小鱼\",\"siteIntro\":\"网站介绍\",\"siteName\":\"HaoXX`s Blog\",\"siteNotice\":\"个人学习资料记录\",\"socialList\":\"gitee,bilibili,github,qq\",\"touristAvatar\":\"https://upload.haoxx.site/config/0b04691f25e400a708caba867be171d0.jpg\",\"userAvatar\":\"https://upload.haoxx.site/config/e94fc60e58a570ecc3e9ddcb334fdb2b.jpg\",\"weiXinCode\":\"https://upload.haoxx.site/cloud/images/image_1.jpg\"}]','PUT','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',281,'2023-06-08 16:18:23');
INSERT INTO `t_operation_log` VALUES (1434,'网站配置模块','修改','/admin/site/update','com.ican.controller.SiteConfigController.updateSiteConfig','更新网站配置','[{\"aboutMe\":\"🍀个人简介\\n\\n普通人\",\"aliCode\":\"https://upload.haoxx.site/cloud/images/image_2.jpg\",\"articleCover\":\"https://upload.haoxx.site/config/27c7f38a329c07159a80315712680ea5.jpg\",\"authorAvatar\":\"https://upload.haoxx.site/config/5bbb6dc8be42f3e96dbcc7d7529dc402.gif\",\"bilibili\":\"https://space.bilibili.com/263844591\",\"commentCheck\":0,\"createSiteTime\":\"2023-06-06\",\"emailNotice\":1,\"gitee\":\"https://gitee.com/wu_shengdong\",\"github\":\"https://github.com/XiaoYuer2022\",\"id\":1,\"isMusic\":1,\"isReward\":0,\"loginList\":\",gitee,qq\",\"messageCheck\":0,\"musicId\":\"7611185981\",\"qq\":\"508506630\",\"recordNumber\":\"渝ICP备2023001651号-2\",\"siteAddress\":\"https://www.haoxx.site\",\"siteAuthor\":\"小鱼\",\"siteIntro\":\"网站介绍\",\"siteName\":\"HaoXX`s Blog\",\"siteNotice\":\"个人学习资料记录\",\"socialList\":\"gitee,bilibili,github,qq\",\"touristAvatar\":\"https://upload.haoxx.site/config/0b04691f25e400a708caba867be171d0.jpg\",\"userAvatar\":\"https://upload.haoxx.site/config/e94fc60e58a570ecc3e9ddcb334fdb2b.jpg\",\"weiXinCode\":\"https://upload.haoxx.site/cloud/images/image_1.jpg\"}]','PUT','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',16,'2023-06-08 16:19:48');
INSERT INTO `t_operation_log` VALUES (1435,'网站配置模块','修改','/admin/site/update','com.ican.controller.SiteConfigController.updateSiteConfig','更新网站配置','[{\"aboutMe\":\"🍀个人简介\\n\\n普通人\",\"aliCode\":\"https://upload.haoxx.site/cloud/images/image_2.jpg\",\"articleCover\":\"https://upload.haoxx.site/config/27c7f38a329c07159a80315712680ea5.jpg\",\"authorAvatar\":\"https://upload.haoxx.site/config/5bbb6dc8be42f3e96dbcc7d7529dc402.gif\",\"bilibili\":\"https://space.bilibili.com/263844591\",\"commentCheck\":0,\"createSiteTime\":\"2023-06-06\",\"emailNotice\":1,\"gitee\":\"https://gitee.com/haoxxown\",\"github\":\"https://github.com/XiaoYuer2022\",\"id\":1,\"isMusic\":1,\"isReward\":0,\"loginList\":\",gitee,qq\",\"messageCheck\":0,\"musicId\":\"7611185981\",\"qq\":\"508506630\",\"recordNumber\":\"渝ICP备2023001651号-2\",\"siteAddress\":\"https://www.haoxx.site\",\"siteAuthor\":\"小鱼\",\"siteIntro\":\"网站介绍\",\"siteName\":\"HaoXX`s Blog\",\"siteNotice\":\"个人学习资料记录\",\"socialList\":\"gitee,bilibili,github,qq\",\"touristAvatar\":\"https://upload.haoxx.site/config/0b04691f25e400a708caba867be171d0.jpg\",\"userAvatar\":\"https://upload.haoxx.site/config/e94fc60e58a570ecc3e9ddcb334fdb2b.jpg\",\"weiXinCode\":\"https://upload.haoxx.site/cloud/images/image_1.jpg\"}]','PUT','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',15,'2023-06-08 16:20:02');
INSERT INTO `t_operation_log` VALUES (1436,'网站配置模块','修改','/admin/site/update','com.ican.controller.SiteConfigController.updateSiteConfig','更新网站配置','[{\"aboutMe\":\"🍀个人简介\\n\\n普通人\",\"aliCode\":\"https://upload.haoxx.site/cloud/images/image_2.jpg\",\"articleCover\":\"https://upload.haoxx.site/config/27c7f38a329c07159a80315712680ea5.jpg\",\"authorAvatar\":\"https://upload.haoxx.site/config/5bbb6dc8be42f3e96dbcc7d7529dc402.gif\",\"bilibili\":\"https://space.bilibili.com/263844591\",\"commentCheck\":0,\"createSiteTime\":\"2023-06-06\",\"emailNotice\":1,\"gitee\":\"https://gitee.com/haoxxown\",\"github\":\"https://github.com/XiaoYuer2022\",\"id\":1,\"isMusic\":1,\"isReward\":0,\"loginList\":\",gitee,qq,github\",\"messageCheck\":0,\"musicId\":\"7611185981\",\"qq\":\"508506630\",\"recordNumber\":\"渝ICP备2023001651号-2\",\"siteAddress\":\"https://www.haoxx.site\",\"siteAuthor\":\"小鱼\",\"siteIntro\":\"网站介绍\",\"siteName\":\"HaoXX`s Blog\",\"siteNotice\":\"个人学习资料记录\",\"socialList\":\"gitee,bilibili,github,qq\",\"touristAvatar\":\"https://upload.haoxx.site/config/0b04691f25e400a708caba867be171d0.jpg\",\"userAvatar\":\"https://upload.haoxx.site/config/e94fc60e58a570ecc3e9ddcb334fdb2b.jpg\",\"weiXinCode\":\"https://upload.haoxx.site/cloud/images/image_1.jpg\"}]','PUT','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',76,'2023-06-08 18:38:59');
INSERT INTO `t_operation_log` VALUES (1437,'网站配置模块','修改','/admin/site/update','com.ican.controller.SiteConfigController.updateSiteConfig','更新网站配置','[{\"aboutMe\":\"🍀个人简介\\n\\n普通人\",\"aliCode\":\"https://upload.haoxx.site/cloud/images/image_2.jpg\",\"articleCover\":\"https://upload.haoxx.site/config/27c7f38a329c07159a80315712680ea5.jpg\",\"authorAvatar\":\"https://upload.haoxx.site/config/5bbb6dc8be42f3e96dbcc7d7529dc402.gif\",\"bilibili\":\"https://space.bilibili.com/263844591\",\"commentCheck\":0,\"createSiteTime\":\"2023-06-06\",\"emailNotice\":1,\"gitee\":\"https://gitee.com/haoxxown\",\"github\":\"https://github.com/XiaoYuer2022\",\"id\":1,\"isMusic\":1,\"isReward\":0,\"loginList\":\",gitee,github\",\"messageCheck\":0,\"musicId\":\"7611185981\",\"qq\":\"508506630\",\"recordNumber\":\"渝ICP备2023001651号-2\",\"siteAddress\":\"https://www.haoxx.site\",\"siteAuthor\":\"小鱼\",\"siteIntro\":\"网站介绍\",\"siteName\":\"HaoXX`s Blog\",\"siteNotice\":\"个人学习资料记录\",\"socialList\":\"gitee,bilibili,github,qq\",\"touristAvatar\":\"https://upload.haoxx.site/config/0b04691f25e400a708caba867be171d0.jpg\",\"userAvatar\":\"https://upload.haoxx.site/config/e94fc60e58a570ecc3e9ddcb334fdb2b.jpg\",\"weiXinCode\":\"https://upload.haoxx.site/cloud/images/image_1.jpg\"}]','PUT','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'阿冬','183.230.12.181','中国|重庆|重庆市|移动',73,'2023-06-08 18:53:35');
/*!40000 ALTER TABLE `t_operation_log` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `t_photo`
--

DROP TABLE IF EXISTS `t_photo`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `t_photo` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '照片id',
  `album_id` int NOT NULL COMMENT '相册id',
  `photo_name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '照片名',
  `photo_desc` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT NULL COMMENT '照片描述',
  `photo_url` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '照片链接',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=68 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_photo`
--

LOCK TABLES `t_photo` WRITE;
/*!40000 ALTER TABLE `t_photo` DISABLE KEYS */;
INSERT INTO `t_photo` VALUES (28,2,'1666408200108249090',NULL,'https://upload.haoxx.site/photo/3a10aa097584f54f8b871ad0fc8668e6.png','2023-06-07 19:34:10',NULL);
INSERT INTO `t_photo` VALUES (29,2,'1666408219280412673',NULL,'https://upload.haoxx.site/photo/20ec88f94bff808a8bcdbbd7e00c08cd.png','2023-06-07 19:34:15',NULL);
INSERT INTO `t_photo` VALUES (30,2,'1666408234300215297',NULL,'https://upload.haoxx.site/photo/b7cc08bb88c6ef808f23b3202d5763eb.png','2023-06-07 19:34:18',NULL);
INSERT INTO `t_photo` VALUES (31,2,'1666408248804118530',NULL,'https://upload.haoxx.site/photo/47fae86680ce79a7ed24d7237c1d16dc.png','2023-06-07 19:34:22',NULL);
INSERT INTO `t_photo` VALUES (32,2,'1666408263677120513',NULL,'https://upload.haoxx.site/photo/84e8bfe1bdfb66b1da75e06ca2c9fc33.png','2023-06-07 19:34:25',NULL);
INSERT INTO `t_photo` VALUES (33,2,'1666408287328800770',NULL,'https://upload.haoxx.site/photo/630cb06c3086ffba6fb203a5a3ae317b.png','2023-06-07 19:34:31',NULL);
INSERT INTO `t_photo` VALUES (34,2,'1666408313991991298',NULL,'https://upload.haoxx.site/photo/05438e1a57a775323713c45100ac9b5f.png','2023-06-07 19:34:37',NULL);
INSERT INTO `t_photo` VALUES (35,2,'1666408330710487042',NULL,'https://upload.haoxx.site/photo/a55a1d964faddbc271c37e56f0588cde.png','2023-06-07 19:34:41',NULL);
INSERT INTO `t_photo` VALUES (36,2,'1666408346246189057',NULL,'https://upload.haoxx.site/photo/c0bdec69bc1cc87001a1903296feba86.png','2023-06-07 19:34:45',NULL);
INSERT INTO `t_photo` VALUES (43,2,'1666410490386976770',NULL,'https://upload.haoxx.site/photo/02a6d45da336592e5cb66280578c295e.png','2023-06-07 19:43:16',NULL);
INSERT INTO `t_photo` VALUES (44,2,'1666410490386976771',NULL,'https://upload.haoxx.site/photo/5cb46546d42be10317ef6f30ce6d2fa3.png','2023-06-07 19:43:16',NULL);
INSERT INTO `t_photo` VALUES (45,2,'1666410490386976772',NULL,'https://upload.haoxx.site/photo/5f24fbd285b131e20cf48c931def0d45.png','2023-06-07 19:43:16',NULL);
INSERT INTO `t_photo` VALUES (46,2,'1666410490386976773',NULL,'https://upload.haoxx.site/photo/6d0a2a04a3119ad47edcabd7349d4673.png','2023-06-07 19:43:16',NULL);
INSERT INTO `t_photo` VALUES (47,2,'1666410532208381954',NULL,'https://upload.haoxx.site/photo/6f23ed4e0dfc3ec691de15324db383a4.png','2023-06-07 19:43:26',NULL);
INSERT INTO `t_photo` VALUES (48,2,'1666410532208381955',NULL,'https://upload.haoxx.site/photo/105c3ca0ae4de6b12b6147b916a61af1.png','2023-06-07 19:43:26',NULL);
INSERT INTO `t_photo` VALUES (49,2,'1666410532208381956',NULL,'https://upload.haoxx.site/photo/36cf0a7153422dfaf17386b3796366c4.png','2023-06-07 19:43:26',NULL);
INSERT INTO `t_photo` VALUES (50,2,'1666410532208381957',NULL,'https://upload.haoxx.site/photo/5341a44ed914b07567b7dc18abdb8390.png','2023-06-07 19:43:26',NULL);
INSERT INTO `t_photo` VALUES (51,2,'1666410556233355265',NULL,'https://upload.haoxx.site/photo/589080628386800bbe32bb04420e0977.png','2023-06-07 19:43:32',NULL);
INSERT INTO `t_photo` VALUES (52,2,'1666410556233355266',NULL,'https://upload.haoxx.site/photo/ae2a762c612c3978c89eac5acbea13ad.png','2023-06-07 19:43:32',NULL);
INSERT INTO `t_photo` VALUES (53,2,'1666410556233355267',NULL,'https://upload.haoxx.site/photo/a480238e9c3785af646f9d776e569797.png','2023-06-07 19:43:32',NULL);
INSERT INTO `t_photo` VALUES (54,2,'1666410556233355268',NULL,'https://upload.haoxx.site/photo/5529093d85e5635aa1effa437df22107.png','2023-06-07 19:43:32',NULL);
INSERT INTO `t_photo` VALUES (55,2,'1666410587002769409',NULL,'https://upload.haoxx.site/photo/c2a7079ed0d2e0959a02775cfc93798f.png','2023-06-07 19:43:39',NULL);
INSERT INTO `t_photo` VALUES (56,2,'1666410587002769410',NULL,'https://upload.haoxx.site/photo/b329e9b72442e377d0ab3e954626d92a.png','2023-06-07 19:43:39',NULL);
INSERT INTO `t_photo` VALUES (57,2,'1666410587002769411',NULL,'https://upload.haoxx.site/photo/ae42db34e057eaba61295c7337e7c546.png','2023-06-07 19:43:39',NULL);
INSERT INTO `t_photo` VALUES (58,2,'1666410587002769412',NULL,'https://upload.haoxx.site/photo/af808190d54947777f6c8ee2e8d91687.png','2023-06-07 19:43:39',NULL);
INSERT INTO `t_photo` VALUES (59,2,'1666410622071345153',NULL,'https://upload.haoxx.site/photo/dcb7db7fed64b2b783a84f14c2324fc0.png','2023-06-07 19:43:47',NULL);
INSERT INTO `t_photo` VALUES (60,2,'1666410622075539458',NULL,'https://upload.haoxx.site/photo/d9b061df62171b02e7a445e1d176c593.png','2023-06-07 19:43:47',NULL);
INSERT INTO `t_photo` VALUES (61,2,'1666410622075539459',NULL,'https://upload.haoxx.site/photo/c9dd37b5aeb33abe47b944c4fa8bed5f.png','2023-06-07 19:43:47',NULL);
INSERT INTO `t_photo` VALUES (62,2,'1666410622075539460',NULL,'https://upload.haoxx.site/photo/d1f2e482b131c2aac315142934b97807.png','2023-06-07 19:43:47',NULL);
INSERT INTO `t_photo` VALUES (63,2,'1666410650739412993',NULL,'https://upload.haoxx.site/photo/eeec806437bfc7f6d52f615ef7078477.png','2023-06-07 19:43:54',NULL);
INSERT INTO `t_photo` VALUES (64,2,'1666410650739412994',NULL,'https://upload.haoxx.site/photo/ebe07dbeff2c5d9943d4d094dca4ca93.png','2023-06-07 19:43:54',NULL);
INSERT INTO `t_photo` VALUES (65,2,'1666410650739412995',NULL,'https://upload.haoxx.site/photo/f58553028c983dc7f5284ea0f6ff8f10.png','2023-06-07 19:43:54',NULL);
INSERT INTO `t_photo` VALUES (66,2,'1666410650739412996',NULL,'https://upload.haoxx.site/photo/dffc560d52616dd91c7a30860543c238.png','2023-06-07 19:43:54',NULL);
INSERT INTO `t_photo` VALUES (67,2,'1666410650739412997',NULL,'https://upload.haoxx.site/photo/ef46427ce1d4b7268ae4baed43486364.png','2023-06-07 19:43:54',NULL);
/*!40000 ALTER TABLE `t_photo` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `t_role`
--

DROP TABLE IF EXISTS `t_role`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `t_role` (
  `id` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '主键id',
  `role_name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '角色名称',
  `role_desc` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT NULL COMMENT '角色描述',
  `is_disable` tinyint(1) NOT NULL DEFAULT '0' COMMENT '是否禁用 (0否 1是)',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_role`
--

LOCK TABLES `t_role` WRITE;
/*!40000 ALTER TABLE `t_role` DISABLE KEYS */;
INSERT INTO `t_role` VALUES ('1','admin','管理员',0,'2022-11-03 17:41:57','2023-03-10 23:12:59');
INSERT INTO `t_role` VALUES ('2','user','普通用户',0,'2022-11-03 17:42:17','2023-06-05 22:06:09');
INSERT INTO `t_role` VALUES ('3','test','测试账号',0,'2022-11-03 17:42:31','2023-06-05 22:06:11');
/*!40000 ALTER TABLE `t_role` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `t_role_menu`
--

DROP TABLE IF EXISTS `t_role_menu`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `t_role_menu` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键',
  `role_id` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '角色id',
  `menu_id` int NOT NULL COMMENT '菜单id',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=5867 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_role_menu`
--

LOCK TABLES `t_role_menu` WRITE;
/*!40000 ALTER TABLE `t_role_menu` DISABLE KEYS */;
INSERT INTO `t_role_menu` VALUES (5703,'1',1);
INSERT INTO `t_role_menu` VALUES (5704,'1',108);
INSERT INTO `t_role_menu` VALUES (5705,'1',73);
INSERT INTO `t_role_menu` VALUES (5706,'1',80);
INSERT INTO `t_role_menu` VALUES (5707,'1',81);
INSERT INTO `t_role_menu` VALUES (5708,'1',82);
INSERT INTO `t_role_menu` VALUES (5709,'1',83);
INSERT INTO `t_role_menu` VALUES (5710,'1',84);
INSERT INTO `t_role_menu` VALUES (5711,'1',85);
INSERT INTO `t_role_menu` VALUES (5712,'1',86);
INSERT INTO `t_role_menu` VALUES (5713,'1',87);
INSERT INTO `t_role_menu` VALUES (5714,'1',88);
INSERT INTO `t_role_menu` VALUES (5715,'1',3);
INSERT INTO `t_role_menu` VALUES (5716,'1',5);
INSERT INTO `t_role_menu` VALUES (5717,'1',6);
INSERT INTO `t_role_menu` VALUES (5718,'1',7);
INSERT INTO `t_role_menu` VALUES (5719,'1',4);
INSERT INTO `t_role_menu` VALUES (5720,'1',8);
INSERT INTO `t_role_menu` VALUES (5721,'1',9);
INSERT INTO `t_role_menu` VALUES (5722,'1',10);
INSERT INTO `t_role_menu` VALUES (5723,'1',111);
INSERT INTO `t_role_menu` VALUES (5724,'1',36);
INSERT INTO `t_role_menu` VALUES (5725,'1',38);
INSERT INTO `t_role_menu` VALUES (5726,'1',99);
INSERT INTO `t_role_menu` VALUES (5727,'1',100);
INSERT INTO `t_role_menu` VALUES (5728,'1',101);
INSERT INTO `t_role_menu` VALUES (5729,'1',102);
INSERT INTO `t_role_menu` VALUES (5730,'1',37);
INSERT INTO `t_role_menu` VALUES (5731,'1',42);
INSERT INTO `t_role_menu` VALUES (5732,'1',45);
INSERT INTO `t_role_menu` VALUES (5733,'1',11);
INSERT INTO `t_role_menu` VALUES (5734,'1',12);
INSERT INTO `t_role_menu` VALUES (5735,'1',15);
INSERT INTO `t_role_menu` VALUES (5736,'1',16);
INSERT INTO `t_role_menu` VALUES (5737,'1',17);
INSERT INTO `t_role_menu` VALUES (5738,'1',60);
INSERT INTO `t_role_menu` VALUES (5739,'1',13);
INSERT INTO `t_role_menu` VALUES (5740,'1',18);
INSERT INTO `t_role_menu` VALUES (5741,'1',19);
INSERT INTO `t_role_menu` VALUES (5742,'1',20);
INSERT INTO `t_role_menu` VALUES (5743,'1',33);
INSERT INTO `t_role_menu` VALUES (5744,'1',14);
INSERT INTO `t_role_menu` VALUES (5745,'1',69);
INSERT INTO `t_role_menu` VALUES (5746,'1',70);
INSERT INTO `t_role_menu` VALUES (5747,'1',123);
INSERT INTO `t_role_menu` VALUES (5748,'1',124);
INSERT INTO `t_role_menu` VALUES (5749,'1',125);
INSERT INTO `t_role_menu` VALUES (5750,'1',126);
INSERT INTO `t_role_menu` VALUES (5751,'1',21);
INSERT INTO `t_role_menu` VALUES (5752,'1',22);
INSERT INTO `t_role_menu` VALUES (5753,'1',24);
INSERT INTO `t_role_menu` VALUES (5754,'1',23);
INSERT INTO `t_role_menu` VALUES (5755,'1',25);
INSERT INTO `t_role_menu` VALUES (5756,'1',93);
INSERT INTO `t_role_menu` VALUES (5757,'1',94);
INSERT INTO `t_role_menu` VALUES (5758,'1',104);
INSERT INTO `t_role_menu` VALUES (5759,'1',105);
INSERT INTO `t_role_menu` VALUES (5760,'1',106);
INSERT INTO `t_role_menu` VALUES (5761,'1',26);
INSERT INTO `t_role_menu` VALUES (5762,'1',53);
INSERT INTO `t_role_menu` VALUES (5763,'1',71);
INSERT INTO `t_role_menu` VALUES (5764,'1',27);
INSERT INTO `t_role_menu` VALUES (5765,'1',28);
INSERT INTO `t_role_menu` VALUES (5766,'1',29);
INSERT INTO `t_role_menu` VALUES (5767,'1',30);
INSERT INTO `t_role_menu` VALUES (5768,'1',31);
INSERT INTO `t_role_menu` VALUES (5769,'1',32);
INSERT INTO `t_role_menu` VALUES (5770,'1',34);
INSERT INTO `t_role_menu` VALUES (5771,'1',35);
INSERT INTO `t_role_menu` VALUES (5772,'1',39);
INSERT INTO `t_role_menu` VALUES (5773,'1',40);
INSERT INTO `t_role_menu` VALUES (5774,'1',41);
INSERT INTO `t_role_menu` VALUES (5775,'1',61);
INSERT INTO `t_role_menu` VALUES (5776,'1',62);
INSERT INTO `t_role_menu` VALUES (5777,'1',63);
INSERT INTO `t_role_menu` VALUES (5778,'1',64);
INSERT INTO `t_role_menu` VALUES (5779,'1',65);
INSERT INTO `t_role_menu` VALUES (5780,'1',66);
INSERT INTO `t_role_menu` VALUES (5781,'1',103);
INSERT INTO `t_role_menu` VALUES (5782,'1',51);
INSERT INTO `t_role_menu` VALUES (5783,'1',54);
INSERT INTO `t_role_menu` VALUES (5784,'1',55);
INSERT INTO `t_role_menu` VALUES (5785,'1',56);
INSERT INTO `t_role_menu` VALUES (5786,'1',57);
INSERT INTO `t_role_menu` VALUES (5787,'1',58);
INSERT INTO `t_role_menu` VALUES (5788,'1',52);
INSERT INTO `t_role_menu` VALUES (5789,'1',76);
INSERT INTO `t_role_menu` VALUES (5790,'1',77);
INSERT INTO `t_role_menu` VALUES (5791,'1',78);
INSERT INTO `t_role_menu` VALUES (5792,'1',79);
INSERT INTO `t_role_menu` VALUES (5793,'1',46);
INSERT INTO `t_role_menu` VALUES (5794,'1',67);
INSERT INTO `t_role_menu` VALUES (5795,'1',68);
INSERT INTO `t_role_menu` VALUES (5796,'2',1);
INSERT INTO `t_role_menu` VALUES (5797,'2',108);
INSERT INTO `t_role_menu` VALUES (5798,'2',73);
INSERT INTO `t_role_menu` VALUES (5799,'2',84);
INSERT INTO `t_role_menu` VALUES (5800,'2',88);
INSERT INTO `t_role_menu` VALUES (5801,'2',3);
INSERT INTO `t_role_menu` VALUES (5802,'2',4);
INSERT INTO `t_role_menu` VALUES (5803,'2',111);
INSERT INTO `t_role_menu` VALUES (5804,'2',36);
INSERT INTO `t_role_menu` VALUES (5805,'2',38);
INSERT INTO `t_role_menu` VALUES (5806,'2',99);
INSERT INTO `t_role_menu` VALUES (5807,'2',102);
INSERT INTO `t_role_menu` VALUES (5808,'2',37);
INSERT INTO `t_role_menu` VALUES (5809,'2',11);
INSERT INTO `t_role_menu` VALUES (5810,'2',12);
INSERT INTO `t_role_menu` VALUES (5811,'2',60);
INSERT INTO `t_role_menu` VALUES (5812,'2',13);
INSERT INTO `t_role_menu` VALUES (5813,'2',14);
INSERT INTO `t_role_menu` VALUES (5814,'2',95);
INSERT INTO `t_role_menu` VALUES (5815,'2',96);
INSERT INTO `t_role_menu` VALUES (5816,'2',97);
INSERT INTO `t_role_menu` VALUES (5817,'2',98);
INSERT INTO `t_role_menu` VALUES (5818,'2',123);
INSERT INTO `t_role_menu` VALUES (5819,'2',21);
INSERT INTO `t_role_menu` VALUES (5820,'2',22);
INSERT INTO `t_role_menu` VALUES (5821,'2',23);
INSERT INTO `t_role_menu` VALUES (5822,'2',93);
INSERT INTO `t_role_menu` VALUES (5823,'2',104);
INSERT INTO `t_role_menu` VALUES (5824,'2',26);
INSERT INTO `t_role_menu` VALUES (5825,'2',53);
INSERT INTO `t_role_menu` VALUES (5826,'2',27);
INSERT INTO `t_role_menu` VALUES (5827,'2',34);
INSERT INTO `t_role_menu` VALUES (5828,'2',35);
INSERT INTO `t_role_menu` VALUES (5829,'2',61);
INSERT INTO `t_role_menu` VALUES (5830,'2',65);
INSERT INTO `t_role_menu` VALUES (5831,'2',103);
INSERT INTO `t_role_menu` VALUES (5832,'2',51);
INSERT INTO `t_role_menu` VALUES (5833,'2',57);
INSERT INTO `t_role_menu` VALUES (5834,'2',52);
INSERT INTO `t_role_menu` VALUES (5835,'2',46);
INSERT INTO `t_role_menu` VALUES (5836,'3',1);
INSERT INTO `t_role_menu` VALUES (5837,'3',108);
INSERT INTO `t_role_menu` VALUES (5838,'3',73);
INSERT INTO `t_role_menu` VALUES (5839,'3',3);
INSERT INTO `t_role_menu` VALUES (5840,'3',4);
INSERT INTO `t_role_menu` VALUES (5841,'3',111);
INSERT INTO `t_role_menu` VALUES (5842,'3',36);
INSERT INTO `t_role_menu` VALUES (5843,'3',38);
INSERT INTO `t_role_menu` VALUES (5844,'3',37);
INSERT INTO `t_role_menu` VALUES (5845,'3',11);
INSERT INTO `t_role_menu` VALUES (5846,'3',12);
INSERT INTO `t_role_menu` VALUES (5847,'3',60);
INSERT INTO `t_role_menu` VALUES (5848,'3',13);
INSERT INTO `t_role_menu` VALUES (5849,'3',14);
INSERT INTO `t_role_menu` VALUES (5850,'3',123);
INSERT INTO `t_role_menu` VALUES (5851,'3',21);
INSERT INTO `t_role_menu` VALUES (5852,'3',22);
INSERT INTO `t_role_menu` VALUES (5853,'3',23);
INSERT INTO `t_role_menu` VALUES (5854,'3',93);
INSERT INTO `t_role_menu` VALUES (5855,'3',104);
INSERT INTO `t_role_menu` VALUES (5856,'3',26);
INSERT INTO `t_role_menu` VALUES (5857,'3',53);
INSERT INTO `t_role_menu` VALUES (5858,'3',27);
INSERT INTO `t_role_menu` VALUES (5859,'3',34);
INSERT INTO `t_role_menu` VALUES (5860,'3',35);
INSERT INTO `t_role_menu` VALUES (5861,'3',61);
INSERT INTO `t_role_menu` VALUES (5862,'3',65);
INSERT INTO `t_role_menu` VALUES (5863,'3',51);
INSERT INTO `t_role_menu` VALUES (5864,'3',57);
INSERT INTO `t_role_menu` VALUES (5865,'3',52);
INSERT INTO `t_role_menu` VALUES (5866,'3',46);
/*!40000 ALTER TABLE `t_role_menu` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `t_site_config`
--

DROP TABLE IF EXISTS `t_site_config`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `t_site_config` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键',
  `user_avatar` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '用户头像',
  `tourist_avatar` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '游客头像',
  `site_name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '网站名称',
  `site_address` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '网站地址',
  `site_intro` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '网站简介',
  `site_notice` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '网站公告',
  `create_site_time` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '建站日期',
  `record_number` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '备案号',
  `author_avatar` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '作者头像',
  `site_author` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '网站作者',
  `article_cover` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '文章默认封面',
  `about_me` text CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci COMMENT '关于我',
  `github` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT '' COMMENT 'Github',
  `gitee` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT '' COMMENT 'Gitee',
  `bilibili` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT '' COMMENT '哔哩哔哩',
  `qq` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT NULL COMMENT 'QQ',
  `comment_check` tinyint(1) NOT NULL DEFAULT '1' COMMENT '是否评论审核 (0否 1是)',
  `message_check` tinyint(1) NOT NULL DEFAULT '1' COMMENT '是否留言审核 (0否 1是)',
  `is_reward` tinyint(1) NOT NULL DEFAULT '1' COMMENT '是否开启打赏 (0否 1是)',
  `wei_xin_code` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT '' COMMENT '微信二维码',
  `ali_code` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT '' COMMENT '支付宝二维码',
  `email_notice` tinyint(1) NOT NULL DEFAULT '1' COMMENT '是否邮箱通知 (0否 1是)',
  `social_list` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '社交列表',
  `login_list` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '登录方式',
  `is_music` tinyint(1) NOT NULL DEFAULT '1' COMMENT '是否开启音乐播放器 (0否 1是)',
  `music_id` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT '' COMMENT '网易云歌单id',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_site_config`
--

LOCK TABLES `t_site_config` WRITE;
/*!40000 ALTER TABLE `t_site_config` DISABLE KEYS */;
INSERT INTO `t_site_config` VALUES (1,'https://upload.haoxx.site/config/e94fc60e58a570ecc3e9ddcb334fdb2b.jpg','https://upload.haoxx.site/config/0b04691f25e400a708caba867be171d0.jpg','HaoXX`s Blog','https://www.haoxx.site','网站介绍','个人学习资料记录','2023-06-06','渝ICP备2023001651号-2','https://upload.haoxx.site/config/5bbb6dc8be42f3e96dbcc7d7529dc402.gif','小鱼','https://upload.haoxx.site/config/27c7f38a329c07159a80315712680ea5.jpg','🍀个人简介\n\n普通人','https://github.com/XiaoYuer2022','https://gitee.com/haoxxown','https://space.bilibili.com/263844591','508506630',0,0,0,'https://upload.haoxx.site/cloud/images/image_1.jpg','https://upload.haoxx.site/cloud/images/image_2.jpg',1,'gitee,bilibili,github,qq',',gitee,github',1,'7611185981','2023-01-07 19:31:33','2023-06-08 18:53:35');
/*!40000 ALTER TABLE `t_site_config` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `t_tag`
--

DROP TABLE IF EXISTS `t_tag`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `t_tag` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '标签id',
  `tag_name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '标签名',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=32 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_tag`
--

LOCK TABLES `t_tag` WRITE;
/*!40000 ALTER TABLE `t_tag` DISABLE KEYS */;
INSERT INTO `t_tag` VALUES (16,'C++','2023-06-07 16:32:56',NULL);
INSERT INTO `t_tag` VALUES (17,'Python','2023-06-07 16:39:33',NULL);
INSERT INTO `t_tag` VALUES (18,'IP','2023-06-07 16:59:38',NULL);
INSERT INTO `t_tag` VALUES (19,'设计模式','2023-06-07 17:00:36',NULL);
INSERT INTO `t_tag` VALUES (20,'找工作','2023-06-07 17:01:46',NULL);
INSERT INTO `t_tag` VALUES (21,'markdown','2023-06-07 17:02:26',NULL);
INSERT INTO `t_tag` VALUES (22,'脚注设计','2023-06-07 17:03:20',NULL);
INSERT INTO `t_tag` VALUES (23,'其他','2023-06-07 17:04:31',NULL);
INSERT INTO `t_tag` VALUES (24,'博客相关','2023-06-07 17:05:28',NULL);
INSERT INTO `t_tag` VALUES (25,'Linux运维','2023-06-07 17:06:23',NULL);
INSERT INTO `t_tag` VALUES (26,'git','2023-06-07 17:07:21',NULL);
INSERT INTO `t_tag` VALUES (27,'MySql','2023-06-07 17:08:52',NULL);
INSERT INTO `t_tag` VALUES (28,'STL','2023-06-07 17:10:32',NULL);
INSERT INTO `t_tag` VALUES (29,'Docker','2023-06-07 17:11:52',NULL);
INSERT INTO `t_tag` VALUES (30,'进程与线程','2023-06-07 18:18:00',NULL);
INSERT INTO `t_tag` VALUES (31,'操作系统','2023-06-07 18:18:00',NULL);
/*!40000 ALTER TABLE `t_tag` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `t_talk`
--

DROP TABLE IF EXISTS `t_talk`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `t_talk` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '说说id',
  `user_id` int NOT NULL COMMENT '用户id',
  `talk_content` varchar(2000) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '说说内容',
  `images` varchar(2500) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT NULL COMMENT '说说图片',
  `is_top` tinyint(1) NOT NULL DEFAULT '0' COMMENT '是否置顶 (0否 1是)',
  `status` tinyint(1) NOT NULL DEFAULT '1' COMMENT '状态 (1公开  2私密)',
  `create_time` datetime NOT NULL COMMENT '发表时间',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=39 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_talk`
--

LOCK TABLES `t_talk` WRITE;
/*!40000 ALTER TABLE `t_talk` DISABLE KEYS */;
INSERT INTO `t_talk` VALUES (37,1,'测试说说<img src=\"https://static.ttkwsd.top/emoji/chigua.png\" width=\"24\" height=\"24\" alt=\"[吃瓜]\" style=\"margin: 0 1px;vertical-align: text-bottom\">','',0,1,'2023-02-22 12:04:47',NULL);
INSERT INTO `t_talk` VALUES (38,1,'账户登录问题还没弄好<img src=\"https://static.ttkwsd.top/emoji/daku.png\" width=\"24\" height=\"24\" alt=\"[大哭]\" style=\"margin: 0 1px;vertical-align: text-bottom\">','',0,1,'2023-06-07 20:04:46',NULL);
/*!40000 ALTER TABLE `t_talk` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `t_task`
--

DROP TABLE IF EXISTS `t_task`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `t_task` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '任务id',
  `task_name` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '任务名称',
  `task_group` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL DEFAULT 'DEFAULT' COMMENT '任务组名',
  `invoke_target` varchar(500) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '调用目标',
  `cron_expression` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT NULL COMMENT 'cron执行表达式',
  `misfire_policy` tinyint(1) NOT NULL DEFAULT '3' COMMENT '计划执行错误策略 (1立即执行 2执行一次 3放弃执行)',
  `concurrent` tinyint(1) NOT NULL DEFAULT '0' COMMENT '是否并发执行 (0否 1是)',
  `status` tinyint(1) NOT NULL DEFAULT '0' COMMENT '任务状态 (0运行 1暂停)',
  `remark` varchar(500) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT NULL COMMENT '任务备注信息',
  `create_time` datetime DEFAULT NULL COMMENT '创建时间',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_task`
--

LOCK TABLES `t_task` WRITE;
/*!40000 ALTER TABLE `t_task` DISABLE KEYS */;
INSERT INTO `t_task` VALUES (4,'清除每日游客访问记录','SYSTEM','timedTask.clear','0 0 0 * * ?',3,0,0,'清除redis中的游客记录','2023-02-14 09:49:39','2023-02-18 15:48:41');
INSERT INTO `t_task` VALUES (5,'测试任务','SYSTEM','timedTask.test','0/10 * * * * ? ',3,0,1,'测试任务','2023-02-17 21:54:47',NULL);
INSERT INTO `t_task` VALUES (6,'清除访问日志','SYSTEM','timedTask.clearVistiLog','0 0 2 * * ?',3,0,0,'清除一周前的访问日志','2023-02-22 15:56:32',NULL);
/*!40000 ALTER TABLE `t_task` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `t_task_log`
--

DROP TABLE IF EXISTS `t_task_log`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `t_task_log` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '任务日志id',
  `task_name` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '任务名称',
  `task_group` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '任务组名',
  `invoke_target` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '调用目标字符串',
  `task_message` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT '' COMMENT '日志信息',
  `status` tinyint(1) DEFAULT '1' COMMENT '执行状态 (0失败 1正常)',
  `error_info` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci COMMENT '错误信息',
  `create_time` datetime DEFAULT NULL COMMENT '创建时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=20 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_task_log`
--

LOCK TABLES `t_task_log` WRITE;
/*!40000 ALTER TABLE `t_task_log` DISABLE KEYS */;
INSERT INTO `t_task_log` VALUES (17,'清除每日游客访问记录','SYSTEM','timedTask.clear','清除每日游客访问记录 总共耗时：10毫秒',1,NULL,'2023-06-07 00:00:00');
INSERT INTO `t_task_log` VALUES (18,'清除访问日志','SYSTEM','timedTask.clearVistiLog','清除访问日志 总共耗时：33毫秒',1,NULL,'2023-06-07 02:00:00');
INSERT INTO `t_task_log` VALUES (19,'清除每日游客访问记录','SYSTEM','timedTask.clear','清除每日游客访问记录 总共耗时：1毫秒',1,NULL,'2023-06-08 00:00:00');
/*!40000 ALTER TABLE `t_task_log` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `t_user`
--

DROP TABLE IF EXISTS `t_user`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `t_user` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '用户id',
  `nickname` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '用户昵称',
  `username` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '用户名',
  `password` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '用户密码',
  `avatar` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '头像',
  `web_site` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT '' COMMENT '个人网站',
  `intro` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT '' COMMENT '个人简介',
  `email` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT '' COMMENT '邮箱',
  `ip_address` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT '' COMMENT '登录ip',
  `ip_source` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT '' COMMENT '登录地址',
  `login_type` tinyint(1) NOT NULL DEFAULT '0' COMMENT '登录方式 (1邮箱 2QQ 3Gitee 4Github)',
  `is_disable` tinyint(1) NOT NULL DEFAULT '0' COMMENT '是否禁用 (0否 1是)',
  `login_time` datetime DEFAULT NULL COMMENT '登录时间',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=18 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_user`
--

LOCK TABLES `t_user` WRITE;
/*!40000 ALTER TABLE `t_user` DISABLE KEYS */;
INSERT INTO `t_user` VALUES (1,'小鱼','508506630@qq.com','7fbaefda86f15c08f61add2ac994f27ee2ef7919b949043922002fe54524d884','https://upload.haoxx.site/config/e94fc60e58a570ecc3e9ddcb334fdb2b.jpg',NULL,NULL,'508506630@qq.com','183.230.12.181','中国|重庆|重庆市|移动',1,0,'2023-06-08 18:53:28','2022-11-29 21:45:48','2023-06-08 18:53:28');
INSERT INTO `t_user` VALUES (3,'测试账号','test@qq.com','8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92','https://upload.haoxx.site/config/0b04691f25e400a708caba867be171d0.jpg','https://www.haoxx.site','个人简介','test@qq.com','183.230.12.181','中国|重庆|重庆市|移动',1,0,'2023-06-08 16:16:33','2022-11-30 21:34:26','2023-06-08 16:16:33');
INSERT INTO `t_user` VALUES (16,'HaoY','9498238','0b1c09a3713e09c2d47ceafc55e29384','https://foruda.gitee.com/avatar/1677177416257777920/9498238_yuhao1998_1642163960.png','','','','183.230.12.181','中国|重庆|重庆市|移动',3,0,'2023-06-08 18:38:18','2023-06-08 18:37:35','2023-06-08 18:38:18');
INSERT INTO `t_user` VALUES (17,'XiaoYuer2022','97725666','ghu_bXo6v6C9GIPLFp3dxprvltLAxPVuzp2doI6G','https://avatars.githubusercontent.com/u/97725666?v=4','','','','183.230.12.181','中国|重庆|重庆市|移动',4,0,'2023-06-08 18:53:07','2023-06-08 18:53:07','2023-06-08 18:53:07');
/*!40000 ALTER TABLE `t_user` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `t_user_role`
--

DROP TABLE IF EXISTS `t_user_role`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `t_user_role` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键',
  `user_id` int NOT NULL COMMENT '用户id',
  `role_id` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '角色id',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=59 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_user_role`
--

LOCK TABLES `t_user_role` WRITE;
/*!40000 ALTER TABLE `t_user_role` DISABLE KEYS */;
INSERT INTO `t_user_role` VALUES (50,3,'3');
INSERT INTO `t_user_role` VALUES (54,1,'1');
INSERT INTO `t_user_role` VALUES (57,16,'2');
INSERT INTO `t_user_role` VALUES (58,17,'2');
/*!40000 ALTER TABLE `t_user_role` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `t_visit_log`
--

DROP TABLE IF EXISTS `t_visit_log`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `t_visit_log` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT 'id',
  `page` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT NULL COMMENT '访问页面',
  `ip_address` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT NULL COMMENT '访问ip',
  `ip_source` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT NULL COMMENT '访问地址',
  `os` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT NULL COMMENT '操作系统',
  `browser` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT NULL COMMENT '浏览器',
  `create_time` datetime NOT NULL COMMENT '访问时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=1796 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_visit_log`
--

LOCK TABLES `t_visit_log` WRITE;
/*!40000 ALTER TABLE `t_visit_log` DISABLE KEYS */;
INSERT INTO `t_visit_log` VALUES (1671,'首页','183.228.187.36','中国|重庆|重庆市|移动','Android 12','Huawei Browser 13.0.6.302','2023-06-05 12:48:41');
INSERT INTO `t_visit_log` VALUES (1672,'归档','183.228.187.36','中国|重庆|重庆市|移动','Android 12','Huawei Browser 13.0.6.302','2023-06-05 12:49:02');
INSERT INTO `t_visit_log` VALUES (1673,'文章分类','183.228.187.36','中国|重庆|重庆市|移动','Android 12','Huawei Browser 13.0.6.302','2023-06-05 12:49:05');
INSERT INTO `t_visit_log` VALUES (1674,'文章标签','183.228.187.36','中国|重庆|重庆市|移动','Android 12','Huawei Browser 13.0.6.302','2023-06-05 12:49:06');
INSERT INTO `t_visit_log` VALUES (1675,'说说列表','183.228.187.36','中国|重庆|重庆市|移动','Android 12','Huawei Browser 13.0.6.302','2023-06-05 12:49:08');
INSERT INTO `t_visit_log` VALUES (1676,'相册','183.228.187.36','中国|重庆|重庆市|移动','Android 12','Huawei Browser 13.0.6.302','2023-06-05 12:49:11');
INSERT INTO `t_visit_log` VALUES (1677,'友链','183.228.187.36','中国|重庆|重庆市|移动','Android 12','Huawei Browser 13.0.6.302','2023-06-05 12:49:16');
INSERT INTO `t_visit_log` VALUES (1678,'留言','183.228.187.36','中国|重庆|重庆市|移动','Android 12','Huawei Browser 13.0.6.302','2023-06-05 12:49:25');
INSERT INTO `t_visit_log` VALUES (1679,'友链','183.228.187.36','中国|重庆|重庆市|移动','Android 12','Huawei Browser 13.0.6.302','2023-06-05 12:49:52');
INSERT INTO `t_visit_log` VALUES (1680,'首页','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-05 14:41:39');
INSERT INTO `t_visit_log` VALUES (1681,'首页','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-05 14:41:42');
INSERT INTO `t_visit_log` VALUES (1682,'首页','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-05 14:44:36');
INSERT INTO `t_visit_log` VALUES (1683,'首页','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-05 14:44:47');
INSERT INTO `t_visit_log` VALUES (1684,'首页','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-05 14:45:03');
INSERT INTO `t_visit_log` VALUES (1685,'首页','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-05 15:16:23');
INSERT INTO `t_visit_log` VALUES (1686,'首页','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-05 15:17:58');
INSERT INTO `t_visit_log` VALUES (1687,'首页','183.230.12.181','中国|重庆|重庆市|移动','Windows >=10','Chrome 108.0.5359.125','2023-06-05 15:22:32');
INSERT INTO `t_visit_log` VALUES (1688,'首页','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-05 22:04:55');
INSERT INTO `t_visit_log` VALUES (1689,'首页','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-05 22:10:10');
INSERT INTO `t_visit_log` VALUES (1690,'首页','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-06 20:20:20');
INSERT INTO `t_visit_log` VALUES (1691,'首页','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-06 20:20:39');
INSERT INTO `t_visit_log` VALUES (1692,'首页','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-06 20:55:03');
INSERT INTO `t_visit_log` VALUES (1693,'文章','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-06 20:55:13');
INSERT INTO `t_visit_log` VALUES (1694,'友链','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-06 20:56:01');
INSERT INTO `t_visit_log` VALUES (1695,'首页','49.234.34.31','中国|上海|上海市|电信','Windows >=10','Chrome 101.0.4951.64','2023-06-07 05:32:48');
INSERT INTO `t_visit_log` VALUES (1696,'首页','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-07 09:51:18');
INSERT INTO `t_visit_log` VALUES (1697,'首页','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-07 16:33:07');
INSERT INTO `t_visit_log` VALUES (1698,'文章','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-07 16:33:10');
INSERT INTO `t_visit_log` VALUES (1699,'文章','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-07 16:37:57');
INSERT INTO `t_visit_log` VALUES (1700,'首页','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-07 16:37:59');
INSERT INTO `t_visit_log` VALUES (1701,'文章','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-07 16:38:07');
INSERT INTO `t_visit_log` VALUES (1702,'文章','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-07 16:38:26');
INSERT INTO `t_visit_log` VALUES (1703,'首页','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-07 17:10:46');
INSERT INTO `t_visit_log` VALUES (1704,'首页','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-07 17:10:51');
INSERT INTO `t_visit_log` VALUES (1705,'首页','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-07 17:10:51');
INSERT INTO `t_visit_log` VALUES (1706,'首页','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-07 17:10:52');
INSERT INTO `t_visit_log` VALUES (1707,'归档','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-07 17:10:57');
INSERT INTO `t_visit_log` VALUES (1708,'文章分类','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-07 17:10:59');
INSERT INTO `t_visit_log` VALUES (1709,'文章标签','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-07 17:11:12');
INSERT INTO `t_visit_log` VALUES (1710,'说说列表','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-07 17:12:04');
INSERT INTO `t_visit_log` VALUES (1711,'相册','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-07 17:12:05');
INSERT INTO `t_visit_log` VALUES (1712,'照片','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-07 17:12:09');
INSERT INTO `t_visit_log` VALUES (1713,'照片','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-07 17:12:13');
INSERT INTO `t_visit_log` VALUES (1714,'友链','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-07 17:12:15');
INSERT INTO `t_visit_log` VALUES (1715,'友链','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-07 17:14:39');
INSERT INTO `t_visit_log` VALUES (1716,'留言','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-07 17:14:53');
INSERT INTO `t_visit_log` VALUES (1717,'归档','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-07 17:15:45');
INSERT INTO `t_visit_log` VALUES (1718,'文章分类','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-07 17:15:47');
INSERT INTO `t_visit_log` VALUES (1719,'归档','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-07 17:15:51');
INSERT INTO `t_visit_log` VALUES (1720,'归档','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-07 17:15:51');
INSERT INTO `t_visit_log` VALUES (1721,'归档','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-07 17:15:52');
INSERT INTO `t_visit_log` VALUES (1722,'首页','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-07 17:16:00');
INSERT INTO `t_visit_log` VALUES (1723,'首页','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-07 18:18:53');
INSERT INTO `t_visit_log` VALUES (1724,'首页','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-07 18:38:49');
INSERT INTO `t_visit_log` VALUES (1725,'首页','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-07 19:17:25');
INSERT INTO `t_visit_log` VALUES (1726,'首页','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-07 19:17:31');
INSERT INTO `t_visit_log` VALUES (1727,'首页','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-07 19:17:33');
INSERT INTO `t_visit_log` VALUES (1728,'首页','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-07 19:51:51');
INSERT INTO `t_visit_log` VALUES (1729,'文章','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-07 19:51:54');
INSERT INTO `t_visit_log` VALUES (1730,'文章','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-07 19:52:15');
INSERT INTO `t_visit_log` VALUES (1731,'文章','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-07 20:03:02');
INSERT INTO `t_visit_log` VALUES (1732,'首页','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-07 20:03:06');
INSERT INTO `t_visit_log` VALUES (1733,'首页','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-07 20:03:12');
INSERT INTO `t_visit_log` VALUES (1734,'首页','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-07 20:03:14');
INSERT INTO `t_visit_log` VALUES (1735,'首页','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-07 20:03:15');
INSERT INTO `t_visit_log` VALUES (1736,'首页','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-07 20:03:15');
INSERT INTO `t_visit_log` VALUES (1737,'说说列表','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-07 20:03:36');
INSERT INTO `t_visit_log` VALUES (1738,'首页','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-07 20:04:50');
INSERT INTO `t_visit_log` VALUES (1739,'首页','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-07 20:07:22');
INSERT INTO `t_visit_log` VALUES (1740,'首页','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-07 20:07:27');
INSERT INTO `t_visit_log` VALUES (1741,'首页','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-07 20:12:47');
INSERT INTO `t_visit_log` VALUES (1742,'首页','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-07 20:22:17');
INSERT INTO `t_visit_log` VALUES (1743,'首页','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-07 20:46:56');
INSERT INTO `t_visit_log` VALUES (1744,'首页','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-07 20:47:03');
INSERT INTO `t_visit_log` VALUES (1745,'首页','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-07 20:47:31');
INSERT INTO `t_visit_log` VALUES (1746,'首页','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-07 20:47:36');
INSERT INTO `t_visit_log` VALUES (1747,'首页','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-07 21:27:42');
INSERT INTO `t_visit_log` VALUES (1748,'首页','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-07 21:28:47');
INSERT INTO `t_visit_log` VALUES (1749,'首页','39.144.219.46','中国|移动','Android 12','Huawei Browser 13.0.6.302','2023-06-07 21:32:48');
INSERT INTO `t_visit_log` VALUES (1750,'首页','39.144.219.46','中国|移动','Android 12','Huawei Browser 13.0.6.302','2023-06-07 21:32:48');
INSERT INTO `t_visit_log` VALUES (1751,'首页','39.144.219.46','中国|移动','Android 12','WeChat 8.0.37.2380','2023-06-07 21:35:12');
INSERT INTO `t_visit_log` VALUES (1752,'首页','39.144.219.46','中国|移动','Android 12','WeChat 8.0.37.2380','2023-06-07 21:35:28');
INSERT INTO `t_visit_log` VALUES (1753,'首页','39.144.219.46','中国|移动','Android 12','WeChat 8.0.37.2380','2023-06-07 21:35:29');
INSERT INTO `t_visit_log` VALUES (1754,'首页','39.144.219.46','中国|移动','Android 12','WeChat 8.0.37.2380','2023-06-07 21:35:30');
INSERT INTO `t_visit_log` VALUES (1755,'首页','39.144.219.46','中国|移动','Android 12','WeChat 8.0.37.2380','2023-06-07 21:35:32');
INSERT INTO `t_visit_log` VALUES (1756,'首页','39.144.219.46','中国|移动','Android 12','WeChat 8.0.37.2380','2023-06-07 21:35:33');
INSERT INTO `t_visit_log` VALUES (1757,'首页','39.144.219.46','中国|移动','Android 12','WeChat 8.0.37.2380','2023-06-07 21:35:34');
INSERT INTO `t_visit_log` VALUES (1758,'首页','39.144.219.46','中国|移动','Android 12','WeChat 8.0.37.2380','2023-06-07 21:35:46');
INSERT INTO `t_visit_log` VALUES (1759,'首页','39.144.219.46','中国|移动','Android 12','WeChat 8.0.37.2380','2023-06-07 21:35:47');
INSERT INTO `t_visit_log` VALUES (1760,'首页','39.144.219.46','中国|移动','Android 12','WeChat 8.0.37.2380','2023-06-07 21:35:49');
INSERT INTO `t_visit_log` VALUES (1761,'首页','39.144.219.46','中国|移动','Android 12','WeChat 8.0.37.2380','2023-06-07 21:35:50');
INSERT INTO `t_visit_log` VALUES (1762,'首页','117.136.30.136','中国|重庆|重庆市|移动','Android 12','WeChat 8.0.37.2380','2023-06-07 21:57:26');
INSERT INTO `t_visit_log` VALUES (1763,'首页','183.226.175.255','中国|重庆|重庆市|移动','Android 12','WeChat 8.0.37.2380','2023-06-07 22:06:06');
INSERT INTO `t_visit_log` VALUES (1764,'首页','39.144.219.46','中国|移动','Android 12','WeChat 8.0.37.2380','2023-06-07 22:06:29');
INSERT INTO `t_visit_log` VALUES (1765,'首页','183.226.175.255','中国|重庆|重庆市|移动','Android 12','WeChat 8.0.37.2380','2023-06-07 22:07:39');
INSERT INTO `t_visit_log` VALUES (1766,'首页','183.228.187.36','中国|重庆|重庆市|移动','Android 12','Huawei Browser 13.0.6.302','2023-06-07 22:11:42');
INSERT INTO `t_visit_log` VALUES (1767,'首页','183.228.187.36','中国|重庆|重庆市|移动','Android 12','QQ Client 8.9.55.10980','2023-06-07 22:36:44');
INSERT INTO `t_visit_log` VALUES (1768,'首页','183.70.125.59','中国|重庆|重庆市|电信','Android 10','QQ Client 8.9.13.9280','2023-06-07 22:39:28');
INSERT INTO `t_visit_log` VALUES (1769,'首页','183.70.125.59','中国|重庆|重庆市|电信','Android 10','QQ Client 8.9.13.9280','2023-06-07 22:39:48');
INSERT INTO `t_visit_log` VALUES (1770,'首页','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-08 16:16:30');
INSERT INTO `t_visit_log` VALUES (1771,'首页','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-08 16:18:28');
INSERT INTO `t_visit_log` VALUES (1772,'首页','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-08 16:20:12');
INSERT INTO `t_visit_log` VALUES (1773,'首页','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-08 16:20:50');
INSERT INTO `t_visit_log` VALUES (1774,'首页','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-08 16:46:14');
INSERT INTO `t_visit_log` VALUES (1775,'文章','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-08 16:46:19');
INSERT INTO `t_visit_log` VALUES (1776,'留言','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-08 16:46:34');
INSERT INTO `t_visit_log` VALUES (1777,'友链','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-08 16:46:35');
INSERT INTO `t_visit_log` VALUES (1778,'说说列表','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-08 16:46:43');
INSERT INTO `t_visit_log` VALUES (1779,'相册','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-08 16:46:45');
INSERT INTO `t_visit_log` VALUES (1780,'归档','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-08 16:46:49');
INSERT INTO `t_visit_log` VALUES (1781,'文章分类','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-08 16:46:53');
INSERT INTO `t_visit_log` VALUES (1782,'文章标签','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-08 16:46:53');
INSERT INTO `t_visit_log` VALUES (1783,'首页','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-08 16:55:52');
INSERT INTO `t_visit_log` VALUES (1784,'首页','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-08 18:37:33');
INSERT INTO `t_visit_log` VALUES (1785,'首页','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-08 18:37:35');
INSERT INTO `t_visit_log` VALUES (1786,'首页','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-08 18:38:18');
INSERT INTO `t_visit_log` VALUES (1787,'首页','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-08 18:39:04');
INSERT INTO `t_visit_log` VALUES (1788,'首页','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-08 18:44:23');
INSERT INTO `t_visit_log` VALUES (1789,'首页','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-08 18:46:01');
INSERT INTO `t_visit_log` VALUES (1790,'首页','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-08 18:48:21');
INSERT INTO `t_visit_log` VALUES (1791,'留言','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-08 18:48:21');
INSERT INTO `t_visit_log` VALUES (1792,'首页','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-08 18:52:56');
INSERT INTO `t_visit_log` VALUES (1793,'首页','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-08 18:53:05');
INSERT INTO `t_visit_log` VALUES (1794,'首页','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-08 18:57:32');
INSERT INTO `t_visit_log` VALUES (1795,'首页','183.230.12.181','中国|重庆|重庆市|移动','Windows NT ??','Edge 113','2023-06-08 18:57:47');
/*!40000 ALTER TABLE `t_visit_log` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2023-06-08 19:12:40
